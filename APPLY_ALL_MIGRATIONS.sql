
-- ========== 20251205200000_provider_compliance_sota.sql ==========
-- =====================================================
-- MIGRATION: Compliance Prestataire SOTA 2025
-- Système complet de KYC, documents légaux et validation
-- =====================================================

-- =====================================================
-- 1. TABLE: provider_compliance_documents
-- Documents légaux avec gestion expiration
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_compliance_documents (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Type de document
  document_type TEXT NOT NULL CHECK (document_type IN (
    'rc_pro',           -- Responsabilité Civile Pro
    'decennale',        -- Garantie décennale (BTP)
    'kbis',             -- Extrait Kbis
    'id_card_recto',    -- Pièce d'identité gérant (recto)
    'id_card_verso',    -- Pièce d'identité gérant (verso)
    'rib',              -- RIB/IBAN
    'urssaf',           -- Attestation URSSAF
    'qualification',    -- Certifications (RGE, QualiPV, etc.)
    'insurance_other',  -- Autre assurance
    'other'             -- Autre document
  )),
  
  -- Fichier
  storage_path TEXT NOT NULL,
  original_filename TEXT,
  file_size INTEGER,
  mime_type TEXT,
  
  -- Validité
  issue_date DATE,
  expiration_date DATE,
  
  -- Vérification
  verification_status TEXT DEFAULT 'pending' CHECK (verification_status IN (
    'pending',    -- En attente de vérification
    'verified',   -- Vérifié et validé
    'rejected',   -- Rejeté
    'expired'     -- Expiré
  )),
  verified_at TIMESTAMPTZ,
  verified_by UUID REFERENCES auth.users(id),
  rejection_reason TEXT,
  
  -- OCR / IA extraction (pour future implémentation)
  extracted_data JSONB DEFAULT '{}',
  ocr_confidence DECIMAL(5,2),
  
  -- Métadonnées
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour les requêtes fréquentes
CREATE INDEX IF NOT EXISTS idx_compliance_docs_provider ON provider_compliance_documents(provider_profile_id);
CREATE INDEX IF NOT EXISTS idx_compliance_docs_type ON provider_compliance_documents(document_type);
CREATE INDEX IF NOT EXISTS idx_compliance_docs_status ON provider_compliance_documents(verification_status);
CREATE INDEX IF NOT EXISTS idx_compliance_docs_expiration ON provider_compliance_documents(expiration_date) 
  WHERE verification_status = 'verified';

-- =====================================================
-- 2. TABLE: provider_payout_accounts
-- Comptes de paiement prestataire (données bancaires)
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_payout_accounts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Coordonnées bancaires
  iban TEXT NOT NULL,
  bic TEXT,
  bank_name TEXT,
  account_holder_name TEXT NOT NULL,
  
  -- Stripe Connect (optionnel)
  stripe_account_id TEXT,
  stripe_account_status TEXT CHECK (stripe_account_status IN (
    'pending', 'enabled', 'restricted', 'disabled'
  )),
  stripe_capabilities JSONB DEFAULT '{}',
  
  -- Vérification
  is_verified BOOLEAN DEFAULT false,
  verified_at TIMESTAMPTZ,
  verified_by UUID REFERENCES auth.users(id),
  
  -- Statut
  is_default BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_payout_accounts_provider ON provider_payout_accounts(provider_profile_id);

-- Contrainte: un seul compte par défaut par prestataire
CREATE UNIQUE INDEX IF NOT EXISTS idx_payout_accounts_default 
  ON provider_payout_accounts(provider_profile_id) 
  WHERE is_default = true;

-- =====================================================
-- 3. EXTENSION: provider_profiles pour KYC avancé
-- =====================================================

-- Ajouter les colonnes KYC si elles n'existent pas
ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS kyc_status TEXT DEFAULT 'incomplete' 
    CHECK (kyc_status IN (
      'incomplete',      -- Documents manquants
      'pending_review',  -- En attente validation admin
      'verified',        -- Tous documents vérifiés
      'suspended',       -- Suspendu (doc expiré ou problème)
      'rejected'         -- Rejeté définitivement
    ));

ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS kyc_completed_at TIMESTAMPTZ;

ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS suspension_reason TEXT;

ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS suspension_until TIMESTAMPTZ;

-- Type de prestataire (pour déterminer les documents requis)
ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS provider_type TEXT DEFAULT 'independant' 
    CHECK (provider_type IN ('independant', 'entreprise', 'btp'));

-- Informations entreprise
ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS raison_sociale TEXT;

ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS siren TEXT;

ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS siret TEXT;

ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS tva_intra TEXT;

ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS adresse TEXT;

ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS code_postal TEXT;

ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS ville TEXT;

-- Score de conformité (calculé)
ALTER TABLE provider_profiles 
  ADD COLUMN IF NOT EXISTS compliance_score INTEGER DEFAULT 0;

-- Index pour les statuts KYC
CREATE INDEX IF NOT EXISTS idx_provider_profiles_kyc ON provider_profiles(kyc_status);
CREATE INDEX IF NOT EXISTS idx_provider_profiles_type ON provider_profiles(provider_type);

-- =====================================================
-- 4. TABLE: provider_kyc_requirements
-- Documents requis par type de prestataire
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_kyc_requirements (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider_type TEXT NOT NULL CHECK (provider_type IN ('independant', 'entreprise', 'btp')),
  document_type TEXT NOT NULL,
  is_required BOOLEAN DEFAULT true,
  has_expiration BOOLEAN DEFAULT false,
  max_age_months INTEGER, -- Pour les documents avec date de validité max (ex: Kbis < 3 mois)
  description TEXT,
  help_text TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Données de référence
INSERT INTO provider_kyc_requirements (provider_type, document_type, is_required, has_expiration, max_age_months, description, help_text) VALUES
-- Indépendant
('independant', 'rc_pro', true, true, NULL, 'Responsabilité Civile Professionnelle', 'Attestation RC Pro en cours de validité'),
('independant', 'id_card_recto', true, true, NULL, 'Pièce d''identité (recto)', 'CNI, passeport ou titre de séjour'),
('independant', 'rib', true, false, NULL, 'RIB', 'Relevé d''Identité Bancaire'),
('independant', 'urssaf', true, true, 6, 'Attestation URSSAF', 'Attestation de moins de 6 mois'),

-- Entreprise
('entreprise', 'rc_pro', true, true, NULL, 'Responsabilité Civile Professionnelle', 'Attestation RC Pro en cours de validité'),
('entreprise', 'kbis', true, true, 3, 'Extrait Kbis', 'Kbis de moins de 3 mois'),
('entreprise', 'id_card_recto', true, true, NULL, 'Pièce d''identité du gérant (recto)', 'CNI, passeport ou titre de séjour du représentant légal'),
('entreprise', 'rib', true, false, NULL, 'RIB', 'Relevé d''Identité Bancaire de l''entreprise'),
('entreprise', 'urssaf', true, true, 6, 'Attestation URSSAF', 'Attestation de moins de 6 mois'),

-- BTP (inclut entreprise + décennale)
('btp', 'rc_pro', true, true, NULL, 'Responsabilité Civile Professionnelle', 'Attestation RC Pro en cours de validité'),
('btp', 'decennale', true, true, NULL, 'Garantie décennale', 'Attestation de garantie décennale en cours de validité'),
('btp', 'kbis', true, true, 3, 'Extrait Kbis', 'Kbis de moins de 3 mois'),
('btp', 'id_card_recto', true, true, NULL, 'Pièce d''identité du gérant (recto)', 'CNI, passeport ou titre de séjour'),
('btp', 'rib', true, false, NULL, 'RIB', 'Relevé d''Identité Bancaire'),
('btp', 'urssaf', true, true, 6, 'Attestation URSSAF', 'Attestation de moins de 6 mois'),
('btp', 'qualification', false, false, NULL, 'Qualification professionnelle', 'RGE, Qualibat, QualiPV, etc.')

ON CONFLICT DO NOTHING;

-- =====================================================
-- 5. FONCTIONS: Calcul compliance et alertes
-- =====================================================

-- Fonction pour calculer le score de compliance d'un prestataire
CREATE OR REPLACE FUNCTION calculate_provider_compliance_score(p_provider_profile_id UUID)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_provider_type TEXT;
  v_total_required INTEGER;
  v_total_verified INTEGER;
  v_score INTEGER;
BEGIN
  -- Récupérer le type de prestataire
  SELECT provider_type INTO v_provider_type
  FROM provider_profiles
  WHERE profile_id = p_provider_profile_id;
  
  IF v_provider_type IS NULL THEN
    v_provider_type := 'independant';
  END IF;
  
  -- Compter les documents requis
  SELECT COUNT(*) INTO v_total_required
  FROM provider_kyc_requirements
  WHERE provider_type = v_provider_type
  AND is_required = true;
  
  -- Compter les documents vérifiés et non expirés
  SELECT COUNT(*) INTO v_total_verified
  FROM provider_compliance_documents pcd
  JOIN provider_kyc_requirements pkr ON pkr.document_type = pcd.document_type AND pkr.provider_type = v_provider_type
  WHERE pcd.provider_profile_id = p_provider_profile_id
  AND pcd.verification_status = 'verified'
  AND (pcd.expiration_date IS NULL OR pcd.expiration_date > CURRENT_DATE)
  AND pkr.is_required = true;
  
  -- Calculer le score (0-100)
  IF v_total_required > 0 THEN
    v_score := (v_total_verified::DECIMAL / v_total_required * 100)::INTEGER;
  ELSE
    v_score := 100;
  END IF;
  
  -- Mettre à jour le score dans le profil
  UPDATE provider_profiles
  SET compliance_score = v_score,
      updated_at = NOW()
  WHERE profile_id = p_provider_profile_id;
  
  RETURN v_score;
END;
$$;

-- Fonction pour déterminer le statut KYC
CREATE OR REPLACE FUNCTION update_provider_kyc_status(p_provider_profile_id UUID)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_provider_type TEXT;
  v_score INTEGER;
  v_has_expired BOOLEAN;
  v_has_pending BOOLEAN;
  v_new_status TEXT;
BEGIN
  -- Récupérer le type de prestataire
  SELECT COALESCE(provider_type, 'independant') INTO v_provider_type
  FROM provider_profiles
  WHERE profile_id = p_provider_profile_id;
  
  -- Calculer le score
  v_score := calculate_provider_compliance_score(p_provider_profile_id);
  
  -- Vérifier s'il y a des documents expirés
  SELECT EXISTS (
    SELECT 1 FROM provider_compliance_documents pcd
    JOIN provider_kyc_requirements pkr ON pkr.document_type = pcd.document_type AND pkr.provider_type = v_provider_type
    WHERE pcd.provider_profile_id = p_provider_profile_id
    AND pkr.is_required = true
    AND pcd.expiration_date IS NOT NULL
    AND pcd.expiration_date < CURRENT_DATE
  ) INTO v_has_expired;
  
  -- Vérifier s'il y a des documents en attente
  SELECT EXISTS (
    SELECT 1 FROM provider_compliance_documents
    WHERE provider_profile_id = p_provider_profile_id
    AND verification_status = 'pending'
  ) INTO v_has_pending;
  
  -- Déterminer le nouveau statut
  IF v_has_expired THEN
    v_new_status := 'suspended';
  ELSIF v_score = 100 AND NOT v_has_pending THEN
    v_new_status := 'verified';
  ELSIF v_has_pending OR v_score > 0 THEN
    v_new_status := 'pending_review';
  ELSE
    v_new_status := 'incomplete';
  END IF;
  
  -- Mettre à jour le statut
  UPDATE provider_profiles
  SET 
    kyc_status = v_new_status,
    kyc_completed_at = CASE WHEN v_new_status = 'verified' THEN NOW() ELSE kyc_completed_at END,
    suspension_reason = CASE WHEN v_new_status = 'suspended' THEN 'Document expiré' ELSE NULL END,
    updated_at = NOW()
  WHERE profile_id = p_provider_profile_id;
  
  RETURN v_new_status;
END;
$$;

-- Fonction pour obtenir les documents manquants
CREATE OR REPLACE FUNCTION get_provider_missing_documents(p_provider_profile_id UUID)
RETURNS TABLE (
  document_type TEXT,
  description TEXT,
  help_text TEXT,
  is_required BOOLEAN,
  has_expiration BOOLEAN
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_provider_type TEXT;
BEGIN
  SELECT COALESCE(provider_type, 'independant') INTO v_provider_type
  FROM provider_profiles
  WHERE profile_id = p_provider_profile_id;
  
  RETURN QUERY
  SELECT 
    pkr.document_type,
    pkr.description,
    pkr.help_text,
    pkr.is_required,
    pkr.has_expiration
  FROM provider_kyc_requirements pkr
  WHERE pkr.provider_type = v_provider_type
  AND NOT EXISTS (
    SELECT 1 FROM provider_compliance_documents pcd
    WHERE pcd.provider_profile_id = p_provider_profile_id
    AND pcd.document_type = pkr.document_type
    AND pcd.verification_status IN ('pending', 'verified')
    AND (pcd.expiration_date IS NULL OR pcd.expiration_date > CURRENT_DATE)
  );
END;
$$;

-- Fonction pour lister les documents qui expirent bientôt
CREATE OR REPLACE FUNCTION get_expiring_provider_documents(p_days_ahead INTEGER DEFAULT 30)
RETURNS TABLE (
  provider_profile_id UUID,
  provider_name TEXT,
  provider_email TEXT,
  document_type TEXT,
  document_id UUID,
  expiration_date DATE,
  days_until_expiry INTEGER
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pcd.provider_profile_id,
    COALESCE(p.prenom || ' ' || p.nom, 'Prestataire') AS provider_name,
    u.email AS provider_email,
    pcd.document_type,
    pcd.id AS document_id,
    pcd.expiration_date,
    (pcd.expiration_date - CURRENT_DATE)::INTEGER AS days_until_expiry
  FROM provider_compliance_documents pcd
  JOIN profiles p ON p.id = pcd.provider_profile_id
  JOIN auth.users u ON u.id = p.user_id
  WHERE pcd.verification_status = 'verified'
  AND pcd.expiration_date IS NOT NULL
  AND pcd.expiration_date BETWEEN CURRENT_DATE AND (CURRENT_DATE + (p_days_ahead || ' days')::INTERVAL)
  ORDER BY pcd.expiration_date ASC;
END;
$$;

-- =====================================================
-- 6. TRIGGERS: Mise à jour automatique des statuts
-- =====================================================

-- Trigger après modification d'un document
CREATE OR REPLACE FUNCTION trigger_update_provider_compliance()
RETURNS TRIGGER AS $$
BEGIN
  -- Recalculer le statut KYC du prestataire
  PERFORM update_provider_kyc_status(COALESCE(NEW.provider_profile_id, OLD.provider_profile_id));
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_provider_compliance_update ON provider_compliance_documents;
CREATE TRIGGER trg_provider_compliance_update
  AFTER INSERT OR UPDATE OR DELETE ON provider_compliance_documents
  FOR EACH ROW EXECUTE FUNCTION trigger_update_provider_compliance();

-- Trigger updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_compliance_docs_updated_at ON provider_compliance_documents;
CREATE TRIGGER trg_compliance_docs_updated_at
  BEFORE UPDATE ON provider_compliance_documents
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS trg_payout_accounts_updated_at ON provider_payout_accounts;
CREATE TRIGGER trg_payout_accounts_updated_at
  BEFORE UPDATE ON provider_payout_accounts
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- 7. RLS POLICIES
-- =====================================================

-- Activer RLS
ALTER TABLE provider_compliance_documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE provider_payout_accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE provider_kyc_requirements ENABLE ROW LEVEL SECURITY;

-- Policies pour provider_compliance_documents

-- Les prestataires peuvent voir leurs propres documents
DROP POLICY IF EXISTS "Providers can view own documents" ON provider_compliance_documents;
CREATE POLICY "Providers can view own documents"
  ON provider_compliance_documents FOR SELECT
  USING (
    provider_profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  );

-- Les prestataires peuvent insérer leurs documents
DROP POLICY IF EXISTS "Providers can insert own documents" ON provider_compliance_documents;
CREATE POLICY "Providers can insert own documents"
  ON provider_compliance_documents FOR INSERT
  WITH CHECK (
    provider_profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  );

-- Les prestataires peuvent mettre à jour leurs documents non vérifiés
DROP POLICY IF EXISTS "Providers can update pending documents" ON provider_compliance_documents;
CREATE POLICY "Providers can update pending documents"
  ON provider_compliance_documents FOR UPDATE
  USING (
    provider_profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
    AND verification_status = 'pending'
  )
  WITH CHECK (
    provider_profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  );

-- Les admins peuvent tout voir
DROP POLICY IF EXISTS "Admins can view all documents" ON provider_compliance_documents;
CREATE POLICY "Admins can view all documents"
  ON provider_compliance_documents FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- Les admins peuvent tout modifier
DROP POLICY IF EXISTS "Admins can manage all documents" ON provider_compliance_documents;
CREATE POLICY "Admins can manage all documents"
  ON provider_compliance_documents FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- Policies pour provider_payout_accounts

-- Les prestataires peuvent gérer leurs comptes de paiement
DROP POLICY IF EXISTS "Providers can manage own payout accounts" ON provider_payout_accounts;
CREATE POLICY "Providers can manage own payout accounts"
  ON provider_payout_accounts FOR ALL
  USING (
    provider_profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  )
  WITH CHECK (
    provider_profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  );

-- Les admins peuvent voir tous les comptes
DROP POLICY IF EXISTS "Admins can view all payout accounts" ON provider_payout_accounts;
CREATE POLICY "Admins can view all payout accounts"
  ON provider_payout_accounts FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- Policies pour provider_kyc_requirements (lecture seule pour tous)
DROP POLICY IF EXISTS "Everyone can view kyc requirements" ON provider_kyc_requirements;
CREATE POLICY "Everyone can view kyc requirements"
  ON provider_kyc_requirements FOR SELECT
  USING (true);

-- =====================================================
-- 8. VUE: Statut compliance complet
-- =====================================================

CREATE OR REPLACE VIEW provider_compliance_status AS
SELECT 
  pp.profile_id,
  p.prenom || ' ' || p.nom AS provider_name,
  pp.provider_type,
  pp.raison_sociale,
  pp.siret,
  pp.status AS approval_status,
  pp.kyc_status,
  pp.compliance_score,
  pp.kyc_completed_at,
  pp.suspension_reason,
  pp.suspension_until,
  -- Statut des documents
  (
    SELECT jsonb_agg(jsonb_build_object(
      'type', pcd.document_type,
      'status', pcd.verification_status,
      'expiration_date', pcd.expiration_date,
      'is_expired', pcd.expiration_date IS NOT NULL AND pcd.expiration_date < CURRENT_DATE,
      'expires_soon', pcd.expiration_date IS NOT NULL AND pcd.expiration_date < (CURRENT_DATE + INTERVAL '30 days')
    ))
    FROM provider_compliance_documents pcd
    WHERE pcd.provider_profile_id = pp.profile_id
  ) AS documents,
  -- Documents manquants
  (
    SELECT array_agg(pkr.document_type)
    FROM provider_kyc_requirements pkr
    WHERE pkr.provider_type = COALESCE(pp.provider_type, 'independant')
    AND pkr.is_required = true
    AND NOT EXISTS (
      SELECT 1 FROM provider_compliance_documents pcd
      WHERE pcd.provider_profile_id = pp.profile_id
      AND pcd.document_type = pkr.document_type
      AND pcd.verification_status IN ('pending', 'verified')
    )
  ) AS missing_documents,
  -- Peut recevoir des missions
  (pp.status = 'approved' AND pp.kyc_status = 'verified') AS can_receive_missions,
  pp.created_at,
  pp.updated_at
FROM provider_profiles pp
JOIN profiles p ON p.id = pp.profile_id;

-- =====================================================
-- 9. COMMENTAIRES
-- =====================================================

COMMENT ON TABLE provider_compliance_documents IS 'Documents légaux des prestataires avec gestion des expirations';
COMMENT ON TABLE provider_payout_accounts IS 'Comptes bancaires pour les paiements aux prestataires';
COMMENT ON TABLE provider_kyc_requirements IS 'Référentiel des documents requis par type de prestataire';
COMMENT ON FUNCTION calculate_provider_compliance_score IS 'Calcule le score de conformité d''un prestataire (0-100)';
COMMENT ON FUNCTION update_provider_kyc_status IS 'Met à jour le statut KYC d''un prestataire';
COMMENT ON FUNCTION get_provider_missing_documents IS 'Retourne la liste des documents manquants pour un prestataire';
COMMENT ON FUNCTION get_expiring_provider_documents IS 'Liste les documents qui expirent dans les N prochains jours';



-- ========== 20251205300000_work_order_reports.sql ==========
-- =====================================================
-- MIGRATION: Rapports d'intervention SOTA 2025
-- Photos avant/après, checklists techniques, time tracking
-- =====================================================

-- =====================================================
-- 1. TABLE: checklist_templates
-- Templates de checklists par type d'intervention
-- =====================================================

CREATE TABLE IF NOT EXISTS checklist_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- Catégorisation
  service_type TEXT NOT NULL, -- plomberie, electricite, etc.
  intervention_type TEXT, -- depannage, installation, entretien, diagnostic
  name TEXT NOT NULL,
  description TEXT,
  
  -- Structure des items
  items JSONB NOT NULL DEFAULT '[]',
  -- Format: [
  --   {
  --     "id": "1",
  --     "label": "Texte de la question",
  --     "type": "checkbox" | "text" | "number" | "photo" | "select" | "rating",
  --     "required": true | false,
  --     "options": ["option1", "option2"] (pour select),
  --     "min": 0, "max": 10 (pour number/rating),
  --     "category": "sécurité" | "qualité" | "conformité"
  --   }
  -- ]
  
  -- Score de conformité
  min_score_required INTEGER DEFAULT 0, -- Score minimum pour valider
  
  -- Versioning
  version INTEGER DEFAULT 1,
  is_active BOOLEAN DEFAULT true,
  
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_checklist_templates_service ON checklist_templates(service_type);
CREATE INDEX IF NOT EXISTS idx_checklist_templates_active ON checklist_templates(is_active);

-- =====================================================
-- 2. TABLE: work_order_reports
-- Rapports d'intervention avec photos et checklists
-- =====================================================

CREATE TABLE IF NOT EXISTS work_order_reports (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  work_order_id UUID NOT NULL REFERENCES work_orders(id) ON DELETE CASCADE,
  
  -- Type de rapport
  report_type TEXT NOT NULL CHECK (report_type IN (
    'arrival',      -- Arrivée sur site (check-in)
    'before',       -- État avant intervention
    'during',       -- Pendant (pour longs chantiers)
    'after',        -- État après intervention
    'completion'    -- Rapport final de fin
  )),
  
  -- Horodatage précis
  reported_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Géolocalisation
  gps_latitude DECIMAL(10, 8),
  gps_longitude DECIMAL(11, 8),
  gps_accuracy DECIMAL(6, 2), -- Précision en mètres
  gps_address TEXT, -- Adresse reverse-geocodée
  
  -- Photos/Vidéos
  media_items JSONB DEFAULT '[]',
  -- Format: [
  --   {
  --     "id": "uuid",
  --     "type": "photo" | "video",
  --     "storage_path": "path/to/file",
  --     "thumbnail_path": "path/to/thumb",
  --     "caption": "Description",
  --     "taken_at": "2024-01-01T10:00:00Z",
  --     "ai_analysis": { ... } (optionnel)
  --   }
  -- ]
  
  -- Checklist technique
  checklist_template_id UUID REFERENCES checklist_templates(id),
  checklist_responses JSONB DEFAULT '{}',
  -- Format: { "item_id": "response_value", ... }
  checklist_score DECIMAL(5,2), -- Score de conformité calculé (0-100)
  
  -- Notes et observations
  technician_notes TEXT,
  anomalies_detected TEXT[], -- Liste des anomalies
  recommendations TEXT[], -- Recommandations pour le client
  
  -- Signature client (optionnel)
  client_signature_url TEXT,
  client_signed_at TIMESTAMPTZ,
  client_name TEXT,
  client_feedback TEXT,
  client_satisfaction INTEGER CHECK (client_satisfaction BETWEEN 1 AND 5),
  
  -- Métadonnées techniques
  device_info JSONB, -- Infos sur l'appareil utilisé
  app_version TEXT,
  
  -- Créateur
  created_by UUID NOT NULL REFERENCES profiles(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_work_order_reports_work_order ON work_order_reports(work_order_id);
CREATE INDEX IF NOT EXISTS idx_work_order_reports_type ON work_order_reports(report_type);
CREATE INDEX IF NOT EXISTS idx_work_order_reports_created_at ON work_order_reports(created_at);

-- Contrainte: un seul rapport par type par work_order (sauf 'during')
CREATE UNIQUE INDEX IF NOT EXISTS idx_work_order_reports_unique_type 
  ON work_order_reports(work_order_id, report_type) 
  WHERE report_type != 'during';

-- =====================================================
-- 3. EXTENSION: work_orders pour time tracking
-- =====================================================

-- Planification avancée
ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS scheduled_start_at TIMESTAMPTZ;

ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS scheduled_end_at TIMESTAMPTZ;

ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS estimated_duration_minutes INTEGER;

-- Time tracking réel
ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS actual_start_at TIMESTAMPTZ;

ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS actual_end_at TIMESTAMPTZ;

-- Acceptation
ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS accepted_at TIMESTAMPTZ;

ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS rejected_at TIMESTAMPTZ;

ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS rejection_reason TEXT;

-- Rapport final
ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS completion_notes TEXT;

ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS final_report_id UUID REFERENCES work_order_reports(id);

-- Qualité et satisfaction
ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS quality_score DECIMAL(5,2);

ALTER TABLE work_orders 
  ADD COLUMN IF NOT EXISTS client_satisfaction INTEGER CHECK (client_satisfaction BETWEEN 1 AND 5);

-- =====================================================
-- 4. TABLE: work_order_time_entries
-- Entrées de temps détaillées (pour les interventions longues)
-- =====================================================

CREATE TABLE IF NOT EXISTS work_order_time_entries (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  work_order_id UUID NOT NULL REFERENCES work_orders(id) ON DELETE CASCADE,
  
  -- Type d'entrée
  entry_type TEXT NOT NULL CHECK (entry_type IN (
    'travel',       -- Trajet
    'work',         -- Travail sur site
    'break',        -- Pause
    'waiting'       -- Attente (pièces, client, etc.)
  )),
  
  -- Temps
  started_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  duration_minutes INTEGER, -- Calculé automatiquement
  
  -- Notes
  description TEXT,
  
  -- GPS au démarrage
  start_latitude DECIMAL(10, 8),
  start_longitude DECIMAL(11, 8),
  
  created_by UUID NOT NULL REFERENCES profiles(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_time_entries_work_order ON work_order_time_entries(work_order_id);
CREATE INDEX IF NOT EXISTS idx_time_entries_type ON work_order_time_entries(entry_type);

-- =====================================================
-- 5. FONCTIONS
-- =====================================================

-- Fonction pour calculer le score d'une checklist
CREATE OR REPLACE FUNCTION calculate_checklist_score(
  p_template_id UUID,
  p_responses JSONB
)
RETURNS DECIMAL
LANGUAGE plpgsql
AS $$
DECLARE
  v_template RECORD;
  v_items JSONB;
  v_total_points DECIMAL := 0;
  v_earned_points DECIMAL := 0;
  v_item JSONB;
  v_response TEXT;
BEGIN
  -- Récupérer le template
  SELECT items INTO v_items
  FROM checklist_templates
  WHERE id = p_template_id;
  
  IF v_items IS NULL THEN
    RETURN NULL;
  END IF;
  
  -- Parcourir les items
  FOR v_item IN SELECT * FROM jsonb_array_elements(v_items)
  LOOP
    -- Chaque item vaut 1 point s'il est required
    IF (v_item->>'required')::boolean = true THEN
      v_total_points := v_total_points + 1;
      
      -- Vérifier la réponse
      v_response := p_responses->>v_item->>'id';
      
      IF v_response IS NOT NULL AND v_response != '' AND v_response != 'false' THEN
        v_earned_points := v_earned_points + 1;
      END IF;
    END IF;
  END LOOP;
  
  -- Calculer le score (0-100)
  IF v_total_points > 0 THEN
    RETURN ROUND((v_earned_points / v_total_points) * 100, 2);
  ELSE
    RETURN 100; -- Pas d'items requis = 100%
  END IF;
END;
$$;

-- Fonction pour générer un résumé de rapport d'intervention
CREATE OR REPLACE FUNCTION get_work_order_report_summary(p_work_order_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'work_order_id', wo.id,
    'status', wo.statut,
    'scheduled', jsonb_build_object(
      'start', wo.scheduled_start_at,
      'end', wo.scheduled_end_at,
      'duration_minutes', wo.estimated_duration_minutes
    ),
    'actual', jsonb_build_object(
      'start', wo.actual_start_at,
      'end', wo.actual_end_at,
      'duration_minutes', EXTRACT(EPOCH FROM (wo.actual_end_at - wo.actual_start_at)) / 60
    ),
    'punctuality_minutes', EXTRACT(EPOCH FROM (wo.actual_start_at - wo.scheduled_start_at)) / 60,
    'reports', (
      SELECT jsonb_agg(jsonb_build_object(
        'id', wor.id,
        'type', wor.report_type,
        'reported_at', wor.reported_at,
        'photos_count', jsonb_array_length(COALESCE(wor.media_items, '[]')),
        'checklist_score', wor.checklist_score,
        'has_anomalies', array_length(wor.anomalies_detected, 1) > 0
      ) ORDER BY wor.reported_at)
      FROM work_order_reports wor
      WHERE wor.work_order_id = wo.id
    ),
    'time_entries', (
      SELECT jsonb_agg(jsonb_build_object(
        'type', wte.entry_type,
        'duration_minutes', wte.duration_minutes
      ))
      FROM work_order_time_entries wte
      WHERE wte.work_order_id = wo.id
    ),
    'total_work_time_minutes', (
      SELECT SUM(duration_minutes)
      FROM work_order_time_entries
      WHERE work_order_id = wo.id AND entry_type = 'work'
    ),
    'quality_score', wo.quality_score,
    'client_satisfaction', wo.client_satisfaction,
    'completion_notes', wo.completion_notes
  ) INTO v_result
  FROM work_orders wo
  WHERE wo.id = p_work_order_id;
  
  RETURN v_result;
END;
$$;

-- =====================================================
-- 6. TRIGGERS
-- =====================================================

-- Trigger pour calculer la durée des entrées de temps
CREATE OR REPLACE FUNCTION trigger_calculate_time_entry_duration()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.ended_at IS NOT NULL AND NEW.started_at IS NOT NULL THEN
    NEW.duration_minutes := EXTRACT(EPOCH FROM (NEW.ended_at - NEW.started_at)) / 60;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_time_entry_duration ON work_order_time_entries;
CREATE TRIGGER trg_time_entry_duration
  BEFORE INSERT OR UPDATE OF ended_at ON work_order_time_entries
  FOR EACH ROW EXECUTE FUNCTION trigger_calculate_time_entry_duration();

-- Trigger pour mettre à jour le score de checklist
CREATE OR REPLACE FUNCTION trigger_update_checklist_score()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.checklist_template_id IS NOT NULL AND NEW.checklist_responses IS NOT NULL THEN
    NEW.checklist_score := calculate_checklist_score(NEW.checklist_template_id, NEW.checklist_responses);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_update_checklist_score ON work_order_reports;
CREATE TRIGGER trg_update_checklist_score
  BEFORE INSERT OR UPDATE OF checklist_responses ON work_order_reports
  FOR EACH ROW EXECUTE FUNCTION trigger_update_checklist_score();

-- Trigger updated_at
DROP TRIGGER IF EXISTS trg_work_order_reports_updated_at ON work_order_reports;
CREATE TRIGGER trg_work_order_reports_updated_at
  BEFORE UPDATE ON work_order_reports
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS trg_checklist_templates_updated_at ON checklist_templates;
CREATE TRIGGER trg_checklist_templates_updated_at
  BEFORE UPDATE ON checklist_templates
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- 7. RLS POLICIES
-- =====================================================

ALTER TABLE work_order_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE work_order_time_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE checklist_templates ENABLE ROW LEVEL SECURITY;

-- Policies pour work_order_reports

-- Les prestataires peuvent voir et créer des rapports pour leurs interventions
DROP POLICY IF EXISTS "Providers can manage own work order reports" ON work_order_reports;
CREATE POLICY "Providers can manage own work order reports"
  ON work_order_reports FOR ALL
  USING (
    work_order_id IN (
      SELECT id FROM work_orders 
      WHERE provider_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  )
  WITH CHECK (
    work_order_id IN (
      SELECT id FROM work_orders 
      WHERE provider_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- Les propriétaires peuvent voir les rapports de leurs propriétés
DROP POLICY IF EXISTS "Owners can view work order reports" ON work_order_reports;
CREATE POLICY "Owners can view work order reports"
  ON work_order_reports FOR SELECT
  USING (
    work_order_id IN (
      SELECT wo.id FROM work_orders wo
      JOIN tickets t ON t.id = wo.ticket_id
      JOIN properties p ON p.id = t.property_id
      WHERE p.owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- Les admins peuvent tout voir
DROP POLICY IF EXISTS "Admins can view all reports" ON work_order_reports;
CREATE POLICY "Admins can view all reports"
  ON work_order_reports FOR SELECT
  USING (
    EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- Policies pour work_order_time_entries
DROP POLICY IF EXISTS "Providers can manage own time entries" ON work_order_time_entries;
CREATE POLICY "Providers can manage own time entries"
  ON work_order_time_entries FOR ALL
  USING (
    work_order_id IN (
      SELECT id FROM work_orders 
      WHERE provider_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

DROP POLICY IF EXISTS "Owners can view time entries" ON work_order_time_entries;
CREATE POLICY "Owners can view time entries"
  ON work_order_time_entries FOR SELECT
  USING (
    work_order_id IN (
      SELECT wo.id FROM work_orders wo
      JOIN tickets t ON t.id = wo.ticket_id
      JOIN properties p ON p.id = t.property_id
      WHERE p.owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- Policies pour checklist_templates (lecture pour tous les authentifiés)
DROP POLICY IF EXISTS "Authenticated users can view templates" ON checklist_templates;
CREATE POLICY "Authenticated users can view templates"
  ON checklist_templates FOR SELECT
  USING (is_active = true);

DROP POLICY IF EXISTS "Admins can manage templates" ON checklist_templates;
CREATE POLICY "Admins can manage templates"
  ON checklist_templates FOR ALL
  USING (
    EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- =====================================================
-- 8. DONNÉES INITIALES: Templates de checklists
-- =====================================================

INSERT INTO checklist_templates (service_type, intervention_type, name, description, items) VALUES
(
  'plomberie',
  'depannage',
  'Intervention fuite standard',
  'Checklist pour les interventions de réparation de fuite',
  '[
    {"id": "1", "label": "État général de la tuyauterie visible", "type": "select", "required": true, "options": ["Bon", "Usé", "Critique"], "category": "diagnostic"},
    {"id": "2", "label": "Photo de la zone de fuite AVANT", "type": "photo", "required": true, "category": "documentation"},
    {"id": "3", "label": "Origine de la fuite identifiée", "type": "text", "required": true, "category": "diagnostic"},
    {"id": "4", "label": "Joint remplacé", "type": "checkbox", "required": false, "category": "travaux"},
    {"id": "5", "label": "Pièces remplacées (détail)", "type": "text", "required": false, "category": "travaux"},
    {"id": "6", "label": "Test d''étanchéité effectué", "type": "checkbox", "required": true, "category": "qualité"},
    {"id": "7", "label": "Pression eau vérifiée (bar)", "type": "number", "required": false, "min": 0, "max": 10, "category": "qualité"},
    {"id": "8", "label": "Photo de la zone APRÈS réparation", "type": "photo", "required": true, "category": "documentation"},
    {"id": "9", "label": "Zone nettoyée et séchée", "type": "checkbox", "required": true, "category": "finition"},
    {"id": "10", "label": "Recommandations pour le client", "type": "text", "required": false, "category": "conseil"}
  ]'
),
(
  'electricite',
  'depannage',
  'Intervention électrique standard',
  'Checklist pour les interventions électriques de dépannage',
  '[
    {"id": "1", "label": "Coupure du courant effectuée", "type": "checkbox", "required": true, "category": "sécurité"},
    {"id": "2", "label": "Photo du tableau électrique", "type": "photo", "required": true, "category": "documentation"},
    {"id": "3", "label": "Disjoncteur concerné identifié", "type": "text", "required": true, "category": "diagnostic"},
    {"id": "4", "label": "Cause de la panne identifiée", "type": "text", "required": true, "category": "diagnostic"},
    {"id": "5", "label": "Test d''isolation effectué", "type": "checkbox", "required": true, "category": "qualité"},
    {"id": "6", "label": "Remplacement de pièce effectué", "type": "checkbox", "required": false, "category": "travaux"},
    {"id": "7", "label": "Détail des travaux réalisés", "type": "text", "required": true, "category": "travaux"},
    {"id": "8", "label": "Test de fonctionnement OK", "type": "checkbox", "required": true, "category": "qualité"},
    {"id": "9", "label": "Photo finale du tableau", "type": "photo", "required": true, "category": "documentation"},
    {"id": "10", "label": "Conformité NF C 15-100 vérifiée", "type": "checkbox", "required": true, "category": "conformité"}
  ]'
),
(
  'chauffage',
  'entretien',
  'Entretien chaudière annuel',
  'Checklist pour l''entretien annuel obligatoire de chaudière',
  '[
    {"id": "1", "label": "Marque et modèle de la chaudière", "type": "text", "required": true, "category": "identification"},
    {"id": "2", "label": "Photo de la plaque signalétique", "type": "photo", "required": true, "category": "documentation"},
    {"id": "3", "label": "Nettoyage du corps de chauffe effectué", "type": "checkbox", "required": true, "category": "travaux"},
    {"id": "4", "label": "Vérification du brûleur", "type": "checkbox", "required": true, "category": "travaux"},
    {"id": "5", "label": "Réglage de la combustion effectué", "type": "checkbox", "required": true, "category": "travaux"},
    {"id": "6", "label": "Taux de CO mesuré (ppm)", "type": "number", "required": true, "min": 0, "max": 1000, "category": "sécurité"},
    {"id": "7", "label": "Tirage conduit vérifié", "type": "checkbox", "required": true, "category": "sécurité"},
    {"id": "8", "label": "Pression circuit (bar)", "type": "number", "required": true, "min": 0, "max": 5, "category": "qualité"},
    {"id": "9", "label": "Vase d''expansion vérifié", "type": "checkbox", "required": true, "category": "travaux"},
    {"id": "10", "label": "Attestation d''entretien remise", "type": "checkbox", "required": true, "category": "documentation"}
  ]'
)
ON CONFLICT DO NOTHING;

-- =====================================================
-- 9. COMMENTAIRES
-- =====================================================

COMMENT ON TABLE work_order_reports IS 'Rapports d''intervention avec photos, checklists et time tracking';
COMMENT ON TABLE work_order_time_entries IS 'Entrées de temps détaillées pour les interventions';
COMMENT ON TABLE checklist_templates IS 'Templates de checklists par type d''intervention';
COMMENT ON FUNCTION calculate_checklist_score IS 'Calcule le score de conformité d''une checklist (0-100)';
COMMENT ON FUNCTION get_work_order_report_summary IS 'Génère un résumé complet d''un rapport d''intervention';



-- ========== 20251205400000_provider_analytics_dashboard.sql ==========
-- =====================================================
-- MIGRATION: Analytics Prestataire SOTA 2025
-- Dashboard enrichi avec KPIs avancés
-- =====================================================

-- D'abord, ajouter les colonnes manquantes à work_orders si elles n'existent pas
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'work_orders' AND column_name = 'accepted_at') THEN
    ALTER TABLE work_orders ADD COLUMN accepted_at TIMESTAMPTZ;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'work_orders' AND column_name = 'scheduled_start_at') THEN
    ALTER TABLE work_orders ADD COLUMN scheduled_start_at TIMESTAMPTZ;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'work_orders' AND column_name = 'actual_start_at') THEN
    ALTER TABLE work_orders ADD COLUMN actual_start_at TIMESTAMPTZ;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'work_orders' AND column_name = 'actual_end_at') THEN
    ALTER TABLE work_orders ADD COLUMN actual_end_at TIMESTAMPTZ;
  END IF;
END$$;

-- =====================================================
-- 1. FONCTION: Dashboard Analytics Prestataire Simplifié
-- =====================================================

CREATE OR REPLACE FUNCTION provider_analytics_dashboard(
  p_user_id UUID,
  p_period_start DATE DEFAULT (CURRENT_DATE - INTERVAL '30 days')::DATE,
  p_period_end DATE DEFAULT CURRENT_DATE
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile_id UUID;
  v_result JSONB;
BEGIN
  -- Récupérer le profil prestataire
  SELECT id INTO v_profile_id
  FROM profiles
  WHERE user_id = p_user_id AND role = 'provider';
  
  IF v_profile_id IS NULL THEN
    RETURN NULL;
  END IF;

  -- Assembler le résultat simplifié
  v_result := jsonb_build_object(
    'profile_id', v_profile_id,
    'period', jsonb_build_object(
      'start', p_period_start,
      'end', p_period_end
    ),
    'financial', (
      SELECT jsonb_build_object(
        'revenue_period', COALESCE(SUM(CASE WHEN statut = 'done' AND date_intervention_reelle BETWEEN p_period_start AND p_period_end THEN cout_final ELSE 0 END), 0),
        'revenue_pending', COALESCE(SUM(CASE WHEN statut IN ('assigned', 'scheduled') THEN cout_estime ELSE 0 END), 0),
        'invoices_count', COUNT(CASE WHEN statut = 'done' AND date_intervention_reelle BETWEEN p_period_start AND p_period_end THEN 1 END)
      )
      FROM work_orders
      WHERE provider_id = v_profile_id
    ),
    'missions', (
      SELECT jsonb_build_object(
        'total_assigned', COUNT(CASE WHEN created_at::DATE BETWEEN p_period_start AND p_period_end THEN 1 END),
        'completed', COUNT(CASE WHEN statut = 'done' AND date_intervention_reelle BETWEEN p_period_start AND p_period_end THEN 1 END),
        'cancelled', COUNT(CASE WHEN statut = 'cancelled' AND created_at::DATE BETWEEN p_period_start AND p_period_end THEN 1 END),
        'in_progress', COUNT(CASE WHEN statut IN ('assigned', 'scheduled') THEN 1 END)
      )
      FROM work_orders
      WHERE provider_id = v_profile_id
    ),
    'generated_at', NOW()
  );

  RETURN v_result;
END;
$$;

-- =====================================================
-- 2. INDEX pour les performances
-- =====================================================

CREATE INDEX IF NOT EXISTS idx_work_orders_date_intervention 
  ON work_orders(date_intervention_reelle);

CREATE INDEX IF NOT EXISTS idx_work_orders_provider_status 
  ON work_orders(provider_id, statut);

-- =====================================================
-- 3. COMMENTAIRES
-- =====================================================

COMMENT ON FUNCTION provider_analytics_dashboard IS 'Dashboard analytics pour un prestataire avec KPIs financiers et missions';


-- ========== 20251205500000_invoicing_professional.sql ==========
-- =====================================================
-- MIGRATION: Facturation Professionnelle SOTA 2025
-- Factures conformes avec mentions légales obligatoires
-- Acomptes, avoirs, pénalités de retard
-- =====================================================

-- =====================================================
-- 1. TABLE: provider_invoices (refonte complète)
-- =====================================================

-- Supprimer l'ancienne table si elle existe et la recréer
DROP TABLE IF EXISTS provider_invoice_items CASCADE;
DROP TABLE IF EXISTS provider_invoice_payments CASCADE;

-- Recréer provider_invoices avec tous les champs requis
CREATE TABLE IF NOT EXISTS provider_invoices (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- Numérotation unique et séquentielle (obligatoire légalement)
  invoice_number TEXT UNIQUE NOT NULL,
  
  -- Parties
  provider_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  owner_profile_id UUID REFERENCES profiles(id),
  property_id UUID REFERENCES properties(id),
  work_order_id UUID REFERENCES work_orders(id),
  
  -- Type de document
  document_type TEXT NOT NULL DEFAULT 'invoice' CHECK (document_type IN (
    'invoice',    -- Facture
    'quote',      -- Devis
    'credit_note' -- Avoir
  )),
  
  -- Référence (pour avoirs)
  related_invoice_id UUID REFERENCES provider_invoices(id),
  
  -- Informations générales
  title TEXT NOT NULL,
  description TEXT,
  
  -- Dates
  invoice_date DATE NOT NULL DEFAULT CURRENT_DATE,
  due_date DATE,
  paid_date DATE,
  
  -- Conditions de paiement
  payment_terms_days INTEGER DEFAULT 30,
  
  -- Montants
  subtotal DECIMAL(10,2) NOT NULL DEFAULT 0,
  discount_percent DECIMAL(5,2) DEFAULT 0,
  discount_amount DECIMAL(10,2) DEFAULT 0,
  tax_rate DECIMAL(5,2) NOT NULL DEFAULT 20.00,
  tax_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
  total_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
  
  -- Pénalités de retard (Article L441-10 Code Commerce)
  late_payment_rate DECIMAL(5,2) DEFAULT 10.00, -- Taux annuel
  fixed_recovery_fee DECIMAL(10,2) DEFAULT 40.00, -- Indemnité forfaitaire
  late_fees_amount DECIMAL(10,2) DEFAULT 0,
  
  -- Escompte
  early_payment_discount_rate DECIMAL(5,2), -- % escompte paiement anticipé
  early_payment_discount_days INTEGER, -- Délai pour bénéficier de l'escompte
  
  -- Statut
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN (
    'draft',      -- Brouillon
    'sent',       -- Envoyée
    'viewed',     -- Vue par le client
    'partial',    -- Partiellement payée
    'paid',       -- Payée
    'overdue',    -- En retard
    'disputed',   -- Contestée
    'cancelled',  -- Annulée
    'credited'    -- Avoir émis
  )),
  
  -- Envoi
  sent_at TIMESTAMPTZ,
  sent_to_email TEXT,
  viewed_at TIMESTAMPTZ,
  
  -- Rappels
  reminder_count INTEGER DEFAULT 0,
  last_reminder_at TIMESTAMPTZ,
  
  -- PDF
  pdf_storage_path TEXT,
  pdf_generated_at TIMESTAMPTZ,
  
  -- Mentions légales personnalisées
  custom_legal_mentions TEXT,
  custom_payment_info TEXT,
  
  -- Notes internes
  internal_notes TEXT,
  
  -- Métadonnées
  metadata JSONB DEFAULT '{}',
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Ajouter les colonnes manquantes si la table existe déjà
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'provider_profile_id') THEN
    ALTER TABLE provider_invoices ADD COLUMN provider_profile_id UUID REFERENCES profiles(id) ON DELETE CASCADE;
    -- Copier les données de provider_id si elle existe
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'provider_id') THEN
      UPDATE provider_invoices SET provider_profile_id = provider_id WHERE provider_profile_id IS NULL;
    END IF;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'owner_profile_id') THEN
    ALTER TABLE provider_invoices ADD COLUMN owner_profile_id UUID REFERENCES profiles(id);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'property_id') THEN
    ALTER TABLE provider_invoices ADD COLUMN property_id UUID REFERENCES properties(id);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'work_order_id') THEN
    ALTER TABLE provider_invoices ADD COLUMN work_order_id UUID REFERENCES work_orders(id);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'invoice_number') THEN
    ALTER TABLE provider_invoices ADD COLUMN invoice_number TEXT UNIQUE;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'title') THEN
    ALTER TABLE provider_invoices ADD COLUMN title TEXT;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'description') THEN
    ALTER TABLE provider_invoices ADD COLUMN description TEXT;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'subtotal') THEN
    ALTER TABLE provider_invoices ADD COLUMN subtotal DECIMAL(10,2) DEFAULT 0;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'tax_rate') THEN
    ALTER TABLE provider_invoices ADD COLUMN tax_rate DECIMAL(5,2) DEFAULT 20.00;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'tax_amount') THEN
    ALTER TABLE provider_invoices ADD COLUMN tax_amount DECIMAL(10,2) DEFAULT 0;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'total_amount') THEN
    ALTER TABLE provider_invoices ADD COLUMN total_amount DECIMAL(10,2) DEFAULT 0;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'document_type') THEN
    ALTER TABLE provider_invoices ADD COLUMN document_type TEXT DEFAULT 'invoice';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'due_date') THEN
    ALTER TABLE provider_invoices ADD COLUMN due_date DATE;
  END IF;
END$$;

-- Index conditionnels
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'provider_profile_id') THEN
    CREATE INDEX IF NOT EXISTS idx_provider_invoices_provider ON provider_invoices(provider_profile_id);
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'owner_profile_id') THEN
    CREATE INDEX IF NOT EXISTS idx_provider_invoices_owner ON provider_invoices(owner_profile_id);
  END IF;
END$$;
CREATE INDEX IF NOT EXISTS idx_provider_invoices_status ON provider_invoices(status);
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'invoice_date') THEN
    CREATE INDEX IF NOT EXISTS idx_provider_invoices_date ON provider_invoices(invoice_date);
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'due_date') THEN
    CREATE INDEX IF NOT EXISTS idx_provider_invoices_due_date ON provider_invoices(due_date);
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'provider_invoices' AND column_name = 'invoice_number') THEN
    CREATE INDEX IF NOT EXISTS idx_provider_invoices_number ON provider_invoices(invoice_number);
  END IF;
END$$;

-- =====================================================
-- 2. TABLE: provider_invoice_items (lignes de facture)
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_invoice_items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  invoice_id UUID NOT NULL REFERENCES provider_invoices(id) ON DELETE CASCADE,
  
  -- Description
  description TEXT NOT NULL,
  
  -- Quantité et prix
  quantity DECIMAL(10,3) NOT NULL DEFAULT 1,
  unit TEXT DEFAULT 'unité', -- unité, heure, m², kg, etc.
  unit_price DECIMAL(10,2) NOT NULL,
  
  -- TVA par ligne (peut varier)
  tax_rate DECIMAL(5,2) NOT NULL DEFAULT 20.00,
  
  -- Montants calculés
  subtotal DECIMAL(10,2) GENERATED ALWAYS AS (quantity * unit_price) STORED,
  tax_amount DECIMAL(10,2) GENERATED ALWAYS AS (quantity * unit_price * tax_rate / 100) STORED,
  total DECIMAL(10,2) GENERATED ALWAYS AS (quantity * unit_price * (1 + tax_rate / 100)) STORED,
  
  -- Remise par ligne
  discount_percent DECIMAL(5,2) DEFAULT 0,
  
  -- Ordre d'affichage
  sort_order INTEGER DEFAULT 0,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_invoice_items_invoice ON provider_invoice_items(invoice_id);

-- =====================================================
-- 3. TABLE: provider_invoice_payments (paiements)
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_invoice_payments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  invoice_id UUID NOT NULL REFERENCES provider_invoices(id) ON DELETE CASCADE,
  
  -- Montant
  amount DECIMAL(10,2) NOT NULL,
  
  -- Type de paiement
  payment_type TEXT NOT NULL CHECK (payment_type IN (
    'deposit',    -- Acompte
    'partial',    -- Paiement partiel
    'final',      -- Solde
    'refund'      -- Remboursement
  )),
  
  -- Méthode
  payment_method TEXT CHECK (payment_method IN (
    'card',       -- Carte bancaire
    'transfer',   -- Virement
    'check',      -- Chèque
    'cash',       -- Espèces
    'platform'    -- Via la plateforme
  )),
  
  -- Références
  transaction_id TEXT,
  stripe_payment_intent_id TEXT,
  check_number TEXT,
  
  -- Date
  paid_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Notes
  notes TEXT,
  
  -- Reçu
  receipt_number TEXT,
  receipt_pdf_path TEXT,
  
  created_by UUID REFERENCES profiles(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_invoice_payments_invoice ON provider_invoice_payments(invoice_id);
CREATE INDEX IF NOT EXISTS idx_invoice_payments_date ON provider_invoice_payments(paid_at);

-- =====================================================
-- 4. TABLE: invoice_number_sequences (séquences)
-- =====================================================

CREATE TABLE IF NOT EXISTS invoice_number_sequences (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  year INTEGER NOT NULL,
  last_number INTEGER NOT NULL DEFAULT 0,
  prefix TEXT DEFAULT 'FAC',
  
  UNIQUE(provider_profile_id, year)
);

-- =====================================================
-- 5. FONCTIONS
-- =====================================================

-- Fonction pour générer un numéro de facture unique
CREATE OR REPLACE FUNCTION generate_invoice_number(p_provider_id UUID)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  v_year INTEGER;
  v_next_number INTEGER;
  v_prefix TEXT;
  v_invoice_number TEXT;
BEGIN
  v_year := EXTRACT(YEAR FROM CURRENT_DATE);
  
  -- Récupérer ou créer la séquence
  INSERT INTO invoice_number_sequences (provider_profile_id, year, last_number, prefix)
  VALUES (p_provider_id, v_year, 0, 'FAC')
  ON CONFLICT (provider_profile_id, year) DO NOTHING;
  
  -- Incrémenter et récupérer le numéro
  UPDATE invoice_number_sequences
  SET last_number = last_number + 1
  WHERE provider_profile_id = p_provider_id AND year = v_year
  RETURNING last_number, prefix INTO v_next_number, v_prefix;
  
  -- Formater le numéro: FAC-2024-000001
  v_invoice_number := v_prefix || '-' || v_year || '-' || LPAD(v_next_number::TEXT, 6, '0');
  
  RETURN v_invoice_number;
END;
$$;

-- Fonction pour calculer les totaux d'une facture
CREATE OR REPLACE FUNCTION calculate_invoice_totals(p_invoice_id UUID)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
  v_subtotal DECIMAL(10,2);
  v_discount_amount DECIMAL(10,2);
  v_tax_amount DECIMAL(10,2);
  v_total_amount DECIMAL(10,2);
  v_discount_percent DECIMAL(5,2);
BEGIN
  -- Récupérer le pourcentage de remise
  SELECT discount_percent INTO v_discount_percent
  FROM provider_invoices WHERE id = p_invoice_id;
  
  -- Calculer le sous-total
  SELECT COALESCE(SUM(quantity * unit_price * (1 - COALESCE(discount_percent, 0) / 100)), 0)
  INTO v_subtotal
  FROM provider_invoice_items
  WHERE invoice_id = p_invoice_id;
  
  -- Appliquer la remise globale
  v_discount_amount := v_subtotal * COALESCE(v_discount_percent, 0) / 100;
  v_subtotal := v_subtotal - v_discount_amount;
  
  -- Calculer la TVA
  SELECT COALESCE(SUM(
    (quantity * unit_price * (1 - COALESCE(discount_percent, 0) / 100)) * tax_rate / 100
  ), 0)
  INTO v_tax_amount
  FROM provider_invoice_items
  WHERE invoice_id = p_invoice_id;
  
  -- Ajuster la TVA avec la remise globale
  v_tax_amount := v_tax_amount * (1 - COALESCE(v_discount_percent, 0) / 100);
  
  -- Total
  v_total_amount := v_subtotal + v_tax_amount;
  
  -- Mettre à jour la facture
  UPDATE provider_invoices
  SET 
    subtotal = v_subtotal,
    discount_amount = v_discount_amount,
    tax_amount = v_tax_amount,
    total_amount = v_total_amount,
    updated_at = NOW()
  WHERE id = p_invoice_id;
END;
$$;

-- Fonction pour calculer le solde dû d'une facture
CREATE OR REPLACE FUNCTION get_invoice_balance(p_invoice_id UUID)
RETURNS DECIMAL(10,2)
LANGUAGE plpgsql
AS $$
DECLARE
  v_total DECIMAL(10,2);
  v_paid DECIMAL(10,2);
BEGIN
  SELECT total_amount INTO v_total
  FROM provider_invoices WHERE id = p_invoice_id;
  
  SELECT COALESCE(SUM(
    CASE WHEN payment_type = 'refund' THEN -amount ELSE amount END
  ), 0) INTO v_paid
  FROM provider_invoice_payments WHERE invoice_id = p_invoice_id;
  
  RETURN v_total - v_paid;
END;
$$;

-- Fonction pour calculer les pénalités de retard
CREATE OR REPLACE FUNCTION calculate_late_fees(p_invoice_id UUID)
RETURNS DECIMAL(10,2)
LANGUAGE plpgsql
AS $$
DECLARE
  v_invoice RECORD;
  v_balance DECIMAL(10,2);
  v_days_late INTEGER;
  v_late_fees DECIMAL(10,2);
BEGIN
  SELECT * INTO v_invoice
  FROM provider_invoices WHERE id = p_invoice_id;
  
  IF v_invoice.due_date IS NULL OR v_invoice.due_date >= CURRENT_DATE THEN
    RETURN 0;
  END IF;
  
  v_balance := get_invoice_balance(p_invoice_id);
  IF v_balance <= 0 THEN
    RETURN 0;
  END IF;
  
  v_days_late := CURRENT_DATE - v_invoice.due_date;
  
  -- Pénalités = (solde * taux annuel / 365 * jours de retard) + indemnité forfaitaire
  v_late_fees := (v_balance * v_invoice.late_payment_rate / 100 / 365 * v_days_late) + v_invoice.fixed_recovery_fee;
  
  -- Mettre à jour la facture
  UPDATE provider_invoices
  SET late_fees_amount = v_late_fees
  WHERE id = p_invoice_id;
  
  RETURN v_late_fees;
END;
$$;

-- Fonction pour générer les données du PDF
CREATE OR REPLACE FUNCTION get_invoice_pdf_data(p_invoice_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'invoice', jsonb_build_object(
      'number', pi.invoice_number,
      'date', pi.invoice_date,
      'due_date', pi.due_date,
      'type', pi.document_type,
      'title', pi.title,
      'description', pi.description,
      'subtotal', pi.subtotal,
      'discount_percent', pi.discount_percent,
      'discount_amount', pi.discount_amount,
      'tax_rate', pi.tax_rate,
      'tax_amount', pi.tax_amount,
      'total_amount', pi.total_amount,
      'late_payment_rate', pi.late_payment_rate,
      'fixed_recovery_fee', pi.fixed_recovery_fee,
      'early_payment_discount_rate', pi.early_payment_discount_rate,
      'custom_legal_mentions', pi.custom_legal_mentions,
      'custom_payment_info', pi.custom_payment_info
    ),
    'provider', jsonb_build_object(
      'name', COALESCE(pp.raison_sociale, p_prov.prenom || ' ' || p_prov.nom),
      'siret', pp.siret,
      'tva_intra', pp.tva_intra,
      'address', pp.adresse,
      'postal_code', pp.code_postal,
      'city', pp.ville,
      'phone', p_prov.telephone,
      'email', (SELECT email FROM auth.users WHERE id = p_prov.user_id)
    ),
    'client', jsonb_build_object(
      'name', p_own.prenom || ' ' || p_own.nom,
      'address', prop.adresse_complete,
      'postal_code', prop.code_postal,
      'city', prop.ville
    ),
    'items', (
      SELECT jsonb_agg(jsonb_build_object(
        'description', pii.description,
        'quantity', pii.quantity,
        'unit', pii.unit,
        'unit_price', pii.unit_price,
        'tax_rate', pii.tax_rate,
        'subtotal', pii.subtotal,
        'total', pii.total
      ) ORDER BY pii.sort_order)
      FROM provider_invoice_items pii
      WHERE pii.invoice_id = pi.id
    ),
    'payments', (
      SELECT jsonb_agg(jsonb_build_object(
        'amount', pip.amount,
        'type', pip.payment_type,
        'method', pip.payment_method,
        'date', pip.paid_at
      ) ORDER BY pip.paid_at)
      FROM provider_invoice_payments pip
      WHERE pip.invoice_id = pi.id
    ),
    'balance', get_invoice_balance(pi.id),
    'legal_mentions', jsonb_build_object(
      'late_payment_text', 'En cas de retard de paiement, une pénalité de ' || pi.late_payment_rate || '% annuel sera appliquée.',
      'recovery_fee_text', 'Indemnité forfaitaire pour frais de recouvrement: ' || pi.fixed_recovery_fee || '€ (Article L441-10 du Code de Commerce).',
      'early_discount_text', CASE WHEN pi.early_payment_discount_rate IS NOT NULL 
        THEN 'Escompte de ' || pi.early_payment_discount_rate || '% pour paiement sous ' || pi.early_payment_discount_days || ' jours.'
        ELSE 'Pas d''escompte pour paiement anticipé.'
      END
    )
  ) INTO v_result
  FROM provider_invoices pi
  JOIN profiles p_prov ON p_prov.id = pi.provider_profile_id
  LEFT JOIN provider_profiles pp ON pp.profile_id = pi.provider_profile_id
  LEFT JOIN profiles p_own ON p_own.id = pi.owner_profile_id
  LEFT JOIN properties prop ON prop.id = pi.property_id
  WHERE pi.id = p_invoice_id;
  
  RETURN v_result;
END;
$$;

-- =====================================================
-- 6. TRIGGERS
-- =====================================================

-- Trigger pour générer le numéro de facture
CREATE OR REPLACE FUNCTION trigger_generate_invoice_number()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.invoice_number IS NULL THEN
    NEW.invoice_number := generate_invoice_number(NEW.provider_profile_id);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generate_invoice_number ON provider_invoices;
CREATE TRIGGER trg_generate_invoice_number
  BEFORE INSERT ON provider_invoices
  FOR EACH ROW EXECUTE FUNCTION trigger_generate_invoice_number();

-- Trigger pour recalculer les totaux après modification des items
CREATE OR REPLACE FUNCTION trigger_recalculate_invoice_totals()
RETURNS TRIGGER AS $$
BEGIN
  PERFORM calculate_invoice_totals(COALESCE(NEW.invoice_id, OLD.invoice_id));
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_recalculate_invoice_totals ON provider_invoice_items;
CREATE TRIGGER trg_recalculate_invoice_totals
  AFTER INSERT OR UPDATE OR DELETE ON provider_invoice_items
  FOR EACH ROW EXECUTE FUNCTION trigger_recalculate_invoice_totals();

-- Trigger pour mettre à jour le statut de la facture après paiement
CREATE OR REPLACE FUNCTION trigger_update_invoice_status_on_payment()
RETURNS TRIGGER AS $$
DECLARE
  v_balance DECIMAL(10,2);
  v_new_status TEXT;
BEGIN
  v_balance := get_invoice_balance(NEW.invoice_id);
  
  IF v_balance <= 0 THEN
    v_new_status := 'paid';
  ELSIF v_balance < (SELECT total_amount FROM provider_invoices WHERE id = NEW.invoice_id) THEN
    v_new_status := 'partial';
  ELSE
    -- Garder le statut actuel
    RETURN NEW;
  END IF;
  
  UPDATE provider_invoices
  SET 
    status = v_new_status,
    paid_date = CASE WHEN v_new_status = 'paid' THEN CURRENT_DATE ELSE paid_date END,
    updated_at = NOW()
  WHERE id = NEW.invoice_id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_update_invoice_status_on_payment ON provider_invoice_payments;
CREATE TRIGGER trg_update_invoice_status_on_payment
  AFTER INSERT ON provider_invoice_payments
  FOR EACH ROW EXECUTE FUNCTION trigger_update_invoice_status_on_payment();

-- Trigger updated_at
DROP TRIGGER IF EXISTS trg_provider_invoices_updated_at ON provider_invoices;
CREATE TRIGGER trg_provider_invoices_updated_at
  BEFORE UPDATE ON provider_invoices
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- 7. RLS POLICIES
-- =====================================================

ALTER TABLE provider_invoices ENABLE ROW LEVEL SECURITY;
ALTER TABLE provider_invoice_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE provider_invoice_payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE invoice_number_sequences ENABLE ROW LEVEL SECURITY;

-- Policies provider_invoices
DROP POLICY IF EXISTS "Providers can manage own invoices" ON provider_invoices;
CREATE POLICY "Providers can manage own invoices"
  ON provider_invoices FOR ALL
  USING (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()))
  WITH CHECK (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

DROP POLICY IF EXISTS "Owners can view invoices addressed to them" ON provider_invoices;
CREATE POLICY "Owners can view invoices addressed to them"
  ON provider_invoices FOR SELECT
  USING (owner_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

DROP POLICY IF EXISTS "Admins can view all invoices" ON provider_invoices;
CREATE POLICY "Admins can view all invoices"
  ON provider_invoices FOR SELECT
  USING (EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin'));

-- Policies provider_invoice_items
DROP POLICY IF EXISTS "Users can manage invoice items" ON provider_invoice_items;
CREATE POLICY "Users can manage invoice items"
  ON provider_invoice_items FOR ALL
  USING (
    invoice_id IN (
      SELECT id FROM provider_invoices 
      WHERE provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

DROP POLICY IF EXISTS "Owners can view invoice items" ON provider_invoice_items;
CREATE POLICY "Owners can view invoice items"
  ON provider_invoice_items FOR SELECT
  USING (
    invoice_id IN (
      SELECT id FROM provider_invoices 
      WHERE owner_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- Policies provider_invoice_payments
DROP POLICY IF EXISTS "Providers can manage payments" ON provider_invoice_payments;
CREATE POLICY "Providers can manage payments"
  ON provider_invoice_payments FOR ALL
  USING (
    invoice_id IN (
      SELECT id FROM provider_invoices 
      WHERE provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

DROP POLICY IF EXISTS "Owners can view payments" ON provider_invoice_payments;
CREATE POLICY "Owners can view payments"
  ON provider_invoice_payments FOR SELECT
  USING (
    invoice_id IN (
      SELECT id FROM provider_invoices 
      WHERE owner_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- Policies sequences
DROP POLICY IF EXISTS "Providers can manage own sequences" ON invoice_number_sequences;
CREATE POLICY "Providers can manage own sequences"
  ON invoice_number_sequences FOR ALL
  USING (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

-- =====================================================
-- 8. COMMENTAIRES
-- =====================================================

COMMENT ON TABLE provider_invoices IS 'Factures prestataires conformes aux obligations légales françaises';
COMMENT ON TABLE provider_invoice_items IS 'Lignes de facture avec TVA par ligne';
COMMENT ON TABLE provider_invoice_payments IS 'Paiements et acomptes sur factures';
COMMENT ON FUNCTION generate_invoice_number IS 'Génère un numéro de facture unique et séquentiel';
COMMENT ON FUNCTION calculate_invoice_totals IS 'Recalcule les totaux d''une facture';
COMMENT ON FUNCTION get_invoice_balance IS 'Retourne le solde dû d''une facture';
COMMENT ON FUNCTION calculate_late_fees IS 'Calcule les pénalités de retard selon l''Article L441-10';
COMMENT ON FUNCTION get_invoice_pdf_data IS 'Génère les données structurées pour la génération du PDF';



-- ========== 20251205600000_notifications_centralized.sql ==========
-- =====================================================
-- MIGRATION: Notifications Centralisées (version simplifiée)
-- =====================================================

-- Ajouter les colonnes manquantes à notifications si nécessaire
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'notifications' AND column_name = 'profile_id') THEN
    ALTER TABLE notifications ADD COLUMN profile_id UUID REFERENCES profiles(id) ON DELETE CASCADE;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'notifications' AND column_name = 'priority') THEN
    ALTER TABLE notifications ADD COLUMN priority TEXT DEFAULT 'normal';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'notifications' AND column_name = 'action_url') THEN
    ALTER TABLE notifications ADD COLUMN action_url TEXT;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'notifications' AND column_name = 'channels_status') THEN
    ALTER TABLE notifications ADD COLUMN channels_status JSONB DEFAULT '{}';
  END IF;
END$$;

-- Index conditionnels
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'notifications' AND column_name = 'profile_id') THEN
    CREATE INDEX IF NOT EXISTS idx_notifications_profile ON notifications(profile_id);
  END IF;
END$$;

-- Table de préférences de notifications
CREATE TABLE IF NOT EXISTS notification_preferences (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Canaux activés
  in_app_enabled BOOLEAN DEFAULT true,
  email_enabled BOOLEAN DEFAULT true,
  sms_enabled BOOLEAN DEFAULT false,
  push_enabled BOOLEAN DEFAULT false,
  
  -- Plages horaires (ne pas déranger)
  quiet_hours_start TIME,
  quiet_hours_end TIME,
  
  -- Fréquence des digests email
  email_digest_frequency TEXT DEFAULT 'instant',
  
  -- Templates désactivés
  disabled_templates TEXT[] DEFAULT '{}',
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(profile_id)
);

CREATE INDEX IF NOT EXISTS idx_notification_preferences_profile ON notification_preferences(profile_id);

-- RLS
ALTER TABLE notification_preferences ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can manage their notification preferences" ON notification_preferences;
CREATE POLICY "Users can manage their notification preferences"
  ON notification_preferences FOR ALL
  USING (profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()))
  WITH CHECK (profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

COMMENT ON TABLE notification_preferences IS 'Préférences de notification par utilisateur';


-- ========== 20251205700000_provider_missing_tables.sql ==========
-- =====================================================
-- MIGRATION: Tables et fonctions manquantes prestataire
-- Corrige les erreurs critiques du module prestataire
-- =====================================================

-- =====================================================
-- 1. TABLE: provider_reviews (avis clients)
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_reviews (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- Relations
  provider_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  reviewer_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  work_order_id UUID REFERENCES work_orders(id) ON DELETE SET NULL,
  property_id UUID REFERENCES properties(id) ON DELETE SET NULL,
  
  -- Notes (1-5)
  rating_overall INTEGER NOT NULL CHECK (rating_overall BETWEEN 1 AND 5),
  rating_punctuality INTEGER CHECK (rating_punctuality BETWEEN 1 AND 5),
  rating_quality INTEGER CHECK (rating_quality BETWEEN 1 AND 5),
  rating_communication INTEGER CHECK (rating_communication BETWEEN 1 AND 5),
  rating_value INTEGER CHECK (rating_value BETWEEN 1 AND 5),
  
  -- Contenu
  title TEXT,
  comment TEXT,
  would_recommend BOOLEAN DEFAULT true,
  
  -- Réponse du prestataire
  provider_response TEXT,
  provider_response_at TIMESTAMPTZ,
  
  -- Modération
  is_published BOOLEAN DEFAULT true,
  is_flagged BOOLEAN DEFAULT false,
  flag_reason TEXT,
  moderated_at TIMESTAMPTZ,
  moderated_by UUID REFERENCES profiles(id),
  
  -- Métadonnées
  helpful_count INTEGER DEFAULT 0,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_provider_reviews_provider ON provider_reviews(provider_profile_id);
CREATE INDEX IF NOT EXISTS idx_provider_reviews_reviewer ON provider_reviews(reviewer_profile_id);
CREATE INDEX IF NOT EXISTS idx_provider_reviews_rating ON provider_reviews(rating_overall);
CREATE INDEX IF NOT EXISTS idx_provider_reviews_published ON provider_reviews(is_published) WHERE is_published = true;

-- RLS
ALTER TABLE provider_reviews ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Anyone can read published reviews" ON provider_reviews;
CREATE POLICY "Anyone can read published reviews"
  ON provider_reviews FOR SELECT
  USING (is_published = true);

DROP POLICY IF EXISTS "Providers can read own reviews" ON provider_reviews;
CREATE POLICY "Providers can read own reviews"
  ON provider_reviews FOR SELECT
  USING (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

DROP POLICY IF EXISTS "Owners can create reviews" ON provider_reviews;
CREATE POLICY "Owners can create reviews"
  ON provider_reviews FOR INSERT
  WITH CHECK (reviewer_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid() AND role = 'owner'));

DROP POLICY IF EXISTS "Providers can respond to reviews" ON provider_reviews;
CREATE POLICY "Providers can respond to reviews"
  ON provider_reviews FOR UPDATE
  USING (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()))
  WITH CHECK (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

-- =====================================================
-- 2. TABLE: provider_availability (disponibilités)
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_availability (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Type de créneau
  type TEXT NOT NULL CHECK (type IN ('available', 'busy', 'vacation')),
  
  -- Récurrence ou date unique
  is_recurring BOOLEAN DEFAULT false,
  day_of_week INTEGER CHECK (day_of_week BETWEEN 0 AND 6), -- 0 = dimanche
  
  -- Horaires
  start_time TIME,
  end_time TIME,
  
  -- Pour les dates uniques
  specific_date DATE,
  
  -- Notes
  notes TEXT,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_provider_availability_provider ON provider_availability(provider_profile_id);
CREATE INDEX IF NOT EXISTS idx_provider_availability_date ON provider_availability(specific_date);
CREATE INDEX IF NOT EXISTS idx_provider_availability_day ON provider_availability(day_of_week);

-- RLS
ALTER TABLE provider_availability ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Providers can manage own availability" ON provider_availability;
CREATE POLICY "Providers can manage own availability"
  ON provider_availability FOR ALL
  USING (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()))
  WITH CHECK (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

DROP POLICY IF EXISTS "Owners can view provider availability" ON provider_availability;
CREATE POLICY "Owners can view provider availability"
  ON provider_availability FOR SELECT
  USING (EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'owner'));

-- =====================================================
-- 3. TABLE: provider_quotes (devis)
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_quotes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- Numérotation
  reference TEXT UNIQUE NOT NULL,
  
  -- Relations
  provider_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  owner_profile_id UUID REFERENCES profiles(id),
  property_id UUID REFERENCES properties(id),
  ticket_id UUID REFERENCES tickets(id),
  
  -- Contenu
  title TEXT NOT NULL,
  description TEXT,
  
  -- Montants
  subtotal DECIMAL(10,2) NOT NULL DEFAULT 0,
  tax_rate DECIMAL(5,2) NOT NULL DEFAULT 20,
  tax_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
  total_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
  
  -- Validité
  valid_until DATE,
  
  -- Statut
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'sent', 'viewed', 'accepted', 'rejected', 'expired', 'converted')),
  
  -- Dates
  sent_at TIMESTAMPTZ,
  viewed_at TIMESTAMPTZ,
  accepted_at TIMESTAMPTZ,
  rejected_at TIMESTAMPTZ,
  rejection_reason TEXT,
  
  -- Conversion en facture
  converted_invoice_id UUID,
  
  -- Notes
  internal_notes TEXT,
  terms_and_conditions TEXT,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_provider_quotes_provider ON provider_quotes(provider_profile_id);
CREATE INDEX IF NOT EXISTS idx_provider_quotes_owner ON provider_quotes(owner_profile_id);
CREATE INDEX IF NOT EXISTS idx_provider_quotes_status ON provider_quotes(status);
CREATE INDEX IF NOT EXISTS idx_provider_quotes_reference ON provider_quotes(reference);

-- RLS
ALTER TABLE provider_quotes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Providers can manage own quotes" ON provider_quotes;
CREATE POLICY "Providers can manage own quotes"
  ON provider_quotes FOR ALL
  USING (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()))
  WITH CHECK (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

DROP POLICY IF EXISTS "Owners can view quotes addressed to them" ON provider_quotes;
CREATE POLICY "Owners can view quotes addressed to them"
  ON provider_quotes FOR SELECT
  USING (owner_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

-- =====================================================
-- 4. TABLE: provider_quote_items (lignes de devis)
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_quote_items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  quote_id UUID NOT NULL REFERENCES provider_quotes(id) ON DELETE CASCADE,
  
  description TEXT NOT NULL,
  quantity DECIMAL(10,3) NOT NULL DEFAULT 1,
  unit TEXT DEFAULT 'unité',
  unit_price DECIMAL(10,2) NOT NULL,
  tax_rate DECIMAL(5,2) NOT NULL DEFAULT 20,
  
  subtotal DECIMAL(10,2) GENERATED ALWAYS AS (quantity * unit_price) STORED,
  
  sort_order INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_provider_quote_items_quote ON provider_quote_items(quote_id);

-- RLS
ALTER TABLE provider_quote_items ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can manage quote items via quotes" ON provider_quote_items;
CREATE POLICY "Users can manage quote items via quotes"
  ON provider_quote_items FOR ALL
  USING (
    quote_id IN (
      SELECT id FROM provider_quotes 
      WHERE provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- =====================================================
-- 5. FONCTION: provider_dashboard (dashboard principal)
-- =====================================================

CREATE OR REPLACE FUNCTION provider_dashboard(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile_id UUID;
  v_result JSONB;
  v_stats JSONB;
  v_pending_orders JSONB;
  v_recent_reviews JSONB;
BEGIN
  -- Récupérer le profil prestataire
  SELECT id INTO v_profile_id
  FROM profiles
  WHERE user_id = p_user_id AND role = 'provider';
  
  IF v_profile_id IS NULL THEN
    RETURN NULL;
  END IF;
  
  -- Statistiques
  SELECT jsonb_build_object(
    'total_interventions', COUNT(*),
    'completed_interventions', COUNT(*) FILTER (WHERE statut = 'done'),
    'pending_interventions', COUNT(*) FILTER (WHERE statut IN ('assigned', 'scheduled')),
    'in_progress_interventions', COUNT(*) FILTER (WHERE statut = 'in_progress'),
    'total_revenue', COALESCE(SUM(cout_final) FILTER (WHERE statut = 'done'), 0),
    'avg_rating', (
      SELECT ROUND(AVG(rating_overall)::NUMERIC, 1)
      FROM provider_reviews
      WHERE provider_profile_id = v_profile_id AND is_published = true
    ),
    'total_reviews', (
      SELECT COUNT(*) FROM provider_reviews
      WHERE provider_profile_id = v_profile_id AND is_published = true
    )
  ) INTO v_stats
  FROM work_orders
  WHERE provider_id = v_profile_id;
  
  -- Interventions en attente (avec détails)
  SELECT COALESCE(jsonb_agg(order_data ORDER BY order_data->>'created_at' DESC), '[]'::jsonb)
  INTO v_pending_orders
  FROM (
    SELECT jsonb_build_object(
      'id', wo.id,
      'ticket_id', wo.ticket_id,
      'statut', wo.statut,
      'cout_estime', wo.cout_estime,
      'date_intervention_prevue', wo.date_intervention_prevue,
      'created_at', wo.created_at,
      'ticket', jsonb_build_object(
        'titre', t.titre,
        'priorite', t.priorite
      ),
      'property', jsonb_build_object(
        'adresse', p.adresse_complete,
        'ville', p.ville
      )
    ) as order_data
    FROM work_orders wo
    JOIN tickets t ON t.id = wo.ticket_id
    JOIN properties p ON p.id = t.property_id
    WHERE wo.provider_id = v_profile_id
    AND wo.statut IN ('assigned', 'scheduled', 'in_progress')
    ORDER BY wo.created_at DESC
    LIMIT 10
  ) sub;
  
  -- Avis récents
  SELECT COALESCE(jsonb_agg(review_data ORDER BY review_data->>'created_at' DESC), '[]'::jsonb)
  INTO v_recent_reviews
  FROM (
    SELECT jsonb_build_object(
      'id', pr.id,
      'rating_overall', pr.rating_overall,
      'comment', pr.comment,
      'created_at', pr.created_at,
      'reviewer', jsonb_build_object(
        'prenom', prof.prenom,
        'nom', LEFT(prof.nom, 1) || '.'
      )
    ) as review_data
    FROM provider_reviews pr
    JOIN profiles prof ON prof.id = pr.reviewer_profile_id
    WHERE pr.provider_profile_id = v_profile_id
    AND pr.is_published = true
    ORDER BY pr.created_at DESC
    LIMIT 5
  ) sub;
  
  -- Construire le résultat final
  v_result := jsonb_build_object(
    'profile_id', v_profile_id,
    'stats', v_stats,
    'pending_orders', v_pending_orders,
    'recent_reviews', v_recent_reviews
  );
  
  RETURN v_result;
END;
$$;

-- =====================================================
-- 6. FONCTION: Génération numéro de devis
-- =====================================================

CREATE OR REPLACE FUNCTION generate_quote_reference(p_provider_id UUID)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  v_year INTEGER;
  v_count INTEGER;
BEGIN
  v_year := EXTRACT(YEAR FROM CURRENT_DATE);
  
  SELECT COUNT(*) + 1 INTO v_count
  FROM provider_quotes
  WHERE provider_profile_id = p_provider_id
  AND EXTRACT(YEAR FROM created_at) = v_year;
  
  RETURN 'DEV-' || v_year || '-' || LPAD(v_count::TEXT, 4, '0');
END;
$$;

-- Trigger pour générer automatiquement la référence
CREATE OR REPLACE FUNCTION trigger_generate_quote_reference()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.reference IS NULL THEN
    NEW.reference := generate_quote_reference(NEW.provider_profile_id);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generate_quote_reference ON provider_quotes;
CREATE TRIGGER trg_generate_quote_reference
  BEFORE INSERT ON provider_quotes
  FOR EACH ROW EXECUTE FUNCTION trigger_generate_quote_reference();

-- =====================================================
-- 7. TRIGGER: Calcul automatique des totaux de devis
-- =====================================================

CREATE OR REPLACE FUNCTION calculate_quote_totals()
RETURNS TRIGGER AS $$
DECLARE
  v_subtotal DECIMAL(10,2);
  v_tax_amount DECIMAL(10,2);
BEGIN
  SELECT 
    COALESCE(SUM(quantity * unit_price), 0),
    COALESCE(SUM(quantity * unit_price * tax_rate / 100), 0)
  INTO v_subtotal, v_tax_amount
  FROM provider_quote_items
  WHERE quote_id = COALESCE(NEW.quote_id, OLD.quote_id);
  
  UPDATE provider_quotes
  SET 
    subtotal = v_subtotal,
    tax_amount = v_tax_amount,
    total_amount = v_subtotal + v_tax_amount,
    updated_at = NOW()
  WHERE id = COALESCE(NEW.quote_id, OLD.quote_id);
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_calculate_quote_totals ON provider_quote_items;
CREATE TRIGGER trg_calculate_quote_totals
  AFTER INSERT OR UPDATE OR DELETE ON provider_quote_items
  FOR EACH ROW EXECUTE FUNCTION calculate_quote_totals();

-- =====================================================
-- 8. TRIGGERS: updated_at
-- =====================================================

DROP TRIGGER IF EXISTS trg_provider_reviews_updated_at ON provider_reviews;
CREATE TRIGGER trg_provider_reviews_updated_at
  BEFORE UPDATE ON provider_reviews
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS trg_provider_availability_updated_at ON provider_availability;
CREATE TRIGGER trg_provider_availability_updated_at
  BEFORE UPDATE ON provider_availability
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS trg_provider_quotes_updated_at ON provider_quotes;
CREATE TRIGGER trg_provider_quotes_updated_at
  BEFORE UPDATE ON provider_quotes
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- 9. COMMENTAIRES
-- =====================================================

COMMENT ON TABLE provider_reviews IS 'Avis clients sur les prestataires';
COMMENT ON TABLE provider_availability IS 'Disponibilités et créneaux des prestataires';
COMMENT ON TABLE provider_quotes IS 'Devis des prestataires';
COMMENT ON TABLE provider_quote_items IS 'Lignes de devis';
COMMENT ON FUNCTION provider_dashboard IS 'Dashboard principal du prestataire avec stats et interventions';



-- ========== 20251205800000_intervention_flow_complete.sql ==========
-- =====================================================
-- MIGRATION: Flux Intervention Complet SOTA 2025
-- Cycle: Visite → Devis → Acompte → Travaux → Solde
-- Frais transparents: 2.4% + 0.75€ (payés par prestataire)
-- =====================================================

-- =====================================================
-- 1. EXTENSION: work_orders - Nouveaux statuts
-- =====================================================

-- Supprimer l'ancienne contrainte
ALTER TABLE work_orders 
  DROP CONSTRAINT IF EXISTS work_orders_statut_check;

-- Ajouter les nouveaux statuts
ALTER TABLE work_orders 
  ADD CONSTRAINT work_orders_statut_check 
  CHECK (statut IN (
    -- Flux initial
    'assigned',           -- Assigné, en attente acceptation prestataire
    'accepted',           -- Accepté, en attente prise de RDV visite
    'refused',            -- Refusé par le prestataire
    
    -- Phase visite
    'visit_scheduled',    -- RDV visite planifié
    'visit_completed',    -- Visite effectuée, en attente devis
    
    -- Phase devis
    'quote_sent',         -- Devis envoyé
    'quote_accepted',     -- Devis accepté, en attente acompte
    'quote_refused',      -- Devis refusé
    
    -- Phase paiement acompte
    'deposit_pending',    -- Acompte en attente de paiement
    'deposit_paid',       -- Acompte payé (2/3), fonds en escrow
    
    -- Phase travaux
    'work_scheduled',     -- Travaux planifiés
    'in_progress',        -- Travaux en cours
    'work_completed',     -- Travaux terminés
    
    -- Phase solde
    'balance_pending',    -- Solde en attente de paiement
    'fully_paid',         -- Entièrement payé
    
    -- Clôture
    'pending_review',     -- En attente d'avis
    'closed',             -- Clôturé
    
    -- Cas particuliers
    'cancelled',          -- Annulé
    'disputed'            -- Litige en cours
  ));

-- Nouveaux champs pour le flux complet
ALTER TABLE work_orders
  -- Dates clés
  ADD COLUMN IF NOT EXISTS accepted_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS refused_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS refusal_reason TEXT,
  ADD COLUMN IF NOT EXISTS visit_scheduled_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS visit_completed_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS visit_notes TEXT,
  ADD COLUMN IF NOT EXISTS work_started_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS work_completed_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS completion_report TEXT,
  ADD COLUMN IF NOT EXISTS closed_at TIMESTAMPTZ,
  
  -- Lien avec le devis accepté
  ADD COLUMN IF NOT EXISTS accepted_quote_id UUID,
  
  -- Photos
  ADD COLUMN IF NOT EXISTS visit_photos JSONB DEFAULT '[]',
  ADD COLUMN IF NOT EXISTS before_photos JSONB DEFAULT '[]',
  ADD COLUMN IF NOT EXISTS after_photos JSONB DEFAULT '[]';

-- =====================================================
-- 2. TABLE: payment_fee_config
-- Configuration des frais de paiement
-- =====================================================

CREATE TABLE IF NOT EXISTS payment_fee_config (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- Identifiant unique de la config
  config_key TEXT UNIQUE NOT NULL DEFAULT 'default',
  
  -- Frais Stripe (incompressibles)
  stripe_percent DECIMAL(5,4) NOT NULL DEFAULT 0.014,    -- 1.4%
  stripe_fixed DECIMAL(10,2) NOT NULL DEFAULT 0.25,      -- 0.25€
  
  -- Marge plateforme
  platform_percent DECIMAL(5,4) NOT NULL DEFAULT 0.01,   -- 1.0%
  platform_fixed DECIMAL(10,2) NOT NULL DEFAULT 0.50,    -- 0.50€
  
  -- Qui paie les frais
  fee_payer TEXT NOT NULL DEFAULT 'provider' CHECK (fee_payer IN ('provider', 'owner', 'split')),
  
  -- Acompte
  deposit_percent DECIMAL(5,2) NOT NULL DEFAULT 66.67,   -- 2/3
  
  -- Actif
  is_active BOOLEAN DEFAULT true,
  
  -- Dates
  effective_from DATE NOT NULL DEFAULT CURRENT_DATE,
  effective_until DATE,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Insérer la configuration par défaut
INSERT INTO payment_fee_config (config_key, stripe_percent, stripe_fixed, platform_percent, platform_fixed, fee_payer, deposit_percent)
VALUES ('default', 0.014, 0.25, 0.01, 0.50, 'provider', 66.67)
ON CONFLICT (config_key) DO NOTHING;

-- =====================================================
-- 3. TABLE: work_order_payments
-- Paiements d'intervention (acompte + solde)
-- =====================================================

CREATE TABLE IF NOT EXISTS work_order_payments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- Relations
  work_order_id UUID NOT NULL REFERENCES work_orders(id) ON DELETE CASCADE,
  quote_id UUID REFERENCES provider_quotes(id),
  payer_profile_id UUID NOT NULL REFERENCES profiles(id),       -- Propriétaire qui paie
  payee_profile_id UUID NOT NULL REFERENCES profiles(id),       -- Prestataire qui reçoit
  
  -- Type de paiement
  payment_type TEXT NOT NULL CHECK (payment_type IN (
    'deposit',     -- Acompte (2/3)
    'balance',     -- Solde (1/3)
    'full',        -- Paiement intégral
    'refund'       -- Remboursement
  )),
  
  -- Montants bruts
  gross_amount DECIMAL(10,2) NOT NULL CHECK (gross_amount > 0),  -- Montant payé par propriétaire
  percentage_of_total DECIMAL(5,2),                               -- 66.67 ou 33.33
  
  -- Frais détaillés
  stripe_fee DECIMAL(10,2) NOT NULL DEFAULT 0,
  platform_fee DECIMAL(10,2) NOT NULL DEFAULT 0,
  total_fees DECIMAL(10,2) NOT NULL DEFAULT 0,
  
  -- Montant net pour le prestataire
  net_amount DECIMAL(10,2) NOT NULL,
  
  -- Méthode de paiement
  payment_method TEXT CHECK (payment_method IN ('card', 'sepa_debit', 'bank_transfer', 'direct')),
  
  -- Stripe
  stripe_payment_intent_id TEXT,
  stripe_charge_id TEXT,
  stripe_transfer_id TEXT,          -- Transfer vers le compte Connect du prestataire
  
  -- Escrow (séquestre)
  escrow_status TEXT DEFAULT 'none' CHECK (escrow_status IN (
    'none',       -- Pas d'escrow (paiement direct)
    'pending',    -- En attente de paiement
    'held',       -- Fonds bloqués sur la plateforme
    'released',   -- Libéré vers prestataire
    'refunded',   -- Remboursé au propriétaire
    'disputed'    -- En litige
  )),
  escrow_held_at TIMESTAMPTZ,
  escrow_released_at TIMESTAMPTZ,
  escrow_release_reason TEXT,
  
  -- Statut global
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
    'pending',      -- En attente
    'processing',   -- En cours de traitement
    'succeeded',    -- Réussi
    'failed',       -- Échoué
    'cancelled',    -- Annulé
    'refunded',     -- Remboursé
    'disputed'      -- Contesté
  )),
  
  -- Dates
  initiated_at TIMESTAMPTZ DEFAULT NOW(),
  paid_at TIMESTAMPTZ,
  failed_at TIMESTAMPTZ,
  failure_reason TEXT,
  failure_code TEXT,
  
  -- Facture de frais générée
  fee_invoice_id UUID,
  
  -- Métadonnées
  metadata JSONB DEFAULT '{}',
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_wo_payments_work_order ON work_order_payments(work_order_id);
CREATE INDEX IF NOT EXISTS idx_wo_payments_payer ON work_order_payments(payer_profile_id);
CREATE INDEX IF NOT EXISTS idx_wo_payments_payee ON work_order_payments(payee_profile_id);
CREATE INDEX IF NOT EXISTS idx_wo_payments_status ON work_order_payments(status);
CREATE INDEX IF NOT EXISTS idx_wo_payments_escrow ON work_order_payments(escrow_status);
CREATE INDEX IF NOT EXISTS idx_wo_payments_type ON work_order_payments(payment_type);
CREATE INDEX IF NOT EXISTS idx_wo_payments_stripe ON work_order_payments(stripe_payment_intent_id);

-- =====================================================
-- 4. TABLE: work_order_timeline
-- Historique complet des étapes
-- =====================================================

CREATE TABLE IF NOT EXISTS work_order_timeline (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  work_order_id UUID NOT NULL REFERENCES work_orders(id) ON DELETE CASCADE,
  
  -- Événement
  event_type TEXT NOT NULL CHECK (event_type IN (
    -- Création et assignation
    'created', 'assigned', 'accepted', 'refused',
    
    -- Visite
    'visit_proposed', 'visit_scheduled', 'visit_rescheduled', 'visit_completed', 'visit_cancelled',
    
    -- Devis
    'quote_created', 'quote_sent', 'quote_viewed', 'quote_accepted', 'quote_refused', 'quote_expired',
    
    -- Paiements
    'deposit_requested', 'deposit_paid', 'deposit_failed',
    'balance_requested', 'balance_paid', 'balance_failed',
    'payment_refunded',
    
    -- Travaux
    'work_scheduled', 'work_started', 'work_paused', 'work_resumed', 'work_completed',
    
    -- Clôture
    'review_requested', 'review_submitted', 'review_responded',
    'closed',
    
    -- Incidents
    'cancelled', 'dispute_opened', 'dispute_resolved',
    
    -- Communication
    'message_sent', 'photo_added', 'document_added',
    
    -- Système
    'reminder_sent', 'status_changed', 'auto_action'
  )),
  
  -- Acteur
  actor_profile_id UUID REFERENCES profiles(id),
  actor_role TEXT CHECK (actor_role IN ('owner', 'provider', 'tenant', 'admin', 'system')),
  
  -- Changement de statut
  old_status TEXT,
  new_status TEXT,
  
  -- Données de l'événement
  event_data JSONB DEFAULT '{}',
  
  -- Commentaire/description
  description TEXT,
  
  -- Visibilité
  is_internal BOOLEAN DEFAULT false,  -- Si true, visible uniquement par admin
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_wo_timeline_work_order ON work_order_timeline(work_order_id);
CREATE INDEX IF NOT EXISTS idx_wo_timeline_event ON work_order_timeline(event_type);
CREATE INDEX IF NOT EXISTS idx_wo_timeline_created ON work_order_timeline(created_at);
CREATE INDEX IF NOT EXISTS idx_wo_timeline_actor ON work_order_timeline(actor_profile_id);

-- =====================================================
-- 5. FONCTION: Calcul des frais de paiement
-- =====================================================

CREATE OR REPLACE FUNCTION calculate_payment_fees(
  p_amount DECIMAL(10,2),
  p_config_key TEXT DEFAULT 'default'
)
RETURNS TABLE (
  gross_amount DECIMAL(10,2),
  stripe_fee DECIMAL(10,2),
  platform_fee DECIMAL(10,2),
  total_fees DECIMAL(10,2),
  net_amount DECIMAL(10,2),
  effective_rate DECIMAL(5,2)
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_config payment_fee_config%ROWTYPE;
  v_stripe_fee DECIMAL(10,2);
  v_platform_fee DECIMAL(10,2);
  v_total_fees DECIMAL(10,2);
  v_net_amount DECIMAL(10,2);
BEGIN
  -- Récupérer la configuration
  SELECT * INTO v_config
  FROM payment_fee_config
  WHERE config_key = p_config_key AND is_active = true
  LIMIT 1;
  
  IF v_config IS NULL THEN
    -- Config par défaut si non trouvée
    v_stripe_fee := (p_amount * 0.014) + 0.25;
    v_platform_fee := (p_amount * 0.01) + 0.50;
  ELSE
    v_stripe_fee := (p_amount * v_config.stripe_percent) + v_config.stripe_fixed;
    v_platform_fee := (p_amount * v_config.platform_percent) + v_config.platform_fixed;
  END IF;
  
  -- Arrondir à 2 décimales
  v_stripe_fee := ROUND(v_stripe_fee, 2);
  v_platform_fee := ROUND(v_platform_fee, 2);
  v_total_fees := v_stripe_fee + v_platform_fee;
  v_net_amount := p_amount - v_total_fees;
  
  RETURN QUERY SELECT 
    p_amount,
    v_stripe_fee,
    v_platform_fee,
    v_total_fees,
    v_net_amount,
    ROUND((v_total_fees / p_amount * 100)::DECIMAL, 2);
END;
$$;

-- =====================================================
-- 6. FONCTION: Calcul acompte et solde
-- =====================================================

CREATE OR REPLACE FUNCTION calculate_deposit_and_balance(
  p_total_amount DECIMAL(10,2),
  p_config_key TEXT DEFAULT 'default'
)
RETURNS TABLE (
  total_amount DECIMAL(10,2),
  deposit_percent DECIMAL(5,2),
  deposit_amount DECIMAL(10,2),
  deposit_fees DECIMAL(10,2),
  deposit_net DECIMAL(10,2),
  balance_percent DECIMAL(5,2),
  balance_amount DECIMAL(10,2),
  balance_fees DECIMAL(10,2),
  balance_net DECIMAL(10,2),
  total_fees DECIMAL(10,2),
  total_net DECIMAL(10,2)
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_config payment_fee_config%ROWTYPE;
  v_deposit_pct DECIMAL(5,2);
  v_deposit_amt DECIMAL(10,2);
  v_balance_amt DECIMAL(10,2);
  v_deposit_fees RECORD;
  v_balance_fees RECORD;
BEGIN
  -- Récupérer la configuration
  SELECT * INTO v_config
  FROM payment_fee_config
  WHERE config_key = p_config_key AND is_active = true
  LIMIT 1;
  
  v_deposit_pct := COALESCE(v_config.deposit_percent, 66.67);
  v_deposit_amt := ROUND(p_total_amount * v_deposit_pct / 100, 2);
  v_balance_amt := p_total_amount - v_deposit_amt;
  
  -- Calculer les frais pour chaque paiement
  SELECT * INTO v_deposit_fees FROM calculate_payment_fees(v_deposit_amt, p_config_key);
  SELECT * INTO v_balance_fees FROM calculate_payment_fees(v_balance_amt, p_config_key);
  
  RETURN QUERY SELECT 
    p_total_amount,
    v_deposit_pct,
    v_deposit_amt,
    v_deposit_fees.total_fees,
    v_deposit_fees.net_amount,
    (100 - v_deposit_pct),
    v_balance_amt,
    v_balance_fees.total_fees,
    v_balance_fees.net_amount,
    (v_deposit_fees.total_fees + v_balance_fees.total_fees),
    (v_deposit_fees.net_amount + v_balance_fees.net_amount);
END;
$$;

-- =====================================================
-- 7. FONCTION: Ajouter un événement au timeline
-- =====================================================

CREATE OR REPLACE FUNCTION add_work_order_event(
  p_work_order_id UUID,
  p_event_type TEXT,
  p_actor_profile_id UUID DEFAULT NULL,
  p_actor_role TEXT DEFAULT 'system',
  p_old_status TEXT DEFAULT NULL,
  p_new_status TEXT DEFAULT NULL,
  p_event_data JSONB DEFAULT '{}',
  p_description TEXT DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
AS $$
DECLARE
  v_event_id UUID;
BEGIN
  INSERT INTO work_order_timeline (
    work_order_id,
    event_type,
    actor_profile_id,
    actor_role,
    old_status,
    new_status,
    event_data,
    description
  ) VALUES (
    p_work_order_id,
    p_event_type,
    p_actor_profile_id,
    p_actor_role,
    p_old_status,
    p_new_status,
    p_event_data,
    p_description
  )
  RETURNING id INTO v_event_id;
  
  RETURN v_event_id;
END;
$$;

-- =====================================================
-- 8. TRIGGER: Log automatique des changements de statut
-- =====================================================

CREATE OR REPLACE FUNCTION log_work_order_status_change()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF OLD.statut IS DISTINCT FROM NEW.statut THEN
    PERFORM add_work_order_event(
      NEW.id,
      'status_changed',
      NULL,
      'system',
      OLD.statut,
      NEW.statut,
      jsonb_build_object(
        'changed_at', NOW(),
        'trigger', 'auto'
      ),
      'Statut changé de ' || COALESCE(OLD.statut, 'null') || ' à ' || NEW.statut
    );
  END IF;
  
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_log_work_order_status ON work_orders;
CREATE TRIGGER trg_log_work_order_status
  AFTER UPDATE OF statut ON work_orders
  FOR EACH ROW
  EXECUTE FUNCTION log_work_order_status_change();

-- =====================================================
-- 9. RLS POLICIES
-- =====================================================

ALTER TABLE payment_fee_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE work_order_payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE work_order_timeline ENABLE ROW LEVEL SECURITY;

-- payment_fee_config: lecture publique
CREATE POLICY "Anyone can read fee config"
  ON payment_fee_config FOR SELECT
  USING (is_active = true);

-- Admins peuvent modifier la config
CREATE POLICY "Admins can manage fee config"
  ON payment_fee_config FOR ALL
  USING (EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin'));

-- work_order_payments: visible par payer et payee
DROP POLICY IF EXISTS "Payment parties can view" ON work_order_payments;
CREATE POLICY "Payment parties can view"
  ON work_order_payments FOR SELECT
  USING (
    payer_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    OR payee_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    OR EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- Seul le système/admin peut créer des paiements
CREATE POLICY "System can create payments"
  ON work_order_payments FOR INSERT
  WITH CHECK (
    EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role IN ('admin', 'owner'))
  );

-- work_order_timeline: visible par les parties de l'intervention
DROP POLICY IF EXISTS "Work order parties can view timeline" ON work_order_timeline;
CREATE POLICY "Work order parties can view timeline"
  ON work_order_timeline FOR SELECT
  USING (
    work_order_id IN (
      SELECT wo.id FROM work_orders wo
      JOIN tickets t ON t.id = wo.ticket_id
      JOIN properties p ON p.id = t.property_id
      WHERE wo.provider_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
         OR p.owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
    OR EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- =====================================================
-- 10. EXTENSION: provider_quotes pour acompte
-- =====================================================

ALTER TABLE provider_quotes
  ADD COLUMN IF NOT EXISTS requires_deposit BOOLEAN DEFAULT true,
  ADD COLUMN IF NOT EXISTS deposit_percent DECIMAL(5,2) DEFAULT 66.67,
  ADD COLUMN IF NOT EXISTS deposit_amount DECIMAL(10,2),
  ADD COLUMN IF NOT EXISTS balance_amount DECIMAL(10,2),
  ADD COLUMN IF NOT EXISTS requires_visit BOOLEAN DEFAULT true,
  ADD COLUMN IF NOT EXISTS visit_completed BOOLEAN DEFAULT false,
  ADD COLUMN IF NOT EXISTS visit_date TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS visit_notes TEXT;

-- =====================================================
-- 11. VUE: Résumé intervention avec paiements
-- =====================================================

CREATE OR REPLACE VIEW v_work_order_payment_summary AS
SELECT 
  wo.id AS work_order_id,
  wo.ticket_id,
  wo.provider_id,
  wo.statut,
  wo.created_at,
  
  -- Devis accepté
  pq.id AS quote_id,
  pq.total_amount AS quote_amount,
  pq.deposit_percent,
  pq.deposit_amount,
  pq.balance_amount,
  
  -- Paiement acompte
  dep.id AS deposit_payment_id,
  dep.status AS deposit_status,
  dep.gross_amount AS deposit_paid,
  dep.paid_at AS deposit_paid_at,
  dep.escrow_status AS deposit_escrow,
  
  -- Paiement solde
  bal.id AS balance_payment_id,
  bal.status AS balance_status,
  bal.gross_amount AS balance_paid,
  bal.paid_at AS balance_paid_at,
  
  -- Totaux
  COALESCE(dep.gross_amount, 0) + COALESCE(bal.gross_amount, 0) AS total_paid,
  COALESCE(dep.total_fees, 0) + COALESCE(bal.total_fees, 0) AS total_fees,
  COALESCE(dep.net_amount, 0) + COALESCE(bal.net_amount, 0) AS total_net_provider

FROM work_orders wo
LEFT JOIN provider_quotes pq ON pq.id = wo.accepted_quote_id
LEFT JOIN work_order_payments dep ON dep.work_order_id = wo.id AND dep.payment_type = 'deposit'
LEFT JOIN work_order_payments bal ON bal.work_order_id = wo.id AND bal.payment_type = 'balance';

-- =====================================================
-- 12. COMMENTAIRES
-- =====================================================

COMMENT ON TABLE payment_fee_config IS 'Configuration des frais de paiement (Stripe + plateforme)';
COMMENT ON TABLE work_order_payments IS 'Paiements d''intervention (acompte 2/3 + solde 1/3)';
COMMENT ON TABLE work_order_timeline IS 'Historique complet des événements d''une intervention';
COMMENT ON FUNCTION calculate_payment_fees IS 'Calcule les frais pour un montant donné';
COMMENT ON FUNCTION calculate_deposit_and_balance IS 'Calcule l''acompte (2/3) et le solde (1/3) avec frais';



-- ========== 20251206100000_vigilance_audit_log.sql ==========
-- =====================================================
-- MIGRATION: Log d'audit des vérifications de vigilance
-- Conformité Article L.8222-1 du Code du travail
-- =====================================================

-- =====================================================
-- 1. TABLE: vigilance_audit_log
-- Historique des vérifications de vigilance
-- =====================================================

CREATE TABLE IF NOT EXISTS vigilance_audit_log (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- Acteurs
  owner_profile_id UUID NOT NULL REFERENCES profiles(id),
  provider_profile_id UUID NOT NULL REFERENCES profiles(id),
  
  -- Contexte
  quote_id UUID REFERENCES quotes(id),
  work_order_id UUID REFERENCES work_orders(id),
  
  -- Montants
  amount_ht DECIMAL(10,2) NOT NULL,
  threshold_ht DECIMAL(10,2) NOT NULL DEFAULT 5000,
  yearly_total_ht DECIMAL(10,2), -- Cumul annuel
  
  -- Résultat de la vérification
  is_required BOOLEAN NOT NULL DEFAULT true,
  is_compliant BOOLEAN NOT NULL,
  
  -- Documents
  missing_documents TEXT[] DEFAULT '{}',
  expired_documents TEXT[] DEFAULT '{}',
  valid_documents TEXT[] DEFAULT '{}',
  
  -- Action prise
  action_taken TEXT NOT NULL CHECK (action_taken IN (
    'approved',   -- Accepté (conforme)
    'blocked',    -- Bloqué (non conforme)
    'override'    -- Passé outre (avec justification)
  )),
  override_reason TEXT, -- Obligatoire si action_taken = 'override'
  
  -- Métadonnées
  ip_address INET,
  user_agent TEXT,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX idx_vigilance_audit_owner ON vigilance_audit_log(owner_profile_id);
CREATE INDEX idx_vigilance_audit_provider ON vigilance_audit_log(provider_profile_id);
CREATE INDEX idx_vigilance_audit_date ON vigilance_audit_log(created_at);
CREATE INDEX idx_vigilance_audit_action ON vigilance_audit_log(action_taken);

-- =====================================================
-- 2. VUE: Cumul annuel par couple propriétaire/prestataire
-- =====================================================

CREATE OR REPLACE VIEW vigilance_yearly_totals AS
SELECT 
  owner_profile_id,
  provider_profile_id,
  EXTRACT(YEAR FROM created_at) AS year,
  SUM(amount_ht) AS total_amount_ht,
  COUNT(*) AS transaction_count,
  BOOL_OR(NOT is_compliant) AS had_compliance_issues
FROM vigilance_audit_log
WHERE action_taken IN ('approved', 'override')
GROUP BY owner_profile_id, provider_profile_id, EXTRACT(YEAR FROM created_at);

-- =====================================================
-- 3. FONCTION: Vérifier le cumul annuel
-- =====================================================

CREATE OR REPLACE FUNCTION get_vigilance_yearly_total(
  p_owner_id UUID,
  p_provider_id UUID,
  p_year INTEGER DEFAULT EXTRACT(YEAR FROM CURRENT_DATE)
)
RETURNS DECIMAL
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_total DECIMAL;
BEGIN
  SELECT COALESCE(SUM(amount_ht), 0) INTO v_total
  FROM vigilance_audit_log
  WHERE owner_profile_id = p_owner_id
    AND provider_profile_id = p_provider_id
    AND EXTRACT(YEAR FROM created_at) = p_year
    AND action_taken IN ('approved', 'override');
  
  RETURN v_total;
END;
$$;

-- =====================================================
-- 4. RLS POLICIES
-- =====================================================

ALTER TABLE vigilance_audit_log ENABLE ROW LEVEL SECURITY;

-- Les propriétaires peuvent voir leurs propres logs
DROP POLICY IF EXISTS "Owners can view own vigilance logs" ON vigilance_audit_log;
CREATE POLICY "Owners can view own vigilance logs"
  ON vigilance_audit_log FOR SELECT
  USING (
    owner_profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  );

-- Les prestataires peuvent voir les logs les concernant
DROP POLICY IF EXISTS "Providers can view own vigilance logs" ON vigilance_audit_log;
CREATE POLICY "Providers can view own vigilance logs"
  ON vigilance_audit_log FOR SELECT
  USING (
    provider_profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  );

-- Les admins peuvent tout voir
DROP POLICY IF EXISTS "Admins can view all vigilance logs" ON vigilance_audit_log;
CREATE POLICY "Admins can view all vigilance logs"
  ON vigilance_audit_log FOR SELECT
  USING (
    EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- Insertion uniquement par le système (service role)
DROP POLICY IF EXISTS "System can insert vigilance logs" ON vigilance_audit_log;
CREATE POLICY "System can insert vigilance logs"
  ON vigilance_audit_log FOR INSERT
  WITH CHECK (true); -- Contrôlé par le backend

-- =====================================================
-- 5. COMMENTAIRES
-- =====================================================

COMMENT ON TABLE vigilance_audit_log IS 'Log d''audit des vérifications de vigilance (Article L.8222-1)';
COMMENT ON FUNCTION get_vigilance_yearly_total IS 'Calcule le cumul annuel des prestations entre un propriétaire et un prestataire';



-- ========== 20251206200000_provider_portfolio.sql ==========
-- =====================================================
-- MIGRATION: Portfolio prestataire
-- Photos avant/après des réalisations
-- =====================================================

-- =====================================================
-- 1. TABLE: provider_portfolio_items
-- Réalisations des prestataires avec photos avant/après
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_portfolio_items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  provider_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Source (optionnel, si issu d'une intervention)
  work_order_id UUID REFERENCES work_orders(id) ON DELETE SET NULL,
  
  -- Catégorie
  service_type TEXT NOT NULL,
  intervention_type TEXT, -- depannage, installation, renovation, entretien
  
  -- Titre et description
  title TEXT NOT NULL,
  description TEXT,
  
  -- Photos AVANT / APRÈS
  before_photo_url TEXT,
  before_photo_caption TEXT,
  after_photo_url TEXT NOT NULL,
  after_photo_caption TEXT,
  
  -- Photos supplémentaires (JSONB array)
  additional_photos JSONB DEFAULT '[]',
  -- Format: [{ "url": "...", "caption": "...", "type": "before|after|during" }]
  
  -- Contexte
  location_type TEXT CHECK (location_type IN ('appartement', 'maison', 'commerce', 'bureau', 'autre')),
  location_city TEXT,
  location_department TEXT,
  completed_at DATE,
  duration_hours DECIMAL(5,2),
  
  -- Coût (optionnel, pour référence)
  total_cost DECIMAL(10,2),
  
  -- Visibilité
  is_public BOOLEAN DEFAULT true,
  is_featured BOOLEAN DEFAULT false,
  display_order INTEGER DEFAULT 0,
  
  -- Modération
  moderation_status TEXT DEFAULT 'pending' CHECK (moderation_status IN (
    'pending',    -- En attente de modération
    'approved',   -- Approuvé et visible
    'rejected'    -- Rejeté
  )),
  moderated_by UUID REFERENCES auth.users(id),
  moderated_at TIMESTAMPTZ,
  rejection_reason TEXT,
  
  -- Stats
  view_count INTEGER DEFAULT 0,
  like_count INTEGER DEFAULT 0,
  
  -- Métadonnées
  tags TEXT[] DEFAULT '{}',
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX idx_portfolio_provider ON provider_portfolio_items(provider_profile_id);
CREATE INDEX idx_portfolio_service ON provider_portfolio_items(service_type);
CREATE INDEX idx_portfolio_public ON provider_portfolio_items(is_public, moderation_status) 
  WHERE is_public = true AND moderation_status = 'approved';
CREATE INDEX idx_portfolio_featured ON provider_portfolio_items(provider_profile_id, is_featured)
  WHERE is_featured = true;
CREATE INDEX idx_portfolio_moderation ON provider_portfolio_items(moderation_status)
  WHERE moderation_status = 'pending';

-- Contrainte: max 3 items en vedette par prestataire
CREATE OR REPLACE FUNCTION check_max_featured_items()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.is_featured = true THEN
    IF (SELECT COUNT(*) FROM provider_portfolio_items 
        WHERE provider_profile_id = NEW.provider_profile_id 
        AND is_featured = true 
        AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::UUID)) >= 3 THEN
      RAISE EXCEPTION 'Maximum 3 items en vedette par prestataire';
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_check_max_featured ON provider_portfolio_items;
CREATE TRIGGER trg_check_max_featured
  BEFORE INSERT OR UPDATE OF is_featured ON provider_portfolio_items
  FOR EACH ROW EXECUTE FUNCTION check_max_featured_items();

-- Trigger updated_at
DROP TRIGGER IF EXISTS trg_portfolio_items_updated_at ON provider_portfolio_items;
CREATE TRIGGER trg_portfolio_items_updated_at
  BEFORE UPDATE ON provider_portfolio_items
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- 2. VUE: Portfolio public avec stats prestataire
-- =====================================================

-- Vue simplifiée sans dépendance à provider_reviews
CREATE OR REPLACE VIEW provider_portfolio_public AS
SELECT 
  ppi.*,
  p.prenom || ' ' || p.nom AS provider_name,
  pp.type_services,
  pp.certifications
FROM provider_portfolio_items ppi
JOIN profiles p ON p.id = ppi.provider_profile_id
LEFT JOIN provider_profiles pp ON pp.profile_id = ppi.provider_profile_id
WHERE ppi.is_public = true 
  AND ppi.moderation_status = 'approved';

-- =====================================================
-- 3. FONCTION: Obtenir le portfolio d'un prestataire
-- =====================================================

CREATE OR REPLACE FUNCTION get_provider_portfolio(
  p_provider_id UUID,
  p_include_private BOOLEAN DEFAULT false
)
RETURNS SETOF provider_portfolio_items
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT * FROM provider_portfolio_items
  WHERE provider_profile_id = p_provider_id
    AND (p_include_private OR (is_public = true AND moderation_status = 'approved'))
  ORDER BY is_featured DESC, display_order ASC, created_at DESC;
END;
$$;

-- =====================================================
-- 4. FONCTION: Importer depuis une intervention
-- =====================================================

CREATE OR REPLACE FUNCTION import_portfolio_from_work_order(
  p_work_order_id UUID,
  p_title TEXT,
  p_description TEXT DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_work_order RECORD;
  v_ticket RECORD;
  v_portfolio_id UUID;
BEGIN
  -- Récupérer les infos de l'intervention
  SELECT * INTO v_work_order 
  FROM work_orders 
  WHERE id = p_work_order_id;
  
  IF v_work_order IS NULL THEN
    RAISE EXCEPTION 'Work order non trouvé';
  END IF;
  
  -- Récupérer le ticket associé
  SELECT t.*, p.type AS property_type, p.ville, p.code_postal
  INTO v_ticket
  FROM tickets t
  JOIN properties p ON p.id = t.property_id
  WHERE t.id = v_work_order.ticket_id;
  
  -- Créer l'item de portfolio
  INSERT INTO provider_portfolio_items (
    provider_profile_id,
    work_order_id,
    service_type,
    title,
    description,
    before_photo_url,
    after_photo_url,
    location_type,
    location_city,
    completed_at,
    total_cost
  ) VALUES (
    v_work_order.provider_id,
    p_work_order_id,
    COALESCE(v_ticket.categorie, 'autre'),
    p_title,
    COALESCE(p_description, v_work_order.completion_report),
    (v_work_order.before_photos->0->>'url')::TEXT,
    (v_work_order.after_photos->0->>'url')::TEXT,
    v_ticket.property_type,
    v_ticket.ville,
    v_work_order.work_completed_at::DATE,
    v_work_order.cout_final
  )
  RETURNING id INTO v_portfolio_id;
  
  RETURN v_portfolio_id;
END;
$$;

-- =====================================================
-- 5. RLS POLICIES
-- =====================================================

ALTER TABLE provider_portfolio_items ENABLE ROW LEVEL SECURITY;

-- Tout le monde peut voir les portfolios publics approuvés
DROP POLICY IF EXISTS "Anyone can view public portfolios" ON provider_portfolio_items;
CREATE POLICY "Anyone can view public portfolios"
  ON provider_portfolio_items FOR SELECT
  USING (is_public = true AND moderation_status = 'approved');

-- Les prestataires peuvent gérer leur propre portfolio
DROP POLICY IF EXISTS "Providers can manage own portfolio" ON provider_portfolio_items;
CREATE POLICY "Providers can manage own portfolio"
  ON provider_portfolio_items FOR ALL
  USING (
    provider_profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  )
  WITH CHECK (
    provider_profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  );

-- Les admins peuvent tout voir et modérer
DROP POLICY IF EXISTS "Admins can manage all portfolios" ON provider_portfolio_items;
CREATE POLICY "Admins can manage all portfolios"
  ON provider_portfolio_items FOR ALL
  USING (
    EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- =====================================================
-- 6. COMMENTAIRES
-- =====================================================

COMMENT ON TABLE provider_portfolio_items IS 'Portfolio des réalisations prestataires avec photos avant/après';
COMMENT ON FUNCTION get_provider_portfolio IS 'Récupère le portfolio d''un prestataire (public ou complet)';
COMMENT ON FUNCTION import_portfolio_from_work_order IS 'Importe une intervention terminée dans le portfolio';



-- ========== 20251206300000_enterprise_tiers.sql ==========
-- Migration: Grille tarifaire Enterprise optimisée
-- Date: 2024-12-06
-- Description: Ajoute les 4 tiers Enterprise avec tarification par volume
--
-- NOUVELLE GRILLE ENTERPRISE (3 options combinées):
--   - enterprise_s: 199€/mois (50-100 biens) - 20 signatures incluses
--   - enterprise_m: 299€/mois (100-200 biens) - 30 signatures + White label basic
--   - enterprise_l: 449€/mois (200-500 biens) - 50 signatures + AM partagé ⭐
--   - enterprise_xl: 699€/mois (500+ biens) - Signatures illimitées + AM dédié
--
-- MISE À JOUR DES PLANS EXISTANTS:
--   - gratuit: 0€ (1 bien) - Nouveau plan d'acquisition
--   - starter: 9€/mois - 0 signature incluse, paiement en ligne
--   - confort: 29€/mois - 1 signature/mois incluse (au lieu de 5)
--   - pro: 59€/mois - 5 signatures/mois (au lieu de illimité)

BEGIN;

-- ============================================
-- ÉTAPE 1: Ajouter le plan GRATUIT
-- ============================================

INSERT INTO subscription_plans (
  slug, name, description, 
  price_monthly, price_yearly, 
  max_properties, max_leases, max_tenants, max_documents_gb,
  features, is_active, is_popular, display_order
) VALUES (
  'gratuit',
  'Gratuit',
  'Découvrez Talok et simplifiez la gestion de votre premier bien',
  0, 0,  -- Gratuit
  1, 1, 2, 0.1,  -- 1 bien, 100 Mo
  '{
    "signatures": true,
    "signatures_monthly_quota": 0,
    "signature_price": 590,
    "open_banking": false,
    "bank_reconciliation": false,
    "auto_reminders": false,
    "auto_reminders_sms": false,
    "irl_revision": false,
    "tenant_portal": "basic",
    "tenant_payment_online": false,
    "payment_fees_cb": 0,
    "payment_fees_sepa": 0,
    "lease_generation": true,
    "colocation": false,
    "multi_users": false,
    "work_orders": false,
    "providers_management": false,
    "owner_reports": false,
    "api_access": false,
    "scoring_tenant": false,
    "edl_digital": false,
    "gli_discount": 0,
    "included_properties": 1,
    "extra_property_price": 0
  }'::jsonb,
  true, false, -1
)
ON CONFLICT (slug) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  price_monthly = EXCLUDED.price_monthly,
  price_yearly = EXCLUDED.price_yearly,
  max_properties = EXCLUDED.max_properties,
  max_leases = EXCLUDED.max_leases,
  max_tenants = EXCLUDED.max_tenants,
  max_documents_gb = EXCLUDED.max_documents_gb,
  features = EXCLUDED.features,
  is_popular = EXCLUDED.is_popular,
  display_order = EXCLUDED.display_order,
  updated_at = NOW();

-- ============================================
-- ÉTAPE 2: Mettre à jour STARTER avec paiements
-- ============================================

UPDATE subscription_plans SET
  features = '{
    "signatures": true,
    "signatures_monthly_quota": 0,
    "signature_price": 490,
    "open_banking": false,
    "bank_reconciliation": false,
    "auto_reminders": "email_basic",
    "auto_reminders_sms": false,
    "irl_revision": false,
    "tenant_portal": "basic",
    "tenant_payment_online": true,
    "payment_fees_cb": 220,
    "payment_fees_sepa": 50,
    "lease_generation": true,
    "colocation": false,
    "multi_users": false,
    "work_orders": false,
    "providers_management": false,
    "owner_reports": false,
    "api_access": false,
    "scoring_tenant": false,
    "edl_digital": false,
    "gli_discount": 0,
    "included_properties": 3,
    "extra_property_price": 300
  }'::jsonb,
  updated_at = NOW()
WHERE slug = 'starter';

-- ============================================
-- ÉTAPE 3: Mettre à jour CONFORT (1 signature/mois)
-- ============================================

UPDATE subscription_plans SET
  features = '{
    "signatures": true,
    "signatures_monthly_quota": 1,
    "signature_price": 390,
    "open_banking": true,
    "open_banking_level": "basic",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": false,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "advanced",
    "tenant_payment_online": true,
    "payment_fees_cb": 220,
    "payment_fees_sepa": 50,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": false,
    "work_orders": true,
    "providers_management": false,
    "owner_reports": true,
    "api_access": false,
    "scoring_tenant": true,
    "edl_digital": true,
    "gli_discount": 10,
    "included_properties": 10,
    "extra_property_price": 250
  }'::jsonb,
  updated_at = NOW()
WHERE slug = 'confort';

-- ============================================
-- ÉTAPE 4: Mettre à jour PRO (5 signatures/mois)
-- ============================================

UPDATE subscription_plans SET
  features = '{
    "signatures": true,
    "signatures_monthly_quota": 5,
    "signature_price": 290,
    "open_banking": true,
    "open_banking_level": "advanced",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": true,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "full",
    "tenant_payment_online": true,
    "payment_fees_cb": 220,
    "payment_fees_sepa": 50,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": true,
    "max_users": 5,
    "roles_permissions": true,
    "activity_log": true,
    "work_orders": true,
    "work_orders_planning": true,
    "providers_management": true,
    "owner_reports": true,
    "api_access": true,
    "api_access_level": "read",
    "scoring_tenant": true,
    "scoring_advanced": true,
    "edl_digital": true,
    "gli_discount": 15,
    "included_properties": 50,
    "extra_property_price": 200
  }'::jsonb,
  updated_at = NOW()
WHERE slug = 'pro';

-- ============================================
-- ÉTAPE 5: Créer ENTERPRISE S (199€/mois)
-- ============================================

INSERT INTO subscription_plans (
  slug, name, description, 
  price_monthly, price_yearly, 
  max_properties, max_leases, max_tenants, max_documents_gb,
  features, is_active, is_popular, display_order
) VALUES (
  'enterprise_s',
  'Enterprise S',
  'Pour les gestionnaires de 50 à 100 biens',
  19900, 199000,  -- 199€/mois, 1990€/an
  100, -1, -1, 50,
  '{
    "signatures": true,
    "signatures_monthly_quota": 20,
    "signature_price": 150,
    "open_banking": true,
    "open_banking_level": "premium",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": true,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "full",
    "tenant_payment_online": true,
    "payment_fees_cb": 190,
    "payment_fees_sepa": 35,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": true,
    "max_users": -1,
    "roles_permissions": true,
    "activity_log": true,
    "work_orders": true,
    "work_orders_planning": true,
    "providers_management": true,
    "owner_reports": true,
    "multi_mandants": true,
    "channel_manager": "all",
    "api_access": true,
    "api_access_level": "full",
    "webhooks": true,
    "white_label": false,
    "custom_domain": false,
    "sso": false,
    "scoring_tenant": true,
    "scoring_advanced": true,
    "edl_digital": true,
    "copro_module": false,
    "priority_support": true,
    "dedicated_account_manager": false,
    "sla_guarantee": false,
    "gli_discount": 20,
    "included_properties": 100,
    "extra_property_price": 0,
    "tier_min_properties": 50,
    "tier_max_properties": 100
  }'::jsonb,
  true, false, 4
)
ON CONFLICT (slug) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  price_monthly = EXCLUDED.price_monthly,
  price_yearly = EXCLUDED.price_yearly,
  max_properties = EXCLUDED.max_properties,
  max_leases = EXCLUDED.max_leases,
  max_tenants = EXCLUDED.max_tenants,
  max_documents_gb = EXCLUDED.max_documents_gb,
  features = EXCLUDED.features,
  is_popular = EXCLUDED.is_popular,
  display_order = EXCLUDED.display_order,
  updated_at = NOW();

-- ============================================
-- ÉTAPE 6: Créer ENTERPRISE M (299€/mois)
-- ============================================

INSERT INTO subscription_plans (
  slug, name, description, 
  price_monthly, price_yearly, 
  max_properties, max_leases, max_tenants, max_documents_gb,
  features, is_active, is_popular, display_order
) VALUES (
  'enterprise_m',
  'Enterprise M',
  'Pour les gestionnaires de 100 à 200 biens',
  29900, 299000,  -- 299€/mois, 2990€/an
  200, -1, -1, 100,
  '{
    "signatures": true,
    "signatures_monthly_quota": 30,
    "signature_price": 150,
    "open_banking": true,
    "open_banking_level": "premium",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": true,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "full",
    "tenant_payment_online": true,
    "payment_fees_cb": 190,
    "payment_fees_sepa": 35,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": true,
    "max_users": -1,
    "roles_permissions": true,
    "activity_log": true,
    "work_orders": true,
    "work_orders_planning": true,
    "providers_management": true,
    "owner_reports": true,
    "multi_mandants": true,
    "channel_manager": "all",
    "api_access": true,
    "api_access_level": "full",
    "webhooks": true,
    "white_label": true,
    "white_label_level": "basic",
    "custom_domain": false,
    "sso": false,
    "scoring_tenant": true,
    "scoring_advanced": true,
    "edl_digital": true,
    "copro_module": false,
    "priority_support": true,
    "dedicated_account_manager": false,
    "sla_guarantee": false,
    "gli_discount": 20,
    "included_properties": 200,
    "extra_property_price": 0,
    "tier_min_properties": 100,
    "tier_max_properties": 200
  }'::jsonb,
  true, false, 5
)
ON CONFLICT (slug) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  price_monthly = EXCLUDED.price_monthly,
  price_yearly = EXCLUDED.price_yearly,
  max_properties = EXCLUDED.max_properties,
  max_leases = EXCLUDED.max_leases,
  max_tenants = EXCLUDED.max_tenants,
  max_documents_gb = EXCLUDED.max_documents_gb,
  features = EXCLUDED.features,
  is_popular = EXCLUDED.is_popular,
  display_order = EXCLUDED.display_order,
  updated_at = NOW();

-- ============================================
-- ÉTAPE 7: Créer ENTERPRISE L (449€/mois) ⭐
-- ============================================

INSERT INTO subscription_plans (
  slug, name, description, 
  price_monthly, price_yearly, 
  max_properties, max_leases, max_tenants, max_documents_gb,
  features, is_active, is_popular, display_order
) VALUES (
  'enterprise_l',
  'Enterprise L',
  'Pour les gestionnaires de 200 à 500 biens',
  44900, 449000,  -- 449€/mois, 4490€/an
  500, -1, -1, 200,
  '{
    "signatures": true,
    "signatures_monthly_quota": 50,
    "signature_price": 150,
    "open_banking": true,
    "open_banking_level": "premium",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": true,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "full",
    "tenant_payment_online": true,
    "payment_fees_cb": 190,
    "payment_fees_sepa": 35,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": true,
    "max_users": -1,
    "roles_permissions": true,
    "activity_log": true,
    "work_orders": true,
    "work_orders_planning": true,
    "providers_management": true,
    "owner_reports": true,
    "multi_mandants": true,
    "channel_manager": "all",
    "api_access": true,
    "api_access_level": "full",
    "webhooks": true,
    "white_label": true,
    "white_label_level": "full",
    "custom_domain": true,
    "sso": false,
    "scoring_tenant": true,
    "scoring_advanced": true,
    "edl_digital": true,
    "copro_module": true,
    "priority_support": true,
    "dedicated_account_manager": true,
    "account_manager_type": "shared",
    "sla_guarantee": true,
    "sla_percent": 99.5,
    "gli_discount": 20,
    "included_properties": 500,
    "extra_property_price": 0,
    "tier_min_properties": 200,
    "tier_max_properties": 500
  }'::jsonb,
  true, true, 6  -- is_popular = true (Le plus choisi Enterprise)
)
ON CONFLICT (slug) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  price_monthly = EXCLUDED.price_monthly,
  price_yearly = EXCLUDED.price_yearly,
  max_properties = EXCLUDED.max_properties,
  max_leases = EXCLUDED.max_leases,
  max_tenants = EXCLUDED.max_tenants,
  max_documents_gb = EXCLUDED.max_documents_gb,
  features = EXCLUDED.features,
  is_popular = EXCLUDED.is_popular,
  display_order = EXCLUDED.display_order,
  updated_at = NOW();

-- ============================================
-- ÉTAPE 8: Créer ENTERPRISE XL (699€/mois)
-- ============================================

INSERT INTO subscription_plans (
  slug, name, description, 
  price_monthly, price_yearly, 
  max_properties, max_leases, max_tenants, max_documents_gb,
  features, is_active, is_popular, display_order
) VALUES (
  'enterprise_xl',
  'Enterprise XL',
  'Solution sur-mesure pour +500 biens',
  69900, 699000,  -- 699€/mois, 6990€/an
  -1, -1, -1, -1,  -- Tout illimité
  '{
    "signatures": true,
    "signatures_monthly_quota": -1,
    "signature_price": 0,
    "open_banking": true,
    "open_banking_level": "premium",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": true,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "full",
    "tenant_payment_online": true,
    "payment_fees_cb": 190,
    "payment_fees_sepa": 35,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": true,
    "max_users": -1,
    "roles_permissions": true,
    "activity_log": true,
    "work_orders": true,
    "work_orders_planning": true,
    "providers_management": true,
    "owner_reports": true,
    "multi_mandants": true,
    "channel_manager": "all",
    "api_access": true,
    "api_access_level": "full",
    "webhooks": true,
    "white_label": true,
    "white_label_level": "full",
    "custom_domain": true,
    "sso": true,
    "scoring_tenant": true,
    "scoring_advanced": true,
    "edl_digital": true,
    "copro_module": true,
    "priority_support": true,
    "dedicated_account_manager": true,
    "account_manager_type": "dedicated",
    "sla_guarantee": true,
    "sla_percent": 99.5,
    "gli_discount": 20,
    "included_properties": -1,
    "extra_property_price": 0,
    "tier_min_properties": 500,
    "tier_max_properties": -1
  }'::jsonb,
  true, false, 7
)
ON CONFLICT (slug) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  price_monthly = EXCLUDED.price_monthly,
  price_yearly = EXCLUDED.price_yearly,
  max_properties = EXCLUDED.max_properties,
  max_leases = EXCLUDED.max_leases,
  max_tenants = EXCLUDED.max_tenants,
  max_documents_gb = EXCLUDED.max_documents_gb,
  features = EXCLUDED.features,
  is_popular = EXCLUDED.is_popular,
  display_order = EXCLUDED.display_order,
  updated_at = NOW();

-- ============================================
-- ÉTAPE 9: Mettre à jour le plan ENTERPRISE legacy
-- ============================================

-- Garder le plan "enterprise" pour rétrocompatibilité mais le rediriger
-- Note: price_monthly = 0 au lieu de NULL car la colonne a une contrainte NOT NULL
UPDATE subscription_plans SET
  description = 'Solution Enterprise - Contactez-nous pour choisir votre taille',
  price_monthly = 0,  -- Sur devis (0 = contact)
  price_yearly = 0,
  features = features || '{
    "legacy": true,
    "redirect_to": "enterprise_s",
    "contact_required": true
  }'::jsonb,
  display_order = 99,  -- Masquer en bas
  updated_at = NOW()
WHERE slug = 'enterprise';

-- ============================================
-- ÉTAPE 10: Mettre à jour le trigger auto-subscription
-- Pour utiliser "gratuit" au lieu de "starter"
-- ============================================

CREATE OR REPLACE FUNCTION create_owner_subscription()
RETURNS TRIGGER AS $$
DECLARE
  v_plan_id UUID;
BEGIN
  -- Seulement pour les propriétaires
  IF NEW.role = 'owner' THEN
    -- Récupérer l'ID du plan gratuit (nouveau défaut)
    SELECT id INTO v_plan_id 
    FROM subscription_plans 
    WHERE slug = 'gratuit' 
    LIMIT 1;
    
    -- Fallback sur starter si gratuit n'existe pas
    IF v_plan_id IS NULL THEN
      SELECT id INTO v_plan_id 
      FROM subscription_plans 
      WHERE slug = 'starter' 
      LIMIT 1;
    END IF;
    
    -- Créer l'abonnement si le plan existe
    IF v_plan_id IS NOT NULL THEN
      INSERT INTO subscriptions (
        owner_id, 
        plan_id, 
        status, 
        billing_cycle, 
        current_period_start,
        current_period_end,
        properties_count,
        leases_count
      )
      VALUES (
        NEW.id,
        v_plan_id,
        'active',  -- Actif immédiatement (plan gratuit)
        'monthly',
        NOW(),
        NOW() + INTERVAL '1 month',
        0,
        0
      )
      ON CONFLICT (owner_id) DO NOTHING;
      
      RAISE NOTICE 'Abonnement Talok Gratuit créé pour le propriétaire %', NEW.id;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- ÉTAPE 11: Fonction pour recommander le tier Enterprise
-- ============================================

CREATE OR REPLACE FUNCTION get_recommended_enterprise_tier(property_count INTEGER)
RETURNS TEXT AS $$
BEGIN
  IF property_count >= 500 THEN
    RETURN 'enterprise_xl';
  ELSIF property_count >= 200 THEN
    RETURN 'enterprise_l';
  ELSIF property_count >= 100 THEN
    RETURN 'enterprise_m';
  ELSIF property_count >= 50 THEN
    RETURN 'enterprise_s';
  ELSE
    RETURN 'pro';  -- Pas besoin d'Enterprise
  END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================
-- ÉTAPE 12: Vue récapitulative des plans
-- ============================================

CREATE OR REPLACE VIEW v_subscription_plans_summary AS
SELECT 
  slug,
  name,
  price_monthly,
  price_yearly,
  max_properties,
  features->>'signatures_monthly_quota' as signatures_quota,
  features->>'signature_price' as signature_extra_price,
  features->>'payment_fees_cb' as cb_fee_bps,
  features->>'payment_fees_sepa' as sepa_fee_cents,
  features->>'gli_discount' as gli_discount_percent,
  features->>'included_properties' as included_properties,
  is_popular,
  display_order
FROM subscription_plans
WHERE is_active = true
ORDER BY display_order;

-- ============================================
-- VÉRIFICATION
-- ============================================

DO $$
DECLARE
  v_count INTEGER;
  v_plan_info TEXT;
BEGIN
  SELECT COUNT(*) INTO v_count FROM subscription_plans WHERE is_active = true;
  RAISE NOTICE 'Migration terminée. % plans actifs', v_count;
  
  -- Afficher le résumé
  FOR v_plan_info IN 
    SELECT slug || ': ' || COALESCE(price_monthly::text, '0') || ' centimes/mois'
    FROM subscription_plans 
    WHERE is_active = true 
    ORDER BY display_order
  LOOP
    RAISE NOTICE '%', v_plan_info;
  END LOOP;
END $$;

COMMIT;



-- ========== 20251206400000_pricing_option_b.sql ==========
-- Migration: Grille tarifaire Option B (Aggressive)
-- Date: 2024-12-06
-- Description: Optimisation des prix pour maximiser les revenus
--
-- CHANGEMENTS PRINCIPAUX :
-- - Confort : 29€ → 35€, 1 → 2 signatures, 2 utilisateurs
-- - Pro : 59€ → 69€, 5 → 10 signatures, API lecture+écriture
-- - Enterprise S : 199€ → 249€, AM partagé inclus
-- - Enterprise M : 299€ → 349€, AM partagé inclus
-- - Enterprise L : 449€ → 499€, AM dédié
-- - Enterprise XL : 699€ → 799€, formations incluses, SLA 99.9%
-- - Réduction annuelle : 17% → 20%
-- - Signatures Enterprise : 1,50€ → 1,90€
-- - SEPA Enterprise : 0,35€ → 0,40€
-- - GLI différenciés par tier

BEGIN;

-- ============================================
-- MISE À JOUR STARTER (GLI ajouté)
-- ============================================

UPDATE subscription_plans SET
  features = features || '{
    "gli_discount": 5,
    "payment_fees_cb": 220,
    "payment_fees_sepa": 50
  }'::jsonb,
  updated_at = NOW()
WHERE slug = 'starter';

-- ============================================
-- MISE À JOUR CONFORT : 29€ → 35€
-- ============================================

UPDATE subscription_plans SET
  price_monthly = 3500, -- 35€
  price_yearly = 33600, -- 336€ (28€/mois, -20%)
  features = '{
    "signatures": true,
    "signatures_monthly_quota": 2,
    "signature_price": 390,
    "open_banking": true,
    "open_banking_level": "basic",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": false,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "advanced",
    "tenant_payment_online": true,
    "payment_fees_cb": 220,
    "payment_fees_sepa": 50,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": true,
    "max_users": 2,
    "work_orders": true,
    "providers_management": false,
    "owner_reports": true,
    "api_access": false,
    "scoring_tenant": true,
    "edl_digital": true,
    "gli_discount": 10,
    "included_properties": 10,
    "extra_property_price": 250
  }'::jsonb,
  updated_at = NOW()
WHERE slug = 'confort';

-- ============================================
-- MISE À JOUR PRO : 59€ → 69€
-- ============================================

UPDATE subscription_plans SET
  price_monthly = 6900, -- 69€
  price_yearly = 66200, -- 662€ (55€/mois, -20%)
  max_documents_gb = 30, -- Augmenté
  features = '{
    "signatures": true,
    "signatures_monthly_quota": 10,
    "signature_price": 250,
    "open_banking": true,
    "open_banking_level": "advanced",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": true,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "full",
    "tenant_payment_online": true,
    "payment_fees_cb": 220,
    "payment_fees_sepa": 50,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": true,
    "max_users": 5,
    "roles_permissions": true,
    "activity_log": true,
    "work_orders": true,
    "work_orders_planning": true,
    "providers_management": true,
    "owner_reports": true,
    "api_access": true,
    "api_access_level": "read_write",
    "scoring_tenant": true,
    "scoring_advanced": true,
    "edl_digital": true,
    "gli_discount": 15,
    "included_properties": 50,
    "extra_property_price": 200
  }'::jsonb,
  updated_at = NOW()
WHERE slug = 'pro';

-- ============================================
-- MISE À JOUR ENTERPRISE S : 199€ → 249€
-- ============================================

UPDATE subscription_plans SET
  price_monthly = 24900, -- 249€
  price_yearly = 239000, -- 2390€ (199€/mois, -20%)
  features = '{
    "signatures": true,
    "signatures_monthly_quota": 25,
    "signature_price": 190,
    "open_banking": true,
    "open_banking_level": "premium",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": true,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "full",
    "tenant_payment_online": true,
    "payment_fees_cb": 190,
    "payment_fees_sepa": 40,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": true,
    "max_users": -1,
    "roles_permissions": true,
    "activity_log": true,
    "work_orders": true,
    "work_orders_planning": true,
    "providers_management": true,
    "owner_reports": true,
    "multi_mandants": true,
    "channel_manager": "all",
    "api_access": true,
    "api_access_level": "full",
    "webhooks": true,
    "white_label": false,
    "custom_domain": false,
    "sso": false,
    "scoring_tenant": true,
    "scoring_advanced": true,
    "edl_digital": true,
    "copro_module": false,
    "priority_support": true,
    "dedicated_account_manager": true,
    "account_manager_type": "shared",
    "sla_guarantee": true,
    "sla_percent": 99,
    "gli_discount": 18,
    "included_properties": 100,
    "extra_property_price": 0,
    "tier_min_properties": 50,
    "tier_max_properties": 100
  }'::jsonb,
  updated_at = NOW()
WHERE slug = 'enterprise_s';

-- ============================================
-- MISE À JOUR ENTERPRISE M : 299€ → 349€
-- ============================================

UPDATE subscription_plans SET
  price_monthly = 34900, -- 349€
  price_yearly = 335000, -- 3350€ (279€/mois, -20%)
  features = '{
    "signatures": true,
    "signatures_monthly_quota": 40,
    "signature_price": 190,
    "open_banking": true,
    "open_banking_level": "premium",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": true,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "full",
    "tenant_payment_online": true,
    "payment_fees_cb": 190,
    "payment_fees_sepa": 40,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": true,
    "max_users": -1,
    "roles_permissions": true,
    "activity_log": true,
    "work_orders": true,
    "work_orders_planning": true,
    "providers_management": true,
    "owner_reports": true,
    "multi_mandants": true,
    "channel_manager": "all",
    "api_access": true,
    "api_access_level": "full",
    "webhooks": true,
    "white_label": true,
    "white_label_level": "basic",
    "custom_domain": false,
    "sso": false,
    "scoring_tenant": true,
    "scoring_advanced": true,
    "edl_digital": true,
    "copro_module": false,
    "priority_support": true,
    "dedicated_account_manager": true,
    "account_manager_type": "shared",
    "sla_guarantee": true,
    "sla_percent": 99,
    "gli_discount": 20,
    "included_properties": 200,
    "extra_property_price": 0,
    "tier_min_properties": 100,
    "tier_max_properties": 200
  }'::jsonb,
  updated_at = NOW()
WHERE slug = 'enterprise_m';

-- ============================================
-- MISE À JOUR ENTERPRISE L : 449€ → 499€
-- ============================================

UPDATE subscription_plans SET
  price_monthly = 49900, -- 499€
  price_yearly = 479000, -- 4790€ (399€/mois, -20%)
  features = '{
    "signatures": true,
    "signatures_monthly_quota": 60,
    "signature_price": 190,
    "open_banking": true,
    "open_banking_level": "premium",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": true,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "full",
    "tenant_payment_online": true,
    "payment_fees_cb": 190,
    "payment_fees_sepa": 40,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": true,
    "max_users": -1,
    "roles_permissions": true,
    "activity_log": true,
    "work_orders": true,
    "work_orders_planning": true,
    "providers_management": true,
    "owner_reports": true,
    "multi_mandants": true,
    "channel_manager": "all",
    "api_access": true,
    "api_access_level": "full",
    "webhooks": true,
    "white_label": true,
    "white_label_level": "full",
    "custom_domain": true,
    "sso": false,
    "scoring_tenant": true,
    "scoring_advanced": true,
    "edl_digital": true,
    "copro_module": true,
    "priority_support": true,
    "dedicated_account_manager": true,
    "account_manager_type": "dedicated",
    "sla_guarantee": true,
    "sla_percent": 99.5,
    "gli_discount": 22,
    "included_properties": 500,
    "extra_property_price": 0,
    "tier_min_properties": 200,
    "tier_max_properties": 500
  }'::jsonb,
  is_popular = true,
  updated_at = NOW()
WHERE slug = 'enterprise_l';

-- ============================================
-- MISE À JOUR ENTERPRISE XL : 699€ → 799€
-- ============================================

UPDATE subscription_plans SET
  price_monthly = 79900, -- 799€
  price_yearly = 767000, -- 7670€ (639€/mois, -20%)
  features = '{
    "signatures": true,
    "signatures_monthly_quota": -1,
    "signature_price": 0,
    "open_banking": true,
    "open_banking_level": "premium",
    "bank_reconciliation": true,
    "auto_reminders": true,
    "auto_reminders_sms": true,
    "irl_revision": true,
    "alerts_deadlines": true,
    "tenant_portal": "full",
    "tenant_payment_online": true,
    "payment_fees_cb": 190,
    "payment_fees_sepa": 40,
    "lease_generation": true,
    "colocation": true,
    "multi_units": true,
    "multi_users": true,
    "max_users": -1,
    "roles_permissions": true,
    "activity_log": true,
    "work_orders": true,
    "work_orders_planning": true,
    "providers_management": true,
    "owner_reports": true,
    "multi_mandants": true,
    "channel_manager": "all",
    "api_access": true,
    "api_access_level": "full",
    "webhooks": true,
    "white_label": true,
    "white_label_level": "full",
    "custom_domain": true,
    "sso": true,
    "scoring_tenant": true,
    "scoring_advanced": true,
    "edl_digital": true,
    "copro_module": true,
    "priority_support": true,
    "dedicated_account_manager": true,
    "account_manager_type": "dedicated",
    "onboarding_included": true,
    "training_hours": 10,
    "sla_guarantee": true,
    "sla_percent": 99.9,
    "gli_discount": 25,
    "included_properties": -1,
    "extra_property_price": 0,
    "tier_min_properties": 500,
    "tier_max_properties": -1
  }'::jsonb,
  updated_at = NOW()
WHERE slug = 'enterprise_xl';

-- ============================================
-- VÉRIFICATION
-- ============================================

DO $$
DECLARE
  v_record RECORD;
BEGIN
  RAISE NOTICE '========================================';
  RAISE NOTICE 'GRILLE TARIFAIRE OPTION B APPLIQUÉE';
  RAISE NOTICE '========================================';
  
  FOR v_record IN 
    SELECT 
      slug,
      price_monthly / 100 as prix_mensuel,
      price_yearly / 100 as prix_annuel,
      features->>'signatures_monthly_quota' as signatures,
      features->>'gli_discount' as gli_discount
    FROM subscription_plans 
    WHERE is_active = true 
    ORDER BY display_order
  LOOP
    RAISE NOTICE '% : %€/mois, %€/an, % sign., GLI -%', 
      v_record.slug, 
      v_record.prix_mensuel, 
      v_record.prix_annuel,
      COALESCE(v_record.signatures, '0'),
      COALESCE(v_record.gli_discount, '0') || '%';
  END LOOP;
END $$;

COMMIT;



-- ========== 20251206500000_fix_lease_end_processes.sql ==========
-- ============================================
-- Migration: Unifier lease_end_processes et end_of_lease_processes
-- Date: 2025-12-06
-- Problème: Incohérence de nommage entre tables et APIs
-- ============================================

-- ============================================
-- 1. CRÉER LA TABLE lease_end_processes (nom utilisé par l'API)
-- ============================================
CREATE TABLE IF NOT EXISTS lease_end_processes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
  property_id UUID NOT NULL REFERENCES properties(id),
  created_by UUID REFERENCES profiles(id),
  
  -- Status & Progress
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
    'pending', 'triggered', 'edl_scheduled', 'edl_in_progress', 'edl_completed',
    'damages_assessed', 'dg_calculated', 'renovation_planned', 'renovation_in_progress',
    'ready_to_rent', 'completed', 'cancelled'
  )),
  progress_percentage INTEGER DEFAULT 0 CHECK (progress_percentage BETWEEN 0 AND 100),
  
  -- Dates importantes
  lease_end_date DATE NOT NULL,
  trigger_date DATE,
  edl_sortie_scheduled_date DATE,
  edl_sortie_completed_date DATE,
  ready_to_rent_date DATE,
  completed_date DATE,
  
  -- Dépôt de garantie
  dg_amount DECIMAL(10,2) DEFAULT 0,
  dg_retention_amount DECIMAL(10,2) DEFAULT 0,
  dg_refund_amount DECIMAL(10,2) DEFAULT 0,
  
  -- Coûts calculés
  tenant_damage_cost DECIMAL(10,2) DEFAULT 0,
  vetusty_cost DECIMAL(10,2) DEFAULT 0,
  renovation_cost DECIMAL(10,2) DEFAULT 0,
  total_budget DECIMAL(10,2) DEFAULT 0,
  
  -- Références EDL
  edl_entree_id UUID REFERENCES edl(id),
  edl_sortie_id UUID REFERENCES edl(id),
  
  -- Métadonnées
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Contraintes
  UNIQUE(lease_id)
);

-- Index pour performances
CREATE INDEX IF NOT EXISTS idx_lease_end_processes_status ON lease_end_processes(status);
CREATE INDEX IF NOT EXISTS idx_lease_end_processes_lease ON lease_end_processes(lease_id);
CREATE INDEX IF NOT EXISTS idx_lease_end_processes_property ON lease_end_processes(property_id);
CREATE INDEX IF NOT EXISTS idx_lease_end_processes_created_by ON lease_end_processes(created_by);

-- Trigger pour updated_at
CREATE OR REPLACE FUNCTION update_lease_end_processes_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_lease_end_processes_updated_at ON lease_end_processes;
CREATE TRIGGER trg_lease_end_processes_updated_at
  BEFORE UPDATE ON lease_end_processes
  FOR EACH ROW EXECUTE FUNCTION update_lease_end_processes_updated_at();

-- ============================================
-- 2. RLS POLICIES pour lease_end_processes
-- ============================================
ALTER TABLE lease_end_processes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "lease_end_owner_select" ON lease_end_processes;
DROP POLICY IF EXISTS "lease_end_owner_all" ON lease_end_processes;
DROP POLICY IF EXISTS "lease_end_admin_all" ON lease_end_processes;

-- Owners can view their processes (via property ownership)
CREATE POLICY "lease_end_owner_select" ON lease_end_processes FOR SELECT TO authenticated
USING (
  property_id IN (SELECT id FROM properties WHERE owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()))
);

-- Owners can manage their processes
CREATE POLICY "lease_end_owner_all" ON lease_end_processes FOR ALL TO authenticated
USING (
  property_id IN (SELECT id FROM properties WHERE owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()))
)
WITH CHECK (
  property_id IN (SELECT id FROM properties WHERE owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()))
);

-- Admin full access
CREATE POLICY "lease_end_admin_all" ON lease_end_processes FOR ALL TO authenticated
USING (EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin'));

-- ============================================
-- 3. TABLES DE SUPPORT
-- ============================================

-- Items d'inspection EDL sortie
CREATE TABLE IF NOT EXISTS edl_inspection_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lease_end_process_id UUID NOT NULL REFERENCES lease_end_processes(id) ON DELETE CASCADE,
  category TEXT NOT NULL CHECK (category IN (
    'murs', 'sols', 'plafonds', 'salle_de_bain', 'cuisine', 
    'fenetres_portes', 'electricite_plomberie', 'meubles', 'exterieur', 'autre'
  )),
  item_name TEXT,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed')),
  condition_entree TEXT,
  condition_sortie TEXT,
  damage_type TEXT CHECK (damage_type IN ('none', 'normal_wear', 'tenant_damage', 'pre_existing')),
  damage_description TEXT,
  photo_urls TEXT[], -- Array of storage paths
  estimated_cost DECIMAL(10,2) DEFAULT 0,
  vetusty_rate DECIMAL(5,2) DEFAULT 0, -- Taux de vétusté (0-100)
  tenant_responsibility DECIMAL(5,2) DEFAULT 0, -- Part locataire (0-100)
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_edl_items_process ON edl_inspection_items(lease_end_process_id);
CREATE INDEX IF NOT EXISTS idx_edl_items_category ON edl_inspection_items(category);

-- RLS pour edl_inspection_items
ALTER TABLE edl_inspection_items ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "edl_items_via_process" ON edl_inspection_items;
CREATE POLICY "edl_items_via_process" ON edl_inspection_items FOR ALL TO authenticated
USING (
  lease_end_process_id IN (SELECT id FROM lease_end_processes)
);

-- Items de rénovation
CREATE TABLE IF NOT EXISTS renovation_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lease_end_process_id UUID NOT NULL REFERENCES lease_end_processes(id) ON DELETE CASCADE,
  work_type TEXT NOT NULL,
  description TEXT,
  room TEXT,
  priority INTEGER DEFAULT 5 CHECK (priority BETWEEN 1 AND 10),
  estimated_cost DECIMAL(10,2) DEFAULT 0,
  vetusty_deduction DECIMAL(10,2) DEFAULT 0,
  tenant_share DECIMAL(10,2) DEFAULT 0,
  owner_share DECIMAL(10,2) DEFAULT 0,
  payer TEXT CHECK (payer IN ('tenant', 'owner', 'shared')),
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'quoted', 'approved', 'in_progress', 'completed', 'cancelled')),
  scheduled_date DATE,
  completed_date DATE,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_renovation_items_process ON renovation_items(lease_end_process_id);

-- RLS
ALTER TABLE renovation_items ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "renovation_items_via_process" ON renovation_items;
CREATE POLICY "renovation_items_via_process" ON renovation_items FOR ALL TO authenticated
USING (
  lease_end_process_id IN (SELECT id FROM lease_end_processes)
);

-- Timeline des actions
CREATE TABLE IF NOT EXISTS lease_end_timeline (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lease_end_process_id UUID NOT NULL REFERENCES lease_end_processes(id) ON DELETE CASCADE,
  action_type TEXT NOT NULL,
  description TEXT,
  day_offset INTEGER NOT NULL, -- Nombre de jours avant/après la date de fin
  scheduled_date DATE,
  completed_date DATE,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'skipped')),
  assigned_to UUID REFERENCES profiles(id),
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_timeline_process ON lease_end_timeline(lease_end_process_id);

-- RLS
ALTER TABLE lease_end_timeline ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "timeline_via_process" ON lease_end_timeline;
CREATE POLICY "timeline_via_process" ON lease_end_timeline FOR ALL TO authenticated
USING (
  lease_end_process_id IN (SELECT id FROM lease_end_processes)
);

-- ============================================
-- 4. FONCTION RPC CORRIGÉE
-- ============================================
DROP FUNCTION IF EXISTS public.get_owner_lease_end_processes(UUID);
CREATE OR REPLACE FUNCTION public.get_owner_lease_end_processes(p_owner_id UUID)
RETURNS TABLE (
  id UUID,
  lease_id UUID,
  property_id UUID,
  status TEXT,
  progress_percentage INTEGER,
  lease_end_date DATE,
  trigger_date DATE,
  dg_amount DECIMAL,
  dg_retention_amount DECIMAL,
  dg_refund_amount DECIMAL,
  tenant_damage_cost DECIMAL,
  vetusty_cost DECIMAL,
  renovation_cost DECIMAL,
  total_budget DECIMAL,
  created_at TIMESTAMPTZ,
  -- Données jointes
  property JSONB,
  lease JSONB,
  tenant JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    lep.id,
    lep.lease_id,
    lep.property_id,
    lep.status,
    lep.progress_percentage,
    lep.lease_end_date,
    lep.trigger_date,
    lep.dg_amount,
    lep.dg_retention_amount,
    lep.dg_refund_amount,
    lep.tenant_damage_cost,
    lep.vetusty_cost,
    lep.renovation_cost,
    lep.total_budget,
    lep.created_at,
    -- Property info
    jsonb_build_object(
      'id', p.id,
      'adresse_complete', p.adresse_complete,
      'ville', p.ville,
      'code_postal', p.code_postal,
      'type', p.type
    ) AS property,
    -- Lease info
    jsonb_build_object(
      'id', l.id,
      'type_bail', l.type_bail,
      'loyer', l.loyer,
      'charges_forfaitaires', l.charges_forfaitaires,
      'depot_de_garantie', l.depot_de_garantie,
      'date_debut', l.date_debut,
      'date_fin', l.date_fin
    ) AS lease,
    -- Tenant info (first tenant signer)
    COALESCE(
      (
        SELECT jsonb_build_object(
          'id', pr.id,
          'prenom', pr.prenom,
          'nom', pr.nom,
          'email', u.email
        )
        FROM lease_signers ls
        JOIN profiles pr ON pr.id = ls.profile_id
        LEFT JOIN auth.users u ON u.id = pr.user_id
        WHERE ls.lease_id = l.id 
          AND ls.role IN ('locataire_principal', 'locataire')
        LIMIT 1
      ),
      '{}'::jsonb
    ) AS tenant
  FROM lease_end_processes lep
  JOIN properties p ON p.id = lep.property_id
  JOIN leases l ON l.id = lep.lease_id
  WHERE p.owner_id = p_owner_id
  ORDER BY lep.lease_end_date ASC NULLS LAST;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_owner_lease_end_processes(UUID) TO authenticated;

-- ============================================
-- 5. VUE POUR LES BAUX À SURVEILLER (trigger)
-- ============================================
CREATE OR REPLACE VIEW v_upcoming_lease_ends AS
SELECT 
  l.id AS lease_id,
  l.property_id,
  l.type_bail,
  l.loyer,
  l.date_fin,
  p.owner_id,
  p.adresse_complete,
  p.ville,
  CASE l.type_bail
    WHEN 'nu' THEN 90
    WHEN 'meuble' THEN 30
    WHEN 'colocation' THEN 30
    WHEN 'saisonnier' THEN 0
    WHEN 'mobilite' THEN 15
    WHEN 'etudiant' THEN 30
    WHEN 'commercial' THEN 180
    ELSE 30
  END AS trigger_days,
  (l.date_fin::DATE - CURRENT_DATE) AS days_until_end,
  (l.date_fin::DATE - CURRENT_DATE - 
    CASE l.type_bail
      WHEN 'nu' THEN 90
      WHEN 'meuble' THEN 30
      WHEN 'colocation' THEN 30
      WHEN 'saisonnier' THEN 0
      WHEN 'mobilite' THEN 15
      WHEN 'etudiant' THEN 30
      WHEN 'commercial' THEN 180
      ELSE 30
    END
  ) AS days_until_trigger,
  CASE 
    WHEN (l.date_fin::DATE - CURRENT_DATE - 
      CASE l.type_bail
        WHEN 'nu' THEN 90
        WHEN 'meuble' THEN 30
        WHEN 'colocation' THEN 30
        WHEN 'saisonnier' THEN 0
        WHEN 'mobilite' THEN 15
        WHEN 'etudiant' THEN 30
        WHEN 'commercial' THEN 180
        ELSE 30
      END) <= 0 THEN true
    ELSE false
  END AS will_trigger_soon
FROM leases l
JOIN properties p ON p.id = l.property_id
WHERE l.statut IN ('active', 'pending_signature')
  AND l.date_fin IS NOT NULL
  AND l.date_fin >= CURRENT_DATE
  AND NOT EXISTS (
    SELECT 1 FROM lease_end_processes lep 
    WHERE lep.lease_id = l.id AND lep.status NOT IN ('completed', 'cancelled')
  );

-- ============================================
-- 6. GRILLES DE RÉFÉRENCE
-- ============================================

-- Grille de vétusté (si n'existe pas)
CREATE TABLE IF NOT EXISTS vetusty_grid (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  category TEXT NOT NULL,
  item TEXT NOT NULL,
  lifespan_years INTEGER NOT NULL,
  yearly_depreciation DECIMAL(5,2) NOT NULL,
  min_residual_value DECIMAL(5,2) DEFAULT 10, -- Valeur résiduelle minimum en %
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(category, item)
);

-- Grille des coûts de réparation (si n'existe pas)
CREATE TABLE IF NOT EXISTS repair_cost_grid (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  work_type TEXT NOT NULL,
  description TEXT,
  unit TEXT NOT NULL, -- 'm2', 'unite', 'ml' (mètre linéaire)
  cost_min DECIMAL(10,2) NOT NULL,
  cost_max DECIMAL(10,2) NOT NULL,
  cost_avg DECIMAL(10,2) NOT NULL,
  region TEXT DEFAULT 'france', -- Pour différencier les coûts par région
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(work_type, region)
);

-- Données de base pour la grille de vétusté
INSERT INTO vetusty_grid (category, item, lifespan_years, yearly_depreciation, min_residual_value) VALUES
  ('sols', 'moquette', 7, 14.28, 0),
  ('sols', 'parquet_massif', 25, 4, 20),
  ('sols', 'parquet_stratifie', 15, 6.67, 10),
  ('sols', 'carrelage', 30, 3.33, 20),
  ('sols', 'lino_pvc', 10, 10, 10),
  ('murs', 'peinture', 7, 14.28, 0),
  ('murs', 'papier_peint', 9, 11.11, 0),
  ('murs', 'faience', 30, 3.33, 20),
  ('plafonds', 'peinture', 10, 10, 0),
  ('plafonds', 'lambris', 20, 5, 10),
  ('equipements', 'robinetterie', 15, 6.67, 10),
  ('equipements', 'sanitaires', 25, 4, 15),
  ('equipements', 'chauffe_eau', 15, 6.67, 10),
  ('equipements', 'chaudiere', 20, 5, 15),
  ('menuiseries', 'portes_interieures', 25, 4, 15),
  ('menuiseries', 'fenetres_pvc', 30, 3.33, 20),
  ('menuiseries', 'volets', 25, 4, 15),
  ('electricite', 'prises_interrupteurs', 25, 4, 15),
  ('electricite', 'tableau_electrique', 30, 3.33, 20)
ON CONFLICT (category, item) DO NOTHING;

-- Données de base pour les coûts de réparation
INSERT INTO repair_cost_grid (work_type, description, unit, cost_min, cost_max, cost_avg) VALUES
  ('peinture_murs', 'Peinture des murs (préparation + 2 couches)', 'm2', 15, 35, 25),
  ('peinture_plafond', 'Peinture du plafond', 'm2', 18, 40, 28),
  ('parquet_stratifie', 'Pose de parquet stratifié', 'm2', 25, 50, 38),
  ('carrelage', 'Pose de carrelage', 'm2', 35, 80, 55),
  ('moquette', 'Pose de moquette', 'm2', 15, 40, 25),
  ('rebouchage_trous', 'Rebouchage de trous', 'unite', 5, 20, 12),
  ('porte_interieure', 'Remplacement porte intérieure', 'unite', 150, 400, 250),
  ('robinetterie', 'Remplacement robinetterie', 'unite', 80, 200, 130),
  ('prise_electrique', 'Remplacement prise électrique', 'unite', 25, 60, 40),
  ('interrupteur', 'Remplacement interrupteur', 'unite', 20, 50, 35),
  ('nettoyage_profond', 'Nettoyage profond complet', 'unite', 100, 300, 180),
  ('desinfection', 'Désinfection locaux', 'm2', 5, 15, 9)
ON CONFLICT (work_type, region) DO NOTHING;

-- ============================================
-- DONE
-- ============================================
COMMENT ON TABLE lease_end_processes IS 'Processus de fin de bail avec suivi EDL, rénovation et restitution DG';
COMMENT ON TABLE edl_inspection_items IS 'Items d''inspection pour l''EDL de sortie';
COMMENT ON TABLE renovation_items IS 'Travaux de rénovation planifiés';
COMMENT ON TABLE lease_end_timeline IS 'Timeline des actions de fin de bail';
COMMENT ON TABLE vetusty_grid IS 'Grille de vétusté officielle pour calcul de la part locataire';
COMMENT ON TABLE repair_cost_grid IS 'Grille de référence des coûts de réparation';



-- ========== 20251206550000_impersonation_sessions.sql ==========
-- Migration: Table de tracking des sessions d'impersonation
-- Date: 2024-12-06
-- Description: Stocke l'historique des sessions d'impersonation admin

BEGIN;

-- ============================================
-- TABLE: impersonation_sessions
-- ============================================

CREATE TABLE IF NOT EXISTS impersonation_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  admin_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  target_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  reason TEXT NOT NULL,
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,
  ended_at TIMESTAMPTZ,
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'ended', 'expired')),
  actions_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT different_users CHECK (admin_id != target_user_id)
);

-- Index pour recherche rapide
CREATE INDEX IF NOT EXISTS idx_impersonation_admin 
  ON impersonation_sessions(admin_id, status);
  
CREATE INDEX IF NOT EXISTS idx_impersonation_target 
  ON impersonation_sessions(target_user_id);
  
CREATE INDEX IF NOT EXISTS idx_impersonation_active 
  ON impersonation_sessions(status) WHERE status = 'active';

-- ============================================
-- RLS: Seuls les admins peuvent voir les sessions
-- ============================================

ALTER TABLE impersonation_sessions ENABLE ROW LEVEL SECURITY;

-- Politique: Admin peut voir toutes les sessions
CREATE POLICY "admin_view_impersonation_sessions" ON impersonation_sessions
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE profiles.user_id = auth.uid() 
      AND profiles.role = 'admin'
    )
  );

-- Politique: Admin peut insérer ses propres sessions
CREATE POLICY "admin_insert_impersonation_sessions" ON impersonation_sessions
  FOR INSERT
  WITH CHECK (
    admin_id = auth.uid() AND
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE profiles.user_id = auth.uid() 
      AND profiles.role = 'admin'
    )
  );

-- Politique: Admin peut mettre à jour ses propres sessions
CREATE POLICY "admin_update_impersonation_sessions" ON impersonation_sessions
  FOR UPDATE
  USING (
    admin_id = auth.uid() AND
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE profiles.user_id = auth.uid() 
      AND profiles.role = 'admin'
    )
  );

-- ============================================
-- FUNCTION: Expirer les sessions automatiquement
-- ============================================

CREATE OR REPLACE FUNCTION expire_impersonation_sessions()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE impersonation_sessions
  SET 
    status = 'expired',
    ended_at = NOW()
  WHERE 
    status = 'active' 
    AND expires_at < NOW();
END;
$$;

-- Commentaires
COMMENT ON TABLE impersonation_sessions IS 
  'Historique des sessions d''impersonation admin pour audit et sécurité';
COMMENT ON COLUMN impersonation_sessions.reason IS 
  'Raison de l''impersonation (obligatoire pour audit)';
COMMENT ON COLUMN impersonation_sessions.actions_count IS 
  'Nombre d''actions effectuées pendant la session';

COMMIT;



-- ========== 20251206600000_analytics_materialized_views.sql ==========
-- Migration: Materialized Views pour Analytics
-- Date: 2024-12-06
-- Description: Vues matérialisées pour dashboards et rapports performants

BEGIN;

-- ============================================
-- VUE: Statistiques mensuelles propriétaires
-- ============================================

CREATE MATERIALIZED VIEW IF NOT EXISTS mv_owner_monthly_stats AS
SELECT 
  p.id AS owner_id,
  DATE_TRUNC('month', i.created_at) AS month,
  COUNT(DISTINCT prop.id) AS properties_count,
  COUNT(DISTINCT l.id) AS active_leases_count,
  COUNT(DISTINCT i.id) AS invoices_count,
  COALESCE(SUM(i.montant_total), 0) AS total_invoiced,
  COALESCE(SUM(CASE WHEN i.statut = 'paid' THEN i.montant_total ELSE 0 END), 0) AS total_collected,
  COALESCE(SUM(CASE WHEN i.statut = 'late' THEN i.montant_total ELSE 0 END), 0) AS total_late,
  COUNT(CASE WHEN i.statut = 'paid' THEN 1 END) AS paid_invoices_count,
  COUNT(CASE WHEN i.statut = 'late' THEN 1 END) AS late_invoices_count,
  ROUND(
    CASE 
      WHEN COUNT(i.id) > 0 
      THEN COUNT(CASE WHEN i.statut = 'paid' THEN 1 END)::DECIMAL / COUNT(i.id) * 100 
      ELSE 0 
    END, 2
  ) AS collection_rate
FROM profiles p
LEFT JOIN properties prop ON prop.owner_id = p.id
LEFT JOIN leases l ON l.property_id = prop.id AND l.statut = 'active'
LEFT JOIN invoices i ON i.owner_id = p.id
WHERE p.role = 'owner'
GROUP BY p.id, DATE_TRUNC('month', i.created_at);

CREATE UNIQUE INDEX IF NOT EXISTS idx_mv_owner_monthly_stats 
  ON mv_owner_monthly_stats(owner_id, month);

-- ============================================
-- VUE: KPIs globaux plateforme
-- ============================================

CREATE MATERIALIZED VIEW IF NOT EXISTS mv_platform_kpis AS
SELECT 
  DATE_TRUNC('day', NOW()) AS snapshot_date,
  
  -- Utilisateurs
  (SELECT COUNT(*) FROM profiles WHERE role = 'owner') AS total_owners,
  (SELECT COUNT(*) FROM profiles WHERE role = 'tenant') AS total_tenants,
  (SELECT COUNT(*) FROM profiles WHERE role = 'provider') AS total_providers,
  (SELECT COUNT(*) FROM profiles WHERE created_at > NOW() - INTERVAL '30 days') AS new_users_30d,
  
  -- Propriétés (etat au lieu de status)
  (SELECT COUNT(*) FROM properties WHERE etat = 'published') AS active_properties,
  (SELECT COUNT(*) FROM properties WHERE created_at > NOW() - INTERVAL '30 days') AS new_properties_30d,
  
  -- Baux (statut au lieu de status)
  (SELECT COUNT(*) FROM leases WHERE statut = 'active') AS active_leases,
  (SELECT COUNT(*) FROM leases WHERE created_at > NOW() - INTERVAL '30 days') AS new_leases_30d,
  
  -- Facturation (statut au lieu de status)
  (SELECT COALESCE(SUM(montant_total), 0) FROM invoices WHERE statut = 'paid' AND created_at > NOW() - INTERVAL '30 days') AS revenue_30d,
  (SELECT COALESCE(SUM(montant_total), 0) FROM invoices WHERE statut = 'late') AS total_late_amount,
  
  -- Abonnements
  (SELECT COUNT(*) FROM subscriptions WHERE status = 'active') AS active_subscriptions,
  (SELECT COALESCE(SUM(sp.price_monthly), 0) FROM subscriptions s 
   JOIN subscription_plans sp ON s.plan_id = sp.id 
   WHERE s.status = 'active') AS mrr_estimate,
  
  -- Tickets (statut au lieu de status)
  (SELECT COUNT(*) FROM tickets WHERE statut = 'open') AS open_tickets,
  (SELECT AVG(EXTRACT(EPOCH FROM (updated_at - created_at))/3600) 
   FROM tickets WHERE statut = 'resolved' AND updated_at > NOW() - INTERVAL '30 days') AS avg_resolution_hours;

-- Index unique sur la date de snapshot
CREATE UNIQUE INDEX IF NOT EXISTS idx_mv_platform_kpis_date 
  ON mv_platform_kpis(snapshot_date);

-- ============================================
-- VUE: Analyse des paiements
-- ============================================

CREATE MATERIALIZED VIEW IF NOT EXISTS mv_payment_analytics AS
SELECT 
  DATE_TRUNC('month', p.created_at) AS month,
  p.moyen AS payment_method,
  COUNT(*) AS transaction_count,
  SUM(p.montant) AS total_amount,
  AVG(p.montant) AS avg_amount,
  COUNT(CASE WHEN p.statut = 'succeeded' THEN 1 END) AS successful_count,
  COUNT(CASE WHEN p.statut = 'failed' THEN 1 END) AS failed_count,
  ROUND(
    COUNT(CASE WHEN p.statut = 'succeeded' THEN 1 END)::DECIMAL / NULLIF(COUNT(*), 0) * 100, 2
  ) AS success_rate
FROM payments p
WHERE p.created_at > NOW() - INTERVAL '12 months'
GROUP BY DATE_TRUNC('month', p.created_at), p.moyen
ORDER BY month DESC, payment_method;

CREATE INDEX IF NOT EXISTS idx_mv_payment_analytics_month 
  ON mv_payment_analytics(month);

-- ============================================
-- VUE: Taux d'occupation par propriété
-- ============================================

CREATE MATERIALIZED VIEW IF NOT EXISTS mv_property_occupancy AS
SELECT 
  prop.id AS property_id,
  prop.owner_id,
  prop.type AS property_type,
  prop.ville AS city,
  COUNT(DISTINCT l.id) AS total_leases,
  COUNT(DISTINCT CASE WHEN l.statut = 'active' THEN l.id END) AS active_leases,
  COALESCE(
    EXTRACT(DAY FROM (
      SELECT SUM(
        LEAST(COALESCE(l2.date_fin, NOW()), NOW()) - 
        GREATEST(l2.date_debut, NOW() - INTERVAL '12 months')
      )
      FROM leases l2 
      WHERE l2.property_id = prop.id 
      AND l2.date_debut < NOW()
      AND (l2.date_fin IS NULL OR l2.date_fin > NOW() - INTERVAL '12 months')
    )) / 365 * 100, 0
  )::INTEGER AS occupancy_rate_12m,
  (SELECT COALESCE(SUM(i.montant_total), 0) 
   FROM invoices i 
   JOIN leases l3 ON i.lease_id = l3.id 
   WHERE l3.property_id = prop.id 
   AND i.statut = 'paid' 
   AND i.created_at > NOW() - INTERVAL '12 months'
  ) AS revenue_12m
FROM properties prop
LEFT JOIN leases l ON l.property_id = prop.id
WHERE prop.etat = 'published'
GROUP BY prop.id, prop.owner_id, prop.type, prop.ville;

CREATE UNIQUE INDEX IF NOT EXISTS idx_mv_property_occupancy 
  ON mv_property_occupancy(property_id);

-- ============================================
-- VUE: Retards de paiement par locataire
-- ============================================

CREATE MATERIALIZED VIEW IF NOT EXISTS mv_tenant_payment_history AS
SELECT 
  tp.profile_id AS tenant_id,
  p.prenom || ' ' || p.nom AS tenant_name,
  COUNT(DISTINCT i.id) AS total_invoices,
  COUNT(DISTINCT CASE WHEN i.statut = 'paid' THEN i.id END) AS paid_invoices,
  COUNT(DISTINCT CASE WHEN i.statut = 'late' THEN i.id END) AS late_invoices,
  ROUND(
    COUNT(DISTINCT CASE WHEN i.statut = 'paid' THEN i.id END)::DECIMAL / 
    NULLIF(COUNT(DISTINCT i.id), 0) * 100, 2
  ) AS payment_rate,
  COALESCE(SUM(CASE WHEN i.statut = 'late' THEN i.montant_total ELSE 0 END), 0) AS current_late_amount
FROM tenant_profiles tp
JOIN profiles p ON p.id = tp.profile_id
LEFT JOIN invoices i ON i.tenant_id = tp.profile_id
GROUP BY tp.profile_id, p.prenom, p.nom;

CREATE UNIQUE INDEX IF NOT EXISTS idx_mv_tenant_payment_history 
  ON mv_tenant_payment_history(tenant_id);

-- ============================================
-- FONCTION: Rafraîchir toutes les vues
-- ============================================

CREATE OR REPLACE FUNCTION refresh_analytics_views()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_platform_kpis;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_owner_monthly_stats;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_payment_analytics;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_property_occupancy;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mv_tenant_payment_history;
  
  RAISE NOTICE 'Toutes les vues analytics ont été rafraîchies à %', NOW();
END;
$$;

-- ============================================
-- COMMENTAIRES
-- ============================================

COMMENT ON MATERIALIZED VIEW mv_platform_kpis IS 
  'KPIs globaux de la plateforme - rafraîchir quotidiennement';
COMMENT ON MATERIALIZED VIEW mv_owner_monthly_stats IS 
  'Statistiques mensuelles par propriétaire - rafraîchir quotidiennement';
COMMENT ON MATERIALIZED VIEW mv_payment_analytics IS 
  'Analyse des paiements par méthode et mois - rafraîchir quotidiennement';
COMMENT ON MATERIALIZED VIEW mv_property_occupancy IS 
  'Taux d''occupation par propriété - rafraîchir hebdomadairement';
COMMENT ON MATERIALIZED VIEW mv_tenant_payment_history IS 
  'Historique de paiement des locataires - rafraîchir quotidiennement';

COMMIT;



-- ========== 20251206700000_agency_module.sql ==========
-- Migration : Module Agence / Conciergerie
-- Ajoute le support pour les agences immobilières et conciergeries

-- ============================================
-- 1. Ajouter le rôle "agency" dans profiles
-- ============================================

-- Modifier la contrainte de rôle pour inclure "agency"
ALTER TABLE profiles 
DROP CONSTRAINT IF EXISTS profiles_role_check;

ALTER TABLE profiles 
ADD CONSTRAINT profiles_role_check 
CHECK (role IN ('admin', 'owner', 'tenant', 'provider', 'agency'));

-- ============================================
-- 2. Ajouter raison_sociale à owner_profiles
-- ============================================

ALTER TABLE owner_profiles 
ADD COLUMN IF NOT EXISTS raison_sociale TEXT;

ALTER TABLE owner_profiles 
ADD COLUMN IF NOT EXISTS adresse_siege TEXT;

ALTER TABLE owner_profiles 
ADD COLUMN IF NOT EXISTS forme_juridique TEXT 
CHECK (forme_juridique IN ('SARL', 'SAS', 'SASU', 'SCI', 'EURL', 'EI', 'SA', 'SCPI', 'autre'));

COMMENT ON COLUMN owner_profiles.raison_sociale IS 'Raison sociale pour les sociétés';
COMMENT ON COLUMN owner_profiles.adresse_siege IS 'Adresse du siège social';
COMMENT ON COLUMN owner_profiles.forme_juridique IS 'Forme juridique de la société';

-- ============================================
-- 3. Table des profils agence
-- ============================================

CREATE TABLE IF NOT EXISTS agency_profiles (
  profile_id UUID PRIMARY KEY REFERENCES profiles(id) ON DELETE CASCADE,
  raison_sociale TEXT NOT NULL,
  forme_juridique TEXT CHECK (forme_juridique IN ('SARL', 'SAS', 'SASU', 'SCI', 'EURL', 'EI', 'SA', 'autre')),
  siret TEXT,
  numero_carte_pro TEXT, -- Carte professionnelle immobilier
  carte_pro_delivree_par TEXT, -- CCI délivrant la carte
  carte_pro_validite DATE, -- Date de validité
  garantie_financiere_montant DECIMAL(12, 2), -- Montant de la garantie
  garantie_financiere_organisme TEXT, -- Organisme garantissant
  assurance_rcp TEXT, -- Numéro police RCP
  assurance_rcp_organisme TEXT, -- Assureur RCP
  adresse_siege TEXT,
  logo_url TEXT,
  website TEXT,
  description TEXT,
  zones_intervention TEXT[], -- Départements/villes d'intervention
  services_proposes TEXT[] DEFAULT ARRAY['gestion_locative'], -- Types de services
  commission_gestion_defaut DECIMAL(4, 2) DEFAULT 7.0, -- Commission par défaut en %
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_agency_profiles_siret ON agency_profiles(siret);

COMMENT ON TABLE agency_profiles IS 'Profils des agences immobilières et conciergeries';

-- ============================================
-- 4. Table des mandats de gestion
-- ============================================

CREATE TABLE IF NOT EXISTS mandates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  agency_profile_id UUID NOT NULL REFERENCES agency_profiles(profile_id) ON DELETE CASCADE,
  owner_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Informations du mandat
  numero_mandat TEXT, -- Numéro de mandat unique
  type_mandat TEXT NOT NULL DEFAULT 'gestion' CHECK (type_mandat IN ('gestion', 'location', 'vente', 'syndic')),
  date_debut DATE NOT NULL DEFAULT CURRENT_DATE,
  date_fin DATE, -- NULL = durée indéterminée
  duree_mois INTEGER, -- Durée en mois si déterminée
  tacite_reconduction BOOLEAN DEFAULT true,
  preavis_resiliation_mois INTEGER DEFAULT 3,
  
  -- Étendue du mandat
  properties_ids UUID[] DEFAULT '{}', -- Liste des biens concernés, vide = tous
  inclut_tous_biens BOOLEAN DEFAULT true, -- Si true, tous les biens du propriétaire
  
  -- Commission et rémunération
  commission_pourcentage DECIMAL(4, 2) NOT NULL DEFAULT 7.0, -- % sur loyers encaissés
  commission_fixe_mensuelle DECIMAL(10, 2), -- Alternative : montant fixe
  honoraires_mise_en_location DECIMAL(10, 2), -- Honoraires pour trouver un locataire
  honoraires_edl DECIMAL(10, 2), -- Honoraires état des lieux
  
  -- Statut
  statut TEXT NOT NULL DEFAULT 'draft' CHECK (statut IN ('draft', 'pending_signature', 'active', 'suspended', 'terminated')),
  date_signature DATE,
  document_mandat_url TEXT, -- URL du document signé
  
  -- Métadonnées
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(agency_profile_id, owner_profile_id, type_mandat)
);

CREATE INDEX IF NOT EXISTS idx_mandates_agency ON mandates(agency_profile_id);
CREATE INDEX IF NOT EXISTS idx_mandates_owner ON mandates(owner_profile_id);
CREATE INDEX IF NOT EXISTS idx_mandates_statut ON mandates(statut);

COMMENT ON TABLE mandates IS 'Mandats de gestion entre agences et propriétaires';

-- ============================================
-- 5. Table des gestionnaires (employés agence)
-- ============================================

CREATE TABLE IF NOT EXISTS agency_managers (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  agency_profile_id UUID NOT NULL REFERENCES agency_profiles(profile_id) ON DELETE CASCADE,
  user_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  role_agence TEXT NOT NULL DEFAULT 'gestionnaire' CHECK (role_agence IN ('directeur', 'gestionnaire', 'assistant', 'comptable')),
  properties_assigned UUID[] DEFAULT '{}', -- Biens assignés à ce gestionnaire
  can_sign_documents BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(agency_profile_id, user_profile_id)
);

CREATE INDEX IF NOT EXISTS idx_agency_managers_agency ON agency_managers(agency_profile_id);
CREATE INDEX IF NOT EXISTS idx_agency_managers_user ON agency_managers(user_profile_id);

COMMENT ON TABLE agency_managers IS 'Gestionnaires employés par une agence';

-- ============================================
-- 6. Table des commissions générées
-- ============================================

CREATE TABLE IF NOT EXISTS agency_commissions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  mandate_id UUID NOT NULL REFERENCES mandates(id) ON DELETE CASCADE,
  invoice_id UUID REFERENCES invoices(id) ON DELETE SET NULL,
  
  periode TEXT NOT NULL, -- Format YYYY-MM
  loyer_encaisse DECIMAL(10, 2) NOT NULL,
  taux_commission DECIMAL(4, 2) NOT NULL,
  montant_commission DECIMAL(10, 2) NOT NULL,
  montant_tva DECIMAL(10, 2) DEFAULT 0,
  montant_total_ttc DECIMAL(10, 2) NOT NULL,
  
  statut TEXT NOT NULL DEFAULT 'pending' CHECK (statut IN ('pending', 'invoiced', 'paid')),
  date_paiement DATE,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_agency_commissions_mandate ON agency_commissions(mandate_id);
CREATE INDEX IF NOT EXISTS idx_agency_commissions_periode ON agency_commissions(periode);
CREATE INDEX IF NOT EXISTS idx_agency_commissions_statut ON agency_commissions(statut);

COMMENT ON TABLE agency_commissions IS 'Commissions générées pour les agences';

-- ============================================
-- 7. RLS Policies
-- ============================================

-- Agency profiles
ALTER TABLE agency_profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "agency_profiles_select_own" ON agency_profiles
  FOR SELECT USING (
    profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    OR EXISTS (
      SELECT 1 FROM profiles p WHERE p.user_id = auth.uid() AND p.role = 'admin'
    )
  );

CREATE POLICY "agency_profiles_insert_own" ON agency_profiles
  FOR INSERT WITH CHECK (
    profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "agency_profiles_update_own" ON agency_profiles
  FOR UPDATE USING (
    profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Mandates
ALTER TABLE mandates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "mandates_select_agency" ON mandates
  FOR SELECT USING (
    agency_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    OR owner_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    OR EXISTS (
      SELECT 1 FROM profiles p WHERE p.user_id = auth.uid() AND p.role = 'admin'
    )
  );

CREATE POLICY "mandates_insert_agency" ON mandates
  FOR INSERT WITH CHECK (
    agency_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid() AND role = 'agency')
  );

CREATE POLICY "mandates_update_agency" ON mandates
  FOR UPDATE USING (
    agency_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Agency managers
ALTER TABLE agency_managers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "agency_managers_select" ON agency_managers
  FOR SELECT USING (
    agency_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    OR user_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    OR EXISTS (
      SELECT 1 FROM profiles p WHERE p.user_id = auth.uid() AND p.role = 'admin'
    )
  );

CREATE POLICY "agency_managers_manage" ON agency_managers
  FOR ALL USING (
    agency_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Agency commissions
ALTER TABLE agency_commissions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "agency_commissions_select" ON agency_commissions
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM mandates m 
      WHERE m.id = mandate_id 
      AND (
        m.agency_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
        OR m.owner_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
      )
    )
    OR EXISTS (
      SELECT 1 FROM profiles p WHERE p.user_id = auth.uid() AND p.role = 'admin'
    )
  );

-- ============================================
-- 8. Fonction pour calculer les commissions
-- ============================================

CREATE OR REPLACE FUNCTION calculate_agency_commission(
  p_mandate_id UUID,
  p_periode TEXT,
  p_loyer_encaisse DECIMAL
)
RETURNS TABLE(
  montant_commission DECIMAL,
  montant_tva DECIMAL,
  montant_total_ttc DECIMAL
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_taux_commission DECIMAL;
  v_commission DECIMAL;
  v_tva DECIMAL;
  v_total DECIMAL;
BEGIN
  -- Récupérer le taux de commission du mandat
  SELECT commission_pourcentage INTO v_taux_commission
  FROM mandates
  WHERE id = p_mandate_id;
  
  IF v_taux_commission IS NULL THEN
    RAISE EXCEPTION 'Mandat non trouvé';
  END IF;
  
  -- Calculer la commission HT
  v_commission := p_loyer_encaisse * (v_taux_commission / 100);
  
  -- Calculer la TVA (20%)
  v_tva := v_commission * 0.20;
  
  -- Total TTC
  v_total := v_commission + v_tva;
  
  RETURN QUERY SELECT v_commission, v_tva, v_total;
END;
$$;

-- ============================================
-- 9. Vue pour le dashboard agence
-- ============================================

CREATE OR REPLACE VIEW agency_dashboard_stats AS
SELECT 
  ap.profile_id as agency_id,
  COUNT(DISTINCT m.id) as total_mandats,
  COUNT(DISTINCT m.id) FILTER (WHERE m.statut = 'active') as mandats_actifs,
  COUNT(DISTINCT m.owner_profile_id) as total_proprietaires,
  (
    SELECT COUNT(*) FROM properties p
    INNER JOIN profiles pr ON p.owner_id = pr.id
    INNER JOIN mandates m2 ON m2.owner_profile_id = pr.id AND m2.agency_profile_id = ap.profile_id
    WHERE m2.statut = 'active' AND (m2.inclut_tous_biens = true OR p.id = ANY(m2.properties_ids))
  ) as total_biens_geres,
  COALESCE(SUM(ac.montant_commission) FILTER (WHERE ac.statut = 'paid'), 0) as commissions_encaissees,
  COALESCE(SUM(ac.montant_commission) FILTER (WHERE ac.statut = 'pending'), 0) as commissions_en_attente
FROM agency_profiles ap
LEFT JOIN mandates m ON m.agency_profile_id = ap.profile_id
LEFT JOIN agency_commissions ac ON ac.mandate_id = m.id
GROUP BY ap.profile_id;

-- ============================================
-- 10. Triggers pour updated_at
-- ============================================

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_agency_profiles_updated_at ON agency_profiles;
CREATE TRIGGER update_agency_profiles_updated_at
  BEFORE UPDATE ON agency_profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_mandates_updated_at ON mandates;
CREATE TRIGGER update_mandates_updated_at
  BEFORE UPDATE ON mandates
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_agency_managers_updated_at ON agency_managers;
CREATE TRIGGER update_agency_managers_updated_at
  BEFORE UPDATE ON agency_managers
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_agency_commissions_updated_at ON agency_commissions;
CREATE TRIGGER update_agency_commissions_updated_at
  BEFORE UPDATE ON agency_commissions
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- 11. Grants
-- ============================================

GRANT SELECT, INSERT, UPDATE, DELETE ON agency_profiles TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON mandates TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON agency_managers TO authenticated;
GRANT SELECT, INSERT, UPDATE ON agency_commissions TO authenticated;
GRANT SELECT ON agency_dashboard_stats TO authenticated;

-- ============================================
-- 12. Commentaires
-- ============================================

COMMENT ON COLUMN agency_profiles.numero_carte_pro IS 'Numéro de la carte professionnelle immobilier obligatoire';
COMMENT ON COLUMN mandates.commission_pourcentage IS 'Pourcentage de commission sur les loyers encaissés (généralement 5-10%)';
COMMENT ON COLUMN agency_commissions.periode IS 'Période de facturation au format YYYY-MM';



-- ========== 20251206750000_fix_all_missing_tables.sql ==========
-- =====================================================
-- MIGRATION CONSOLIDÉE : Toutes les tables et fonctions manquantes
-- Résout les erreurs API 500 du module prestataire et notifications
-- =====================================================

-- =====================================================
-- 1. TABLE NOTIFICATIONS - Adaptation pour profile_id
-- =====================================================

-- Créer la table si elle n'existe pas
CREATE TABLE IF NOT EXISTS notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  type TEXT NOT NULL,
  title TEXT NOT NULL,
  message TEXT,
  link TEXT,
  data JSONB DEFAULT '{}',
  is_read BOOLEAN DEFAULT false,
  read_at TIMESTAMPTZ,
  related_id UUID,
  related_type TEXT,
  priority TEXT DEFAULT 'normal' CHECK (priority IN ('low', 'normal', 'high', 'urgent')),
  action_url TEXT,
  action_label TEXT,
  channels_status JSONB DEFAULT '{"in_app": "pending"}',
  status TEXT DEFAULT 'pending',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Ajouter les colonnes manquantes si la table existe
DO $$
BEGIN
  -- Ajouter profile_id si n'existe pas
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'notifications' AND column_name = 'profile_id'
  ) THEN
    ALTER TABLE notifications ADD COLUMN profile_id UUID REFERENCES profiles(id) ON DELETE CASCADE;
  END IF;
  
  -- Ajouter is_read si n'existe pas
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'notifications' AND column_name = 'is_read'
  ) THEN
    ALTER TABLE notifications ADD COLUMN is_read BOOLEAN DEFAULT false;
  END IF;
  
  -- Ajouter priority si n'existe pas
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'notifications' AND column_name = 'priority'
  ) THEN
    ALTER TABLE notifications ADD COLUMN priority TEXT DEFAULT 'normal';
  END IF;
  
  -- Ajouter action_url si n'existe pas
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'notifications' AND column_name = 'action_url'
  ) THEN
    ALTER TABLE notifications ADD COLUMN action_url TEXT;
  END IF;
  
  -- Ajouter action_label si n'existe pas
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'notifications' AND column_name = 'action_label'
  ) THEN
    ALTER TABLE notifications ADD COLUMN action_label TEXT;
  END IF;
END $$;

-- Index pour notifications
CREATE INDEX IF NOT EXISTS idx_notifications_profile_id ON notifications(profile_id);
CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_is_read ON notifications(is_read);
CREATE INDEX IF NOT EXISTS idx_notifications_created_at ON notifications(created_at DESC);

-- RLS pour notifications
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own notifications by profile" ON notifications;
CREATE POLICY "Users can view own notifications by profile"
  ON notifications FOR SELECT
  USING (
    profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    OR user_id = auth.uid()
  );

DROP POLICY IF EXISTS "Users can update own notifications" ON notifications;
CREATE POLICY "Users can update own notifications"
  ON notifications FOR UPDATE
  USING (
    profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    OR user_id = auth.uid()
  );

DROP POLICY IF EXISTS "System can insert notifications" ON notifications;
CREATE POLICY "System can insert notifications"
  ON notifications FOR INSERT
  WITH CHECK (true);

-- =====================================================
-- 2. FONCTIONS RPC NOTIFICATIONS
-- =====================================================

-- Fonction pour récupérer les notifications récentes
CREATE OR REPLACE FUNCTION get_recent_notifications(
  p_profile_id UUID,
  p_limit INTEGER DEFAULT 20,
  p_offset INTEGER DEFAULT 0,
  p_unread_only BOOLEAN DEFAULT false
)
RETURNS TABLE (
  id UUID,
  type TEXT,
  title TEXT,
  message TEXT,
  link TEXT,
  data JSONB,
  is_read BOOLEAN,
  read_at TIMESTAMPTZ,
  priority TEXT,
  action_url TEXT,
  action_label TEXT,
  created_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    n.id,
    n.type,
    n.title,
    n.message,
    n.link,
    n.data,
    COALESCE(n.is_read, false),
    n.read_at,
    COALESCE(n.priority, 'normal'),
    n.action_url,
    n.action_label,
    n.created_at
  FROM notifications n
  WHERE n.profile_id = p_profile_id
    AND (NOT p_unread_only OR COALESCE(n.is_read, false) = false)
  ORDER BY n.created_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

-- Fonction pour compter les notifications non lues
CREATE OR REPLACE FUNCTION get_unread_notification_count(p_profile_id UUID)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_count INTEGER;
BEGIN
  SELECT COUNT(*)::INTEGER INTO v_count
  FROM notifications
  WHERE profile_id = p_profile_id
    AND COALESCE(is_read, false) = false;
  
  RETURN COALESCE(v_count, 0);
END;
$$;

-- Fonction pour marquer une notification comme lue
CREATE OR REPLACE FUNCTION mark_notification_read(p_notification_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE notifications
  SET is_read = true, read_at = NOW(), updated_at = NOW()
  WHERE id = p_notification_id
    AND profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid());
  
  RETURN FOUND;
END;
$$;

-- Fonction pour marquer toutes les notifications comme lues
CREATE OR REPLACE FUNCTION mark_all_notifications_read(p_profile_id UUID)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_count INTEGER;
BEGIN
  WITH updated AS (
    UPDATE notifications
    SET is_read = true, read_at = NOW(), updated_at = NOW()
    WHERE profile_id = p_profile_id
      AND COALESCE(is_read, false) = false
    RETURNING id
  )
  SELECT COUNT(*)::INTEGER INTO v_count FROM updated;
  
  RETURN COALESCE(v_count, 0);
END;
$$;

-- =====================================================
-- 3. TABLES PRESTATAIRE - DEVIS
-- =====================================================

-- Table provider_quotes
CREATE TABLE IF NOT EXISTS provider_quotes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  reference TEXT UNIQUE,
  provider_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  owner_profile_id UUID REFERENCES profiles(id),
  property_id UUID REFERENCES properties(id),
  ticket_id UUID REFERENCES tickets(id),
  title TEXT NOT NULL,
  description TEXT,
  subtotal DECIMAL(10,2) NOT NULL DEFAULT 0,
  tax_rate DECIMAL(5,2) NOT NULL DEFAULT 20,
  tax_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
  total_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
  valid_until DATE,
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'sent', 'viewed', 'accepted', 'rejected', 'expired', 'converted')),
  sent_at TIMESTAMPTZ,
  viewed_at TIMESTAMPTZ,
  accepted_at TIMESTAMPTZ,
  rejected_at TIMESTAMPTZ,
  rejection_reason TEXT,
  converted_invoice_id UUID,
  internal_notes TEXT,
  terms_and_conditions TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour provider_quotes
CREATE INDEX IF NOT EXISTS idx_provider_quotes_provider ON provider_quotes(provider_profile_id);
CREATE INDEX IF NOT EXISTS idx_provider_quotes_owner ON provider_quotes(owner_profile_id);
CREATE INDEX IF NOT EXISTS idx_provider_quotes_status ON provider_quotes(status);

-- RLS pour provider_quotes
ALTER TABLE provider_quotes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Providers can manage own quotes" ON provider_quotes;
CREATE POLICY "Providers can manage own quotes"
  ON provider_quotes FOR ALL
  USING (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()))
  WITH CHECK (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

DROP POLICY IF EXISTS "Owners can view quotes addressed to them" ON provider_quotes;
CREATE POLICY "Owners can view quotes addressed to them"
  ON provider_quotes FOR SELECT
  USING (owner_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

-- Table provider_quote_items
CREATE TABLE IF NOT EXISTS provider_quote_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  quote_id UUID NOT NULL REFERENCES provider_quotes(id) ON DELETE CASCADE,
  description TEXT NOT NULL,
  quantity DECIMAL(10,3) NOT NULL DEFAULT 1,
  unit TEXT DEFAULT 'unité',
  unit_price DECIMAL(10,2) NOT NULL,
  tax_rate DECIMAL(5,2) NOT NULL DEFAULT 20,
  sort_order INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour provider_quote_items
CREATE INDEX IF NOT EXISTS idx_provider_quote_items_quote ON provider_quote_items(quote_id);

-- RLS pour provider_quote_items
ALTER TABLE provider_quote_items ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can manage quote items via quotes" ON provider_quote_items;
CREATE POLICY "Users can manage quote items via quotes"
  ON provider_quote_items FOR ALL
  USING (
    quote_id IN (
      SELECT id FROM provider_quotes 
      WHERE provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- =====================================================
-- 4. TABLES PRESTATAIRE - FACTURES
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  reference TEXT UNIQUE,
  provider_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  owner_profile_id UUID REFERENCES profiles(id),
  property_id UUID REFERENCES properties(id),
  work_order_id UUID REFERENCES work_orders(id),
  quote_id UUID REFERENCES provider_quotes(id),
  title TEXT NOT NULL,
  description TEXT,
  subtotal DECIMAL(10,2) NOT NULL DEFAULT 0,
  tax_rate DECIMAL(5,2) NOT NULL DEFAULT 20,
  tax_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
  total_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'sent', 'viewed', 'paid', 'partial', 'overdue', 'cancelled')),
  due_date DATE,
  paid_at TIMESTAMPTZ,
  paid_amount DECIMAL(10,2) DEFAULT 0,
  payment_method TEXT,
  payment_reference TEXT,
  sent_at TIMESTAMPTZ,
  internal_notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour provider_invoices
CREATE INDEX IF NOT EXISTS idx_provider_invoices_provider ON provider_invoices(provider_profile_id);
CREATE INDEX IF NOT EXISTS idx_provider_invoices_owner ON provider_invoices(owner_profile_id);
CREATE INDEX IF NOT EXISTS idx_provider_invoices_status ON provider_invoices(status);

-- RLS pour provider_invoices
ALTER TABLE provider_invoices ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Providers can manage own invoices" ON provider_invoices;
CREATE POLICY "Providers can manage own invoices"
  ON provider_invoices FOR ALL
  USING (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()))
  WITH CHECK (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

DROP POLICY IF EXISTS "Owners can view invoices addressed to them" ON provider_invoices;
CREATE POLICY "Owners can view invoices addressed to them"
  ON provider_invoices FOR SELECT
  USING (owner_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

-- =====================================================
-- 5. TABLES PRESTATAIRE - AVIS
-- =====================================================

CREATE TABLE IF NOT EXISTS provider_reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  provider_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  reviewer_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  work_order_id UUID REFERENCES work_orders(id) ON DELETE SET NULL,
  property_id UUID REFERENCES properties(id) ON DELETE SET NULL,
  rating_overall INTEGER NOT NULL CHECK (rating_overall BETWEEN 1 AND 5),
  rating_punctuality INTEGER CHECK (rating_punctuality BETWEEN 1 AND 5),
  rating_quality INTEGER CHECK (rating_quality BETWEEN 1 AND 5),
  rating_communication INTEGER CHECK (rating_communication BETWEEN 1 AND 5),
  rating_value INTEGER CHECK (rating_value BETWEEN 1 AND 5),
  title TEXT,
  comment TEXT,
  would_recommend BOOLEAN DEFAULT true,
  provider_response TEXT,
  provider_response_at TIMESTAMPTZ,
  is_published BOOLEAN DEFAULT true,
  is_flagged BOOLEAN DEFAULT false,
  flag_reason TEXT,
  moderated_at TIMESTAMPTZ,
  moderated_by UUID REFERENCES profiles(id),
  helpful_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour provider_reviews
CREATE INDEX IF NOT EXISTS idx_provider_reviews_provider ON provider_reviews(provider_profile_id);
CREATE INDEX IF NOT EXISTS idx_provider_reviews_reviewer ON provider_reviews(reviewer_profile_id);
CREATE INDEX IF NOT EXISTS idx_provider_reviews_published ON provider_reviews(is_published) WHERE is_published = true;

-- RLS pour provider_reviews
ALTER TABLE provider_reviews ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Anyone can read published reviews" ON provider_reviews;
CREATE POLICY "Anyone can read published reviews"
  ON provider_reviews FOR SELECT
  USING (is_published = true);

DROP POLICY IF EXISTS "Providers can read own reviews" ON provider_reviews;
CREATE POLICY "Providers can read own reviews"
  ON provider_reviews FOR SELECT
  USING (provider_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

DROP POLICY IF EXISTS "Owners can create reviews" ON provider_reviews;
CREATE POLICY "Owners can create reviews"
  ON provider_reviews FOR INSERT
  WITH CHECK (reviewer_profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid() AND role = 'owner'));

-- =====================================================
-- 6. FONCTION RPC DASHBOARD PRESTATAIRE
-- =====================================================

CREATE OR REPLACE FUNCTION provider_dashboard(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile_id UUID;
  v_result JSONB;
  v_stats JSONB;
  v_pending_orders JSONB;
  v_recent_reviews JSONB;
  v_provider_info JSONB;
BEGIN
  -- Récupérer le profil prestataire
  SELECT id INTO v_profile_id
  FROM profiles
  WHERE user_id = p_user_id AND role = 'provider';
  
  IF v_profile_id IS NULL THEN
    -- Retourner un objet vide si pas de profil prestataire
    RETURN jsonb_build_object(
      'error', 'Profil prestataire non trouvé',
      'profile_id', NULL
    );
  END IF;
  
  -- Informations du profil prestataire
  SELECT jsonb_build_object(
    'status', COALESCE(pp.status, 'pending'),
    'kyc_status', COALESCE(pp.kyc_status, 'incomplete'),
    'compliance_score', COALESCE(pp.compliance_score, 0),
    'type_services', COALESCE(pp.type_services, ARRAY[]::TEXT[]),
    'raison_sociale', pp.raison_sociale
  ) INTO v_provider_info
  FROM provider_profiles pp
  WHERE pp.profile_id = v_profile_id;
  
  -- Statistiques des work_orders
  SELECT jsonb_build_object(
    'total_interventions', COUNT(*),
    'completed_interventions', COUNT(*) FILTER (WHERE statut = 'done'),
    'pending_interventions', COUNT(*) FILTER (WHERE statut IN ('assigned', 'scheduled')),
    'in_progress_interventions', COUNT(*) FILTER (WHERE statut = 'in_progress'),
    'total_revenue', COALESCE(SUM(cout_final) FILTER (WHERE statut = 'done'), 0),
    'avg_rating', (
      SELECT ROUND(AVG(rating_overall)::NUMERIC, 1)
      FROM provider_reviews
      WHERE provider_profile_id = v_profile_id AND is_published = true
    ),
    'total_reviews', (
      SELECT COUNT(*) FROM provider_reviews
      WHERE provider_profile_id = v_profile_id AND is_published = true
    )
  ) INTO v_stats
  FROM work_orders
  WHERE provider_id = v_profile_id;
  
  -- Si pas de stats, créer des valeurs par défaut
  IF v_stats IS NULL THEN
    v_stats := jsonb_build_object(
      'total_interventions', 0,
      'completed_interventions', 0,
      'pending_interventions', 0,
      'in_progress_interventions', 0,
      'total_revenue', 0,
      'avg_rating', NULL,
      'total_reviews', 0
    );
  END IF;
  
  -- Interventions en attente
  SELECT COALESCE(jsonb_agg(order_data ORDER BY order_data->>'created_at' DESC), '[]'::jsonb)
  INTO v_pending_orders
  FROM (
    SELECT jsonb_build_object(
      'id', wo.id,
      'ticket_id', wo.ticket_id,
      'statut', wo.statut,
      'cout_estime', wo.cout_estime,
      'date_intervention_prevue', wo.date_intervention_prevue,
      'created_at', wo.created_at,
      'ticket', CASE WHEN t.id IS NOT NULL THEN jsonb_build_object(
        'titre', t.titre,
        'priorite', t.priorite
      ) ELSE NULL END,
      'property', CASE WHEN p.id IS NOT NULL THEN jsonb_build_object(
        'adresse', p.adresse_complete,
        'ville', p.ville
      ) ELSE NULL END
    ) as order_data
    FROM work_orders wo
    LEFT JOIN tickets t ON t.id = wo.ticket_id
    LEFT JOIN properties p ON p.id = t.property_id
    WHERE wo.provider_id = v_profile_id
    AND wo.statut IN ('assigned', 'scheduled', 'in_progress')
    ORDER BY wo.created_at DESC
    LIMIT 10
  ) sub;
  
  -- Avis récents
  SELECT COALESCE(jsonb_agg(review_data ORDER BY review_data->>'created_at' DESC), '[]'::jsonb)
  INTO v_recent_reviews
  FROM (
    SELECT jsonb_build_object(
      'id', pr.id,
      'rating_overall', pr.rating_overall,
      'comment', pr.comment,
      'created_at', pr.created_at,
      'reviewer', jsonb_build_object(
        'prenom', COALESCE(prof.prenom, 'Utilisateur'),
        'nom', CASE WHEN prof.nom IS NOT NULL THEN LEFT(prof.nom, 1) || '.' ELSE '' END
      )
    ) as review_data
    FROM provider_reviews pr
    LEFT JOIN profiles prof ON prof.id = pr.reviewer_profile_id
    WHERE pr.provider_profile_id = v_profile_id
    AND pr.is_published = true
    ORDER BY pr.created_at DESC
    LIMIT 5
  ) sub;
  
  -- Construire le résultat final
  v_result := jsonb_build_object(
    'profile_id', v_profile_id,
    'provider', COALESCE(v_provider_info, jsonb_build_object('status', 'pending', 'kyc_status', 'incomplete', 'compliance_score', 0)),
    'stats', v_stats,
    'pending_orders', COALESCE(v_pending_orders, '[]'::jsonb),
    'recent_reviews', COALESCE(v_recent_reviews, '[]'::jsonb)
  );
  
  RETURN v_result;
END;
$$;

-- =====================================================
-- 7. FONCTIONS UTILITAIRES
-- =====================================================

-- Génération numéro de devis
CREATE OR REPLACE FUNCTION generate_quote_reference(p_provider_id UUID)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  v_year INTEGER;
  v_count INTEGER;
BEGIN
  v_year := EXTRACT(YEAR FROM CURRENT_DATE);
  
  SELECT COUNT(*) + 1 INTO v_count
  FROM provider_quotes
  WHERE provider_profile_id = p_provider_id
  AND EXTRACT(YEAR FROM created_at) = v_year;
  
  RETURN 'DEV-' || v_year || '-' || LPAD(v_count::TEXT, 4, '0');
END;
$$;

-- Génération numéro de facture
CREATE OR REPLACE FUNCTION generate_invoice_reference(p_provider_id UUID)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  v_year INTEGER;
  v_count INTEGER;
BEGIN
  v_year := EXTRACT(YEAR FROM CURRENT_DATE);
  
  SELECT COUNT(*) + 1 INTO v_count
  FROM provider_invoices
  WHERE provider_profile_id = p_provider_id
  AND EXTRACT(YEAR FROM created_at) = v_year;
  
  RETURN 'FAC-' || v_year || '-' || LPAD(v_count::TEXT, 4, '0');
END;
$$;

-- Trigger pour générer automatiquement la référence des devis
CREATE OR REPLACE FUNCTION trigger_generate_quote_reference()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.reference IS NULL THEN
    NEW.reference := generate_quote_reference(NEW.provider_profile_id);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generate_quote_reference ON provider_quotes;
CREATE TRIGGER trg_generate_quote_reference
  BEFORE INSERT ON provider_quotes
  FOR EACH ROW EXECUTE FUNCTION trigger_generate_quote_reference();

-- Trigger pour générer automatiquement la référence des factures
CREATE OR REPLACE FUNCTION trigger_generate_invoice_reference()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.reference IS NULL THEN
    NEW.reference := generate_invoice_reference(NEW.provider_profile_id);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generate_invoice_reference ON provider_invoices;
CREATE TRIGGER trg_generate_invoice_reference
  BEFORE INSERT ON provider_invoices
  FOR EACH ROW EXECUTE FUNCTION trigger_generate_invoice_reference();

-- =====================================================
-- 8. TRIGGER: Calcul automatique des totaux de devis
-- =====================================================

CREATE OR REPLACE FUNCTION calculate_quote_totals()
RETURNS TRIGGER AS $$
DECLARE
  v_subtotal DECIMAL(10,2);
  v_tax_amount DECIMAL(10,2);
  v_quote_id UUID;
BEGIN
  v_quote_id := COALESCE(NEW.quote_id, OLD.quote_id);
  
  SELECT 
    COALESCE(SUM(quantity * unit_price), 0),
    COALESCE(SUM(quantity * unit_price * tax_rate / 100), 0)
  INTO v_subtotal, v_tax_amount
  FROM provider_quote_items
  WHERE quote_id = v_quote_id;
  
  UPDATE provider_quotes
  SET 
    subtotal = v_subtotal,
    tax_amount = v_tax_amount,
    total_amount = v_subtotal + v_tax_amount,
    updated_at = NOW()
  WHERE id = v_quote_id;
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_calculate_quote_totals ON provider_quote_items;
CREATE TRIGGER trg_calculate_quote_totals
  AFTER INSERT OR UPDATE OR DELETE ON provider_quote_items
  FOR EACH ROW EXECUTE FUNCTION calculate_quote_totals();

-- =====================================================
-- 9. ASSURER QUE work_orders A provider_id
-- =====================================================

DO $$
BEGIN
  -- Vérifier si la colonne provider_id existe dans work_orders
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'work_orders' AND column_name = 'provider_id'
  ) THEN
    ALTER TABLE work_orders ADD COLUMN provider_id UUID REFERENCES profiles(id);
    CREATE INDEX IF NOT EXISTS idx_work_orders_provider ON work_orders(provider_id);
  END IF;
END $$;

-- =====================================================
-- 10. COMMENTAIRES
-- =====================================================

COMMENT ON TABLE notifications IS 'Notifications utilisateurs centralisées';
COMMENT ON TABLE provider_quotes IS 'Devis des prestataires';
COMMENT ON TABLE provider_quote_items IS 'Lignes de devis prestataires';
COMMENT ON TABLE provider_invoices IS 'Factures des prestataires';
COMMENT ON TABLE provider_reviews IS 'Avis clients sur les prestataires';
COMMENT ON FUNCTION provider_dashboard IS 'Dashboard principal du prestataire avec stats et interventions';
COMMENT ON FUNCTION get_recent_notifications IS 'Récupère les notifications récentes d''un profil';
COMMENT ON FUNCTION get_unread_notification_count IS 'Compte les notifications non lues';

-- =====================================================
-- FIN DE LA MIGRATION
-- =====================================================
SELECT 'Migration tables/fonctions manquantes appliquée avec succès!' as result;



-- ========== 20251206800000_assistant_ai_tables.sql ==========
-- ============================================
-- Migration: Tables pour l'Assistant IA
-- SOTA Décembre 2025 - GPT-5.1 + LangGraph
-- ============================================

-- ============================================
-- TABLE: assistant_threads
-- Stocke les conversations avec l'assistant
-- ============================================

CREATE TABLE IF NOT EXISTS assistant_threads (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  title TEXT DEFAULT 'Nouvelle conversation',
  last_message TEXT,
  message_count INTEGER DEFAULT 0,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index pour la performance
CREATE INDEX IF NOT EXISTS idx_assistant_threads_profile_id ON assistant_threads(profile_id);
CREATE INDEX IF NOT EXISTS idx_assistant_threads_user_id ON assistant_threads(user_id);
CREATE INDEX IF NOT EXISTS idx_assistant_threads_updated_at ON assistant_threads(updated_at DESC);

-- ============================================
-- TABLE: assistant_messages
-- Stocke les messages des conversations
-- ============================================

CREATE TABLE IF NOT EXISTS assistant_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  thread_id UUID NOT NULL REFERENCES assistant_threads(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system', 'tool')),
  content TEXT NOT NULL,
  tools_used TEXT[] DEFAULT '{}',
  tool_results JSONB,
  tokens_used INTEGER,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index pour la performance
CREATE INDEX IF NOT EXISTS idx_assistant_messages_thread_id ON assistant_messages(thread_id);
CREATE INDEX IF NOT EXISTS idx_assistant_messages_created_at ON assistant_messages(created_at);

-- ============================================
-- FUNCTION: increment_message_count
-- Incrémente le compteur de messages d'un thread
-- ============================================

CREATE OR REPLACE FUNCTION increment_message_count(thread_id_param UUID)
RETURNS INTEGER AS $$
DECLARE
  new_count INTEGER;
BEGIN
  UPDATE assistant_threads 
  SET message_count = message_count + 1
  WHERE id = thread_id_param
  RETURNING message_count INTO new_count;
  
  RETURN new_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- TRIGGER: update_thread_updated_at
-- Met à jour updated_at quand un message est ajouté
-- ============================================

CREATE OR REPLACE FUNCTION update_thread_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE assistant_threads 
  SET updated_at = NOW(),
      message_count = message_count + 1
  WHERE id = NEW.thread_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_update_thread_on_message ON assistant_messages;
CREATE TRIGGER trigger_update_thread_on_message
AFTER INSERT ON assistant_messages
FOR EACH ROW
EXECUTE FUNCTION update_thread_timestamp();

-- ============================================
-- RLS: Row Level Security
-- ============================================

-- Enable RLS
ALTER TABLE assistant_threads ENABLE ROW LEVEL SECURITY;
ALTER TABLE assistant_messages ENABLE ROW LEVEL SECURITY;

-- Policies pour assistant_threads
DROP POLICY IF EXISTS "Users can view their own threads" ON assistant_threads;
CREATE POLICY "Users can view their own threads"
  ON assistant_threads FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can create their own threads" ON assistant_threads;
CREATE POLICY "Users can create their own threads"
  ON assistant_threads FOR INSERT
  WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own threads" ON assistant_threads;
CREATE POLICY "Users can update their own threads"
  ON assistant_threads FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete their own threads" ON assistant_threads;
CREATE POLICY "Users can delete their own threads"
  ON assistant_threads FOR DELETE
  USING (auth.uid() = user_id);

-- Policies pour assistant_messages
DROP POLICY IF EXISTS "Users can view messages in their threads" ON assistant_messages;
CREATE POLICY "Users can view messages in their threads"
  ON assistant_messages FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM assistant_threads 
      WHERE assistant_threads.id = assistant_messages.thread_id 
      AND assistant_threads.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Users can create messages in their threads" ON assistant_messages;
CREATE POLICY "Users can create messages in their threads"
  ON assistant_messages FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM assistant_threads 
      WHERE assistant_threads.id = thread_id 
      AND assistant_threads.user_id = auth.uid()
    )
  );

-- ============================================
-- TABLE: assistant_usage_stats (optionnel)
-- Pour le suivi des coûts et de l'utilisation
-- ============================================

CREATE TABLE IF NOT EXISTS assistant_usage_stats (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  date DATE NOT NULL DEFAULT CURRENT_DATE,
  messages_sent INTEGER DEFAULT 0,
  tokens_used INTEGER DEFAULT 0,
  tools_called INTEGER DEFAULT 0,
  estimated_cost_cents INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(profile_id, date)
);

CREATE INDEX IF NOT EXISTS idx_assistant_usage_stats_profile_date 
  ON assistant_usage_stats(profile_id, date);

-- Policy pour assistant_usage_stats
ALTER TABLE assistant_usage_stats ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their own stats" ON assistant_usage_stats;
CREATE POLICY "Users can view their own stats"
  ON assistant_usage_stats FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE profiles.id = assistant_usage_stats.profile_id 
      AND profiles.user_id = auth.uid()
    )
  );

-- ============================================
-- COMMENTS
-- ============================================

COMMENT ON TABLE assistant_threads IS 'Conversations avec l''assistant IA LangGraph';
COMMENT ON TABLE assistant_messages IS 'Messages des conversations assistant';
COMMENT ON TABLE assistant_usage_stats IS 'Statistiques d''utilisation pour le suivi des coûts';

COMMENT ON COLUMN assistant_threads.metadata IS 'Données additionnelles (contexte, préférences)';
COMMENT ON COLUMN assistant_messages.tools_used IS 'Liste des tools appelés pendant la génération';
COMMENT ON COLUMN assistant_messages.tool_results IS 'Résultats des tools pour debugging';



-- ========== 20251207000000_colocation_advanced.sql ==========
-- ============================================
-- Migration: Colocation Avancée - SOTA 2025
-- Gestion complète des colocations avec recalcul des parts
-- ============================================

-- ============================================
-- 1. CONFIGURATION COLOCATION SUR LE BAIL
-- ============================================

-- Ajouter la configuration colocation au bail
ALTER TABLE leases ADD COLUMN IF NOT EXISTS coloc_config JSONB DEFAULT NULL;
-- Structure: {
--   nb_places: number,
--   bail_type: 'unique' | 'individuel',
--   solidarite: boolean,
--   solidarite_duration_months: number (max 6),
--   split_mode: 'equal' | 'custom' | 'by_room',
--   solidarite_end_date: date
-- }

COMMENT ON COLUMN leases.coloc_config IS 'Configuration colocation: nb_places, type bail, solidarité, mode de split';

-- ============================================
-- 2. TABLE: DEPOSIT_SHARES (Parts de dépôt de garantie)
-- ============================================

CREATE TABLE IF NOT EXISTS deposit_shares (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
  roommate_id UUID NOT NULL REFERENCES roommates(id) ON DELETE CASCADE,
  
  -- Montants
  amount NUMERIC(10,2) NOT NULL CHECK (amount >= 0),
  amount_paid NUMERIC(10,2) NOT NULL DEFAULT 0 CHECK (amount_paid >= 0),
  
  -- Statut
  status TEXT NOT NULL DEFAULT 'pending' 
    CHECK (status IN ('pending', 'partial', 'paid', 'refund_pending', 'refunded', 'retained')),
  
  -- Restitution
  refund_amount NUMERIC(10,2) DEFAULT NULL,
  retention_amount NUMERIC(10,2) DEFAULT NULL,
  retention_reason TEXT,
  refunded_at TIMESTAMPTZ,
  
  -- Dates
  paid_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(lease_id, roommate_id)
);

CREATE INDEX idx_deposit_shares_lease_id ON deposit_shares(lease_id);
CREATE INDEX idx_deposit_shares_roommate_id ON deposit_shares(roommate_id);
CREATE INDEX idx_deposit_shares_status ON deposit_shares(status);

COMMENT ON TABLE deposit_shares IS 'Parts de dépôt de garantie par colocataire';

-- ============================================
-- 3. TABLE: PAYMENT_ADJUSTMENTS (Ajustements de paiement)
-- ============================================

CREATE TABLE IF NOT EXISTS payment_adjustments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
  month DATE NOT NULL, -- Premier jour du mois (YYYY-MM-01)
  roommate_id UUID NOT NULL REFERENCES roommates(id) ON DELETE CASCADE,
  
  -- Montants
  original_amount NUMERIC(10,2) NOT NULL,
  adjusted_amount NUMERIC(10,2) NOT NULL,
  difference NUMERIC(10,2) GENERATED ALWAYS AS (adjusted_amount - original_amount) STORED,
  
  -- Raison du changement
  reason TEXT NOT NULL CHECK (reason IN (
    'new_roommate',      -- Nouveau colocataire arrivé
    'roommate_left',     -- Colocataire parti
    'weight_change',     -- Changement de répartition
    'rent_revision',     -- Révision du loyer
    'prorata_entry',     -- Prorata entrée en cours de mois
    'prorata_exit',      -- Prorata sortie en cours de mois
    'manual'             -- Ajustement manuel
  )),
  triggered_by_roommate_id UUID REFERENCES roommates(id), -- Qui a causé le changement
  
  -- Traitement du crédit/débit
  credit_type TEXT CHECK (credit_type IN (
    'next_month',    -- Reporté sur le mois suivant
    'refund',        -- Remboursement
    'redistribute',  -- Redistribué aux autres
    'pending'        -- En attente de décision
  )),
  credit_applied BOOLEAN DEFAULT false,
  credit_applied_to_month DATE,
  
  -- Notes
  notes TEXT,
  created_by UUID REFERENCES auth.users(id),
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_payment_adjustments_lease_id ON payment_adjustments(lease_id);
CREATE INDEX idx_payment_adjustments_month ON payment_adjustments(month);
CREATE INDEX idx_payment_adjustments_roommate_id ON payment_adjustments(roommate_id);
CREATE INDEX idx_payment_adjustments_reason ON payment_adjustments(reason);

COMMENT ON TABLE payment_adjustments IS 'Historique des ajustements de parts de paiement';

-- ============================================
-- 4. TABLE: PAYMENT_CREDITS (Crédits de paiement)
-- ============================================

CREATE TABLE IF NOT EXISTS payment_credits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  roommate_id UUID NOT NULL REFERENCES roommates(id) ON DELETE CASCADE,
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
  
  -- Montant (positif = crédit, négatif = débit)
  amount NUMERIC(10,2) NOT NULL,
  
  -- Origine
  reason TEXT NOT NULL,
  adjustment_id UUID REFERENCES payment_adjustments(id),
  source_month DATE, -- Mois d'où provient le crédit
  
  -- Utilisation
  status TEXT NOT NULL DEFAULT 'available' 
    CHECK (status IN ('available', 'applied', 'refunded', 'expired', 'cancelled')),
  applied_to_month DATE,
  applied_at TIMESTAMPTZ,
  refunded_at TIMESTAMPTZ,
  expires_at DATE, -- Date d'expiration du crédit
  
  -- Traçabilité
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_payment_credits_roommate_id ON payment_credits(roommate_id);
CREATE INDEX idx_payment_credits_lease_id ON payment_credits(lease_id);
CREATE INDEX idx_payment_credits_status ON payment_credits(status);

COMMENT ON TABLE payment_credits IS 'Crédits de paiement (trop-perçus, avoirs)';

-- ============================================
-- 5. TABLE: ROOMMATE_HISTORY (Historique des changements)
-- ============================================

CREATE TABLE IF NOT EXISTS roommate_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
  roommate_id UUID NOT NULL REFERENCES roommates(id) ON DELETE CASCADE,
  
  -- Type d'événement
  event_type TEXT NOT NULL CHECK (event_type IN (
    'joined',           -- Arrivée
    'left',             -- Départ
    'weight_changed',   -- Changement de part
    'role_changed',     -- Changement de rôle
    'guarantor_added',  -- Garant ajouté
    'guarantor_removed' -- Garant retiré
  )),
  
  -- Valeurs avant/après
  old_value JSONB,
  new_value JSONB,
  
  -- Contexte
  effective_date DATE NOT NULL,
  notes TEXT,
  created_by UUID REFERENCES auth.users(id),
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_roommate_history_lease_id ON roommate_history(lease_id);
CREATE INDEX idx_roommate_history_roommate_id ON roommate_history(roommate_id);
CREATE INDEX idx_roommate_history_event_type ON roommate_history(event_type);
CREATE INDEX idx_roommate_history_effective_date ON roommate_history(effective_date);

COMMENT ON TABLE roommate_history IS 'Historique complet des changements de colocataires (audit trail)';

-- ============================================
-- 6. AJOUTER CHAMPS MANQUANTS À ROOMMATES
-- ============================================

-- Lien vers la chambre (pour baux individuels ou répartition par chambre)
ALTER TABLE roommates ADD COLUMN IF NOT EXISTS room_id UUID REFERENCES rooms(id);

-- Garants multiples (JSON array de profile_ids)
ALTER TABLE roommates ADD COLUMN IF NOT EXISTS guarantor_ids UUID[] DEFAULT '{}';

-- Date effective pour le calcul des parts
ALTER TABLE roommates ADD COLUMN IF NOT EXISTS effective_from DATE;
ALTER TABLE roommates ADD COLUMN IF NOT EXISTS effective_until DATE;

-- Email d'invitation (avant création du compte)
ALTER TABLE roommates ADD COLUMN IF NOT EXISTS invited_email TEXT;
ALTER TABLE roommates ADD COLUMN IF NOT EXISTS invitation_sent_at TIMESTAMPTZ;
ALTER TABLE roommates ADD COLUMN IF NOT EXISTS invitation_status TEXT DEFAULT 'pending'
  CHECK (invitation_status IN ('pending', 'sent', 'accepted', 'declined', 'expired'));

COMMENT ON COLUMN roommates.room_id IS 'Chambre attribuée au colocataire';
COMMENT ON COLUMN roommates.guarantor_ids IS 'Liste des garants (profile_ids)';
COMMENT ON COLUMN roommates.invited_email IS 'Email utilisé pour l''invitation';

-- ============================================
-- 7. FONCTION: RECALCUL DES PARTS AVEC PRORATA
-- ============================================

CREATE OR REPLACE FUNCTION recalculate_payment_shares(
  p_lease_id UUID,
  p_month DATE,
  p_trigger_type TEXT DEFAULT 'manual',
  p_triggered_by UUID DEFAULT NULL,
  p_created_by UUID DEFAULT NULL
) RETURNS JSONB AS $$
DECLARE
  v_lease RECORD;
  v_total_rent NUMERIC;
  v_days_in_month INTEGER;
  v_roommate RECORD;
  v_old_share RECORD;
  v_new_amount NUMERIC;
  v_total_weight NUMERIC;
  v_prorata_days INTEGER;
  v_result JSONB := '{"adjustments": [], "created": [], "updated": []}'::JSONB;
BEGIN
  -- Récupérer le bail et le loyer total
  SELECT l.*, 
         COALESCE(l.loyer, 0) + COALESCE(l.charges_forfaitaires, 0) as total_rent
  INTO v_lease
  FROM leases l 
  WHERE l.id = p_lease_id;
  
  IF v_lease IS NULL THEN
    RAISE EXCEPTION 'Bail non trouvé: %', p_lease_id;
  END IF;
  
  v_total_rent := v_lease.total_rent;
  
  -- Nombre de jours dans le mois
  v_days_in_month := EXTRACT(DAY FROM (
    (p_month + INTERVAL '1 month')::DATE - INTERVAL '1 day'
  ))::INTEGER;
  
  -- Calculer le poids total des colocataires actifs ce mois
  SELECT COALESCE(SUM(
    r.weight * (
      LEAST(
        COALESCE(r.left_on, (p_month + INTERVAL '1 month')::DATE - INTERVAL '1 day'),
        (p_month + INTERVAL '1 month')::DATE - INTERVAL '1 day'
      ) - 
      GREATEST(r.joined_on, p_month) + 1
    )::NUMERIC / v_days_in_month
  ), 0)
  INTO v_total_weight
  FROM roommates r
  WHERE r.lease_id = p_lease_id
    AND r.joined_on <= ((p_month + INTERVAL '1 month')::DATE - INTERVAL '1 day')
    AND (r.left_on IS NULL OR r.left_on >= p_month)
    AND r.role IN ('principal', 'tenant');
  
  -- Si aucun colocataire, ne rien faire
  IF v_total_weight = 0 THEN
    RETURN v_result;
  END IF;
  
  -- Pour chaque colocataire actif pendant ce mois
  FOR v_roommate IN
    SELECT r.*,
           GREATEST(r.joined_on, p_month) as period_start,
           LEAST(
             COALESCE(r.left_on, (p_month + INTERVAL '1 month')::DATE - INTERVAL '1 day'),
             (p_month + INTERVAL '1 month')::DATE - INTERVAL '1 day'
           ) as period_end
    FROM roommates r
    WHERE r.lease_id = p_lease_id
      AND r.joined_on <= ((p_month + INTERVAL '1 month')::DATE - INTERVAL '1 day')
      AND (r.left_on IS NULL OR r.left_on >= p_month)
      AND r.role IN ('principal', 'tenant')
  LOOP
    -- Calculer le prorata de jours
    v_prorata_days := (v_roommate.period_end - v_roommate.period_start + 1)::INTEGER;
    
    -- Calculer le nouveau montant dû
    v_new_amount := ROUND(
      v_total_rent * v_roommate.weight * v_prorata_days::NUMERIC / v_days_in_month,
      2
    );
    
    -- Récupérer l'ancienne part si elle existe
    SELECT * INTO v_old_share
    FROM payment_shares
    WHERE lease_id = p_lease_id 
      AND month = p_month 
      AND roommate_id = v_roommate.id;
    
    -- Créer ou mettre à jour la part
    IF v_old_share IS NULL THEN
      -- Créer nouvelle part
      INSERT INTO payment_shares (lease_id, month, roommate_id, due_amount)
      VALUES (p_lease_id, p_month, v_roommate.id, v_new_amount);
      
      v_result := jsonb_set(
        v_result, 
        '{created}', 
        v_result->'created' || jsonb_build_object(
          'roommate_id', v_roommate.id,
          'amount', v_new_amount
        )
      );
    ELSE
      -- Mettre à jour si le montant a changé
      IF v_old_share.due_amount != v_new_amount THEN
        UPDATE payment_shares 
        SET due_amount = v_new_amount, updated_at = NOW()
        WHERE id = v_old_share.id;
        
        -- Créer un ajustement
        INSERT INTO payment_adjustments (
          lease_id, month, roommate_id,
          original_amount, adjusted_amount,
          reason, triggered_by_roommate_id, created_by,
          credit_type
        ) VALUES (
          p_lease_id, p_month, v_roommate.id,
          v_old_share.due_amount, v_new_amount,
          p_trigger_type, p_triggered_by, p_created_by,
          CASE 
            WHEN v_old_share.amount_paid > v_new_amount THEN 'pending'
            ELSE NULL
          END
        );
        
        -- Si trop payé, créer un crédit
        IF v_old_share.amount_paid > v_new_amount THEN
          INSERT INTO payment_credits (
            roommate_id, lease_id, amount, reason,
            source_month, created_by
          ) VALUES (
            v_roommate.id, p_lease_id, 
            v_old_share.amount_paid - v_new_amount,
            'Ajustement ' || p_trigger_type || ' - ' || to_char(p_month, 'MM/YYYY'),
            p_month, p_created_by
          );
        END IF;
        
        v_result := jsonb_set(
          v_result, 
          '{adjustments}', 
          v_result->'adjustments' || jsonb_build_object(
            'roommate_id', v_roommate.id,
            'old_amount', v_old_share.due_amount,
            'new_amount', v_new_amount,
            'difference', v_new_amount - v_old_share.due_amount
          )
        );
      END IF;
    END IF;
  END LOOP;
  
  RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION recalculate_payment_shares IS 'Recalcule les parts de paiement avec prorata temporis';

-- ============================================
-- 8. FONCTION: CALCULER LES PARTS POUR UN NOUVEAU MOIS
-- ============================================

CREATE OR REPLACE FUNCTION generate_monthly_shares(
  p_lease_id UUID,
  p_month DATE
) RETURNS JSONB AS $$
BEGIN
  RETURN recalculate_payment_shares(p_lease_id, p_month, 'manual', NULL, NULL);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 9. TRIGGER: HISTORIQUE DES CHANGEMENTS DE ROOMMATES
-- ============================================

CREATE OR REPLACE FUNCTION log_roommate_changes()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO roommate_history (
      lease_id, roommate_id, event_type, 
      new_value, effective_date
    ) VALUES (
      NEW.lease_id, NEW.id, 'joined',
      jsonb_build_object(
        'role', NEW.role,
        'weight', NEW.weight,
        'joined_on', NEW.joined_on
      ),
      NEW.joined_on
    );
  ELSIF TG_OP = 'UPDATE' THEN
    -- Départ
    IF OLD.left_on IS NULL AND NEW.left_on IS NOT NULL THEN
      INSERT INTO roommate_history (
        lease_id, roommate_id, event_type,
        old_value, new_value, effective_date
      ) VALUES (
        NEW.lease_id, NEW.id, 'left',
        jsonb_build_object('left_on', OLD.left_on),
        jsonb_build_object('left_on', NEW.left_on),
        NEW.left_on
      );
    END IF;
    
    -- Changement de poids
    IF OLD.weight != NEW.weight THEN
      INSERT INTO roommate_history (
        lease_id, roommate_id, event_type,
        old_value, new_value, effective_date
      ) VALUES (
        NEW.lease_id, NEW.id, 'weight_changed',
        jsonb_build_object('weight', OLD.weight),
        jsonb_build_object('weight', NEW.weight),
        CURRENT_DATE
      );
    END IF;
    
    -- Changement de rôle
    IF OLD.role != NEW.role THEN
      INSERT INTO roommate_history (
        lease_id, roommate_id, event_type,
        old_value, new_value, effective_date
      ) VALUES (
        NEW.lease_id, NEW.id, 'role_changed',
        jsonb_build_object('role', OLD.role),
        jsonb_build_object('role', NEW.role),
        CURRENT_DATE
      );
    END IF;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS roommate_history_trigger ON roommates;
CREATE TRIGGER roommate_history_trigger
  AFTER INSERT OR UPDATE ON roommates
  FOR EACH ROW
  EXECUTE FUNCTION log_roommate_changes();

-- ============================================
-- 10. ROW LEVEL SECURITY
-- ============================================

ALTER TABLE deposit_shares ENABLE ROW LEVEL SECURITY;
ALTER TABLE payment_adjustments ENABLE ROW LEVEL SECURITY;
ALTER TABLE payment_credits ENABLE ROW LEVEL SECURITY;
ALTER TABLE roommate_history ENABLE ROW LEVEL SECURITY;

-- Policies pour deposit_shares
CREATE POLICY "Owners can manage deposit shares"
  ON deposit_shares FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      JOIN profiles pr ON p.owner_id = pr.id
      WHERE l.id = deposit_shares.lease_id
        AND pr.user_id = auth.uid()
    )
  );

CREATE POLICY "Roommates can view their deposit share"
  ON deposit_shares FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM roommates r
      WHERE r.id = deposit_shares.roommate_id
        AND r.user_id = auth.uid()
    )
  );

-- Policies pour payment_adjustments
CREATE POLICY "Owners can manage payment adjustments"
  ON payment_adjustments FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      JOIN profiles pr ON p.owner_id = pr.id
      WHERE l.id = payment_adjustments.lease_id
        AND pr.user_id = auth.uid()
    )
  );

CREATE POLICY "Roommates can view their adjustments"
  ON payment_adjustments FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM roommates r
      WHERE r.id = payment_adjustments.roommate_id
        AND r.user_id = auth.uid()
    )
  );

-- Policies pour payment_credits
CREATE POLICY "Owners can manage payment credits"
  ON payment_credits FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      JOIN profiles pr ON p.owner_id = pr.id
      WHERE l.id = payment_credits.lease_id
        AND pr.user_id = auth.uid()
    )
  );

CREATE POLICY "Roommates can view their credits"
  ON payment_credits FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM roommates r
      WHERE r.id = payment_credits.roommate_id
        AND r.user_id = auth.uid()
    )
  );

-- Policies pour roommate_history
CREATE POLICY "Owners can view roommate history"
  ON roommate_history FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      JOIN profiles pr ON p.owner_id = pr.id
      WHERE l.id = roommate_history.lease_id
        AND pr.user_id = auth.uid()
    )
  );

CREATE POLICY "Roommates can view history of their lease"
  ON roommate_history FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM roommates r
      WHERE r.lease_id = roommate_history.lease_id
        AND r.user_id = auth.uid()
    )
  );

-- ============================================
-- 11. TRIGGERS UPDATED_AT
-- ============================================

CREATE TRIGGER update_deposit_shares_updated_at 
  BEFORE UPDATE ON deposit_shares 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_payment_credits_updated_at 
  BEFORE UPDATE ON payment_credits 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- FIN DE LA MIGRATION
-- ============================================

COMMENT ON SCHEMA public IS 'Migration colocation avancée appliquée - SOTA 2025';



-- ========== 20251207231451_add_visite_virtuelle_url.sql ==========
-- Migration : Ajout de la colonne visite_virtuelle_url pour les visites virtuelles (Matterport, Nodalview, etc.)
BEGIN;

ALTER TABLE properties
  ADD COLUMN IF NOT EXISTS visite_virtuelle_url TEXT;

COMMIT;



-- ========== 20251208000000_fix_all_roles_complete.sql ==========
-- ============================================
-- Migration : Correction complète de tous les rôles
-- Date: 2024-12-08
-- Corrige: guarantor, agency, syndic, copropriétaire
-- ============================================

BEGIN;

-- ============================================
-- 1. CORRIGER LA CONTRAINTE CHECK DES RÔLES
-- ============================================

-- Supprimer l'ancienne contrainte
ALTER TABLE profiles 
DROP CONSTRAINT IF EXISTS profiles_role_check;

-- Ajouter la nouvelle contrainte avec TOUS les rôles
ALTER TABLE profiles 
ADD CONSTRAINT profiles_role_check 
CHECK (role IN ('admin', 'owner', 'tenant', 'provider', 'agency', 'guarantor', 'syndic', 'coproprietaire'));

COMMENT ON CONSTRAINT profiles_role_check ON profiles IS 'Contrainte des rôles valides: admin, owner, tenant, provider, agency, guarantor, syndic, coproprietaire';

-- ============================================
-- 2. TABLE GUARANTOR_PROFILES
-- ============================================

CREATE TABLE IF NOT EXISTS guarantor_profiles (
  profile_id UUID PRIMARY KEY REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Informations personnelles
  situation_professionnelle TEXT CHECK (situation_professionnelle IN (
    'salarie_cdi', 'salarie_cdd', 'fonctionnaire', 'independant', 
    'retraite', 'sans_emploi', 'etudiant', 'autre'
  )),
  employeur TEXT,
  profession TEXT,
  revenus_mensuels_nets DECIMAL(10, 2),
  revenus_annuels DECIMAL(12, 2),
  
  -- Patrimoine
  proprietaire_residence BOOLEAN DEFAULT false,
  valeur_patrimoine_immobilier DECIMAL(12, 2),
  epargne_disponible DECIMAL(12, 2),
  
  -- Documents
  documents_verified BOOLEAN DEFAULT false,
  avis_imposition_url TEXT,
  justificatif_domicile_url TEXT,
  cni_url TEXT,
  
  -- Statut
  onboarding_completed BOOLEAN DEFAULT false,
  onboarding_step INTEGER DEFAULT 0,
  
  -- Métadonnées
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_guarantor_profiles_verified ON guarantor_profiles(documents_verified);
CREATE INDEX IF NOT EXISTS idx_guarantor_profiles_onboarding ON guarantor_profiles(onboarding_completed);

COMMENT ON TABLE guarantor_profiles IS 'Profils des garants avec informations financières';

-- ============================================
-- 3. TABLE DES ENGAGEMENTS DE GARANTIE
-- ============================================

CREATE TABLE IF NOT EXISTS guarantor_engagements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  guarantor_profile_id UUID NOT NULL REFERENCES guarantor_profiles(profile_id) ON DELETE CASCADE,
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
  tenant_profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  
  -- Détails de l'engagement
  type_garantie TEXT NOT NULL DEFAULT 'caution_simple' 
    CHECK (type_garantie IN ('caution_simple', 'caution_solidaire')),
  montant_max_garanti DECIMAL(10, 2), -- Montant max couvert (null = illimité)
  duree_engagement TEXT CHECK (duree_engagement IN ('duree_bail', 'illimitee', 'limitee')),
  date_fin_engagement DATE, -- Si durée limitée
  
  -- Statut
  statut TEXT NOT NULL DEFAULT 'pending' 
    CHECK (statut IN ('pending', 'active', 'expired', 'invoked', 'terminated')),
  date_signature DATE,
  document_engagement_url TEXT,
  
  -- Historique d'invocation
  date_derniere_invocation DATE,
  montant_total_invoque DECIMAL(10, 2) DEFAULT 0,
  
  -- Métadonnées
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(guarantor_profile_id, lease_id, tenant_profile_id)
);

CREATE INDEX IF NOT EXISTS idx_guarantor_engagements_guarantor ON guarantor_engagements(guarantor_profile_id);
CREATE INDEX IF NOT EXISTS idx_guarantor_engagements_lease ON guarantor_engagements(lease_id);
CREATE INDEX IF NOT EXISTS idx_guarantor_engagements_tenant ON guarantor_engagements(tenant_profile_id);
CREATE INDEX IF NOT EXISTS idx_guarantor_engagements_statut ON guarantor_engagements(statut);

COMMENT ON TABLE guarantor_engagements IS 'Engagements de caution des garants pour les baux';

-- ============================================
-- 4. TABLES SYNDIC/COPRO (si non existantes)
-- ============================================

-- Table des sites de copropriété
CREATE TABLE IF NOT EXISTS sites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  type TEXT DEFAULT 'copropriete' CHECK (type IN ('copropriete', 'lotissement', 'residence_mixte', 'asl', 'aful')),
  
  -- Adresse
  address_line1 TEXT NOT NULL,
  address_line2 TEXT,
  postal_code TEXT NOT NULL,
  city TEXT NOT NULL,
  country TEXT DEFAULT 'FR',
  
  -- Informations légales
  siret TEXT,
  numero_immatriculation TEXT,
  date_reglement DATE,
  
  -- Configuration
  fiscal_year_start_month INTEGER DEFAULT 1 CHECK (fiscal_year_start_month BETWEEN 1 AND 12),
  total_tantiemes_general INTEGER DEFAULT 10000,
  
  -- Syndic
  syndic_type TEXT DEFAULT 'professionnel' CHECK (syndic_type IN ('professionnel', 'benevole', 'cooperatif')),
  syndic_profile_id UUID REFERENCES profiles(id),
  syndic_company_name TEXT,
  syndic_siret TEXT,
  syndic_address TEXT,
  syndic_email TEXT,
  syndic_phone TEXT,
  
  -- Statut
  is_active BOOLEAN DEFAULT true,
  
  -- Métadonnées
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_sites_syndic ON sites(syndic_profile_id);
CREATE INDEX IF NOT EXISTS idx_sites_active ON sites(is_active);

COMMENT ON TABLE sites IS 'Sites de copropriété gérés';

-- Table des bâtiments
CREATE TABLE IF NOT EXISTS buildings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  site_id UUID NOT NULL REFERENCES sites(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  code TEXT, -- Code interne (ex: A, B, Entrée 1)
  floors_count INTEGER,
  has_elevator BOOLEAN DEFAULT false,
  construction_year INTEGER,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_buildings_site ON buildings(site_id);

COMMENT ON TABLE buildings IS 'Bâtiments d''une copropriété';

-- Table des lots (unités de copropriété)
CREATE TABLE IF NOT EXISTS copro_units (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  site_id UUID NOT NULL REFERENCES sites(id) ON DELETE CASCADE,
  building_id UUID REFERENCES buildings(id) ON DELETE SET NULL,
  
  -- Identification
  lot_number TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('appartement', 'parking', 'cave', 'box', 'local_commercial', 'bureau', 'autre')),
  description TEXT,
  floor INTEGER,
  surface DECIMAL(8, 2),
  
  -- Propriétaire
  owner_profile_id UUID REFERENCES profiles(id),
  
  -- Tantièmes
  tantieme_general INTEGER NOT NULL DEFAULT 0,
  tantiemes_speciaux JSONB DEFAULT '{}', -- {"ascenseur": 100, "chauffage": 150}
  
  -- Lien avec le module locatif
  property_id UUID REFERENCES properties(id), -- Si le lot est aussi un bien locatif
  
  -- Statut
  is_active BOOLEAN DEFAULT true,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(site_id, lot_number)
);

CREATE INDEX IF NOT EXISTS idx_copro_units_site ON copro_units(site_id);
CREATE INDEX IF NOT EXISTS idx_copro_units_building ON copro_units(building_id);
CREATE INDEX IF NOT EXISTS idx_copro_units_owner ON copro_units(owner_profile_id);
CREATE INDEX IF NOT EXISTS idx_copro_units_property ON copro_units(property_id);

COMMENT ON TABLE copro_units IS 'Lots (unités) de copropriété';

-- Table des rôles utilisateurs sur les sites
CREATE TABLE IF NOT EXISTS user_site_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  site_id UUID NOT NULL REFERENCES sites(id) ON DELETE CASCADE,
  role_code TEXT NOT NULL CHECK (role_code IN ('syndic', 'conseil_syndical', 'coproprietaire', 'coproprietaire_bailleur', 'locataire_copro')),
  
  -- Si copropriétaire, lier aux lots
  unit_ids UUID[] DEFAULT '{}',
  
  granted_by UUID REFERENCES auth.users(id),
  granted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(user_id, site_id, role_code)
);

CREATE INDEX IF NOT EXISTS idx_user_site_roles_user ON user_site_roles(user_id);
CREATE INDEX IF NOT EXISTS idx_user_site_roles_site ON user_site_roles(site_id);
CREATE INDEX IF NOT EXISTS idx_user_site_roles_role ON user_site_roles(role_code);

COMMENT ON TABLE user_site_roles IS 'Rôles des utilisateurs sur les sites de copropriété';

-- ============================================
-- 5. RLS POLICIES POUR GUARANTOR
-- ============================================

ALTER TABLE guarantor_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE guarantor_engagements ENABLE ROW LEVEL SECURITY;

-- Guarantor profiles - voir son propre profil
CREATE POLICY "guarantor_profiles_select_own" ON guarantor_profiles
  FOR SELECT USING (
    profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    OR EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- Guarantor profiles - créer son propre profil
CREATE POLICY "guarantor_profiles_insert_own" ON guarantor_profiles
  FOR INSERT WITH CHECK (
    profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Guarantor profiles - modifier son propre profil
CREATE POLICY "guarantor_profiles_update_own" ON guarantor_profiles
  FOR UPDATE USING (
    profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Admin peut tout voir et modifier
CREATE POLICY "guarantor_profiles_admin_all" ON guarantor_profiles
  FOR ALL USING (
    EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- Engagements - le garant voit ses engagements
CREATE POLICY "guarantor_engagements_select_guarantor" ON guarantor_engagements
  FOR SELECT USING (
    guarantor_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Engagements - le propriétaire voit les engagements de ses baux
CREATE POLICY "guarantor_engagements_select_owner" ON guarantor_engagements
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = lease_id
      AND p.owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- Engagements - le locataire voit les engagements le concernant
CREATE POLICY "guarantor_engagements_select_tenant" ON guarantor_engagements
  FOR SELECT USING (
    tenant_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Engagements - admin peut tout voir
CREATE POLICY "guarantor_engagements_admin_all" ON guarantor_engagements
  FOR ALL USING (
    EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- ============================================
-- 6. RLS POLICIES POUR SYNDIC/COPRO
-- ============================================

ALTER TABLE sites ENABLE ROW LEVEL SECURITY;
ALTER TABLE buildings ENABLE ROW LEVEL SECURITY;
ALTER TABLE copro_units ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_site_roles ENABLE ROW LEVEL SECURITY;

-- Sites - le syndic peut tout faire sur ses sites
CREATE POLICY "sites_syndic_all" ON sites
  FOR ALL USING (
    syndic_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Sites - les copropriétaires peuvent voir leurs sites
CREATE POLICY "sites_coproprietaire_select" ON sites
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM user_site_roles usr
      WHERE usr.site_id = sites.id
      AND usr.user_id = auth.uid()
    )
  );

-- Sites - admin peut tout voir
CREATE POLICY "sites_admin_all" ON sites
  FOR ALL USING (
    EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- Buildings - accessible via le site
CREATE POLICY "buildings_via_site" ON buildings
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM sites s
      WHERE s.id = site_id
      AND (
        s.syndic_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
        OR EXISTS (SELECT 1 FROM user_site_roles usr WHERE usr.site_id = s.id AND usr.user_id = auth.uid())
      )
    )
  );

-- Buildings - syndic peut modifier
CREATE POLICY "buildings_syndic_manage" ON buildings
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM sites s
      WHERE s.id = site_id
      AND s.syndic_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- Copro_units - accessible via le site
CREATE POLICY "copro_units_via_site" ON copro_units
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM sites s
      WHERE s.id = site_id
      AND (
        s.syndic_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
        OR EXISTS (SELECT 1 FROM user_site_roles usr WHERE usr.site_id = s.id AND usr.user_id = auth.uid())
      )
    )
    OR owner_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Copro_units - syndic peut modifier
CREATE POLICY "copro_units_syndic_manage" ON copro_units
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM sites s
      WHERE s.id = site_id
      AND s.syndic_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- User_site_roles - visible par l'utilisateur concerné ou le syndic
CREATE POLICY "user_site_roles_select" ON user_site_roles
  FOR SELECT USING (
    user_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM sites s
      WHERE s.id = site_id
      AND s.syndic_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- User_site_roles - syndic peut gérer
CREATE POLICY "user_site_roles_syndic_manage" ON user_site_roles
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM sites s
      WHERE s.id = site_id
      AND s.syndic_profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- ============================================
-- 7. FONCTION RPC GUARANTOR_DASHBOARD
-- ============================================

CREATE OR REPLACE FUNCTION guarantor_dashboard(p_guarantor_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile_id UUID;
  v_guarantor_profile RECORD;
  v_engagements JSONB;
  v_stats JSONB;
BEGIN
  -- Récupérer le profile_id
  SELECT id INTO v_profile_id
  FROM profiles
  WHERE user_id = p_guarantor_user_id;
  
  IF v_profile_id IS NULL THEN
    RETURN jsonb_build_object('error', 'Profile not found');
  END IF;
  
  -- Récupérer le profil garant
  SELECT * INTO v_guarantor_profile
  FROM guarantor_profiles
  WHERE profile_id = v_profile_id;
  
  IF v_guarantor_profile IS NULL THEN
    RETURN jsonb_build_object(
      'has_profile', false,
      'onboarding_required', true
    );
  END IF;
  
  -- Récupérer les engagements
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', ge.id,
      'lease_id', ge.lease_id,
      'tenant_name', COALESCE(tp.prenom || ' ' || tp.nom, 'Inconnu'),
      'property_address', COALESCE(pr.adresse_complete, 'Adresse inconnue'),
      'type_garantie', ge.type_garantie,
      'statut', ge.statut,
      'montant_max_garanti', ge.montant_max_garanti,
      'loyer', l.loyer,
      'date_signature', ge.date_signature
    )
  ), '[]'::jsonb)
  INTO v_engagements
  FROM guarantor_engagements ge
  JOIN leases l ON l.id = ge.lease_id
  JOIN profiles tp ON tp.id = ge.tenant_profile_id
  LEFT JOIN properties pr ON pr.id = l.property_id
  WHERE ge.guarantor_profile_id = v_profile_id;
  
  -- Calculer les stats
  SELECT jsonb_build_object(
    'total_engagements', COUNT(*),
    'engagements_actifs', COUNT(*) FILTER (WHERE statut = 'active'),
    'engagements_en_attente', COUNT(*) FILTER (WHERE statut = 'pending'),
    'montant_total_garanti', COALESCE(SUM(l.loyer) FILTER (WHERE ge.statut = 'active'), 0)
  )
  INTO v_stats
  FROM guarantor_engagements ge
  JOIN leases l ON l.id = ge.lease_id
  WHERE ge.guarantor_profile_id = v_profile_id;
  
  RETURN jsonb_build_object(
    'has_profile', true,
    'onboarding_completed', v_guarantor_profile.onboarding_completed,
    'documents_verified', v_guarantor_profile.documents_verified,
    'profile', jsonb_build_object(
      'situation_professionnelle', v_guarantor_profile.situation_professionnelle,
      'profession', v_guarantor_profile.profession,
      'revenus_mensuels_nets', v_guarantor_profile.revenus_mensuels_nets
    ),
    'engagements', v_engagements,
    'stats', v_stats
  );
END;
$$;

COMMENT ON FUNCTION guarantor_dashboard IS 'Retourne les données du dashboard garant';

-- ============================================
-- 8. FONCTION RPC SYNDIC_DASHBOARD
-- ============================================

CREATE OR REPLACE FUNCTION syndic_dashboard(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile_id UUID;
  v_sites JSONB;
  v_stats JSONB;
BEGIN
  -- Récupérer le profile_id
  SELECT id INTO v_profile_id
  FROM profiles
  WHERE user_id = p_user_id;
  
  IF v_profile_id IS NULL THEN
    RETURN jsonb_build_object('error', 'Profile not found');
  END IF;
  
  -- Récupérer les sites gérés
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'id', s.id,
      'name', s.name,
      'type', s.type,
      'address', s.address_line1 || ', ' || s.postal_code || ' ' || s.city,
      'total_tantiemes', s.total_tantiemes_general,
      'buildings_count', (SELECT COUNT(*) FROM buildings b WHERE b.site_id = s.id),
      'units_count', (SELECT COUNT(*) FROM copro_units cu WHERE cu.site_id = s.id)
    )
  ), '[]'::jsonb)
  INTO v_sites
  FROM sites s
  WHERE s.syndic_profile_id = v_profile_id
  AND s.is_active = true;
  
  -- Calculer les stats globales
  SELECT jsonb_build_object(
    'total_sites', COUNT(*),
    'total_buildings', (SELECT COUNT(*) FROM buildings b JOIN sites s2 ON b.site_id = s2.id WHERE s2.syndic_profile_id = v_profile_id),
    'total_units', (SELECT COUNT(*) FROM copro_units cu JOIN sites s3 ON cu.site_id = s3.id WHERE s3.syndic_profile_id = v_profile_id),
    'total_coproprietaires', (
      SELECT COUNT(DISTINCT usr.user_id) 
      FROM user_site_roles usr 
      JOIN sites s4 ON usr.site_id = s4.id 
      WHERE s4.syndic_profile_id = v_profile_id
      AND usr.role_code IN ('coproprietaire', 'coproprietaire_bailleur')
    )
  )
  INTO v_stats
  FROM sites s
  WHERE s.syndic_profile_id = v_profile_id
  AND s.is_active = true;
  
  RETURN jsonb_build_object(
    'profile_id', v_profile_id,
    'sites', v_sites,
    'stats', v_stats
  );
END;
$$;

COMMENT ON FUNCTION syndic_dashboard IS 'Retourne les données du dashboard syndic';

-- ============================================
-- 9. TRIGGERS UPDATED_AT
-- ============================================

-- Trigger générique
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_guarantor_profiles_updated_at ON guarantor_profiles;
CREATE TRIGGER update_guarantor_profiles_updated_at
  BEFORE UPDATE ON guarantor_profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_guarantor_engagements_updated_at ON guarantor_engagements;
CREATE TRIGGER update_guarantor_engagements_updated_at
  BEFORE UPDATE ON guarantor_engagements
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_sites_updated_at ON sites;
CREATE TRIGGER update_sites_updated_at
  BEFORE UPDATE ON sites
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_buildings_updated_at ON buildings;
CREATE TRIGGER update_buildings_updated_at
  BEFORE UPDATE ON buildings
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_copro_units_updated_at ON copro_units;
CREATE TRIGGER update_copro_units_updated_at
  BEFORE UPDATE ON copro_units
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- 10. GRANTS
-- ============================================

GRANT SELECT, INSERT, UPDATE ON guarantor_profiles TO authenticated;
GRANT SELECT, INSERT, UPDATE ON guarantor_engagements TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON sites TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON buildings TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON copro_units TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON user_site_roles TO authenticated;

COMMIT;

-- ============================================
-- FIN DE LA MIGRATION
-- ============================================



-- ========== 20251210100000_add_lease_payment_fields.sql ==========
-- Migration: Ajouter les champs de paiement et révision au bail
-- Date: 2025-12-10

-- Champs de modalités de paiement
ALTER TABLE leases
ADD COLUMN IF NOT EXISTS charges_type TEXT DEFAULT 'forfait' CHECK (charges_type IN ('forfait', 'provisions'));

ALTER TABLE leases
ADD COLUMN IF NOT EXISTS mode_paiement TEXT DEFAULT 'virement' CHECK (mode_paiement IN ('virement', 'prelevement', 'cheque', 'especes'));

ALTER TABLE leases
ADD COLUMN IF NOT EXISTS jour_paiement INTEGER DEFAULT 5 CHECK (jour_paiement >= 1 AND jour_paiement <= 28);

-- Champs de révision du loyer
ALTER TABLE leases
ADD COLUMN IF NOT EXISTS revision_autorisee BOOLEAN DEFAULT true;

-- Clauses particulières (texte libre)
ALTER TABLE leases
ADD COLUMN IF NOT EXISTS clauses_particulieres TEXT;

-- Commentaires
COMMENT ON COLUMN leases.charges_type IS 'Type de charges: forfait (montant fixe) ou provisions (régularisation annuelle)';
COMMENT ON COLUMN leases.mode_paiement IS 'Mode de paiement du loyer: virement, prélèvement, chèque, espèces';
COMMENT ON COLUMN leases.jour_paiement IS 'Jour du mois pour le paiement du loyer (1-28)';
COMMENT ON COLUMN leases.revision_autorisee IS 'Si la révision annuelle du loyer est autorisée';
COMMENT ON COLUMN leases.clauses_particulieres IS 'Clauses particulières ajoutées au bail';


-- ========== 20251221000000_document_caching.sql ==========
-- =====================================================
-- Migration: Optimisation du cache des documents générés
-- Date: 2024-12-21
-- Pattern: Création unique → Lectures multiples
-- =====================================================
-- 
-- Cette migration ajoute les structures nécessaires pour implémenter
-- le pattern "création unique → lectures multiples" pour tous les
-- documents générés (quittances, baux, EDL, factures, etc.)
--
-- Principe:
-- 1. Un document est généré UNE SEULE FOIS lors de la première demande
-- 2. Stocké dans Supabase Storage avec référence dans la table documents
-- 3. Les demandes suivantes retournent le document stocké via URL signée
-- 4. Un hash permet d'invalider le cache si les données source changent
-- =====================================================

BEGIN;

-- ============================================
-- ÉTENDRE LA TABLE DOCUMENTS
-- ============================================

-- Ajouter colonne content_hash pour déduplication rapide
DO $$ 
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'documents' AND column_name = 'content_hash'
  ) THEN
    ALTER TABLE documents ADD COLUMN content_hash TEXT;
    COMMENT ON COLUMN documents.content_hash IS 'Hash SHA256 du contenu/données source pour cache invalidation';
  END IF;
END $$;

-- Ajouter colonne is_generated pour distinguer documents uploadés vs générés
DO $$ 
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'documents' AND column_name = 'is_generated'
  ) THEN
    ALTER TABLE documents ADD COLUMN is_generated BOOLEAN DEFAULT FALSE;
    COMMENT ON COLUMN documents.is_generated IS 'TRUE si document généré automatiquement (PDF), FALSE si uploadé manuellement';
  END IF;
END $$;

-- Ajouter colonne generation_source pour traçabilité
DO $$ 
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'documents' AND column_name = 'generation_source'
  ) THEN
    ALTER TABLE documents ADD COLUMN generation_source TEXT;
    COMMENT ON COLUMN documents.generation_source IS 'Source de génération: api_receipt, api_lease_pdf, edge_function, etc.';
  END IF;
END $$;

-- ============================================
-- INDEX POUR RECHERCHE RAPIDE
-- ============================================

-- Index sur le hash pour recherche par contenu (déduplication)
CREATE INDEX IF NOT EXISTS idx_documents_content_hash 
  ON documents(content_hash) 
  WHERE content_hash IS NOT NULL;

-- Index composite pour les quittances (recherche fréquente)
CREATE INDEX IF NOT EXISTS idx_documents_quittance_lookup 
  ON documents(type, tenant_id, lease_id) 
  WHERE type = 'quittance';

-- Index composite pour les baux
CREATE INDEX IF NOT EXISTS idx_documents_bail_lookup 
  ON documents(type, lease_id) 
  WHERE type = 'bail';

-- Index sur metadata->hash (utilisé par les API)
CREATE INDEX IF NOT EXISTS idx_documents_metadata_hash 
  ON documents((metadata->>'hash'))
  WHERE metadata->>'hash' IS NOT NULL;

-- Index sur metadata->payment_id (pour quittances)
CREATE INDEX IF NOT EXISTS idx_documents_metadata_payment 
  ON documents((metadata->>'payment_id'))
  WHERE metadata->>'payment_id' IS NOT NULL;

-- Index sur is_generated
CREATE INDEX IF NOT EXISTS idx_documents_is_generated
  ON documents(is_generated)
  WHERE is_generated = TRUE;

-- ============================================
-- TABLE DE CACHE DES APERÇUS HTML (optionnel)
-- ============================================

CREATE TABLE IF NOT EXISTS preview_cache (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  
  -- Clé de cache (composite unique)
  cache_key TEXT NOT NULL,
  
  -- Type d'aperçu
  preview_type TEXT NOT NULL CHECK (preview_type IN ('lease', 'receipt', 'edl', 'invoice', 'other')),
  
  -- Contenu HTML généré
  html_content TEXT NOT NULL,
  
  -- Métadonnées
  data_hash TEXT NOT NULL,
  
  -- TTL - expire après 1 heure par défaut
  expires_at TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '1 hour'),
  
  -- Tracking
  hit_count INTEGER DEFAULT 0,
  last_accessed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Contraintes
  CONSTRAINT preview_cache_key_unique UNIQUE (cache_key),
  CONSTRAINT preview_cache_valid_expiry CHECK (expires_at > created_at)
);

-- Index pour nettoyage automatique des aperçus expirés
CREATE INDEX IF NOT EXISTS idx_preview_cache_expires 
  ON preview_cache(expires_at);

-- Index pour recherche par type et hash
CREATE INDEX IF NOT EXISTS idx_preview_cache_lookup
  ON preview_cache(preview_type, data_hash);

-- ============================================
-- FONCTION DE NETTOYAGE DES APERÇUS EXPIRÉS
-- ============================================

CREATE OR REPLACE FUNCTION cleanup_expired_previews()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM preview_cache WHERE expires_at < NOW();
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  
  -- Log si beaucoup de suppressions
  IF deleted_count > 100 THEN
    RAISE NOTICE 'cleanup_expired_previews: % aperçus expirés supprimés', deleted_count;
  END IF;
  
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- FONCTION POUR OBTENIR OU MARQUER CRÉATION
-- ============================================

CREATE OR REPLACE FUNCTION get_or_mark_document_creation(
  p_type TEXT,
  p_hash TEXT,
  p_lease_id UUID DEFAULT NULL,
  p_property_id UUID DEFAULT NULL,
  p_owner_id UUID DEFAULT NULL,
  p_tenant_id UUID DEFAULT NULL,
  p_payment_id TEXT DEFAULT NULL
)
RETURNS TABLE (
  document_id UUID,
  storage_path TEXT,
  is_new BOOLEAN,
  created_at TIMESTAMPTZ
) AS $$
DECLARE
  v_existing_doc RECORD;
BEGIN
  -- Chercher document existant par type et hash
  SELECT d.id, d.storage_path, d.created_at INTO v_existing_doc
  FROM documents d
  WHERE d.type = p_type
    AND (
      d.content_hash = p_hash 
      OR d.metadata->>'hash' = p_hash
      OR (p_payment_id IS NOT NULL AND d.metadata->>'payment_id' = p_payment_id)
    )
    AND (p_lease_id IS NULL OR d.lease_id = p_lease_id)
    AND (p_property_id IS NULL OR d.property_id = p_property_id)
    AND (p_owner_id IS NULL OR d.owner_id = p_owner_id)
    AND (p_tenant_id IS NULL OR d.tenant_id = p_tenant_id)
  ORDER BY d.created_at DESC
  LIMIT 1;

  IF v_existing_doc.id IS NOT NULL THEN
    -- Document existe → retourner pour LECTURE
    RETURN QUERY SELECT 
      v_existing_doc.id, 
      v_existing_doc.storage_path, 
      FALSE::BOOLEAN,
      v_existing_doc.created_at;
  ELSE
    -- Document n'existe pas → signaler pour CRÉATION
    RETURN QUERY SELECT 
      NULL::UUID, 
      NULL::TEXT, 
      TRUE::BOOLEAN,
      NULL::TIMESTAMPTZ;
  END IF;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION get_or_mark_document_creation IS 
  'Vérifie si un document existe déjà pour éviter régénération (pattern création unique → lectures multiples)';

-- ============================================
-- FONCTION POUR METTRE À JOUR LE COMPTEUR D'APERÇU
-- ============================================

CREATE OR REPLACE FUNCTION update_preview_cache_hit(p_cache_key TEXT)
RETURNS VOID AS $$
BEGIN
  UPDATE preview_cache
  SET 
    hit_count = hit_count + 1,
    last_accessed_at = NOW(),
    -- Prolonger le TTL si souvent accédé
    expires_at = CASE 
      WHEN hit_count > 10 THEN GREATEST(expires_at, NOW() + INTERVAL '2 hours')
      ELSE expires_at
    END
  WHERE cache_key = p_cache_key;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- TRIGGER POUR NETTOYER LES VIEUX APERÇUS
-- ============================================

-- Supprimer automatiquement les aperçus après insertion si trop nombreux
CREATE OR REPLACE FUNCTION cleanup_old_previews_on_insert()
RETURNS TRIGGER AS $$
BEGIN
  -- Si plus de 10000 aperçus, supprimer les plus anciens
  IF (SELECT COUNT(*) FROM preview_cache) > 10000 THEN
    DELETE FROM preview_cache
    WHERE id IN (
      SELECT id FROM preview_cache
      ORDER BY last_accessed_at NULLS FIRST, created_at
      LIMIT 1000
    );
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_cleanup_old_previews ON preview_cache;
CREATE TRIGGER trg_cleanup_old_previews
  AFTER INSERT ON preview_cache
  FOR EACH STATEMENT
  EXECUTE FUNCTION cleanup_old_previews_on_insert();

-- ============================================
-- RLS POLICIES POUR PREVIEW_CACHE
-- ============================================

ALTER TABLE preview_cache ENABLE ROW LEVEL SECURITY;

-- Les utilisateurs authentifiés peuvent lire les aperçus
CREATE POLICY "Authenticated users can read previews" ON preview_cache
  FOR SELECT TO authenticated
  USING (true);

-- Seul le service peut insérer/modifier les aperçus
CREATE POLICY "Service role can manage previews" ON preview_cache
  FOR ALL TO service_role
  USING (true)
  WITH CHECK (true);

-- ============================================
-- METTRE À JOUR LES DOCUMENTS EXISTANTS
-- ============================================

-- Marquer les documents générés existants
UPDATE documents
SET 
  is_generated = TRUE,
  generation_source = 'legacy_migration'
WHERE type IN ('quittance', 'bail', 'EDL_entree', 'EDL_sortie')
  AND is_generated IS NULL
  AND storage_path IS NOT NULL;

-- ============================================
-- STATISTIQUES POUR MONITORING
-- ============================================

CREATE OR REPLACE VIEW document_cache_stats AS
SELECT 
  type,
  is_generated,
  COUNT(*) as total_count,
  COUNT(CASE WHEN content_hash IS NOT NULL THEN 1 END) as with_hash,
  COUNT(CASE WHEN storage_path IS NOT NULL THEN 1 END) as with_storage,
  MIN(created_at) as oldest,
  MAX(created_at) as newest
FROM documents
GROUP BY type, is_generated
ORDER BY total_count DESC;

COMMENT ON VIEW document_cache_stats IS 
  'Vue de monitoring pour le cache des documents générés';

COMMIT;

-- ============================================
-- NOTES D'UTILISATION
-- ============================================
-- 
-- Pattern d'utilisation côté API:
-- 
-- 1. Appeler get_or_mark_document_creation() avec les paramètres
-- 2. Si is_new = FALSE: 
--    - Récupérer le document via storage_path
--    - Générer une URL signée
--    - Retourner au client
-- 3. Si is_new = TRUE:
--    - Générer le document (PDF)
--    - Uploader dans Supabase Storage
--    - Insérer dans la table documents
--    - Retourner l'URL signée
--
-- Exemple de requête pour vérifier un document:
-- 
-- SELECT * FROM get_or_mark_document_creation(
--   'quittance',           -- type
--   'abc123hash',          -- hash
--   'uuid-lease',          -- lease_id
--   NULL,                  -- property_id
--   NULL,                  -- owner_id
--   'uuid-tenant',         -- tenant_id
--   'uuid-payment'         -- payment_id
-- );
-- =====================================================



-- ========== 20251221000001_deposit_refunds.sql ==========
-- =====================================================
-- Migration: Table de restitution des dépôts de garantie
-- Date: 2024-12-21
-- =====================================================

BEGIN;

-- Table des restitutions de dépôt
CREATE TABLE IF NOT EXISTS deposit_refunds (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
    
    -- Montants
    total_deposit DECIMAL(10,2) NOT NULL,
    total_deductions DECIMAL(10,2) NOT NULL DEFAULT 0,
    refund_amount DECIMAL(10,2) NOT NULL,
    
    -- Détail des retenues
    deductions JSONB DEFAULT '[]'::jsonb,
    -- Format: [{ "type": "loyers_impayes", "label": "Loyers impayés", "amount": 500 }]
    
    -- Mode de remboursement
    refund_method VARCHAR(50) DEFAULT 'virement', -- 'virement' | 'cheque' | 'especes'
    iban VARCHAR(50),
    
    -- Statut
    status VARCHAR(50) DEFAULT 'pending', -- 'pending' | 'completed' | 'cancelled'
    
    -- Dates
    refund_date DATE,
    completed_at TIMESTAMPTZ,
    
    -- Notes
    notes TEXT,
    
    -- Audit
    created_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_deposit_refunds_lease_id ON deposit_refunds(lease_id);
CREATE INDEX IF NOT EXISTS idx_deposit_refunds_status ON deposit_refunds(status);

-- Trigger updated_at
DROP TRIGGER IF EXISTS set_updated_at_deposit_refunds ON deposit_refunds;
CREATE TRIGGER set_updated_at_deposit_refunds
    BEFORE UPDATE ON deposit_refunds
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- RLS
ALTER TABLE deposit_refunds ENABLE ROW LEVEL SECURITY;

-- Politique: Le propriétaire peut voir/créer ses remboursements
CREATE POLICY "Owner can manage deposit_refunds" ON deposit_refunds
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM leases l
            JOIN properties p ON l.property_id = p.id
            WHERE l.id = deposit_refunds.lease_id
            AND p.owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
        )
    );

-- Politique: Le locataire peut voir ses remboursements
CREATE POLICY "Tenant can view their deposit_refunds" ON deposit_refunds
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM lease_signers ls
            WHERE ls.lease_id = deposit_refunds.lease_id
            AND ls.role IN ('locataire_principal', 'colocataire')
            AND ls.profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
        )
    );

-- Politique: Admin peut tout voir
CREATE POLICY "Admin can manage all deposit_refunds" ON deposit_refunds
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE user_id = auth.uid() AND role = 'admin'
        )
    );

-- =====================================================
-- Table des indexations IRL (si elle n'existe pas)
-- =====================================================

CREATE TABLE IF NOT EXISTS lease_indexations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
    
    -- Valeurs de loyer
    old_rent DECIMAL(10,2) NOT NULL,
    new_rent DECIMAL(10,2) NOT NULL,
    increase_amount DECIMAL(10,2) NOT NULL,
    increase_percent DECIMAL(5,2) NOT NULL,
    
    -- Valeurs IRL
    old_irl_quarter VARCHAR(10) NOT NULL, -- Ex: "2023-Q4"
    old_irl_value DECIMAL(8,2) NOT NULL,
    new_irl_quarter VARCHAR(10) NOT NULL, -- Ex: "2024-Q4"
    new_irl_value DECIMAL(8,2) NOT NULL,
    
    -- Dates
    effective_date DATE NOT NULL,
    applied_at TIMESTAMPTZ,
    declined_at TIMESTAMPTZ,
    
    -- Statut
    status VARCHAR(50) DEFAULT 'pending', -- 'pending' | 'applied' | 'declined'
    decline_reason TEXT,
    
    -- Audit
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Index
CREATE INDEX IF NOT EXISTS idx_lease_indexations_lease_id ON lease_indexations(lease_id);
CREATE INDEX IF NOT EXISTS idx_lease_indexations_status ON lease_indexations(status);
CREATE INDEX IF NOT EXISTS idx_lease_indexations_effective_date ON lease_indexations(effective_date);

-- RLS
ALTER TABLE lease_indexations ENABLE ROW LEVEL SECURITY;

-- Politique: Le propriétaire peut gérer les indexations
CREATE POLICY "Owner can manage lease_indexations" ON lease_indexations
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM leases l
            JOIN properties p ON l.property_id = p.id
            WHERE l.id = lease_indexations.lease_id
            AND p.owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
        )
    );

-- Politique: Le locataire peut voir les indexations
CREATE POLICY "Tenant can view their lease_indexations" ON lease_indexations
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM lease_signers ls
            WHERE ls.lease_id = lease_indexations.lease_id
            AND ls.role IN ('locataire_principal', 'colocataire')
            AND ls.profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
        )
    );

-- Politique: Admin peut tout voir
CREATE POLICY "Admin can manage all lease_indexations" ON lease_indexations
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE user_id = auth.uid() AND role = 'admin'
        )
    );

COMMIT;



-- ========== 20251221000002_lease_signers_invited_email.sql ==========
-- =====================================================
-- Migration: Ajouter invited_email aux lease_signers
-- Date: 2024-12-21
-- =====================================================
-- Cette colonne stocke l'email d'invitation pour les signataires
-- qui n'ont pas encore créé leur compte.
-- =====================================================

BEGIN;

-- Ajouter la colonne invited_email si elle n'existe pas
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'lease_signers' 
        AND column_name = 'invited_email'
    ) THEN
        ALTER TABLE lease_signers 
        ADD COLUMN invited_email VARCHAR(255);
        
        COMMENT ON COLUMN lease_signers.invited_email IS 
            'Email utilisé pour l''invitation, avant que le signataire ne crée son compte';
    END IF;
END $$;

-- Index pour rechercher par email
CREATE INDEX IF NOT EXISTS idx_lease_signers_invited_email 
ON lease_signers(invited_email) 
WHERE invited_email IS NOT NULL;

COMMIT;



-- ========== 20251221000003_fix_lease_signers_nullable.sql ==========
-- =====================================================
-- Migration: Corriger lease_signers pour invitations
-- Date: 2024-12-21
-- =====================================================
-- Cette migration permet d'inviter des signataires qui
-- n'ont pas encore de compte sur la plateforme.
-- =====================================================

BEGIN;

-- 1. Rendre profile_id nullable pour permettre les invitations sans compte
ALTER TABLE lease_signers 
ALTER COLUMN profile_id DROP NOT NULL;

-- 2. Ajouter la colonne invited_email si elle n'existe pas
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'lease_signers' 
        AND column_name = 'invited_email'
    ) THEN
        ALTER TABLE lease_signers 
        ADD COLUMN invited_email VARCHAR(255);
        
        COMMENT ON COLUMN lease_signers.invited_email IS 
            'Email utilisé pour l''invitation, avant que le signataire ne crée son compte';
    END IF;
END $$;

-- 3. Ajouter une colonne pour suivre quand l'invitation a été envoyée
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'lease_signers' 
        AND column_name = 'invited_at'
    ) THEN
        ALTER TABLE lease_signers 
        ADD COLUMN invited_at TIMESTAMPTZ DEFAULT NOW();
    END IF;
END $$;

-- 4. Ajouter une colonne pour le nom invité (avant création du profil)
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'lease_signers' 
        AND column_name = 'invited_name'
    ) THEN
        ALTER TABLE lease_signers 
        ADD COLUMN invited_name VARCHAR(255);
    END IF;
END $$;

-- 5. Index pour rechercher par email d'invitation
CREATE INDEX IF NOT EXISTS idx_lease_signers_invited_email 
ON lease_signers(invited_email) 
WHERE invited_email IS NOT NULL;

-- 6. Contrainte: soit profile_id soit invited_email doit être défini
-- (Commenté car peut casser les données existantes - à activer après nettoyage)
-- ALTER TABLE lease_signers
-- ADD CONSTRAINT check_profile_or_email 
-- CHECK (profile_id IS NOT NULL OR invited_email IS NOT NULL);

COMMIT;



-- ========== 20251222000000_add_profile_columns.sql ==========
-- =====================================================
-- Migration: Ajouter colonnes manquantes dans profiles
-- Date: 2024-12-22
-- =====================================================
-- Colonnes nécessaires pour le flux de signature locataire
-- =====================================================

BEGIN;

-- 1. Ajouter lieu_naissance si manquant
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'profiles' 
        AND column_name = 'lieu_naissance'
    ) THEN
        ALTER TABLE profiles 
        ADD COLUMN lieu_naissance VARCHAR(255);
        
        COMMENT ON COLUMN profiles.lieu_naissance IS 
            'Lieu de naissance pour les documents officiels';
    END IF;
END $$;

-- 2. Ajouter adresse si manquant
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'profiles' 
        AND column_name = 'adresse'
    ) THEN
        ALTER TABLE profiles 
        ADD COLUMN adresse TEXT;
        
        COMMENT ON COLUMN profiles.adresse IS 
            'Adresse complète du profil';
    END IF;
END $$;

-- 3. Ajouter nationalite si manquant
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'profiles' 
        AND column_name = 'nationalite'
    ) THEN
        ALTER TABLE profiles 
        ADD COLUMN nationalite VARCHAR(100) DEFAULT 'Française';
        
        COMMENT ON COLUMN profiles.nationalite IS 
            'Nationalité du profil';
    END IF;
END $$;

COMMIT;








-- ========== 20251222000001_signature_image.sql ==========
-- Migration: Ajouter la colonne signature_image à lease_signers
-- Date: 2025-12-22
-- Description: Permet de stocker l'image de signature (base64 ou URL) pour l'afficher sur le bail

-- Ajouter la colonne signature_image si elle n'existe pas
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'lease_signers' 
    AND column_name = 'signature_image'
  ) THEN
    ALTER TABLE lease_signers ADD COLUMN signature_image TEXT;
    COMMENT ON COLUMN lease_signers.signature_image IS 'Image de signature en base64 (data:image/png;base64,...) ou URL';
  END IF;
END $$;

-- Index pour optimiser les requêtes sur les signataires avec signature
CREATE INDEX IF NOT EXISTS idx_lease_signers_has_signature 
  ON lease_signers(lease_id) 
  WHERE signature_status = 'signed' AND signature_image IS NOT NULL;








-- ========== 20251228000000_documents_sota.sql ==========
-- Migration : Documents SOTA 2025
-- Date : 2025-12-28
-- 
-- Fonctionnalités :
-- 1. Unification des tables de documents
-- 2. Correction des owner_id/property_id manquants
-- 3. Index full-text pour la recherche
-- 4. Types de documents étendus

BEGIN;

-- ============================================
-- 1. EXTENSION DES TYPES DE DOCUMENTS
-- ============================================

-- Supprimer l'ancienne contrainte
ALTER TABLE documents DROP CONSTRAINT IF EXISTS documents_type_check;

-- Ajouter les nouveaux types
ALTER TABLE documents ADD CONSTRAINT documents_type_check CHECK (
  type IN (
    -- Contrats
    'bail', 'avenant', 'engagement_garant', 'bail_signe_locataire', 'bail_signe_proprietaire',
    -- Identité
    'piece_identite', 'cni_recto', 'cni_verso', 'passeport', 'titre_sejour',
    -- Finance
    'quittance', 'facture', 'rib', 'avis_imposition', 'bulletin_paie', 'attestation_loyer',
    -- Assurance
    'attestation_assurance', 'assurance_pno',
    -- Diagnostics
    'diagnostic', 'dpe', 'diagnostic_gaz', 'diagnostic_electricite', 
    'diagnostic_plomb', 'diagnostic_amiante', 'diagnostic_termites', 'erp',
    -- États des lieux
    'EDL_entree', 'EDL_sortie', 'inventaire',
    -- Candidature (migrés depuis application_files)
    'candidature_identite', 'candidature_revenus', 'candidature_domicile', 'candidature_garantie',
    -- Garant (migrés depuis guarantor_documents)
    'garant_identite', 'garant_revenus', 'garant_domicile', 'garant_engagement',
    -- Prestataire
    'devis', 'ordre_mission', 'rapport_intervention',
    -- Copropriété
    'taxe_fonciere', 'taxe_sejour', 'copropriete', 'proces_verbal', 'appel_fonds',
    -- Divers
    'consentement', 'courrier', 'photo', 'justificatif_revenus', 'autre'
  )
);

-- ============================================
-- 2. AJOUT DE COLONNES MANQUANTES
-- ============================================

-- Catégorie pour le filtrage
ALTER TABLE documents ADD COLUMN IF NOT EXISTS category TEXT;

-- Application ID (pour les documents de candidature)
ALTER TABLE documents ADD COLUMN IF NOT EXISTS application_id UUID REFERENCES tenant_applications(id) ON DELETE SET NULL;

-- Garant ID (pour les documents de garant)
ALTER TABLE documents ADD COLUMN IF NOT EXISTS guarantor_profile_id UUID REFERENCES profiles(id) ON DELETE SET NULL;

-- Nom original du fichier
ALTER TABLE documents ADD COLUMN IF NOT EXISTS original_filename TEXT;

-- Hash SHA256 pour déduplication
ALTER TABLE documents ADD COLUMN IF NOT EXISTS sha256 TEXT;

-- Taille du fichier
ALTER TABLE documents ADD COLUMN IF NOT EXISTS file_size BIGINT;

-- Type MIME
ALTER TABLE documents ADD COLUMN IF NOT EXISTS mime_type TEXT;

-- Index de recherche full-text
ALTER TABLE documents ADD COLUMN IF NOT EXISTS search_vector TSVECTOR;

-- ============================================
-- 3. CORRECTION DES DOCUMENTS EXISTANTS
-- ============================================

-- Mettre à jour les documents liés à un bail qui n'ont pas de owner_id/property_id
UPDATE documents d
SET 
  property_id = COALESCE(d.property_id, l.property_id),
  owner_id = COALESCE(d.owner_id, p.owner_id)
FROM leases l
JOIN properties p ON l.property_id = p.id
WHERE d.lease_id = l.id
  AND (d.property_id IS NULL OR d.owner_id IS NULL);

-- Mettre à jour la catégorie automatiquement
UPDATE documents SET category = CASE
  WHEN type IN ('bail', 'avenant', 'engagement_garant', 'bail_signe_locataire', 'bail_signe_proprietaire') THEN 'contrat'
  WHEN type IN ('piece_identite', 'cni_recto', 'cni_verso', 'passeport', 'titre_sejour') THEN 'identite'
  WHEN type IN ('quittance', 'facture', 'rib', 'avis_imposition', 'bulletin_paie', 'attestation_loyer') THEN 'finance'
  WHEN type IN ('attestation_assurance', 'assurance_pno') THEN 'assurance'
  WHEN type LIKE 'diagnostic%' OR type IN ('dpe', 'erp') THEN 'diagnostic'
  WHEN type IN ('EDL_entree', 'EDL_sortie', 'inventaire') THEN 'edl'
  WHEN type LIKE 'candidature%' THEN 'candidature'
  WHEN type LIKE 'garant%' THEN 'garant'
  WHEN type IN ('devis', 'ordre_mission', 'rapport_intervention') THEN 'prestataire'
  ELSE 'autre'
END
WHERE category IS NULL;

-- ============================================
-- 4. INDEX FULL-TEXT POUR RECHERCHE
-- ============================================

-- Créer la fonction de mise à jour du vecteur de recherche
CREATE OR REPLACE FUNCTION documents_search_vector_update()
RETURNS TRIGGER AS $$
BEGIN
  NEW.search_vector := 
    setweight(to_tsvector('french', COALESCE(NEW.title, '')), 'A') ||
    setweight(to_tsvector('french', COALESCE(NEW.type, '')), 'B') ||
    setweight(to_tsvector('french', COALESCE(NEW.original_filename, '')), 'C') ||
    setweight(to_tsvector('french', COALESCE(NEW.metadata->>'nom', '')), 'B') ||
    setweight(to_tsvector('french', COALESCE(NEW.metadata->>'prenom', '')), 'B');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger pour mise à jour automatique
DROP TRIGGER IF EXISTS trg_documents_search_vector ON documents;
CREATE TRIGGER trg_documents_search_vector
  BEFORE INSERT OR UPDATE ON documents
  FOR EACH ROW
  EXECUTE FUNCTION documents_search_vector_update();

-- Mettre à jour les documents existants
UPDATE documents SET search_vector = 
  setweight(to_tsvector('french', COALESCE(title, '')), 'A') ||
  setweight(to_tsvector('french', COALESCE(type, '')), 'B') ||
  setweight(to_tsvector('french', COALESCE(original_filename, '')), 'C') ||
  setweight(to_tsvector('french', COALESCE(metadata->>'nom', '')), 'B') ||
  setweight(to_tsvector('french', COALESCE(metadata->>'prenom', '')), 'B');

-- Index GIN pour la recherche full-text
CREATE INDEX IF NOT EXISTS idx_documents_search_vector ON documents USING gin(search_vector);

-- Index sur la catégorie
CREATE INDEX IF NOT EXISTS idx_documents_category ON documents(category);

-- Index composite pour les requêtes fréquentes
CREATE INDEX IF NOT EXISTS idx_documents_owner_property ON documents(owner_id, property_id);

-- ============================================
-- 5. MIGRATION DES DONNÉES (application_files → documents)
-- ============================================

-- Ne migrer que si la table source existe et n'est pas vide
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'application_files') THEN
    -- Migrer les fichiers de candidature vers documents
    INSERT INTO documents (
      type,
      application_id,
      tenant_id,
      storage_path,
      original_filename,
      sha256,
      file_size,
      mime_type,
      metadata,
      created_at,
      category
    )
    SELECT 
      CASE af.kind
        WHEN 'identity' THEN 'candidature_identite'
        WHEN 'income' THEN 'candidature_revenus'
        WHEN 'address' THEN 'candidature_domicile'
        WHEN 'guarantee' THEN 'candidature_garantie'
        ELSE 'autre'
      END,
      af.application_id,
      ta.tenant_profile_id,
      af.storage_path,
      af.file_name,
      af.sha256,
      af.size_bytes,
      af.mime_type,
      jsonb_build_object(
        'ocr_provider', af.ocr_provider,
        'ocr_result', af.ocr_result,
        'confidence', af.confidence,
        'migrated_from', 'application_files',
        'original_id', af.id
      ),
      af.uploaded_at,
      'candidature'
    FROM application_files af
    JOIN tenant_applications ta ON ta.id = af.application_id
    WHERE NOT EXISTS (
      SELECT 1 FROM documents d 
      WHERE d.metadata->>'original_id' = af.id::text
        AND d.metadata->>'migrated_from' = 'application_files'
    );
    
    RAISE NOTICE 'Migration application_files terminée';
  END IF;
END $$;

-- ============================================
-- 6. MIGRATION DES DONNÉES (guarantor_documents → documents)
-- ============================================

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'guarantor_documents') THEN
    -- Migrer les documents garant vers documents
    INSERT INTO documents (
      type,
      guarantor_profile_id,
      storage_path,
      original_filename,
      file_size,
      mime_type,
      metadata,
      created_at,
      category
    )
    SELECT 
      CASE gd.document_type
        WHEN 'identity' THEN 'garant_identite'
        WHEN 'income' THEN 'garant_revenus'
        WHEN 'address' THEN 'garant_domicile'
        WHEN 'engagement' THEN 'garant_engagement'
        ELSE 'garant_' || COALESCE(gd.document_type, 'autre')
      END,
      gd.guarantor_profile_id,
      gd.storage_path,
      gd.original_filename,
      gd.file_size,
      gd.mime_type,
      jsonb_build_object(
        'verification_status', gd.verification_status,
        'verified_at', gd.verified_at,
        'verified_by', gd.verified_by,
        'migrated_from', 'guarantor_documents',
        'original_id', gd.id
      ),
      gd.created_at,
      'garant'
    FROM guarantor_documents gd
    WHERE NOT EXISTS (
      SELECT 1 FROM documents d 
      WHERE d.metadata->>'original_id' = gd.id::text
        AND d.metadata->>'migrated_from' = 'guarantor_documents'
    );
    
    RAISE NOTICE 'Migration guarantor_documents terminée';
  END IF;
END $$;

-- ============================================
-- 7. VUE ENRICHIE POUR LES REQUÊTES
-- ============================================

CREATE OR REPLACE VIEW documents_enriched AS
SELECT 
  d.*,
  -- Infos du locataire
  COALESCE(tp.prenom || ' ' || tp.nom, 'Non défini') AS tenant_name,
  tp.prenom AS tenant_prenom,
  tp.nom AS tenant_nom,
  -- Infos du propriétaire
  op.prenom || ' ' || op.nom AS owner_name,
  -- Infos du bien
  p.adresse_complete AS property_address,
  p.ville AS property_ville,
  -- Infos du bail
  l.type_bail,
  l.statut AS lease_status,
  l.date_debut AS lease_start,
  -- Catégorie calculée
  COALESCE(d.category, 
    CASE 
      WHEN d.type IN ('bail', 'avenant', 'engagement_garant') THEN 'contrat'
      WHEN d.type IN ('cni_recto', 'cni_verso', 'passeport', 'piece_identite') THEN 'identite'
      WHEN d.type IN ('quittance', 'facture') THEN 'finance'
      WHEN d.type LIKE 'diagnostic%' OR d.type IN ('dpe', 'erp') THEN 'diagnostic'
      WHEN d.type IN ('EDL_entree', 'EDL_sortie') THEN 'edl'
      ELSE 'autre'
    END
  ) AS computed_category
FROM documents d
LEFT JOIN profiles tp ON d.tenant_id = tp.id
LEFT JOIN profiles op ON d.owner_id = op.id
LEFT JOIN properties p ON d.property_id = p.id
LEFT JOIN leases l ON d.lease_id = l.id;

-- ============================================
-- 8. FONCTION DE RECHERCHE
-- ============================================

CREATE OR REPLACE FUNCTION search_documents(
  search_query TEXT,
  p_owner_id UUID DEFAULT NULL,
  p_tenant_id UUID DEFAULT NULL,
  p_property_id UUID DEFAULT NULL,
  p_category TEXT DEFAULT NULL,
  p_limit INTEGER DEFAULT 50
)
RETURNS TABLE (
  id UUID,
  type TEXT,
  title TEXT,
  tenant_name TEXT,
  property_address TEXT,
  created_at TIMESTAMPTZ,
  rank REAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    d.id,
    d.type,
    d.title,
    COALESCE(tp.prenom || ' ' || tp.nom, 'Non défini') AS tenant_name,
    p.adresse_complete AS property_address,
    d.created_at,
    ts_rank(d.search_vector, plainto_tsquery('french', search_query)) AS rank
  FROM documents d
  LEFT JOIN profiles tp ON d.tenant_id = tp.id
  LEFT JOIN properties p ON d.property_id = p.id
  WHERE 
    d.search_vector @@ plainto_tsquery('french', search_query)
    AND (p_owner_id IS NULL OR d.owner_id = p_owner_id)
    AND (p_tenant_id IS NULL OR d.tenant_id = p_tenant_id)
    AND (p_property_id IS NULL OR d.property_id = p_property_id)
    AND (p_category IS NULL OR d.category = p_category)
  ORDER BY rank DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 9. COMMENTAIRES
-- ============================================

COMMENT ON COLUMN documents.category IS 'Catégorie du document : contrat, identite, finance, assurance, diagnostic, edl, candidature, garant, prestataire, autre';
COMMENT ON COLUMN documents.search_vector IS 'Vecteur de recherche full-text pour recherche rapide';
COMMENT ON COLUMN documents.application_id IS 'ID de la candidature associée (migré depuis application_files)';
COMMENT ON COLUMN documents.guarantor_profile_id IS 'ID du profil garant (migré depuis guarantor_documents)';
COMMENT ON VIEW documents_enriched IS 'Vue enrichie des documents avec informations locataire/propriétaire/bien';
COMMENT ON FUNCTION search_documents IS 'Recherche full-text dans les documents avec filtres';

COMMIT;



-- ========== 20251228000001_edl_before_activation.sql ==========
-- ============================================
-- Migration : EDL obligatoire avant activation
-- Date : 2025-12-28
-- ============================================
-- FLUX LÉGAL FRANÇAIS :
-- 1. Bail signé par toutes les parties → statut "fully_signed"
-- 2. EDL d'entrée réalisé et signé
-- 3. Bail activé → statut "active"
-- ============================================

-- Supprimer l'ancienne contrainte si elle existe
ALTER TABLE leases 
DROP CONSTRAINT IF EXISTS leases_statut_check;

-- Ajouter la nouvelle contrainte avec tous les statuts du cycle de vie
ALTER TABLE leases
ADD CONSTRAINT leases_statut_check
CHECK (statut IN (
  'draft',              -- Brouillon
  'sent',               -- Envoyé pour signature
  'pending_signature',  -- En attente de signatures
  'partially_signed',   -- Partiellement signé (au moins une signature)
  'pending_owner_signature', -- Locataire(s) signé, attente propriétaire
  'fully_signed',       -- Entièrement signé (AVANT activation - attend EDL)
  'active',             -- Actif (APRÈS EDL d'entrée)
  'amended',            -- Avenant en cours
  'suspended',          -- Suspendu temporairement
  'terminated',         -- Terminé
  'archived'            -- Archivé
));

-- Ajouter une colonne pour suivre la date d'activation réelle
ALTER TABLE leases
ADD COLUMN IF NOT EXISTS activated_at TIMESTAMPTZ;

-- Ajouter une colonne pour stocker l'ID de l'EDL d'entrée qui a déclenché l'activation
ALTER TABLE leases
ADD COLUMN IF NOT EXISTS entry_edl_id UUID REFERENCES edl(id) ON DELETE SET NULL;

-- Index pour rechercher les baux en attente d'activation
CREATE INDEX IF NOT EXISTS idx_leases_fully_signed ON leases(statut) WHERE statut = 'fully_signed';

-- Commentaires pour documentation
COMMENT ON COLUMN leases.activated_at IS 'Date réelle d''activation du bail (après EDL d''entrée)';
COMMENT ON COLUMN leases.entry_edl_id IS 'Référence à l''EDL d''entrée qui a permis l''activation';

-- ============================================
-- Fonction : Vérifier si un bail peut être activé
-- ============================================
DROP FUNCTION IF EXISTS can_activate_lease(UUID);
CREATE OR REPLACE FUNCTION can_activate_lease(p_lease_id UUID)
RETURNS TABLE(
  can_activate BOOLEAN,
  reason TEXT,
  edl_status TEXT
) AS $$
DECLARE
  v_lease_status TEXT;
  v_edl_record RECORD;
BEGIN
  -- Récupérer le statut du bail
  SELECT statut INTO v_lease_status
  FROM leases
  WHERE id = p_lease_id;
  
  IF v_lease_status IS NULL THEN
    RETURN QUERY SELECT FALSE, 'Bail non trouvé'::TEXT, NULL::TEXT;
    RETURN;
  END IF;
  
  IF v_lease_status != 'fully_signed' THEN
    RETURN QUERY SELECT FALSE, 
      ('Le bail doit être entièrement signé (statut actuel: ' || v_lease_status || ')')::TEXT, 
      NULL::TEXT;
    RETURN;
  END IF;
  
  -- Vérifier l'EDL d'entrée
  SELECT id, status INTO v_edl_record
  FROM edl
  WHERE lease_id = p_lease_id AND type = 'entree'
  ORDER BY created_at DESC
  LIMIT 1;
  
  IF v_edl_record.id IS NULL THEN
    RETURN QUERY SELECT FALSE, 
      'Aucun état des lieux d''entrée n''existe pour ce bail'::TEXT, 
      NULL::TEXT;
    RETURN;
  END IF;
  
  IF v_edl_record.status != 'signed' THEN
    RETURN QUERY SELECT FALSE, 
      ('L''état des lieux d''entrée doit être signé (statut actuel: ' || v_edl_record.status || ')')::TEXT, 
      v_edl_record.status;
    RETURN;
  END IF;
  
  -- Tout est OK
  RETURN QUERY SELECT TRUE, 'Prêt pour activation'::TEXT, v_edl_record.status;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- Trigger : Auto-activation si EDL signé
-- (Optionnel - peut être commenté si activation manuelle préférée)
-- ============================================
DROP FUNCTION IF EXISTS trigger_activate_lease_on_edl_signed() CASCADE;
CREATE OR REPLACE FUNCTION trigger_activate_lease_on_edl_signed()
RETURNS TRIGGER AS $$
BEGIN
  -- Si l'EDL d'entrée passe à "signed"
  IF NEW.type = 'entree' AND NEW.status = 'signed' AND OLD.status != 'signed' THEN
    -- Vérifier que le bail est bien "fully_signed"
    IF EXISTS (
      SELECT 1 FROM leases 
      WHERE id = NEW.lease_id 
      AND statut = 'fully_signed'
    ) THEN
      -- Activer le bail
      UPDATE leases
      SET 
        statut = 'active',
        activated_at = NOW(),
        entry_edl_id = NEW.id,
        updated_at = NOW()
      WHERE id = NEW.lease_id;
      
      -- Log l'événement
      INSERT INTO audit_log (action, entity_type, entity_id, metadata)
      VALUES (
        'lease_auto_activated',
        'lease',
        NEW.lease_id,
        jsonb_build_object(
          'triggered_by', 'edl_signed',
          'edl_id', NEW.id
        )
      );
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Créer le trigger (désactivé par défaut - décommenter pour activation automatique)
-- DROP TRIGGER IF EXISTS auto_activate_lease_on_edl ON edl;
-- CREATE TRIGGER auto_activate_lease_on_edl
--   AFTER UPDATE ON edl
--   FOR EACH ROW
--   EXECUTE FUNCTION trigger_activate_lease_on_edl_signed();

-- ============================================
-- Vue : Baux en attente d'activation
-- ============================================
CREATE OR REPLACE VIEW v_leases_awaiting_activation AS
SELECT 
  l.id AS lease_id,
  l.date_debut,
  l.date_fin,
  l.type_bail,
  l.statut,
  l.created_at AS lease_created_at,
  p.id AS property_id,
  p.adresse_complete AS adresse,
  p.ville,
  p.code_postal,
  e.id AS edl_id,
  e.status AS edl_status,
  e.scheduled_date AS edl_scheduled,
  CASE 
    WHEN e.id IS NULL THEN 'Créer l''EDL d''entrée'
    WHEN e.status = 'draft' THEN 'Compléter l''EDL'
    WHEN e.status = 'in_progress' THEN 'Terminer l''EDL'
    WHEN e.status = 'completed' THEN 'Faire signer l''EDL'
    WHEN e.status = 'signed' THEN 'Prêt à activer'
    ELSE 'État inconnu'
  END AS next_action
FROM leases l
JOIN properties p ON l.property_id = p.id
LEFT JOIN edl e ON e.lease_id = l.id AND e.type = 'entree'
WHERE l.statut = 'fully_signed'
ORDER BY l.date_debut ASC;

COMMENT ON VIEW v_leases_awaiting_activation IS 'Liste des baux signés en attente d''activation (EDL requis)';







-- ========== 20251228100000_sealed_lease_pdf.sql ==========
-- ============================================
-- Migration : PDF final pour baux signés
-- Date : 2025-12-28
-- ============================================
-- Un bail signé par toutes les parties devient immutable.
-- Le PDF final est stocké et ne peut plus être modifié.
-- ============================================

-- 1. Ajouter la colonne pour stocker le chemin du PDF signé
ALTER TABLE leases 
ADD COLUMN IF NOT EXISTS signed_pdf_path TEXT;

-- 2. Ajouter une colonne pour la date de scellement
ALTER TABLE leases 
ADD COLUMN IF NOT EXISTS sealed_at TIMESTAMPTZ;

-- 3. Commentaires pour documentation
COMMENT ON COLUMN leases.signed_pdf_path IS 'Chemin du PDF final signé dans Storage (immutable après signature complète)';
COMMENT ON COLUMN leases.sealed_at IS 'Date à laquelle le bail a été scellé (toutes signatures collectées)';

-- 4. Index pour rechercher les baux scellés
CREATE INDEX IF NOT EXISTS idx_leases_sealed ON leases(sealed_at) WHERE sealed_at IS NOT NULL;

-- 5. Fonction pour vérifier si un bail est modifiable
CREATE OR REPLACE FUNCTION is_lease_editable(p_lease_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
  v_statut TEXT;
  v_sealed_at TIMESTAMPTZ;
BEGIN
  SELECT statut, sealed_at INTO v_statut, v_sealed_at
  FROM leases
  WHERE id = p_lease_id;
  
  -- Un bail est modifiable si :
  -- 1. Il n'est pas encore scellé (sealed_at IS NULL)
  -- 2. Son statut permet les modifications
  RETURN v_sealed_at IS NULL AND v_statut IN ('draft', 'sent', 'pending_signature', 'partially_signed', 'pending_owner_signature');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6. Trigger pour empêcher les modifications sur un bail scellé
CREATE OR REPLACE FUNCTION prevent_sealed_lease_modification()
RETURNS TRIGGER AS $$
BEGIN
  -- Si le bail est scellé, bloquer certaines modifications
  IF OLD.sealed_at IS NOT NULL THEN
    -- Autoriser uniquement les changements de statut vers terminated/archived
    -- et les mises à jour de activated_at, entry_edl_id
    IF NEW.statut NOT IN ('active', 'terminated', 'archived', 'fully_signed') 
       OR NEW.loyer != OLD.loyer 
       OR NEW.charges_forfaitaires != OLD.charges_forfaitaires
       OR NEW.date_debut != OLD.date_debut
       OR NEW.date_fin != OLD.date_fin
       OR NEW.type_bail != OLD.type_bail THEN
      RAISE EXCEPTION 'Ce bail est scellé et ne peut plus être modifié. Seul le statut peut évoluer vers terminé ou archivé.';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Créer le trigger
DROP TRIGGER IF EXISTS check_sealed_lease ON leases;
CREATE TRIGGER check_sealed_lease
  BEFORE UPDATE ON leases
  FOR EACH ROW
  EXECUTE FUNCTION prevent_sealed_lease_modification();

-- 7. Fonction pour sceller un bail (appelée après signature complète)
CREATE OR REPLACE FUNCTION seal_lease(p_lease_id UUID, p_pdf_path TEXT)
RETURNS BOOLEAN AS $$
DECLARE
  v_all_signed BOOLEAN;
BEGIN
  -- Vérifier que toutes les signatures sont présentes
  SELECT COUNT(*) = SUM(CASE WHEN signature_status = 'signed' THEN 1 ELSE 0 END)
  INTO v_all_signed
  FROM lease_signers
  WHERE lease_id = p_lease_id;
  
  IF NOT v_all_signed THEN
    RAISE EXCEPTION 'Toutes les signatures ne sont pas présentes';
  END IF;
  
  -- Sceller le bail
  UPDATE leases
  SET 
    signed_pdf_path = p_pdf_path,
    sealed_at = NOW(),
    statut = 'fully_signed'
  WHERE id = p_lease_id
    AND sealed_at IS NULL;
  
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION seal_lease IS 'Scelle un bail après signature complète. Stocke le PDF final et empêche les modifications futures.';




















-- ========== 20251228200000_fix_lease_status_trigger.sql ==========
-- Migration : Mise à jour automatique du statut du bail lors des signatures
-- Assure que le statut passe à 'partially_signed' ou 'fully_signed' dès qu'une signature est apposée

CREATE OR REPLACE FUNCTION update_lease_status_on_signature()
RETURNS TRIGGER AS $$
DECLARE
    total_signers INTEGER;
    signed_count INTEGER;
    new_status TEXT;
BEGIN
    -- Si le statut de signature passe à 'signed'
    IF (NEW.signature_status = 'signed' AND (OLD.signature_status IS NULL OR OLD.signature_status != 'signed')) THEN
        -- 1. Compter les signataires
        SELECT COUNT(*) INTO total_signers
        FROM lease_signers
        WHERE lease_id = NEW.lease_id;

        SELECT COUNT(*) INTO signed_count
        FROM lease_signers
        WHERE lease_id = NEW.lease_id
        AND signature_status = 'signed';

        -- 2. Déterminer le nouveau statut
        IF signed_count = total_signers AND total_signers > 0 THEN
            new_status := 'fully_signed';
        ELSIF signed_count > 0 THEN
            -- Vérifier si le propriétaire a signé
            IF EXISTS (
                SELECT 1 FROM lease_signers 
                WHERE lease_id = NEW.lease_id 
                AND role = 'proprietaire' 
                AND signature_status = 'signed'
            ) THEN
                new_status := 'partially_signed';
            ELSE
                -- Si seul le locataire a signé, on peut optionnellement passer à un état spécifique
                -- mais partially_signed convient
                new_status := 'partially_signed';
            END IF;
        ELSE
            new_status := 'pending_signature';
        END IF;

        -- 3. Mettre à jour le bail
        UPDATE leases 
        SET statut = new_status,
            updated_at = NOW()
        WHERE id = NEW.lease_id 
        AND statut IN ('draft', 'sent', 'pending_signature', 'partially_signed', 'pending_owner_signature')
        AND statut != new_status;
        
        -- 4. Si fully_signed, on peut aussi déclencher le scellement via un webhook ou une edge function
        -- (géré côté application pour l'instant)
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger sur lease_signers
DROP TRIGGER IF EXISTS on_lease_signer_updated_status ON lease_signers;
CREATE TRIGGER on_lease_signer_updated_status
    AFTER UPDATE ON lease_signers
    FOR EACH ROW
    EXECUTE FUNCTION update_lease_status_on_signature();

-- Commentaire pour documentation
COMMENT ON FUNCTION update_lease_status_on_signature() IS 'Met à jour automatiquement le statut du bail (leases.statut) en fonction des signatures récoltées.';



-- ========== 20251228210000_dpe_management_system.sql ==========
-- 1) Enums pour le cycle de vie de la demande DPE
do $$ begin
  create type public.dpe_request_status as enum (
    'REQUESTED',      -- demande envoyée (ou créée)
    'QUOTE_RECEIVED', -- devis reçu
    'SCHEDULED',      -- rdv planifié
    'DONE',           -- visite réalisée
    'DELIVERED',      -- rapport reçu (pdf + n°)
    'CANCELLED'
  );
exception when duplicate_object then null; end $$;

-- 2) Diagnostiqueurs "internes" (mini annuaire par propriétaire)
create table if not exists public.dpe_providers (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  name text not null,
  email text,
  phone text,
  coverage text,          -- ex: "Martinique - Nord / CACEM"
  is_active boolean not null default true,
  notes text
);

create index if not exists dpe_providers_owner_id_idx on public.dpe_providers(owner_id);

-- 3) Demandes DPE
create table if not exists public.dpe_requests (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  property_id uuid not null references public.properties(id) on delete cascade,
  status public.dpe_request_status not null default 'REQUESTED',

  visit_contact_name text,
  visit_contact_role text default 'OWNER', -- 'OWNER'|'TENANT'|'OTHER'
  visit_contact_email text,
  visit_contact_phone text,

  access_notes text,
  preferred_slots jsonb,    -- [{start, end}, ...]
  attachments jsonb,        -- [{path, name}]
  notes text
);

create index if not exists dpe_requests_owner_id_idx on public.dpe_requests(owner_id);
create index if not exists dpe_requests_property_id_idx on public.dpe_requests(property_id);

-- 4) Devis liés aux demandes
create table if not exists public.dpe_quotes (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  request_id uuid not null references public.dpe_requests(id) on delete cascade,
  provider_id uuid references public.dpe_providers(id) on delete set null,
  price_cents integer,
  currency text default 'EUR',
  proposed_date timestamptz,
  message text,
  is_accepted boolean not null default false
);

create index if not exists dpe_quotes_request_id_idx on public.dpe_quotes(request_id);

-- 5) Livrable DPE (document officiel stocké avec métadonnées)
create table if not exists public.dpe_deliverables (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  property_id uuid not null references public.properties(id) on delete cascade,
  request_id uuid references public.dpe_requests(id) on delete set null,

  dpe_number text not null,        -- 13 chiffres ADEME
  issued_at date not null,
  energy_class text not null,      -- A-G
  ges_class text,                  -- A-G
  valid_until date not null,

  pdf_path text not null,          -- storage path
  source text default 'UPLOAD'     -- 'UPLOAD'|'API_PREFILL'
);

create index if not exists dpe_deliverables_property_id_idx on public.dpe_deliverables(property_id);

-- 6) Contraintes métier
alter table public.dpe_deliverables
  add constraint dpe_number_13_digits_chk
  check (dpe_number ~ '^[0-9]{13}$');

alter table public.dpe_deliverables
  add constraint energy_class_chk
  check (energy_class in ('A','B','C','D','E','F','G'));

alter table public.dpe_deliverables
  add constraint ges_class_chk
  check (ges_class is null or ges_class in ('A','B','C','D','E','F','G'));

-- 7) Fonction de calcul de validité (Source de vérité)
create or replace function public.compute_dpe_valid_until(p_issued_at date)
returns date
language plpgsql
as $$
begin
  -- Réforme DPE 2021 : période transitoire
  if p_issued_at >= date '2021-07-01' then
    return (p_issued_at + interval '10 years')::date;
  elsif p_issued_at between date '2018-01-01' and date '2021-06-30' then
    return date '2024-12-31';
  elsif p_issued_at between date '2013-01-01' and date '2017-12-31' then
    return date '2022-12-31';
  else
    return p_issued_at; -- considéré expiré car déjà passé
  end if;
end $$;

-- 8) Row Level Security (RLS)
alter table public.dpe_providers enable row level security;
alter table public.dpe_requests enable row level security;
alter table public.dpe_quotes enable row level security;
alter table public.dpe_deliverables enable row level security;

-- Politiques de sécurité (Accès par propriétaire)
create policy "Owners can manage their own DPE providers" on public.dpe_providers
  for all using (owner_id = auth.uid()) with check (owner_id = auth.uid());

create policy "Owners can manage their own DPE requests" on public.dpe_requests
  for all using (owner_id = auth.uid()) with check (owner_id = auth.uid());

create policy "Owners can manage their own DPE quotes" on public.dpe_quotes
  for all using (owner_id = auth.uid()) with check (owner_id = auth.uid());

create policy "Owners can manage their own DPE deliverables" on public.dpe_deliverables
  for all using (owner_id = auth.uid()) with check (owner_id = auth.uid());

-- 9) Trigger pour auto-calculer valid_until à l'insertion
create or replace function public.set_dpe_validity()
returns trigger as $$
begin
  new.valid_until := public.compute_dpe_valid_until(new.issued_at);
  return new;
end;
$$ language plpgsql;

create trigger trg_set_dpe_validity
  before insert or update of issued_at on public.dpe_deliverables
  for each row execute function public.set_dpe_validity();

-- 10) Commentaire pour documentation
comment on table public.dpe_deliverables is 'Stocke les rapports DPE validés avec calcul automatique de fin de validité selon la loi française.';



-- ========== 20251228220000_fix_meters_rls_and_nullability.sql ==========
-- Migration : Rendre lease_id nullable dans meters et ajouter RLS propriétaire
-- Date : 2025-12-28

BEGIN;

-- 1. Rendre lease_id nullable
ALTER TABLE public.meters 
  ALTER COLUMN lease_id DROP NOT NULL;

-- 2. Supprimer les anciennes politiques RLS restrictives (si elles existent)
DROP POLICY IF EXISTS "Meters lease members select" ON public.meters;
DROP POLICY IF EXISTS "Owners can manage meters of own properties" ON public.meters;

-- 3. Nouvelles politiques RLS pour les compteurs (Meters)

-- Les propriétaires peuvent TOUT faire sur les compteurs de leurs logements
CREATE POLICY "Owners can manage meters of own properties"
  ON public.meters FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM public.properties p
      WHERE p.id = public.meters.property_id
      AND p.owner_id = public.user_profile_id()
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.properties p
      WHERE p.id = public.meters.property_id
      AND p.owner_id = public.user_profile_id()
    )
  );

-- Les locataires peuvent VOIR les compteurs liés à leur bail
CREATE POLICY "Tenants can view meters of own lease"
  ON public.meters FOR SELECT
  USING (
    lease_id IN (
      SELECT ls.lease_id 
      FROM public.lease_signers ls
      WHERE ls.profile_id = public.user_profile_id()
    )
  );

-- Les admins peuvent TOUT voir
CREATE POLICY "Admins can view all meters"
  ON public.meters FOR SELECT
  USING (public.user_role() = 'admin');

-- 4. Même logique pour les relevés (meter_readings)

ALTER TABLE public.meter_readings ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Meter readings accessible" ON public.meter_readings;
DROP POLICY IF EXISTS "Meter readings tenant create" ON public.meter_readings;

-- Les propriétaires peuvent TOUT faire sur les relevés des compteurs de leurs logements
CREATE POLICY "Owners can manage readings of own property meters"
  ON public.meter_readings FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM public.meters m
      JOIN public.properties p ON p.id = m.property_id
      WHERE m.id = public.meter_readings.meter_id
      AND p.owner_id = public.user_profile_id()
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.meters m
      JOIN public.properties p ON p.id = m.property_id
      WHERE m.id = public.meter_readings.meter_id
      AND p.owner_id = public.user_profile_id()
    )
  );

-- Les locataires peuvent VOIR et CRÉER des relevés pour leurs compteurs
CREATE POLICY "Tenants can manage readings of own lease meters"
  ON public.meter_readings FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM public.meters m
      WHERE m.id = public.meter_readings.meter_id
      AND m.lease_id IN (
        SELECT ls.lease_id 
        FROM public.lease_signers ls
        WHERE ls.profile_id = public.user_profile_id()
      )
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.meters m
      WHERE m.id = public.meter_readings.meter_id
      AND m.lease_id IN (
        SELECT ls.lease_id 
        FROM public.lease_signers ls
        WHERE ls.profile_id = public.user_profile_id()
      )
    )
  );

COMMIT;



-- ========== 20251228230000_definitive_rls_fix.sql ==========
-- MASTER FIX: Éradication de la récursion infinie RLS
-- Ce script nettoie TOUTES les politiques sur les tables critiques et recrée des règles saines.
-- Tables cibles : lease_signers, leases, roommates, tenant_profiles, meters

BEGIN;

-- ============================================
-- 1. FONCTIONS HELPERS (SECURITY DEFINER)
-- Ces fonctions bypassent RLS et cassent les boucles.
-- ============================================

CREATE OR REPLACE FUNCTION public.user_profile_id()
RETURNS UUID
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT id FROM profiles WHERE user_id = auth.uid() LIMIT 1;
$$;

CREATE OR REPLACE FUNCTION public.user_role()
RETURNS TEXT
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT role FROM profiles WHERE user_id = auth.uid() LIMIT 1;
$$;

-- Helper pour vérifier si un utilisateur est lié à un bail (locataire/colocataire)
CREATE OR REPLACE FUNCTION public.is_lease_member(p_lease_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM lease_signers 
    WHERE lease_id = p_lease_id 
    AND profile_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );
$$;

-- Helper pour vérifier si un utilisateur est propriétaire d'un bail via property
CREATE OR REPLACE FUNCTION public.is_lease_owner(p_lease_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM leases l
    JOIN properties p ON p.id = l.property_id
    WHERE l.id = p_lease_id 
    AND p.owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );
$$;

-- ============================================
-- 2. NETTOYAGE RADICAL
-- Supprime TOUTES les politiques sur les tables à risque pour repartir à zéro.
-- ============================================

DO $$ 
DECLARE 
  r RECORD;
BEGIN
  FOR r IN (
    SELECT policyname, tablename 
    FROM pg_policies 
    WHERE schemaname = 'public' 
    AND tablename IN ('lease_signers', 'leases', 'roommates', 'tenant_profiles', 'meters', 'meter_readings', 'profiles')
  ) LOOP
    EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(r.policyname) || ' ON ' || quote_ident(r.tablename);
  END LOOP;
END $$;

-- ============================================
-- 3. NOUVELLES POLITIQUES : PROFILES
-- ============================================

ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "profiles_self_all" ON profiles FOR ALL TO authenticated 
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());

CREATE POLICY "profiles_admin_all" ON profiles FOR ALL TO authenticated 
USING (public.user_role() = 'admin');

CREATE POLICY "profiles_owner_view_tenants" ON profiles FOR SELECT TO authenticated 
USING (
  EXISTS (
    SELECT 1 FROM lease_signers ls
    JOIN leases l ON l.id = ls.lease_id
    JOIN properties p ON p.id = l.property_id
    WHERE ls.profile_id = profiles.id
    AND p.owner_id = public.user_profile_id()
  )
);

-- ============================================
-- 4. NOUVELLES POLITIQUES : LEASES
-- ============================================

ALTER TABLE leases ENABLE ROW LEVEL SECURITY;

CREATE POLICY "leases_admin_all" ON leases FOR ALL TO authenticated USING (public.user_role() = 'admin');

CREATE POLICY "leases_owner_all" ON leases FOR ALL TO authenticated 
USING (
  EXISTS (
    SELECT 1 FROM properties p 
    WHERE p.id = leases.property_id 
    AND p.owner_id = public.user_profile_id()
  )
);

CREATE POLICY "leases_tenant_select" ON leases FOR SELECT TO authenticated 
USING (public.is_lease_member(id));

-- ============================================
-- 4. NOUVELLES POLITIQUES : LEASE_SIGNERS
-- ============================================

ALTER TABLE lease_signers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "ls_admin_all" ON lease_signers FOR ALL TO authenticated USING (public.user_role() = 'admin');

CREATE POLICY "ls_self_manage" ON lease_signers FOR ALL TO authenticated 
USING (profile_id = public.user_profile_id())
WITH CHECK (profile_id = public.user_profile_id());

CREATE POLICY "ls_owner_manage" ON lease_signers FOR ALL TO authenticated 
USING (public.is_lease_owner(lease_id));

CREATE POLICY "ls_tenant_view_others" ON lease_signers FOR SELECT TO authenticated 
USING (public.is_lease_member(lease_id));

-- ============================================
-- 5. NOUVELLES POLITIQUES : METERS & READINGS
-- ============================================

-- Corrections structurelles sur la table meters
ALTER TABLE meters ALTER COLUMN lease_id DROP NOT NULL;
ALTER TABLE meters DROP CONSTRAINT IF EXISTS meters_unit_check;

ALTER TABLE meters ENABLE ROW LEVEL SECURITY;

CREATE POLICY "meters_admin_all" ON meters FOR ALL TO authenticated USING (public.user_role() = 'admin');

CREATE POLICY "meters_owner_manage" ON meters FOR ALL TO authenticated 
USING (
  EXISTS (
    SELECT 1 FROM properties p 
    WHERE p.id = meters.property_id 
    AND p.owner_id = public.user_profile_id()
  )
);

CREATE POLICY "meters_tenant_select" ON meters FOR SELECT TO authenticated 
USING (public.is_lease_member(lease_id));

-- Meter Readings
ALTER TABLE meter_readings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "readings_admin_all" ON meter_readings FOR ALL TO authenticated USING (public.user_role() = 'admin');

CREATE POLICY "readings_owner_manage" ON meter_readings FOR ALL TO authenticated 
USING (
  EXISTS (
    SELECT 1 FROM meters m
    JOIN properties p ON p.id = m.property_id
    WHERE m.id = meter_readings.meter_id
    AND p.owner_id = public.user_profile_id()
  )
);

CREATE POLICY "readings_tenant_all" ON meter_readings FOR ALL TO authenticated 
USING (
  EXISTS (
    SELECT 1 FROM meters m
    WHERE m.id = meter_readings.meter_id
    AND public.is_lease_member(m.lease_id)
  )
);

-- ============================================
-- 6. NOUVELLES POLITIQUES : ROOMMATES
-- ============================================

ALTER TABLE roommates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "roommates_admin_all" ON roommates FOR ALL TO authenticated USING (public.user_role() = 'admin');

CREATE POLICY "roommates_owner_manage" ON roommates FOR ALL TO authenticated 
USING (public.is_lease_owner(lease_id));

CREATE POLICY "roommates_member_select" ON roommates FOR SELECT TO authenticated 
USING (public.is_lease_member(lease_id));

-- ============================================
-- 7. NOUVELLES POLITIQUES : TENANT_PROFILES
-- ============================================

ALTER TABLE tenant_profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "tp_admin_all" ON tenant_profiles FOR ALL TO authenticated USING (public.user_role() = 'admin');

CREATE POLICY "tp_self_manage" ON tenant_profiles FOR ALL TO authenticated 
USING (profile_id = public.user_profile_id());

CREATE POLICY "tp_owner_view" ON tenant_profiles FOR SELECT TO authenticated 
USING (
  EXISTS (
    SELECT 1 FROM lease_signers ls
    JOIN leases l ON l.id = ls.lease_id
    JOIN properties p ON p.id = l.property_id
    WHERE ls.profile_id = tenant_profiles.profile_id
    AND p.owner_id = public.user_profile_id()
  )
);

COMMIT;



-- ========== 20251229000001_fix_existing_lease_statuses.sql ==========
-- ============================================================================
-- Migration: Correction des statuts de baux existants
-- Date: 2025-12-29
-- Description: Met à jour les baux qui ont toutes les signatures mais un statut incorrect
-- ============================================================================

-- 1. Corriger les baux où TOUS les signataires ont signé mais le statut n'est pas "fully_signed"
UPDATE leases l
SET statut = 'fully_signed'
WHERE l.statut IN ('pending_signature', 'partially_signed', 'sent', 'draft')
  AND NOT EXISTS (
    -- S'assurer qu'il n'y a aucun signataire qui n'a pas signé
    SELECT 1 
    FROM lease_signers ls 
    WHERE ls.lease_id = l.id 
      AND ls.signature_status != 'signed'
  )
  AND EXISTS (
    -- S'assurer qu'il y a au moins un signataire
    SELECT 1 
    FROM lease_signers ls 
    WHERE ls.lease_id = l.id
  );

-- 2. Créer ou remplacer le trigger qui met à jour automatiquement le statut du bail
CREATE OR REPLACE FUNCTION update_lease_status_on_signature()
RETURNS TRIGGER AS $$
DECLARE
  v_all_signed BOOLEAN;
  v_signer_count INTEGER;
  v_signed_count INTEGER;
BEGIN
  -- Compter le nombre total de signataires et ceux qui ont signé
  SELECT 
    COUNT(*),
    COUNT(*) FILTER (WHERE signature_status = 'signed')
  INTO v_signer_count, v_signed_count
  FROM lease_signers
  WHERE lease_id = NEW.lease_id;

  -- Déterminer si tous ont signé
  v_all_signed := (v_signer_count > 0 AND v_signer_count = v_signed_count);

  -- Mettre à jour le statut du bail
  IF v_all_signed THEN
    UPDATE leases 
    SET statut = 'fully_signed', updated_at = NOW()
    WHERE id = NEW.lease_id 
      AND statut NOT IN ('fully_signed', 'active', 'terminated', 'archived');
    
    RAISE NOTICE 'Bail % passé à fully_signed (% signataires)', NEW.lease_id, v_signer_count;
  ELSIF v_signed_count > 0 THEN
    UPDATE leases 
    SET statut = 'partially_signed', updated_at = NOW()
    WHERE id = NEW.lease_id 
      AND statut IN ('pending_signature', 'sent', 'draft');
    
    RAISE NOTICE 'Bail % passé à partially_signed (%/% signataires)', NEW.lease_id, v_signed_count, v_signer_count;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Supprimer l'ancien trigger s'il existe
DROP TRIGGER IF EXISTS trigger_update_lease_status_on_signature ON lease_signers;

-- Créer le nouveau trigger
CREATE TRIGGER trigger_update_lease_status_on_signature
  AFTER UPDATE OF signature_status ON lease_signers
  FOR EACH ROW
  WHEN (NEW.signature_status = 'signed' AND OLD.signature_status != 'signed')
  EXECUTE FUNCTION update_lease_status_on_signature();

-- 3. Afficher les baux corrigés (pour le log)
DO $$
DECLARE
  v_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_count
  FROM leases 
  WHERE statut = 'fully_signed';
  
  RAISE NOTICE 'Nombre total de baux avec statut fully_signed: %', v_count;
END $$;



-- ========== 20251231000000_advanced_signatures.sql ==========
-- ============================================
-- Migration : Signature Électronique Avancée (Audit Trail)
-- Date : 2025-12-31
-- Description : Ajout des colonnes pour le dossier de preuve (eIDAS)
-- ============================================

-- 1. Mise à jour de EDL_SIGNATURES
ALTER TABLE public.edl_signatures 
ADD COLUMN IF NOT EXISTS proof_id TEXT,
ADD COLUMN IF NOT EXISTS proof_metadata JSONB,
ADD COLUMN IF NOT EXISTS document_hash TEXT;

-- Index pour la recherche par preuve
CREATE INDEX IF NOT EXISTS idx_edl_signatures_proof_id ON public.edl_signatures(proof_id);

-- 2. Mise à jour de LEASE_SIGNERS
ALTER TABLE public.lease_signers
ADD COLUMN IF NOT EXISTS signature_image_path TEXT,
ADD COLUMN IF NOT EXISTS ip_inet INET,
ADD COLUMN IF NOT EXISTS user_agent TEXT,
ADD COLUMN IF NOT EXISTS proof_id TEXT,
ADD COLUMN IF NOT EXISTS proof_metadata JSONB,
ADD COLUMN IF NOT EXISTS document_hash TEXT;

-- Index pour la recherche par preuve
CREATE INDEX IF NOT EXISTS idx_lease_signers_proof_id ON public.lease_signers(proof_id);

-- 3. Commentaires pour la documentation
COMMENT ON COLUMN public.edl_signatures.proof_id IS 'Identifiant unique du dossier de preuve (Audit Trail)';
COMMENT ON COLUMN public.edl_signatures.proof_metadata IS 'Dossier de preuve complet (JSON) conforme eIDAS';
COMMENT ON COLUMN public.edl_signatures.document_hash IS 'Empreinte SHA-256 du document au moment de la signature';

COMMENT ON COLUMN public.lease_signers.proof_id IS 'Identifiant unique du dossier de preuve (Audit Trail)';
COMMENT ON COLUMN public.lease_signers.proof_metadata IS 'Dossier de preuve complet (JSON) conforme eIDAS';
COMMENT ON COLUMN public.lease_signers.document_hash IS 'Empreinte SHA-256 du document au moment de la signature';
COMMENT ON COLUMN public.lease_signers.signature_image_path IS 'Chemin de l''image de signature tactile dans le storage';



-- ========== 20251231000001_fix_owner_dashboard_rpc.sql ==========
-- Fix owner_dashboard RPC to use 'etat' instead of 'statut' for properties
-- and fix the values for status filtering

CREATE OR REPLACE FUNCTION owner_dashboard(p_owner_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result JSONB;
BEGIN
  -- Vérifier que l'utilisateur est bien le propriétaire
  IF NOT EXISTS (
    SELECT 1 FROM profiles 
    WHERE id = p_owner_id 
    AND role = 'owner'
    AND user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Accès non autorisé';
  END IF;

  SELECT jsonb_build_object(
    'properties', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', p.id,
          'ref', p.unique_code,
          'adresse', p.adresse_complete,
          'statut', p.etat,
          'type', p.type,
          'surface', p.surface,
          'nb_pieces', p.nb_pieces,
          'created_at', p.created_at,
          'updated_at', p.updated_at
        )
      )
      FROM properties p
      WHERE p.owner_id = p_owner_id
    ),
    'properties_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'active', COUNT(*) FILTER (WHERE etat = 'published'),
        'draft', COUNT(*) FILTER (WHERE etat = 'draft')
      )
      FROM properties
      WHERE owner_id = p_owner_id
    ),
    'leases', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', l.id,
          'property_id', l.property_id,
          'type_bail', l.type_bail,
          'loyer', l.loyer,
          'date_debut', l.date_debut,
          'date_fin', l.date_fin,
          'statut', l.statut,
          'created_at', l.created_at
        )
      )
      FROM leases l
      INNER JOIN properties p ON p.id = l.property_id
      WHERE p.owner_id = p_owner_id
    ),
    'leases_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'active', COUNT(*) FILTER (WHERE l.statut = 'active'),
        'pending', COUNT(*) FILTER (WHERE l.statut = 'pending_signature')
      )
      FROM leases l
      INNER JOIN properties p ON p.id = l.property_id
      WHERE p.owner_id = p_owner_id
    ),
    'invoices', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', i.id,
          'lease_id', i.lease_id,
          'periode', i.periode,
          'montant_total', i.montant_total,
          'statut', i.statut,
          'created_at', i.created_at
        )
      )
      FROM invoices i
      WHERE i.owner_id = p_owner_id
      ORDER BY i.created_at DESC
      LIMIT 10
    ),
    'invoices_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'paid', COUNT(*) FILTER (WHERE statut = 'paid'),
        'pending', COUNT(*) FILTER (WHERE statut = 'sent'),
        'late', COUNT(*) FILTER (WHERE statut = 'late')
      )
      FROM invoices
      WHERE owner_id = p_owner_id
    ),
    'tickets', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', t.id,
          'property_id', t.property_id,
          'titre', t.titre,
          'priorite', t.priorite,
          'statut', t.statut,
          'created_at', t.created_at
        )
      )
      FROM tickets t
      INNER JOIN properties p ON p.id = t.property_id
      WHERE p.owner_id = p_owner_id
      ORDER BY t.created_at DESC
      LIMIT 10
    ),
    'tickets_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'open', COUNT(*) FILTER (WHERE t.statut = 'open'),
        'in_progress', COUNT(*) FILTER (WHERE t.statut = 'in_progress')
      )
      FROM tickets t
      INNER JOIN properties p ON p.id = t.property_id
      WHERE p.owner_id = p_owner_id
    )
  ) INTO v_result;

  RETURN COALESCE(v_result, '{}'::jsonb);
END;
$$;



-- ========== 20251231000002_agency_dashboard_rpc.sql ==========
-- RPC pour le dashboard agence
-- Récupère toutes les données nécessaires (stats, mandats, paiements, tâches)

CREATE OR REPLACE FUNCTION agency_dashboard(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_agency_profile_id UUID;
  v_stats JSONB;
  v_recent_mandates JSONB;
  v_recent_payments JSONB;
  v_pending_tasks JSONB;
  v_result JSONB;
BEGIN
  -- 1. Récupérer l'ID du profil agence
  SELECT id INTO v_agency_profile_id
  FROM profiles
  WHERE user_id = p_user_id AND role = 'agency';

  IF v_agency_profile_id IS NULL THEN
    -- Vérifier si l'utilisateur est un gestionnaire d'agence
    SELECT agency_profile_id INTO v_agency_profile_id
    FROM agency_managers
    WHERE user_profile_id = (SELECT id FROM profiles WHERE user_id = p_user_id)
    AND is_active = true;
  END IF;

  IF v_agency_profile_id IS NULL THEN
    RETURN jsonb_build_object('error', 'Profil agence non trouvé');
  END IF;

  -- 2. Statistiques via la vue existing agency_dashboard_stats
  SELECT jsonb_build_object(
    'mandatsActifs', mandats_actifs,
    'mandatsTotal', total_mandats,
    'proprietaires', total_proprietaires,
    'biensGeres', total_biens_geres,
    'commissionsEncaissees', commissions_encaissees,
    'commissionsEnAttente', commissions_en_attente,
    'loyersEncaissesMois', (
      SELECT COALESCE(SUM(montant_total), 0)
      FROM invoices i
      JOIN mandates m ON m.owner_profile_id = i.owner_id
      WHERE m.agency_profile_id = v_agency_profile_id
      AND i.statut = 'paid'
      AND i.periode = to_char(CURRENT_DATE, 'YYYY-MM')
    ),
    'tauxOccupation', (
      SELECT CASE WHEN total_biens_geres > 0 
        THEN ROUND((COUNT(*) FILTER (WHERE l.statut = 'active'))::NUMERIC / total_biens_geres * 100)
        ELSE 0 END
      FROM leases l
      INNER JOIN properties p ON p.id = l.property_id
      INNER JOIN mandates m ON m.owner_profile_id = p.owner_id
      WHERE m.agency_profile_id = v_agency_profile_id
    ),
    'ticketsOuverts', (
      SELECT COUNT(*)
      FROM tickets t
      INNER JOIN properties p ON p.id = t.property_id
      INNER JOIN mandates m ON m.owner_profile_id = p.owner_id
      WHERE m.agency_profile_id = v_agency_profile_id
      AND t.statut IN ('open', 'in_progress')
    )
  ) INTO v_stats
  FROM agency_dashboard_stats
  WHERE agency_id = v_agency_profile_id;

  -- 3. Mandats récents
  SELECT jsonb_agg(mandate_data) INTO v_recent_mandates
  FROM (
    SELECT jsonb_build_object(
      'id', m.id,
      'owner', (SELECT concat(pr.prenom, ' ', pr.nom) FROM profiles pr WHERE pr.id = m.owner_profile_id),
      'type', m.type_mandat,
      'biens', CASE WHEN m.inclut_tous_biens THEN (SELECT COUNT(*) FROM properties WHERE owner_id = m.owner_profile_id) ELSE array_length(m.properties_ids, 1) END,
      'status', m.statut,
      'commission', m.commission_pourcentage || '%'
    ) as mandate_data
    FROM mandates m
    WHERE m.agency_profile_id = v_agency_profile_id
    ORDER BY m.created_at DESC
    LIMIT 5
  ) sub;

  -- 4. Paiements récents
  SELECT jsonb_agg(payment_data) INTO v_recent_payments
  FROM (
    SELECT jsonb_build_object(
      'id', i.id,
      'property', (SELECT p.adresse_complete FROM properties p WHERE p.id = l.property_id),
      'tenant', (SELECT concat(pr.prenom, ' ', pr.nom) FROM profiles pr WHERE pr.id = i.tenant_id),
      'amount', i.montant_total,
      'status', i.statut,
      'date', to_char(i.updated_at, 'DD/MM/YYYY')
    ) as payment_data
    FROM invoices i
    JOIN leases l ON l.id = i.lease_id
    JOIN mandates m ON m.owner_profile_id = i.owner_id
    WHERE m.agency_profile_id = v_agency_profile_id
    AND i.statut IN ('paid', 'sent', 'late')
    ORDER BY i.updated_at DESC
    LIMIT 5
  ) sub;

  -- 5. Tâches en attente (EDL, Signatures, Révisions)
  SELECT jsonb_agg(task_data) INTO v_pending_tasks
  FROM (
    -- EDL en attente
    SELECT jsonb_build_object(
      'id', e.id,
      'title', 'EDL ' || e.type || ' - ' || (SELECT p.ville FROM properties p WHERE p.id = e.property_id),
      'type', 'edl',
      'dueDate', to_char(e.created_at + interval '2 days', 'DD/MM/YYYY')
    ) as task_data
    FROM edl e
    INNER JOIN properties p ON p.id = e.property_id
    INNER JOIN mandates m ON m.owner_profile_id = p.owner_id
    WHERE m.agency_profile_id = v_agency_profile_id
    AND e.is_signed = false
    UNION ALL
    -- Baux en attente de signature
    SELECT jsonb_build_object(
      'id', l.id,
      'title', 'Signature bail - ' || (SELECT p.adresse_complete FROM properties p WHERE p.id = l.property_id),
      'type', 'signature',
      'dueDate', to_char(l.created_at + interval '1 week', 'DD/MM/YYYY')
    ) as task_data
    FROM leases l
    INNER JOIN properties p ON p.id = l.property_id
    INNER JOIN mandates m ON m.owner_profile_id = p.owner_id
    WHERE m.agency_profile_id = v_agency_profile_id
    AND l.statut = 'pending_signature'
    LIMIT 5
  ) sub;

  -- 6. Résultat final
  v_result := jsonb_build_object(
    'stats', COALESCE(v_stats, '{}'::jsonb),
    'recentMandates', COALESCE(v_recent_mandates, '[]'::jsonb),
    'recentPayments', COALESCE(v_recent_payments, '[]'::jsonb),
    'pendingTasks', COALESCE(v_pending_tasks, '[]'::jsonb)
  );

  RETURN v_result;
END;
$$;



-- ========== 20251231000003_enhance_tenant_dashboard_rpc.sql ==========
-- Amélioration du RPC tenant_dashboard pour supporter multi-baux
-- et retourner plus d'informations connectées

CREATE OR REPLACE FUNCTION tenant_dashboard(p_tenant_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile_id UUID;
  v_leases JSONB;
  v_invoices JSONB;
  v_tickets JSONB;
  v_pending_edls JSONB;
  v_insurance_status JSONB;
  v_stats JSONB;
  v_result JSONB;
BEGIN
  -- 1. Récupérer l'ID du profil à partir du user_id
  SELECT id INTO v_profile_id
  FROM profiles
  WHERE user_id = p_tenant_user_id AND role = 'tenant';

  IF v_profile_id IS NULL THEN
    RETURN NULL;
  END IF;

  -- 2. Récupérer TOUS les baux (actifs ou en attente)
  SELECT jsonb_agg(lease_data) INTO v_leases
  FROM (
    SELECT 
      l.*,
      jsonb_build_object(
        'id', p.id,
        'adresse_complete', p.adresse_complete,
        'ville', p.ville,
        'code_postal', p.code_postal,
        'type', p.type,
        'surface', p.surface,
        'nb_pieces', p.nb_pieces,
        'cover_url', (SELECT url FROM property_photos WHERE property_id = p.id AND is_main = true LIMIT 1)
      ) as property,
      jsonb_build_object(
        'id', owner_prof.id,
        'name', concat(owner_prof.prenom, ' ', owner_prof.nom),
        'email', owner_prof.email
      ) as owner
    FROM leases l
    JOIN lease_signers ls ON ls.lease_id = l.id
    JOIN properties p ON p.id = l.property_id
    JOIN profiles owner_prof ON owner_prof.id = p.owner_id
    WHERE ls.profile_id = v_profile_id
    AND l.statut IN ('active', 'pending_signature', 'terminated')
    ORDER BY l.statut = 'active' DESC, l.created_at DESC
  ) lease_data;

  -- 3. Récupérer les factures (10 dernières)
  SELECT jsonb_agg(invoice_data) INTO v_invoices
  FROM (
    SELECT 
      i.*,
      p.type as property_type,
      p.adresse_complete as property_address
    FROM invoices i
    JOIN leases l ON l.id = i.lease_id
    JOIN properties p ON p.id = l.property_id
    WHERE i.tenant_id = v_profile_id
    ORDER BY i.periode DESC, i.created_at DESC
    LIMIT 10
  ) invoice_data;

  -- 4. Récupérer les tickets récents (10 derniers)
  SELECT jsonb_agg(ticket_data) INTO v_tickets
  FROM (
    SELECT 
      t.*,
      p.adresse_complete as property_address,
      p.type as property_type
    FROM tickets t
    JOIN properties p ON p.id = t.property_id
    WHERE t.created_by_profile_id = v_profile_id
    ORDER BY t.created_at DESC
    LIMIT 10
  ) ticket_data;

  -- 5. Récupérer les EDLs en attente de signature
  SELECT jsonb_agg(edl_data) INTO v_pending_edls
  FROM (
    SELECT 
      e.id,
      e.type,
      e.scheduled_at,
      es.invitation_token,
      p.adresse_complete as property_address,
      p.type as property_type
    FROM edl e
    JOIN edl_signatures es ON es.edl_id = e.id
    JOIN properties p ON p.id = e.property_id
    WHERE es.signer_profile_id = v_profile_id
    AND es.signed_at IS NULL
    AND e.status IN ('draft', 'scheduled', 'in_progress')
    ORDER BY e.created_at DESC
  ) edl_data;

  -- 6. Vérifier l'assurance pour les baux actifs
  SELECT jsonb_build_object(
    'has_insurance', EXISTS (
      SELECT 1 FROM documents 
      WHERE tenant_id = v_profile_id 
      AND type = 'attestation_assurance'
      AND is_archived = false
      AND (expiry_date IS NULL OR expiry_date > NOW())
    ),
    'last_expiry_date', (
      SELECT expiry_date FROM documents 
      WHERE tenant_id = v_profile_id 
      AND type = 'attestation_assurance'
      AND is_archived = false
      ORDER BY expiry_date DESC LIMIT 1
    )
  ) INTO v_insurance_status;

  -- 7. Stats globales
  SELECT jsonb_build_object(
    'unpaid_amount', COALESCE(SUM(montant_total) FILTER (WHERE statut IN ('sent', 'late')), 0),
    'unpaid_count', COUNT(*) FILTER (WHERE statut IN ('sent', 'late')),
    'total_monthly_rent', COALESCE(SUM(loyer + charges_forfaitaires) FILTER (WHERE statut = 'active'), 0),
    'active_leases_count', COUNT(*) FILTER (WHERE statut = 'active')
  ) INTO v_stats
  FROM leases l
  JOIN lease_signers ls ON ls.lease_id = l.id
  WHERE ls.profile_id = v_profile_id;

  -- 8. Assembler le résultat
  v_result := jsonb_build_object(
    'profile_id', v_profile_id,
    'leases', COALESCE(v_leases, '[]'::jsonb),
    -- Rétro-compatibilité : premier bail
    'lease', CASE WHEN v_leases IS NOT NULL THEN v_leases->0 ELSE NULL END,
    'invoices', COALESCE(v_invoices, '[]'::jsonb),
    'tickets', COALESCE(v_tickets, '[]'::jsonb),
    'pending_edls', COALESCE(v_pending_edls, '[]'::jsonb),
    'insurance', v_insurance_status,
    'stats', COALESCE(v_stats, '{"unpaid_amount": 0, "unpaid_count": 0, "total_monthly_rent": 0, "active_leases_count": 0}'::jsonb)
  );

  RETURN v_result;
END;
$$;



-- ========== 20251231000004_fix_admin_stats_rpc.sql ==========
-- Mise à jour admin_stats pour inclure tous les rôles et corriger les agrégats

CREATE OR REPLACE FUNCTION admin_stats()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_is_admin BOOLEAN;
  v_total_users INT;
  v_users_by_role JSONB;
  v_total_properties INT;
  v_properties_by_type JSONB;
  v_total_leases INT;
  v_active_leases INT;
  v_leases_by_status JSONB;
  v_total_invoices INT;
  v_unpaid_invoices INT;
  v_invoices_by_status JSONB;
  v_total_tickets INT;
  v_open_tickets INT;
  v_tickets_by_status JSONB;
  v_total_documents INT;
  v_result JSONB;
BEGIN
  -- 1. Vérifier que l'utilisateur est admin
  v_user_id := auth.uid();
  
  SELECT EXISTS (
    SELECT 1 FROM profiles
    WHERE user_id = v_user_id
    AND role = 'admin'
  ) INTO v_is_admin;

  IF NOT v_is_admin THEN
    RAISE EXCEPTION 'Accès refusé : réservé aux administrateurs';
  END IF;

  -- 2. Stats Utilisateurs (Tous les rôles)
  SELECT COUNT(*) INTO v_total_users FROM profiles;
  
  SELECT jsonb_build_object(
    'admin', COUNT(*) FILTER (WHERE role = 'admin'),
    'owner', COUNT(*) FILTER (WHERE role = 'owner'),
    'tenant', COUNT(*) FILTER (WHERE role = 'tenant'),
    'provider', COUNT(*) FILTER (WHERE role = 'provider'),
    'agency', COUNT(*) FILTER (WHERE role = 'agency'),
    'guarantor', COUNT(*) FILTER (WHERE role = 'guarantor'),
    'syndic', COUNT(*) FILTER (WHERE role = 'syndic'),
    'coproprietaire', COUNT(*) FILTER (WHERE role = 'coproprietaire')
  ) INTO v_users_by_role
  FROM profiles;

  -- 3. Stats Propriétés
  SELECT COUNT(*) INTO v_total_properties FROM properties;
  
  SELECT jsonb_build_object(
    'appartement', COUNT(*) FILTER (WHERE type = 'appartement'),
    'maison', COUNT(*) FILTER (WHERE type = 'maison'),
    'colocation', COUNT(*) FILTER (WHERE type = 'colocation'),
    'saisonnier', COUNT(*) FILTER (WHERE type = 'saisonnier')
  ) INTO v_properties_by_type
  FROM properties;

  -- 4. Stats Baux
  SELECT COUNT(*) INTO v_total_leases FROM leases;
  SELECT COUNT(*) INTO v_active_leases FROM leases WHERE statut = 'active';
  
  SELECT jsonb_build_object(
    'draft', COUNT(*) FILTER (WHERE statut = 'draft'),
    'pending_signature', COUNT(*) FILTER (WHERE statut = 'pending_signature'),
    'active', COUNT(*) FILTER (WHERE statut = 'active'),
    'terminated', COUNT(*) FILTER (WHERE statut = 'terminated')
  ) INTO v_leases_by_status
  FROM leases;

  -- 5. Stats Factures
  SELECT COUNT(*) INTO v_total_invoices FROM invoices;
  SELECT COUNT(*) INTO v_unpaid_invoices FROM invoices WHERE statut IN ('sent', 'late');
  
  SELECT jsonb_build_object(
    'draft', COUNT(*) FILTER (WHERE statut = 'draft'),
    'sent', COUNT(*) FILTER (WHERE statut = 'sent'),
    'paid', COUNT(*) FILTER (WHERE statut = 'paid'),
    'late', COUNT(*) FILTER (WHERE statut = 'late')
  ) INTO v_invoices_by_status
  FROM invoices;

  -- 6. Stats Tickets
  SELECT COUNT(*) INTO v_total_tickets FROM tickets;
  SELECT COUNT(*) INTO v_open_tickets FROM tickets WHERE statut = 'open';
  
  SELECT jsonb_build_object(
    'open', COUNT(*) FILTER (WHERE statut = 'open'),
    'in_progress', COUNT(*) FILTER (WHERE statut = 'in_progress'),
    'resolved', COUNT(*) FILTER (WHERE statut = 'resolved'),
    'closed', COUNT(*) FILTER (WHERE statut = 'closed')
  ) INTO v_tickets_by_status
  FROM tickets;

  -- 7. Stats Documents
  SELECT COUNT(*) INTO v_total_documents FROM documents;

  -- Assembler le résultat
  v_result := jsonb_build_object(
    'totalUsers', v_total_users,
    'usersByRole', v_users_by_role,
    'totalProperties', v_total_properties,
    'propertiesByType', v_properties_by_type,
    'totalLeases', v_total_leases,
    'activeLeases', v_active_leases,
    'leasesByStatus', v_leases_by_status,
    'totalInvoices', v_total_invoices,
    'unpaidInvoices', v_unpaid_invoices,
    'invoicesByStatus', v_invoices_by_status,
    'totalTickets', v_total_tickets,
    'openTickets', v_open_tickets,
    'ticketsByStatus', v_tickets_by_status,
    'totalDocuments', v_total_documents,
    'totalBlogPosts', (SELECT COUNT(*) FROM blog_posts),
    'publishedBlogPosts', (SELECT COUNT(*) FROM blog_posts WHERE is_published = true),
    'recentActivity', (
      SELECT jsonb_agg(activity)
      FROM (
        SELECT 
          'profile' as type,
          concat(prenom, ' ', nom) as title,
          created_at::text as date
        FROM profiles
        ORDER BY created_at DESC
        LIMIT 10
      ) activity
    )
  );

  RETURN v_result;
END;
$$;



-- ========== 20251231000005_finalize_owner_dashboard_rpc.sql ==========
-- Final fix for owner_dashboard RPC: include recent activity

CREATE OR REPLACE FUNCTION owner_dashboard(p_owner_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result JSONB;
BEGIN
  -- Vérifier que l'utilisateur est bien le propriétaire
  IF NOT EXISTS (
    SELECT 1 FROM profiles 
    WHERE id = p_owner_id 
    AND role = 'owner'
    AND user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Accès non autorisé';
  END IF;

  SELECT jsonb_build_object(
    'properties', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', p.id,
          'ref', p.unique_code,
          'adresse', p.adresse_complete,
          'statut', p.etat,
          'type', p.type,
          'surface', p.surface,
          'nb_pieces', p.nb_pieces,
          'created_at', p.created_at,
          'updated_at', p.updated_at
        )
      )
      FROM properties p
      WHERE p.owner_id = p_owner_id
    ),
    'properties_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'active', COUNT(*) FILTER (WHERE etat = 'published'),
        'draft', COUNT(*) FILTER (WHERE etat = 'draft')
      )
      FROM properties
      WHERE owner_id = p_owner_id
    ),
    'leases', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', l.id,
          'property_id', l.property_id,
          'type_bail', l.type_bail,
          'loyer', l.loyer,
          'date_debut', l.date_debut,
          'date_fin', l.date_fin,
          'statut', l.statut,
          'created_at', l.created_at
        )
      )
      FROM leases l
      INNER JOIN properties p ON p.id = l.property_id
      WHERE p.owner_id = p_owner_id
    ),
    'leases_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'active', COUNT(*) FILTER (WHERE l.statut = 'active'),
        'pending', COUNT(*) FILTER (WHERE l.statut = 'pending_signature')
      )
      FROM leases l
      INNER JOIN properties p ON p.id = l.property_id
      WHERE p.owner_id = p_owner_id
    ),
    'invoices', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', i.id,
          'lease_id', i.lease_id,
          'periode', i.periode,
          'montant_total', i.montant_total,
          'statut', i.statut,
          'created_at', i.created_at
        )
      )
      FROM invoices i
      WHERE i.owner_id = p_owner_id
      ORDER BY i.created_at DESC
      LIMIT 10
    ),
    'invoices_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'paid', COUNT(*) FILTER (WHERE statut = 'paid'),
        'pending', COUNT(*) FILTER (WHERE statut = 'sent'),
        'late', COUNT(*) FILTER (WHERE statut = 'late')
      )
      FROM invoices
      WHERE owner_id = p_owner_id
    ),
    'tickets', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', t.id,
          'property_id', t.property_id,
          'titre', t.titre,
          'priorite', t.priorite,
          'statut', t.statut,
          'created_at', t.created_at
        )
      )
      FROM tickets t
      INNER JOIN properties p ON p.id = t.property_id
      WHERE p.owner_id = p_owner_id
      ORDER BY t.created_at DESC
      LIMIT 10
    ),
    'tickets_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'open', COUNT(*) FILTER (WHERE t.statut = 'open'),
        'in_progress', COUNT(*) FILTER (WHERE t.statut = 'in_progress')
      )
      FROM tickets t
      INNER JOIN properties p ON p.id = t.property_id
      WHERE p.owner_id = p_owner_id
    ),
    'recentActivity', (
      SELECT jsonb_agg(act) FROM (
        -- Nouvelles factures
        SELECT 'invoice' as type, 'Facture générée - ' || i.periode as title, i.created_at::text as date
        FROM invoices i WHERE i.owner_id = p_owner_id
        UNION ALL
        -- Nouveaux tickets
        SELECT 'ticket' as type, 'Nouveau ticket: ' || t.titre as title, t.created_at::text as date
        FROM tickets t INNER JOIN properties p ON p.id = t.property_id WHERE p.owner_id = p_owner_id
        UNION ALL
        -- Nouvelles signatures
        SELECT 'signature' as type, 'Bail signé - ' || p.adresse_complete as title, l.updated_at::text as date
        FROM leases l INNER JOIN properties p ON p.id = l.property_id WHERE p.owner_id = p_owner_id AND l.statut = 'active'
        ORDER BY date DESC
        LIMIT 10
      ) act
    )
  ) INTO v_result;

  RETURN COALESCE(v_result, '{}'::jsonb);
END;
$$;



-- ========== 20251231000006_automated_billing.sql ==========
-- ============================================
-- Migration : Automatisation de la Facturation Mensuelle
-- Date : 2025-12-31
-- Description : Fonction pour générer les factures de tous les baux actifs
-- ============================================

CREATE OR REPLACE FUNCTION generate_monthly_invoices(p_target_month TEXT)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_count INT := 0;
  v_lease RECORD;
  v_result JSONB;
BEGIN
  -- Vérifier le format du mois (YYYY-MM)
  IF p_target_month !~ '^\d{4}-\d{2}$' THEN
    RAISE EXCEPTION 'Format de mois invalide. Attendu: YYYY-MM';
  END IF;

  -- Parcourir tous les baux actifs qui n'ont pas encore de facture pour ce mois
  FOR v_lease IN 
    SELECT 
      l.id as lease_id,
      l.property_id,
      p.owner_id,
      ls.profile_id as tenant_id,
      l.loyer,
      l.charges_forfaitaires
    FROM leases l
    JOIN properties p ON p.id = l.property_id
    JOIN lease_signers ls ON ls.lease_id = l.id AND ls.role IN ('locataire', 'locataire_principal')
    WHERE l.statut = 'active'
    AND l.date_debut <= (p_target_month || '-01')::DATE
    AND (l.date_fin IS NULL OR l.date_fin >= (p_target_month || '-01')::DATE)
    AND NOT EXISTS (
      SELECT 1 FROM invoices 
      WHERE lease_id = l.id 
      AND periode = p_target_month
    )
  LOOP
    INSERT INTO invoices (
      lease_id,
      owner_id,
      tenant_id,
      periode,
      montant_loyer,
      montant_charges,
      montant_total,
      statut,
      created_at
    ) VALUES (
      v_lease.lease_id,
      v_lease.owner_id,
      v_lease.tenant_id,
      p_target_month,
      v_lease.loyer,
      v_lease.charges_forfaitaires,
      v_lease.loyer + v_lease.charges_forfaitaires,
      'sent', -- Par défaut, on considère qu'elle est "envoyée" dès génération
      NOW()
    );

    v_count := v_count + 1;
  END LOOP;

  v_result := jsonb_build_object(
    'success', true,
    'month', p_target_month,
    'generated_count', v_count
  );

  RETURN v_result;
END;
$$;

COMMENT ON FUNCTION generate_monthly_invoices IS 'Génère les factures de loyer pour tous les baux actifs pour un mois donné (YYYY-MM)';



-- ========== 20251231000007_invoices_stripe_fields.sql ==========
-- ============================================
-- Migration : Équipement Invoices pour Stripe et Relances
-- Date : 2025-12-31
-- Description : Ajout des colonnes nécessaires pour le suivi des paiements Stripe
-- ============================================

ALTER TABLE public.invoices 
ADD COLUMN IF NOT EXISTS stripe_payment_intent_id TEXT,
ADD COLUMN IF NOT EXISTS stripe_session_id TEXT,
ADD COLUMN IF NOT EXISTS last_reminder_sent_at TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS reminder_count INT DEFAULT 0,
ADD COLUMN IF NOT EXISTS date_paiement DATE;

-- Index pour la recherche rapide par Stripe ID
CREATE INDEX IF NOT EXISTS idx_invoices_stripe_pi ON public.invoices(stripe_payment_intent_id);
CREATE INDEX IF NOT EXISTS idx_invoices_stripe_session ON public.invoices(stripe_session_id);

COMMENT ON COLUMN public.invoices.stripe_payment_intent_id IS 'ID du Payment Intent Stripe lié';
COMMENT ON COLUMN public.invoices.stripe_session_id IS 'ID de la session Checkout Stripe liée';
COMMENT ON COLUMN public.invoices.last_reminder_sent_at IS 'Date du dernier email de relance envoyé';
COMMENT ON COLUMN public.invoices.reminder_count IS 'Nombre de relances déjà envoyées';
COMMENT ON COLUMN public.invoices.date_paiement IS 'Date effective à laquelle le paiement a été reçu';



-- ========== 20251231000008_fix_edl_signatures_schema.sql ==========
-- ============================================
-- Migration : Correction EDL_SIGNATURES schema
-- Date : 2025-12-31
-- Description : Rend signed_at nullable par défaut et ajoute signer_profile_id si manquant
-- ============================================

-- 1. Correction de signed_at (ne doit pas être NOW() par défaut)
ALTER TABLE public.edl_signatures 
ALTER COLUMN signed_at DROP DEFAULT,
ALTER COLUMN signed_at DROP NOT NULL;

-- 2. S'assurer que signer_profile_id existe (il semble déjà exister d'après le code mais par précaution)
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='edl_signatures' AND column_name='signer_profile_id') THEN
        ALTER TABLE public.edl_signatures ADD COLUMN signer_profile_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE;
    END IF;
END $$;

-- 3. Ajouter une contrainte d'unicité pour éviter les doublons de signataires par EDL
ALTER TABLE public.edl_signatures
DROP CONSTRAINT IF EXISTS edl_signatures_edl_id_signer_profile_id_key;

ALTER TABLE public.edl_signatures
ADD CONSTRAINT edl_signatures_edl_id_signer_profile_id_key UNIQUE(edl_id, signer_profile_id);

-- 4. Nettoyage des données : mettre à NULL les signed_at qui n'ont pas d'image de signature (probablement des faux-positifs du NOW() par défaut)
UPDATE public.edl_signatures 
SET signed_at = NULL 
WHERE signature_image_path IS NULL;



-- ========== 20251231000009_tenant_housing_passport.sql ==========
-- Refonte de la RPC tenant_dashboard pour inclure le Passeport du Logement (Fiche Technique)
-- SOTA 2025: Données enrichies, techniques et multi-baux

-- 1. S'assurer que les colonnes techniques existent dans properties
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'properties' AND column_name = 'annee_construction') THEN
    ALTER TABLE properties ADD COLUMN annee_construction INTEGER;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'properties' AND column_name = 'num_lot') THEN
    ALTER TABLE properties ADD COLUMN num_lot TEXT;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'properties' AND column_name = 'digicode') THEN
    ALTER TABLE properties ADD COLUMN digicode TEXT;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'properties' AND column_name = 'interphone') THEN
    ALTER TABLE properties ADD COLUMN interphone TEXT;
  END IF;
END $$;

-- 2. Recréer la RPC tenant_dashboard
CREATE OR REPLACE FUNCTION tenant_dashboard(p_tenant_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile_id UUID;
  v_leases JSONB;
  v_invoices JSONB;
  v_tickets JSONB;
  v_notifications JSONB;
  v_pending_edls JSONB;
  v_insurance_status JSONB;
  v_stats JSONB;
  v_result JSONB;
BEGIN
  -- 1. Récupérer l'ID du profil à partir du user_id
  SELECT id INTO v_profile_id
  FROM profiles
  WHERE user_id = p_tenant_user_id AND role = 'tenant';

  IF v_profile_id IS NULL THEN
    RETURN NULL;
  END IF;

  -- 2. Récupérer TOUS les baux (actifs ou en attente) avec données techniques enrichies
  SELECT jsonb_agg(lease_data) INTO v_leases
  FROM (
    SELECT 
      l.*,
      jsonb_build_object(
        'id', p.id,
        'adresse_complete', p.adresse_complete,
        'ville', p.ville,
        'code_postal', p.code_postal,
        'type', p.type,
        'surface', p.surface,
        'nb_pieces', p.nb_pieces,
        'etage', p.etage,
        'ascenseur', p.ascenseur,
        'annee_construction', p.annee_construction,
        'parking_numero', p.parking_numero,
        'cave_numero', p.has_cave, -- Utilisation de has_cave comme indicateur si cave_numero absent
        'num_lot', p.num_lot,
        'digicode', p.digicode,
        'interphone', p.interphone,
        'dpe_classe_energie', p.energie, -- energie dans initial_schema
        'dpe_classe_climat', p.ges,     -- ges dans initial_schema
        'cover_url', (SELECT url FROM photos WHERE property_id = p.id AND is_main = true LIMIT 1),
        -- Inclure les compteurs (meters)
        'meters', (
          SELECT jsonb_agg(m_data)
          FROM (
            SELECT 
              m.id, 
              m.type, 
              m.serial_number, 
              m.unit,
              (SELECT reading_value FROM meter_readings WHERE meter_id = m.id ORDER BY reading_date DESC LIMIT 1) as last_reading_value,
              (SELECT reading_date FROM meter_readings WHERE meter_id = m.id ORDER BY reading_date DESC LIMIT 1) as last_reading_date
            FROM meters m
            WHERE m.property_id = p.id AND m.is_active = true
          ) m_data
        ),
        -- Inclure un résumé des clés depuis le dernier EDL signé
        'keys', (
          SELECT jsonb_agg(key_data)
          FROM (
            SELECT 
              item_name as label,
              description as count_info
            FROM edl_items ei
            JOIN edl e ON e.id = ei.edl_id
            WHERE e.property_id = p.id 
            AND e.status = 'signed' 
            AND ei.category = 'cles'
            ORDER BY e.completed_date DESC
          ) key_data
        )
      ) as property,
      jsonb_build_object(
        'id', owner_prof.id,
        'name', concat(owner_prof.prenom, ' ', owner_prof.nom),
        'email', owner_prof.email
      ) as owner
    FROM leases l
    JOIN lease_signers ls ON ls.lease_id = l.id
    JOIN properties p ON p.id = l.property_id
    JOIN profiles owner_prof ON owner_prof.id = p.owner_id
    WHERE ls.profile_id = v_profile_id
    AND l.statut IN ('active', 'pending_signature', 'terminated')
    ORDER BY l.statut = 'active' DESC, l.created_at DESC
  ) lease_data;

  -- 3. Récupérer les factures (10 dernières)
  SELECT jsonb_agg(invoice_data) INTO v_invoices
  FROM (
    SELECT 
      i.*,
      p.type as property_type,
      p.adresse_complete as property_address
    FROM invoices i
    JOIN leases l ON l.id = i.lease_id
    JOIN properties p ON p.id = l.property_id
    WHERE i.tenant_id = v_profile_id
    ORDER BY i.periode DESC, i.created_at DESC
    LIMIT 10
  ) invoice_data;

  -- 4. Récupérer les tickets récents (10 derniers)
  SELECT jsonb_agg(ticket_data) INTO v_tickets
  FROM (
    SELECT 
      t.*,
      p.adresse_complete as property_address,
      p.type as property_type
    FROM tickets t
    JOIN properties p ON p.id = t.property_id
    WHERE t.created_by_profile_id = v_profile_id
    ORDER BY t.created_at DESC
    LIMIT 10
  ) ticket_data;

  -- 5. Récupérer les notifications récentes
  SELECT jsonb_agg(notif_data) INTO v_notifications
  FROM (
    SELECT n.*
    FROM notifications n
    WHERE n.profile_id = v_profile_id
    ORDER BY n.is_read ASC, n.created_at DESC
    LIMIT 5
  ) notif_data;

  -- 6. Récupérer les EDLs en attente de signature
  SELECT jsonb_agg(edl_data) INTO v_pending_edls
  FROM (
    SELECT 
      e.id,
      e.type,
      e.scheduled_at,
      es.invitation_token,
      p.adresse_complete as property_address,
      p.type as property_type
    FROM edl e
    JOIN edl_signatures es ON es.edl_id = e.id
    JOIN properties p ON p.id = e.property_id
    WHERE es.signer_profile_id = v_profile_id
    AND es.signed_at IS NULL
    AND e.status IN ('draft', 'scheduled', 'in_progress')
    ORDER BY e.created_at DESC
  ) edl_data;

  -- 7. Vérifier l'assurance pour les baux actifs
  SELECT jsonb_build_object(
    'has_insurance', EXISTS (
      SELECT 1 FROM documents 
      WHERE tenant_id = v_profile_id 
      AND type = 'attestation_assurance'
      AND is_archived = false
      AND (expiry_date IS NULL OR expiry_date > NOW())
    ),
    'last_expiry_date', (
      SELECT expiry_date FROM documents 
      WHERE tenant_id = v_profile_id 
      AND type = 'attestation_assurance' 
      AND is_archived = false
      ORDER BY expiry_date DESC LIMIT 1
    )
  ) INTO v_insurance_status;

  -- 8. Stats globales
  SELECT jsonb_build_object(
    'unpaid_amount', COALESCE(SUM(montant_total) FILTER (WHERE statut IN ('sent', 'late')), 0),
    'unpaid_count', COUNT(*) FILTER (WHERE statut IN ('sent', 'late')),
    'total_monthly_rent', COALESCE(SUM(loyer + charges_forfaitaires) FILTER (WHERE statut = 'active'), 0),
    'active_leases_count', COUNT(*) FILTER (WHERE statut = 'active')
  ) INTO v_stats
  FROM leases l
  JOIN lease_signers ls ON ls.lease_id = l.id
  LEFT JOIN invoices i ON i.lease_id = l.id AND i.tenant_id = v_profile_id
  WHERE ls.profile_id = v_profile_id;

  -- 9. Assembler le résultat
  v_result := jsonb_build_object(
    'profile_id', v_profile_id,
    'leases', COALESCE(v_leases, '[]'::jsonb),
    -- Rétro-compatibilité : premier bail
    'lease', CASE WHEN v_leases IS NOT NULL THEN v_leases->0 ELSE NULL END,
    -- Propriété principale pour rétro-compatibilité
    'property', CASE WHEN v_leases IS NOT NULL THEN (v_leases->0)->'property' ELSE NULL END,
    'invoices', COALESCE(v_invoices, '[]'::jsonb),
    'tickets', COALESCE(v_tickets, '[]'::jsonb),
    'notifications', COALESCE(v_notifications, '[]'::jsonb),
    'pending_edls', COALESCE(v_pending_edls, '[]'::jsonb),
    'insurance', v_insurance_status,
    'stats', COALESCE(v_stats, '{"unpaid_amount": 0, "unpaid_count": 0, "total_monthly_rent": 0, "active_leases_count": 0}'::jsonb)
  );

  RETURN v_result;
END;
$$;


-- ========== 20251231000010_export_system.sql ==========
-- Migration: 20251231000010_export_system.sql

DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'export_status') THEN
        CREATE TYPE export_status AS ENUM ('pending', 'processing', 'completed', 'failed', 'expired');
    END IF;
END $$;

CREATE TABLE IF NOT EXISTS export_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL, -- 'accounting', 'invoices', 'portability'
    format VARCHAR(10) NOT NULL, -- 'csv', 'json', 'xlsx'
    filters JSONB DEFAULT '{}',
    status export_status DEFAULT 'pending',
    storage_path TEXT,
    file_hash TEXT,
    record_count INTEGER DEFAULT 0,
    error_message TEXT,
    expires_at TIMESTAMPTZ NOT NULL DEFAULT (now() + interval '24 hours'),
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Index pour le cleanup
CREATE INDEX IF NOT EXISTS idx_export_jobs_expires_at ON export_jobs(expires_at) WHERE status != 'expired';

-- RLS
ALTER TABLE export_jobs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their own export jobs" ON export_jobs;
CREATE POLICY "Users can view their own export jobs"
    ON export_jobs FOR SELECT
    USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can create their own export jobs" ON export_jobs;
CREATE POLICY "Users can create their own export jobs"
    ON export_jobs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

-- Audit log table if not exists (checked from grep results)
CREATE TABLE IF NOT EXISTS audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    action TEXT NOT NULL,
    entity_type TEXT NOT NULL,
    entity_id UUID,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT now()
);

ALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins can view all audit logs" ON audit_log FOR SELECT USING (
    EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
);



-- ========== 20251231000011_export_cleanup.sql ==========
-- Migration: 20251231000011_export_cleanup.sql

-- 1. Fonction de nettoyage des jobs expirés
CREATE OR REPLACE FUNCTION cleanup_expired_exports()
RETURNS void AS $$
BEGIN
    -- Marquer comme expirés dans la DB
    UPDATE export_jobs
    SET status = 'expired'
    WHERE expires_at < now()
    AND status != 'expired';

    -- Note: La suppression physique des fichiers dans Storage 
    -- doit être gérée par une Edge Function ou via une policy de cycle de vie du bucket.
END;
$$ LANGUAGE plpgsql;

-- 2. Activation de pg_cron si disponible (nécessite permissions superuser)
-- SELECT cron.schedule('cleanup-exports', '0 0 * * *', 'SELECT cleanup_expired_exports()');



-- ========== 20260101000002_fix_tenant_dashboard_signers.sql ==========
-- Migration: Mise à jour de la RPC tenant_dashboard pour inclure les signataires des baux
-- Date: 2026-01-01

CREATE OR REPLACE FUNCTION tenant_dashboard(p_tenant_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile_id UUID;
  v_leases JSONB;
  v_invoices JSONB;
  v_tickets JSONB;
  v_notifications JSONB;
  v_pending_edls JSONB;
  v_insurance_status JSONB;
  v_stats JSONB;
  v_result JSONB;
BEGIN
  -- 1. Récupérer l'ID du profil à partir du user_id
  SELECT id INTO v_profile_id
  FROM profiles
  WHERE user_id = p_tenant_user_id AND role = 'tenant';

  IF v_profile_id IS NULL THEN
    RETURN NULL;
  END IF;

  -- 2. Récupérer TOUS les baux avec signataires et données techniques
  SELECT jsonb_agg(lease_data) INTO v_leases
  FROM (
    SELECT 
      l.*,
      -- Inclure les signataires du bail
      (
        SELECT jsonb_agg(ls_data)
        FROM (
          SELECT 
            ls.id,
            ls.profile_id,
            ls.role,
            ls.signature_status,
            ls.signed_at,
            p_sig.prenom,
            p_sig.nom,
            p_sig.avatar_url
          FROM lease_signers ls
          JOIN profiles p_sig ON p_sig.id = ls.profile_id
          WHERE ls.lease_id = l.id
        ) ls_data
      ) as lease_signers,
      jsonb_build_object(
        'id', p.id,
        'adresse_complete', p.adresse_complete,
        'ville', p.ville,
        'code_postal', p.code_postal,
        'type', p.type,
        'surface', p.surface,
        'nb_pieces', p.nb_pieces,
        'etage', p.etage,
        'ascenseur', p.ascenseur,
        'annee_construction', p.annee_construction,
        'parking_numero', p.parking_numero,
        'cave_numero', p.has_cave,
        'num_lot', p.num_lot,
        'digicode', p.digicode,
        'interphone', p.interphone,
        'dpe_classe_energie', p.energie,
        'dpe_classe_climat', p.ges,
        'cover_url', (SELECT url FROM photos WHERE property_id = p.id AND is_main = true LIMIT 1),
        'meters', (
          SELECT jsonb_agg(m_data)
          FROM (
            SELECT 
              m.id, 
              m.type, 
              m.serial_number, 
              m.unit,
              (SELECT reading_value FROM meter_readings WHERE meter_id = m.id ORDER BY reading_date DESC LIMIT 1) as last_reading_value,
              (SELECT reading_date FROM meter_readings WHERE meter_id = m.id ORDER BY reading_date DESC LIMIT 1) as last_reading_date
            FROM meters m
            WHERE m.property_id = p.id AND m.is_active = true
          ) m_data
        ),
        'keys', (
          SELECT jsonb_agg(key_data)
          FROM (
            SELECT 
              item_name as label,
              description as count_info
            FROM edl_items ei
            JOIN edl e ON e.id = ei.edl_id
            WHERE e.property_id = p.id 
            AND e.status = 'signed' 
            AND ei.category = 'cles'
            ORDER BY e.completed_date DESC
          ) key_data
        )
      ) as property,
      jsonb_build_object(
        'id', owner_prof.id,
        'name', concat(owner_prof.prenom, ' ', owner_prof.nom),
        'email', owner_prof.email
      ) as owner
    FROM leases l
    JOIN lease_signers ls ON ls.lease_id = l.id
    JOIN properties p ON p.id = l.property_id
    JOIN profiles owner_prof ON owner_prof.id = p.owner_id
    WHERE ls.profile_id = v_profile_id
    AND l.statut IN ('active', 'pending_signature', 'terminated')
    ORDER BY l.statut = 'active' DESC, l.created_at DESC
  ) lease_data;

  -- 3. Récupérer les factures (10 dernières)
  SELECT jsonb_agg(invoice_data) INTO v_invoices
  FROM (
    SELECT 
      i.*,
      p.type as property_type,
      p.adresse_complete as property_address
    FROM invoices i
    JOIN leases l ON l.id = i.lease_id
    JOIN properties p ON p.id = l.property_id
    WHERE i.tenant_id = v_profile_id
    ORDER BY i.periode DESC, i.created_at DESC
    LIMIT 10
  ) invoice_data;

  -- 4. Récupérer les tickets récents (10 derniers)
  SELECT jsonb_agg(ticket_data) INTO v_tickets
  FROM (
    SELECT 
      t.*,
      p.adresse_complete as property_address,
      p.type as property_type
    FROM tickets t
    JOIN properties p ON p.id = t.property_id
    WHERE t.created_by_profile_id = v_profile_id
    ORDER BY t.created_at DESC
    LIMIT 10
  ) ticket_data;

  -- 5. Récupérer les notifications récentes
  SELECT jsonb_agg(notif_data) INTO v_notifications
  FROM (
    SELECT n.*
    FROM notifications n
    WHERE n.profile_id = v_profile_id
    ORDER BY n.is_read ASC, n.created_at DESC
    LIMIT 5
  ) notif_data;

  -- 6. Récupérer les EDLs en attente de signature
  SELECT jsonb_agg(edl_data) INTO v_pending_edls
  FROM (
    SELECT 
      e.id,
      e.type,
      e.scheduled_at,
      es.invitation_token,
      p.adresse_complete as property_address,
      p.type as property_type
    FROM edl e
    JOIN edl_signatures es ON es.edl_id = e.id
    JOIN properties p ON p.id = e.property_id
    WHERE es.signer_profile_id = v_profile_id
    AND es.signed_at IS NULL
    AND e.status IN ('draft', 'scheduled', 'in_progress')
    ORDER BY e.created_at DESC
  ) edl_data;

  -- 7. Vérifier l'assurance
  SELECT jsonb_build_object(
    'has_insurance', EXISTS (
      SELECT 1 FROM documents 
      WHERE tenant_id = v_profile_id 
      AND type = 'attestation_assurance'
      AND is_archived = false
      AND (expiry_date IS NULL OR expiry_date > NOW())
    ),
    'last_expiry_date', (
      SELECT expiry_date FROM documents 
      WHERE tenant_id = v_profile_id 
      AND type = 'attestation_assurance' 
      AND is_archived = false
      ORDER BY expiry_date DESC LIMIT 1
    )
  ) INTO v_insurance_status;

  -- 8. Stats globales
  SELECT jsonb_build_object(
    'unpaid_amount', COALESCE(SUM(montant_total) FILTER (WHERE statut IN ('sent', 'late')), 0),
    'unpaid_count', COUNT(*) FILTER (WHERE statut IN ('sent', 'late')),
    'total_monthly_rent', COALESCE(SUM(loyer + charges_forfaitaires) FILTER (WHERE statut = 'active'), 0),
    'active_leases_count', COUNT(*) FILTER (WHERE statut = 'active')
  ) INTO v_stats
  FROM leases l
  JOIN lease_signers ls ON ls.lease_id = l.id
  LEFT JOIN invoices i ON i.lease_id = l.id AND i.tenant_id = v_profile_id
  WHERE ls.profile_id = v_profile_id;

  -- 9. Assembler le résultat
  v_result := jsonb_build_object(
    'profile_id', v_profile_id,
    'leases', COALESCE(v_leases, '[]'::jsonb),
    'lease', CASE WHEN v_leases IS NOT NULL THEN v_leases->0 ELSE NULL END,
    'property', CASE WHEN v_leases IS NOT NULL THEN (v_leases->0)->'property' ELSE NULL END,
    'invoices', COALESCE(v_invoices, '[]'::jsonb),
    'tickets', COALESCE(v_tickets, '[]'::jsonb),
    'notifications', COALESCE(v_notifications, '[]'::jsonb),
    'pending_edls', COALESCE(v_pending_edls, '[]'::jsonb),
    'insurance', v_insurance_status,
    'stats', COALESCE(v_stats, '{"unpaid_amount": 0, "unpaid_count": 0, "total_monthly_rent": 0, "active_leases_count": 0}'::jsonb)
  );

  RETURN v_result;
END;
$$;



-- ========== 20260101000002a_add_invited_email_to_signers.sql ==========
-- Migration : Ajouter les colonnes invited_email et invited_name à lease_signers
-- Ces colonnes sont nécessaires pour le flux d'invitation des locataires

-- 1. Rendre profile_id nullable (pour permettre les invitations avant création de compte)
ALTER TABLE lease_signers 
  ALTER COLUMN profile_id DROP NOT NULL;

-- 2. Ajouter les colonnes d'invitation
ALTER TABLE lease_signers 
  ADD COLUMN IF NOT EXISTS invited_email TEXT,
  ADD COLUMN IF NOT EXISTS invited_name TEXT;

-- 3. Créer un index sur invited_email pour les recherches rapides
CREATE INDEX IF NOT EXISTS idx_lease_signers_invited_email 
  ON lease_signers(invited_email) 
  WHERE invited_email IS NOT NULL;

-- 4. Modifier la contrainte unique pour permettre soit profile_id soit invited_email
-- D'abord supprimer l'ancienne contrainte
ALTER TABLE lease_signers 
  DROP CONSTRAINT IF EXISTS lease_signers_lease_id_profile_id_key;

-- 5. Ajouter une nouvelle contrainte qui vérifie la cohérence
-- Un signataire doit avoir soit un profile_id, soit un invited_email
ALTER TABLE lease_signers 
  ADD CONSTRAINT lease_signers_has_identity 
  CHECK (profile_id IS NOT NULL OR invited_email IS NOT NULL);

-- 6. Créer un index unique partiel pour éviter les doublons
CREATE UNIQUE INDEX IF NOT EXISTS idx_lease_signers_unique_profile 
  ON lease_signers(lease_id, profile_id) 
  WHERE profile_id IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS idx_lease_signers_unique_email 
  ON lease_signers(lease_id, invited_email) 
  WHERE invited_email IS NOT NULL AND profile_id IS NULL;

-- 7. Mettre à jour les RLS pour permettre aux propriétaires de voir les signataires invités
DROP POLICY IF EXISTS "lease_signers_owner_view_invited" ON lease_signers;
CREATE POLICY "lease_signers_owner_view_invited" ON lease_signers
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties prop ON prop.id = l.property_id
      JOIN profiles owner_p ON owner_p.id = prop.owner_id
      WHERE l.id = lease_signers.lease_id 
        AND owner_p.user_id = auth.uid()
    )
  );

-- 8. Créer un trigger pour lier automatiquement profile_id quand le locataire crée son compte
CREATE OR REPLACE FUNCTION public.auto_link_signer_profile()
RETURNS TRIGGER AS $$
BEGIN
  -- Quand un profil est créé, chercher les invitations par email
  UPDATE lease_signers ls
  SET profile_id = NEW.id,
      updated_at = NOW()
  FROM auth.users u
  WHERE u.id = NEW.user_id
    AND ls.invited_email = u.email
    AND ls.profile_id IS NULL;
    
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_profile_created_auto_link ON profiles;
CREATE TRIGGER on_profile_created_auto_link
  AFTER INSERT ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.auto_link_signer_profile();

COMMENT ON COLUMN lease_signers.invited_email IS 'Email du locataire invité avant création de son compte';
COMMENT ON COLUMN lease_signers.invited_name IS 'Nom du locataire invité (optionnel)';



-- ========== 20260101000003_make_lease_signers_profile_nullable.sql ==========
-- =====================================================
-- Migration: Ajouter contrainte CHECK et index pour signataires invités
-- Date: 2026-01-02
-- =====================================================
-- Complète la migration 20251221000003 qui rend profile_id nullable
-- Ajoute une contrainte CHECK et un index pour optimiser les requêtes
-- =====================================================

BEGIN;

-- 1. Vérifier si profile_id est déjà nullable (idempotent)
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'lease_signers' 
    AND column_name = 'profile_id'
    AND is_nullable = 'NO'
  ) THEN
    ALTER TABLE lease_signers 
      ALTER COLUMN profile_id DROP NOT NULL;
  END IF;
END $$;

-- 2. Ajouter la contrainte CHECK pour s'assurer qu'on a soit profile_id, soit invited_email
-- (idempotent - vérifie si la contrainte existe déjà)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint 
    WHERE conname = 'lease_signers_profile_or_email_check'
  ) THEN
    ALTER TABLE lease_signers
      ADD CONSTRAINT lease_signers_profile_or_email_check 
      CHECK (
        (profile_id IS NOT NULL) OR 
        (invited_email IS NOT NULL)
      );
  END IF;
END $$;

-- 3. Ajouter un index partiel pour les signataires invités (sans profile_id)
CREATE INDEX IF NOT EXISTS idx_lease_signers_invited 
ON lease_signers(lease_id, invited_email) 
WHERE profile_id IS NULL AND invited_email IS NOT NULL;

-- 4. Commentaires pour documentation
COMMENT ON COLUMN lease_signers.profile_id IS 
  'ID du profil (NULL si le signataire n''a pas encore créé son compte)';
COMMENT ON COLUMN lease_signers.invited_email IS 
  'Email d''invitation (requis si profile_id est NULL)';

COMMIT;



-- ========== 20260101000004_add_edl_signatures_email.sql ==========
-- =====================================================
-- Migration: Ajouter signer_email à edl_signatures
-- Date: 2026-01-02
-- =====================================================
-- Permet de créer des signatures EDL avec invited_email
-- avant que le signataire n'ait créé son compte
-- =====================================================

BEGIN;

-- Ajouter la colonne signer_email si elle n'existe pas
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'edl_signatures' 
        AND column_name = 'signer_email'
    ) THEN
        ALTER TABLE public.edl_signatures 
        ADD COLUMN signer_email VARCHAR(255);
        
        COMMENT ON COLUMN public.edl_signatures.signer_email IS 
            'Email du signataire (utilisé si signer_profile_id est NULL pour les invitations)';
    END IF;
END $$;

-- Rendre signer_profile_id nullable si ce n'est pas déjà fait
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'edl_signatures' 
        AND column_name = 'signer_profile_id'
        AND is_nullable = 'NO'
    ) THEN
        ALTER TABLE public.edl_signatures 
        ALTER COLUMN signer_profile_id DROP NOT NULL;
    END IF;
END $$;

-- Rendre signer_user nullable si ce n'est pas déjà fait (pour les invitations)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'edl_signatures' 
        AND column_name = 'signer_user'
        AND is_nullable = 'NO'
    ) THEN
        -- Supprimer la contrainte FK d'abord si elle existe
        ALTER TABLE public.edl_signatures 
        DROP CONSTRAINT IF EXISTS edl_signatures_signer_user_fkey;
        
        ALTER TABLE public.edl_signatures 
        ALTER COLUMN signer_user DROP NOT NULL;
        
        -- Recréer la FK mais sans NOT NULL
        ALTER TABLE public.edl_signatures
        ADD CONSTRAINT edl_signatures_signer_user_fkey 
        FOREIGN KEY (signer_user) 
        REFERENCES auth.users(id) 
        ON DELETE CASCADE;
    END IF;
END $$;

-- Ajouter une contrainte CHECK pour s'assurer qu'on a soit signer_profile_id, soit signer_email
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'edl_signatures_profile_or_email_check'
    ) THEN
        ALTER TABLE public.edl_signatures
        ADD CONSTRAINT edl_signatures_profile_or_email_check 
        CHECK (
            (signer_profile_id IS NOT NULL) OR 
            (signer_email IS NOT NULL)
        );
    END IF;
END $$;

-- Index pour rechercher par email
CREATE INDEX IF NOT EXISTS idx_edl_signatures_signer_email 
ON public.edl_signatures(signer_email) 
WHERE signer_email IS NOT NULL;

-- Modifier la contrainte UNIQUE existante pour permettre plusieurs NULL
-- Supprimer l'ancienne contrainte si elle existe
ALTER TABLE public.edl_signatures
DROP CONSTRAINT IF EXISTS edl_signatures_edl_id_signer_profile_id_key;

-- Créer une contrainte UNIQUE partielle qui ne s'applique que si signer_profile_id n'est pas NULL
-- Cela permet plusieurs lignes avec signer_profile_id = NULL pour le même edl_id
CREATE UNIQUE INDEX IF NOT EXISTS edl_signatures_edl_id_signer_profile_id_unique
ON public.edl_signatures(edl_id, signer_profile_id)
WHERE signer_profile_id IS NOT NULL;

-- Créer une contrainte UNIQUE pour signer_email (un seul signataire invité par email par EDL)
CREATE UNIQUE INDEX IF NOT EXISTS edl_signatures_edl_id_signer_email_unique
ON public.edl_signatures(edl_id, signer_email)
WHERE signer_email IS NOT NULL;

COMMIT;



-- ========== 20260101000005_edl_signatures_invited_columns.sql ==========
-- =====================================================
-- Migration: Colonnes d'invitation pour edl_signatures
-- Date: 2026-01-01
-- =====================================================
-- Permet de stocker les informations des signataires invités sans compte

BEGIN;

-- 1. Rendre signer_profile_id et signer_user nullable
ALTER TABLE public.edl_signatures 
  ALTER COLUMN signer_profile_id DROP NOT NULL;

-- signer_user peut aussi être NULL pour les invités
DO $$
BEGIN
    ALTER TABLE public.edl_signatures 
      ALTER COLUMN signer_user DROP NOT NULL;
EXCEPTION
    WHEN others THEN NULL;
END $$;

-- 2. Ajouter la colonne signer_email si elle n'existe pas
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'edl_signatures' 
        AND column_name = 'signer_email'
    ) THEN
        ALTER TABLE public.edl_signatures 
        ADD COLUMN signer_email VARCHAR(255);
        
        COMMENT ON COLUMN public.edl_signatures.signer_email IS 
            'Email du signataire (utilisé si signer_profile_id est NULL pour les invitations)';
    END IF;
END $$;

-- 3. Ajouter la colonne signer_name si elle n'existe pas
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'edl_signatures' 
        AND column_name = 'signer_name'
    ) THEN
        ALTER TABLE public.edl_signatures 
        ADD COLUMN signer_name VARCHAR(255);
        
        COMMENT ON COLUMN public.edl_signatures.signer_name IS 
            'Nom du signataire (stocké directement ou extrait du profil)';
    END IF;
END $$;

-- 4. Index pour rechercher par email
CREATE INDEX IF NOT EXISTS idx_edl_signatures_signer_email 
ON public.edl_signatures(signer_email) 
WHERE signer_email IS NOT NULL;

-- 5. Modifier la contrainte UNIQUE existante pour permettre plusieurs NULL
-- Supprimer l'ancienne contrainte si elle existe
ALTER TABLE public.edl_signatures 
DROP CONSTRAINT IF EXISTS edl_signatures_edl_id_signer_profile_id_key;

-- Créer une contrainte UNIQUE partielle (uniquement pour signer_profile_id non-NULL)
CREATE UNIQUE INDEX IF NOT EXISTS edl_signatures_edl_id_signer_profile_id_unique
ON public.edl_signatures(edl_id, signer_profile_id)
WHERE signer_profile_id IS NOT NULL;

-- Créer une contrainte UNIQUE pour signer_email (un seul signataire invité par email par EDL)
CREATE UNIQUE INDEX IF NOT EXISTS edl_signatures_edl_id_signer_email_unique
ON public.edl_signatures(edl_id, signer_email)
WHERE signer_email IS NOT NULL;

COMMIT;



-- ========== 20260102000006_fix_edl_signatures_schema.sql ==========
-- Migration : Correction du schéma edl_signatures pour supporter les invitations et le profil
-- Date: 2026-01-02

BEGIN;

-- 1. Ajouter les colonnes manquantes à edl_signatures
ALTER TABLE edl_signatures 
  ADD COLUMN IF NOT EXISTS signer_profile_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
  ADD COLUMN IF NOT EXISTS invitation_token UUID DEFAULT uuid_generate_v4(),
  ADD COLUMN IF NOT EXISTS invitation_sent_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

-- 2. Rendre signer_user nullable (car on peut inviter avant que le compte existe)
ALTER TABLE edl_signatures ALTER COLUMN signer_user DROP NOT NULL;

-- 3. Rendre signed_at nullable (car une invitation n'est pas encore une signature)
ALTER TABLE edl_signatures ALTER COLUMN signed_at DROP NOT NULL;
ALTER TABLE edl_signatures ALTER COLUMN signed_at DROP DEFAULT;

-- 4. Ajouter des index pour les performances
CREATE INDEX IF NOT EXISTS idx_edl_signatures_signer_profile_id ON edl_signatures(signer_profile_id);
CREATE INDEX IF NOT EXISTS idx_edl_signatures_invitation_token ON edl_signatures(invitation_token);

-- 5. Mettre à jour les RLS pour permettre l'accès via invitation_token
DROP POLICY IF EXISTS "EDL signatures via token" ON edl_signatures;
CREATE POLICY "EDL signatures via token" ON edl_signatures
  FOR SELECT USING (true); -- On restreindra davantage si besoin, mais permet la lecture pour signature

COMMIT;



-- ========== 20260102000007_auto_activate_leases.sql ==========
-- Migration : Activation automatique des baux et synchronisation finale
-- Date: 2026-01-02

BEGIN;

-- 1. Fonction pour activer le bail si tous les signataires ont signé
CREATE OR REPLACE FUNCTION public.check_and_activate_lease()
RETURNS TRIGGER AS $$
DECLARE
    v_total_signers INTEGER;
    v_signed_count INTEGER;
BEGIN
    -- Compter le nombre de signataires requis
    SELECT COUNT(*) INTO v_total_signers
    FROM lease_signers
    WHERE lease_id = NEW.lease_id;

    -- Compter le nombre de signatures effectuées
    SELECT COUNT(*) INTO v_signed_count
    FROM lease_signers
    WHERE lease_id = NEW.lease_id
    AND signature_status = 'signed';

    -- Si tout le monde a signé (et qu'il y a au moins 2 personnes: proprio + locataire)
    IF v_total_signers >= 2 AND v_signed_count = v_total_signers THEN
        UPDATE leases
        SET statut = 'active',
            updated_at = NOW()
        WHERE id = NEW.lease_id
        AND statut = 'pending_signature';
        
        RAISE NOTICE 'Bail % activé automatiquement', NEW.lease_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. Trigger sur lease_signers
DROP TRIGGER IF EXISTS tr_check_activate_lease ON lease_signers;
CREATE TRIGGER tr_check_activate_lease
AFTER UPDATE OF signature_status ON lease_signers
FOR EACH ROW
WHEN (NEW.signature_status = 'signed')
EXECUTE FUNCTION public.check_and_activate_lease();

-- 3. Réparer les baux existants qui devraient être actifs
UPDATE leases l
SET statut = 'active',
    updated_at = NOW()
WHERE statut = 'pending_signature'
AND (
    SELECT COUNT(*) 
    FROM lease_signers ls 
    WHERE ls.lease_id = l.id
) >= 2
AND NOT EXISTS (
    SELECT 1 
    FROM lease_signers ls 
    WHERE ls.lease_id = l.id 
    AND ls.signature_status != 'signed'
);

COMMIT;



-- ========== 20260102000020_fix_pending_edls_query.sql ==========
-- Migration: Corriger la requête pending_edls dans tenant_dashboard
-- Date: 2026-01-02
-- 
-- PROBLÈME: La RPC utilise es.signer_email qui n'existe pas dans edl_signatures
-- SOLUTION: Chercher par signer_profile_id uniquement, ou joindre via profiles

CREATE OR REPLACE FUNCTION tenant_dashboard(p_tenant_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile_id UUID;
  v_user_email TEXT;
  v_tenant_data JSONB;
  v_leases JSONB;
  v_invoices JSONB;
  v_tickets JSONB;
  v_notifications JSONB;
  v_pending_edls JSONB;
  v_insurance_status JSONB;
  v_stats JSONB;
  v_result JSONB;
BEGIN
  -- 1. Récupérer l'ID du profil ET l'email de l'utilisateur
  SELECT p.id, u.email, 
         jsonb_build_object(
           'id', p.id,
           'prenom', p.prenom,
           'nom', p.nom,
           'email', u.email,
           'telephone', p.telephone,
           'avatar_url', p.avatar_url
         )
  INTO v_profile_id, v_user_email, v_tenant_data
  FROM profiles p
  JOIN auth.users u ON u.id = p.user_id
  WHERE p.user_id = p_tenant_user_id AND p.role = 'tenant';

  IF v_profile_id IS NULL THEN
    RAISE NOTICE '[tenant_dashboard] Aucun profil trouvé pour user_id: %', p_tenant_user_id;
    RETURN NULL;
  END IF;

  RAISE NOTICE '[tenant_dashboard] Profil trouvé: %, email: %', v_profile_id, v_user_email;

  -- 2. Récupérer TOUS les baux
  SELECT jsonb_agg(lease_data ORDER BY lease_data->>'statut' = 'active' DESC, lease_data->>'created_at' DESC) 
  INTO v_leases
  FROM (
    SELECT 
      jsonb_build_object(
        'id', l.id,
        'type_bail', l.type_bail,
        'statut', l.statut,
        'loyer', l.loyer,
        'charges_forfaitaires', l.charges_forfaitaires,
        'depot_de_garantie', l.depot_de_garantie,
        'date_debut', l.date_debut,
        'date_fin', l.date_fin,
        'created_at', l.created_at,
        'signers', (
          SELECT COALESCE(jsonb_agg(
            jsonb_build_object(
              'id', ls2.id,
              'profile_id', ls2.profile_id,
              'role', ls2.role,
              'signature_status', ls2.signature_status,
              'signed_at', ls2.signed_at,
              'invited_name', ls2.invited_name,
              'invited_email', ls2.invited_email,
              'prenom', COALESCE(p_sig.prenom, SPLIT_PART(ls2.invited_name, ' ', 1)),
              'nom', COALESCE(p_sig.nom, SPLIT_PART(ls2.invited_name, ' ', 2)),
              'avatar_url', p_sig.avatar_url
            )
          ), '[]'::jsonb)
          FROM lease_signers ls2
          LEFT JOIN profiles p_sig ON p_sig.id = ls2.profile_id
          WHERE ls2.lease_id = l.id
        ),
        'property', jsonb_build_object(
          'id', p.id,
          'adresse_complete', COALESCE(p.adresse_complete, 'Adresse à compléter'),
          'ville', COALESCE(p.ville, ''),
          'code_postal', COALESCE(p.code_postal, ''),
          'type', COALESCE(p.type, 'appartement'),
          'surface', p.surface,
          'nb_pieces', p.nb_pieces,
          'etage', p.etage,
          'ascenseur', p.ascenseur,
          'annee_construction', p.annee_construction,
          'parking_numero', p.parking_numero,
          'has_cave', p.has_cave,
          'num_lot', p.num_lot,
          'digicode', p.digicode,
          'interphone', p.interphone,
          'dpe_classe_energie', COALESCE(p.energie, p.dpe_classe_energie),
          'dpe_classe_climat', COALESCE(p.ges, p.dpe_classe_climat),
          'chauffage_type', p.chauffage_type,
          'eau_chaude_type', p.eau_chaude_type,
          'cover_url', (
            SELECT url FROM property_photos 
            WHERE property_id = p.id AND is_main = true 
            LIMIT 1
          ),
          'meters', (
            SELECT COALESCE(jsonb_agg(
              jsonb_build_object(
                'id', m.id, 
                'type', m.type, 
                'serial_number', m.serial_number, 
                'unit', m.unit,
                'last_reading_value', (
                  SELECT reading_value FROM meter_readings 
                  WHERE meter_id = m.id ORDER BY reading_date DESC LIMIT 1
                ),
                'last_reading_date', (
                  SELECT reading_date FROM meter_readings 
                  WHERE meter_id = m.id ORDER BY reading_date DESC LIMIT 1
                )
              )
            ), '[]'::jsonb)
            FROM meters m
            WHERE m.property_id = p.id AND m.is_active = true
          )
        ),
        'owner', jsonb_build_object(
          'id', owner_prof.id,
          'name', COALESCE(
            (SELECT raison_sociale FROM owner_profiles WHERE profile_id = owner_prof.id),
            CONCAT(owner_prof.prenom, ' ', owner_prof.nom)
          ),
          'email', owner_prof.email,
          'telephone', owner_prof.telephone
        )
      ) as lease_data
    FROM leases l
    JOIN lease_signers ls ON ls.lease_id = l.id
    JOIN properties p ON p.id = l.property_id
    JOIN profiles owner_prof ON owner_prof.id = p.owner_id
    WHERE 
      (ls.profile_id = v_profile_id OR LOWER(ls.invited_email) = LOWER(v_user_email))
      AND l.statut IN ('active', 'pending_signature', 'fully_signed', 'terminated')
  ) sub;

  RAISE NOTICE '[tenant_dashboard] Baux trouvés: %', COALESCE(jsonb_array_length(v_leases), 0);

  -- 3. Récupérer les factures (10 dernières)
  SELECT COALESCE(jsonb_agg(invoice_data), '[]'::jsonb) INTO v_invoices
  FROM (
    SELECT 
      i.id,
      i.periode,
      i.montant_total,
      i.statut,
      i.created_at,
      i.due_date,
      p.type as property_type,
      p.adresse_complete as property_address
    FROM invoices i
    JOIN leases l ON l.id = i.lease_id
    JOIN lease_signers ls ON ls.lease_id = l.id
    JOIN properties p ON p.id = l.property_id
    WHERE (ls.profile_id = v_profile_id OR LOWER(ls.invited_email) = LOWER(v_user_email))
    ORDER BY i.periode DESC, i.created_at DESC
    LIMIT 10
  ) invoice_data;

  -- 4. Récupérer les tickets récents (10 derniers)
  SELECT COALESCE(jsonb_agg(ticket_data), '[]'::jsonb) INTO v_tickets
  FROM (
    SELECT 
      t.id,
      t.titre,
      t.description,
      t.priorite,
      t.statut,
      t.created_at,
      p.adresse_complete as property_address,
      p.type as property_type
    FROM tickets t
    JOIN properties p ON p.id = t.property_id
    WHERE t.created_by_profile_id = v_profile_id
    ORDER BY t.created_at DESC
    LIMIT 10
  ) ticket_data;

  -- 5. Récupérer les notifications récentes
  SELECT COALESCE(jsonb_agg(notif_data), '[]'::jsonb) INTO v_notifications
  FROM (
    SELECT n.id, n.title, n.message, n.type, n.is_read, n.created_at, n.action_url
    FROM notifications n
    WHERE n.profile_id = v_profile_id
    ORDER BY n.is_read ASC, n.created_at DESC
    LIMIT 5
  ) notif_data;

  -- 6. ✅ FIX: Récupérer les EDLs en attente de signature (sans signer_email)
  SELECT COALESCE(jsonb_agg(edl_data), '[]'::jsonb) INTO v_pending_edls
  FROM (
    SELECT 
      e.id,
      e.type,
      e.status,
      e.scheduled_at,
      es.invitation_token,
      COALESCE(p.adresse_complete, 'Adresse non renseignée') as property_address,
      COALESCE(p.type, 'appartement') as property_type
    FROM edl e
    JOIN edl_signatures es ON es.edl_id = e.id
    LEFT JOIN properties p ON p.id = e.property_id
    WHERE es.signer_profile_id = v_profile_id
      AND es.signed_at IS NULL
      AND e.status IN ('draft', 'scheduled', 'in_progress', 'completed')
    ORDER BY e.created_at DESC
  ) edl_data;

  RAISE NOTICE '[tenant_dashboard] EDLs en attente: %', COALESCE(jsonb_array_length(v_pending_edls), 0);

  -- 7. Vérifier l'assurance
  SELECT jsonb_build_object(
    'has_insurance', EXISTS (
      SELECT 1 FROM documents 
      WHERE tenant_id = v_profile_id 
      AND type = 'attestation_assurance'
      AND is_archived = false
      AND (expiry_date IS NULL OR expiry_date > NOW())
    ),
    'last_expiry_date', (
      SELECT expiry_date FROM documents 
      WHERE tenant_id = v_profile_id 
      AND type = 'attestation_assurance' 
      AND is_archived = false
      ORDER BY expiry_date DESC LIMIT 1
    )
  ) INTO v_insurance_status;

  -- 8. Stats globales
  SELECT jsonb_build_object(
    'unpaid_amount', COALESCE(SUM(i.montant_total) FILTER (WHERE i.statut IN ('sent', 'late')), 0),
    'unpaid_count', COUNT(*) FILTER (WHERE i.statut IN ('sent', 'late')),
    'total_monthly_rent', COALESCE(
      (SELECT SUM(l2.loyer + l2.charges_forfaitaires) 
       FROM leases l2 
       JOIN lease_signers ls2 ON ls2.lease_id = l2.id 
       WHERE (ls2.profile_id = v_profile_id OR LOWER(ls2.invited_email) = LOWER(v_user_email))
       AND l2.statut = 'active'), 
      0
    ),
    'active_leases_count', (
      SELECT COUNT(DISTINCT l2.id) 
      FROM leases l2 
      JOIN lease_signers ls2 ON ls2.lease_id = l2.id 
      WHERE (ls2.profile_id = v_profile_id OR LOWER(ls2.invited_email) = LOWER(v_user_email))
      AND l2.statut = 'active'
    )
  ) INTO v_stats
  FROM leases l
  JOIN lease_signers ls ON ls.lease_id = l.id
  LEFT JOIN invoices i ON i.lease_id = l.id
  WHERE (ls.profile_id = v_profile_id OR LOWER(ls.invited_email) = LOWER(v_user_email));

  -- 9. Assembler le résultat final
  v_result := jsonb_build_object(
    'profile_id', v_profile_id,
    'tenant', v_tenant_data,
    'kyc_status', COALESCE((SELECT kyc_status FROM tenant_profiles WHERE profile_id = v_profile_id), 'pending'),
    'leases', COALESCE(v_leases, '[]'::jsonb),
    'lease', CASE WHEN v_leases IS NOT NULL AND jsonb_array_length(v_leases) > 0 THEN v_leases->0 ELSE NULL END,
    'property', CASE WHEN v_leases IS NOT NULL AND jsonb_array_length(v_leases) > 0 THEN (v_leases->0)->'property' ELSE NULL END,
    'invoices', v_invoices,
    'tickets', v_tickets,
    'notifications', v_notifications,
    'pending_edls', v_pending_edls,
    'insurance', v_insurance_status,
    'stats', COALESCE(v_stats, '{"unpaid_amount": 0, "unpaid_count": 0, "total_monthly_rent": 0, "active_leases_count": 0}'::jsonb)
  );

  RETURN v_result;
END;
$$;

COMMENT ON FUNCTION tenant_dashboard(UUID) IS 
'RPC pour le tableau de bord locataire. Version corrigée sans signer_email.';



-- ========== 20260103000005_enhance_owner_dashboard_edl.sql ==========
-- Enhance owner_dashboard RPC to include EDL stats and pending signatures for the owner

CREATE OR REPLACE FUNCTION owner_dashboard(p_owner_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result JSONB;
BEGIN
  -- Vérifier que l'utilisateur est bien le propriétaire
  IF NOT EXISTS (
    SELECT 1 FROM profiles 
    WHERE id = p_owner_id 
    AND role = 'owner'
    AND user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'Accès non autorisé';
  END IF;

  SELECT jsonb_build_object(
    'properties', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', p.id,
          'ref', p.unique_code,
          'adresse', p.adresse_complete,
          'statut', p.etat,
          'type', p.type,
          'surface', p.surface,
          'nb_pieces', p.nb_pieces,
          'created_at', p.created_at,
          'updated_at', p.updated_at
        )
      )
      FROM properties p
      WHERE p.owner_id = p_owner_id
    ),
    'properties_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'active', COUNT(*) FILTER (WHERE etat = 'published'),
        'draft', COUNT(*) FILTER (WHERE etat = 'draft')
      )
      FROM properties
      WHERE owner_id = p_owner_id
    ),
    'leases', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', l.id,
          'property_id', l.property_id,
          'type_bail', l.type_bail,
          'loyer', l.loyer,
          'date_debut', l.date_debut,
          'date_fin', l.date_fin,
          'statut', l.statut,
          'created_at', l.created_at
        )
      )
      FROM leases l
      INNER JOIN properties p ON p.id = l.property_id
      WHERE p.owner_id = p_owner_id
    ),
    'leases_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'active', COUNT(*) FILTER (WHERE l.statut = 'active'),
        'pending', COUNT(*) FILTER (WHERE l.statut = 'pending_signature')
      )
      FROM leases l
      INNER JOIN properties p ON p.id = l.property_id
      WHERE p.owner_id = p_owner_id
    ),
    'edl_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'pending_owner_signature', COUNT(*) FILTER (
          WHERE e.status = 'completed' AND NOT EXISTS (
            SELECT 1 FROM edl_signatures es 
            WHERE es.edl_id = e.id 
            AND es.signer_role = 'owner' 
            AND es.signed_at IS NOT NULL
          )
        )
      )
      FROM edl e
      INNER JOIN leases l ON l.id = e.lease_id
      INNER JOIN properties p ON p.id = l.property_id
      WHERE p.owner_id = p_owner_id
    ),
    'invoices', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', i.id,
          'lease_id', i.lease_id,
          'periode', i.periode,
          'montant_total', i.montant_total,
          'statut', i.statut,
          'created_at', i.created_at
        )
      )
      FROM invoices i
      WHERE i.owner_id = p_owner_id
      ORDER BY i.created_at DESC
      LIMIT 10
    ),
    'invoices_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'paid', COUNT(*) FILTER (WHERE statut = 'paid'),
        'pending', COUNT(*) FILTER (WHERE statut = 'sent'),
        'late', COUNT(*) FILTER (WHERE statut = 'late')
      )
      FROM invoices
      WHERE owner_id = p_owner_id
    ),
    'tickets', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', t.id,
          'property_id', t.property_id,
          'titre', t.titre,
          'priorite', t.priorite,
          'statut', t.statut,
          'created_at', t.created_at
        )
      )
      FROM tickets t
      INNER JOIN properties p ON p.id = t.property_id
      WHERE p.owner_id = p_owner_id
      ORDER BY t.created_at DESC
      LIMIT 10
    ),
    'tickets_stats', (
      SELECT jsonb_build_object(
        'total', COUNT(*),
        'open', COUNT(*) FILTER (WHERE t.statut = 'open'),
        'in_progress', COUNT(*) FILTER (WHERE t.statut = 'in_progress')
      )
      FROM tickets t
      INNER JOIN properties p ON p.id = t.property_id
      WHERE p.owner_id = p_owner_id
    ),
    'recentActivity', (
      SELECT jsonb_agg(act) FROM (
        -- Nouvelles factures
        SELECT 'invoice' as type, 'Facture générée - ' || i.periode as title, i.created_at::text as date
        FROM invoices i WHERE i.owner_id = p_owner_id
        UNION ALL
        -- Nouveaux tickets
        SELECT 'ticket' as type, 'Nouveau ticket: ' || t.titre as title, t.created_at::text as date
        FROM tickets t INNER JOIN properties p ON p.id = t.property_id WHERE p.owner_id = p_owner_id
        UNION ALL
        -- Nouvelles signatures
        SELECT 'signature' as type, 'Bail signé - ' || p.adresse_complete as title, l.updated_at::text as date
        FROM leases l INNER JOIN properties p ON p.id = l.property_id WHERE p.owner_id = p_owner_id AND l.statut = 'active'
        ORDER BY date DESC
        LIMIT 10
      ) act
    )
  ) INTO v_result;

  RETURN COALESCE(v_result, '{}'::jsonb);
END;
$$;



-- ========== 20260103000010_fix_tenant_dashboard_email_search.sql ==========
-- Migration: Corriger la RPC tenant_dashboard pour chercher par email si profile_id non lié
-- Date: 2026-01-03
-- 
-- PROBLÈME: Si un locataire est invité mais son profile_id n'est pas encore lié 
-- dans lease_signers, le dashboard affiche "Adresse non renseignée"
--
-- SOLUTION: Chercher par profile_id OU par invited_email (email de l'utilisateur)

CREATE OR REPLACE FUNCTION tenant_dashboard(p_tenant_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile_id UUID;
  v_user_email TEXT;
  v_tenant_data JSONB;
  v_leases JSONB;
  v_invoices JSONB;
  v_tickets JSONB;
  v_notifications JSONB;
  v_pending_edls JSONB;
  v_insurance_status JSONB;
  v_stats JSONB;
  v_result JSONB;
BEGIN
  -- 1. Récupérer l'ID du profil ET l'email de l'utilisateur
  SELECT p.id, u.email, 
         jsonb_build_object(
           'id', p.id,
           'prenom', p.prenom,
           'nom', p.nom,
           'email', u.email,
           'telephone', p.telephone,
           'avatar_url', p.avatar_url
         )
  INTO v_profile_id, v_user_email, v_tenant_data
  FROM profiles p
  JOIN auth.users u ON u.id = p.user_id
  WHERE p.user_id = p_tenant_user_id AND p.role = 'tenant';

  IF v_profile_id IS NULL THEN
    RAISE NOTICE '[tenant_dashboard] Aucun profil trouvé pour user_id: %', p_tenant_user_id;
    RETURN NULL;
  END IF;

  RAISE NOTICE '[tenant_dashboard] Profil trouvé: %, email: %', v_profile_id, v_user_email;

  -- 2. Récupérer TOUS les baux - ✅ FIX: Chercher par profile_id OU invited_email
  SELECT jsonb_agg(lease_data ORDER BY lease_data->>'statut' = 'active' DESC, lease_data->>'created_at' DESC) 
  INTO v_leases
  FROM (
    SELECT 
      jsonb_build_object(
        'id', l.id,
        'type_bail', l.type_bail,
        'statut', l.statut,
        'loyer', l.loyer,
        'charges_forfaitaires', l.charges_forfaitaires,
        'depot_de_garantie', l.depot_de_garantie,
        'date_debut', l.date_debut,
        'date_fin', l.date_fin,
        'created_at', l.created_at,
        -- Inclure les signataires du bail
        'signers', (
          SELECT COALESCE(jsonb_agg(
            jsonb_build_object(
              'id', ls2.id,
              'profile_id', ls2.profile_id,
              'role', ls2.role,
              'signature_status', ls2.signature_status,
              'signed_at', ls2.signed_at,
              'invited_name', ls2.invited_name,
              'invited_email', ls2.invited_email,
              'prenom', COALESCE(p_sig.prenom, SPLIT_PART(ls2.invited_name, ' ', 1)),
              'nom', COALESCE(p_sig.nom, SPLIT_PART(ls2.invited_name, ' ', 2)),
              'avatar_url', p_sig.avatar_url
            )
          ), '[]'::jsonb)
          FROM lease_signers ls2
          LEFT JOIN profiles p_sig ON p_sig.id = ls2.profile_id
          WHERE ls2.lease_id = l.id
        ),
        'property', jsonb_build_object(
          'id', p.id,
          'adresse_complete', COALESCE(p.adresse_complete, 'Adresse à compléter'),
          'ville', COALESCE(p.ville, ''),
          'code_postal', COALESCE(p.code_postal, ''),
          'type', COALESCE(p.type, 'appartement'),
          'surface', p.surface,
          'nb_pieces', p.nb_pieces,
          'etage', p.etage,
          'ascenseur', p.ascenseur,
          'annee_construction', p.annee_construction,
          'parking_numero', p.parking_numero,
          'has_cave', p.has_cave,
          'num_lot', p.num_lot,
          'digicode', p.digicode,
          'interphone', p.interphone,
          'dpe_classe_energie', COALESCE(p.energie, p.dpe_classe_energie),
          'dpe_classe_climat', COALESCE(p.ges, p.dpe_classe_climat),
          'chauffage_type', p.chauffage_type,
          'eau_chaude_type', p.eau_chaude_type,
          'cover_url', (
            SELECT url FROM property_photos 
            WHERE property_id = p.id AND is_main = true 
            LIMIT 1
          ),
          'meters', (
            SELECT COALESCE(jsonb_agg(
              jsonb_build_object(
                'id', m.id, 
                'type', m.type, 
                'serial_number', m.serial_number, 
                'unit', m.unit,
                'last_reading_value', (
                  SELECT reading_value FROM meter_readings 
                  WHERE meter_id = m.id ORDER BY reading_date DESC LIMIT 1
                ),
                'last_reading_date', (
                  SELECT reading_date FROM meter_readings 
                  WHERE meter_id = m.id ORDER BY reading_date DESC LIMIT 1
                )
              )
            ), '[]'::jsonb)
            FROM meters m
            WHERE m.property_id = p.id AND m.is_active = true
          )
        ),
        'owner', jsonb_build_object(
          'id', owner_prof.id,
          'name', COALESCE(
            (SELECT raison_sociale FROM owner_profiles WHERE profile_id = owner_prof.id),
            CONCAT(owner_prof.prenom, ' ', owner_prof.nom)
          ),
          'email', owner_prof.email,
          'telephone', owner_prof.telephone
        )
      ) as lease_data
    FROM leases l
    JOIN lease_signers ls ON ls.lease_id = l.id
    JOIN properties p ON p.id = l.property_id
    JOIN profiles owner_prof ON owner_prof.id = p.owner_id
    WHERE 
      -- ✅ FIX: Chercher par profile_id OU par email d'invitation
      (ls.profile_id = v_profile_id OR LOWER(ls.invited_email) = LOWER(v_user_email))
      AND l.statut IN ('active', 'pending_signature', 'fully_signed', 'terminated')
  ) sub;

  RAISE NOTICE '[tenant_dashboard] Baux trouvés: %', COALESCE(jsonb_array_length(v_leases), 0);

  -- 3. Récupérer les factures (10 dernières)
  SELECT COALESCE(jsonb_agg(invoice_data), '[]'::jsonb) INTO v_invoices
  FROM (
    SELECT 
      i.id,
      i.periode,
      i.montant_total,
      i.statut,
      i.created_at,
      i.due_date,
      p.type as property_type,
      p.adresse_complete as property_address
    FROM invoices i
    JOIN leases l ON l.id = i.lease_id
    JOIN lease_signers ls ON ls.lease_id = l.id
    JOIN properties p ON p.id = l.property_id
    WHERE (ls.profile_id = v_profile_id OR LOWER(ls.invited_email) = LOWER(v_user_email))
    ORDER BY i.periode DESC, i.created_at DESC
    LIMIT 10
  ) invoice_data;

  -- 4. Récupérer les tickets récents (10 derniers)
  SELECT COALESCE(jsonb_agg(ticket_data), '[]'::jsonb) INTO v_tickets
  FROM (
    SELECT 
      t.id,
      t.titre,
      t.description,
      t.priorite,
      t.statut,
      t.created_at,
      p.adresse_complete as property_address,
      p.type as property_type
    FROM tickets t
    JOIN properties p ON p.id = t.property_id
    WHERE t.created_by_profile_id = v_profile_id
    ORDER BY t.created_at DESC
    LIMIT 10
  ) ticket_data;

  -- 5. Récupérer les notifications récentes
  SELECT COALESCE(jsonb_agg(notif_data), '[]'::jsonb) INTO v_notifications
  FROM (
    SELECT n.id, n.title, n.message, n.type, n.is_read, n.created_at, n.action_url
    FROM notifications n
    WHERE n.profile_id = v_profile_id
    ORDER BY n.is_read ASC, n.created_at DESC
    LIMIT 5
  ) notif_data;

  -- 6. Récupérer les EDLs en attente de signature
  SELECT COALESCE(jsonb_agg(edl_data), '[]'::jsonb) INTO v_pending_edls
  FROM (
    SELECT 
      e.id,
      e.type,
      e.status,
      e.scheduled_at,
      es.invitation_token,
      p.adresse_complete as property_address,
      p.type as property_type
    FROM edl e
    JOIN edl_signatures es ON es.edl_id = e.id
    JOIN properties p ON p.id = e.property_id
    WHERE (es.signer_profile_id = v_profile_id OR LOWER(es.signer_email) = LOWER(v_user_email))
    AND es.signed_at IS NULL
    AND e.status IN ('draft', 'scheduled', 'in_progress', 'completed')
    ORDER BY e.created_at DESC
  ) edl_data;

  -- 7. Vérifier l'assurance
  SELECT jsonb_build_object(
    'has_insurance', EXISTS (
      SELECT 1 FROM documents 
      WHERE tenant_id = v_profile_id 
      AND type = 'attestation_assurance'
      AND is_archived = false
      AND (expiry_date IS NULL OR expiry_date > NOW())
    ),
    'last_expiry_date', (
      SELECT expiry_date FROM documents 
      WHERE tenant_id = v_profile_id 
      AND type = 'attestation_assurance' 
      AND is_archived = false
      ORDER BY expiry_date DESC LIMIT 1
    )
  ) INTO v_insurance_status;

  -- 8. Stats globales - ✅ FIX: Chercher par email aussi
  SELECT jsonb_build_object(
    'unpaid_amount', COALESCE(SUM(i.montant_total) FILTER (WHERE i.statut IN ('sent', 'late')), 0),
    'unpaid_count', COUNT(*) FILTER (WHERE i.statut IN ('sent', 'late')),
    'total_monthly_rent', COALESCE(
      (SELECT SUM(l2.loyer + l2.charges_forfaitaires) 
       FROM leases l2 
       JOIN lease_signers ls2 ON ls2.lease_id = l2.id 
       WHERE (ls2.profile_id = v_profile_id OR LOWER(ls2.invited_email) = LOWER(v_user_email))
       AND l2.statut = 'active'), 
      0
    ),
    'active_leases_count', (
      SELECT COUNT(DISTINCT l2.id) 
      FROM leases l2 
      JOIN lease_signers ls2 ON ls2.lease_id = l2.id 
      WHERE (ls2.profile_id = v_profile_id OR LOWER(ls2.invited_email) = LOWER(v_user_email))
      AND l2.statut = 'active'
    )
  ) INTO v_stats
  FROM leases l
  JOIN lease_signers ls ON ls.lease_id = l.id
  LEFT JOIN invoices i ON i.lease_id = l.id
  WHERE (ls.profile_id = v_profile_id OR LOWER(ls.invited_email) = LOWER(v_user_email));

  -- 9. Vérifier le statut KYC
  DECLARE
    v_kyc_status TEXT := 'pending';
  BEGIN
    SELECT COALESCE(tp.kyc_status, 'pending') INTO v_kyc_status
    FROM tenant_profiles tp
    WHERE tp.profile_id = v_profile_id;
  EXCEPTION WHEN OTHERS THEN
    v_kyc_status := 'pending';
  END;

  -- 10. Assembler le résultat final
  v_result := jsonb_build_object(
    'profile_id', v_profile_id,
    'tenant', v_tenant_data,
    'kyc_status', COALESCE((SELECT kyc_status FROM tenant_profiles WHERE profile_id = v_profile_id), 'pending'),
    'leases', COALESCE(v_leases, '[]'::jsonb),
    'lease', CASE WHEN v_leases IS NOT NULL AND jsonb_array_length(v_leases) > 0 THEN v_leases->0 ELSE NULL END,
    'property', CASE WHEN v_leases IS NOT NULL AND jsonb_array_length(v_leases) > 0 THEN (v_leases->0)->'property' ELSE NULL END,
    'invoices', v_invoices,
    'tickets', v_tickets,
    'notifications', v_notifications,
    'pending_edls', v_pending_edls,
    'insurance', v_insurance_status,
    'stats', COALESCE(v_stats, '{"unpaid_amount": 0, "unpaid_count": 0, "total_monthly_rent": 0, "active_leases_count": 0}'::jsonb)
  );

  RETURN v_result;
END;
$$;

-- Ajouter un commentaire explicatif
COMMENT ON FUNCTION tenant_dashboard(UUID) IS 
'RPC pour le tableau de bord locataire. Cherche les baux par profile_id OU invited_email pour gérer le cas où le profile_id n''est pas encore lié dans lease_signers.';



-- ========== 20260104000000_add_kyc_status_and_fix_signature_logic.sql ==========
-- ============================================================================
-- MIGRATION: Ajouter kyc_status à tenant_profiles et corriger la logique
-- Date: 2026-01-04
-- Description: 
--   1. Ajoute la colonne kyc_status à tenant_profiles
--   2. Met à jour les locataires existants avec comptes créés comme "verified"
--   3. Corrige la logique pour que les locataires invités soient auto-vérifiés
-- ============================================================================

-- 1. Ajouter la colonne kyc_status si elle n'existe pas
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'tenant_profiles' AND column_name = 'kyc_status'
  ) THEN
    ALTER TABLE tenant_profiles 
    ADD COLUMN kyc_status TEXT DEFAULT 'pending' 
    CHECK (kyc_status IN ('pending', 'processing', 'verified', 'rejected'));
    
    RAISE NOTICE 'Colonne kyc_status ajoutée à tenant_profiles';
  END IF;
END $$;

-- 2. Marquer comme "verified" tous les locataires qui ont :
--    - Un compte créé (profile_id existe)
--    - Signé un bail (lease_signers.signed_at IS NOT NULL)
UPDATE tenant_profiles tp
SET kyc_status = 'verified'
WHERE EXISTS (
  SELECT 1 FROM lease_signers ls
  WHERE ls.profile_id = tp.profile_id
  AND ls.signed_at IS NOT NULL
)
AND (tp.kyc_status IS NULL OR tp.kyc_status = 'pending');

-- 3. Marquer comme "verified" tous les locataires qui ont un compte actif
--    (ils se sont connectés, donc leur email est vérifié)
UPDATE tenant_profiles tp
SET kyc_status = 'verified'
WHERE tp.profile_id IN (
  SELECT p.id FROM profiles p
  JOIN auth.users u ON u.id = p.user_id
  WHERE u.email_confirmed_at IS NOT NULL
)
AND (tp.kyc_status IS NULL OR tp.kyc_status = 'pending');

-- 4. Créer un trigger pour auto-vérifier les nouveaux locataires qui acceptent une invitation
CREATE OR REPLACE FUNCTION auto_verify_tenant_on_signup()
RETURNS TRIGGER AS $$
BEGIN
  -- Si un locataire crée un compte via invitation, on le marque comme vérifié
  IF NEW.kyc_status IS NULL OR NEW.kyc_status = 'pending' THEN
    -- Vérifier si ce locataire a une invitation acceptée
    IF EXISTS (
      SELECT 1 FROM invitations i
      WHERE LOWER(i.email) = LOWER((SELECT email FROM auth.users WHERE id = (SELECT user_id FROM profiles WHERE id = NEW.profile_id)))
      AND i.status = 'accepted'
    ) THEN
      NEW.kyc_status := 'verified';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Supprimer le trigger s'il existe
DROP TRIGGER IF EXISTS tr_auto_verify_tenant ON tenant_profiles;

-- Créer le trigger
CREATE TRIGGER tr_auto_verify_tenant
BEFORE INSERT OR UPDATE ON tenant_profiles
FOR EACH ROW
EXECUTE FUNCTION auto_verify_tenant_on_signup();

-- 5. Mettre à jour la fonction tenant_dashboard pour récupérer correctement le kyc_status
-- Cette partie est informative - la RPC actuelle fait déjà un COALESCE sur kyc_status

COMMENT ON COLUMN tenant_profiles.kyc_status IS 
'Statut de vérification d''identité: pending (en attente), processing (en cours), verified (vérifié), rejected (rejeté). 
Un locataire est auto-vérifié s''il a créé un compte via invitation ou s''il a signé un bail.';



-- ========== 20260104000001_lease_auto_activation_trigger.sql ==========
-- Migration : Activer l'auto-activation du bail après signature de l'EDL
-- Date: 2026-01-04

-- 1. Fonction pour activer le bail
CREATE OR REPLACE FUNCTION public.trigger_activate_lease_on_edl_signed()
RETURNS TRIGGER AS $$
BEGIN
  -- Si l'EDL d'entrée passe à "signed"
  IF NEW.type = 'entree' AND NEW.status = 'signed' AND (OLD.status IS NULL OR OLD.status != 'signed') THEN
    -- Mettre à jour le bail associé
    UPDATE leases
    SET 
      statut = 'active',
      activated_at = NOW(),
      entry_edl_id = NEW.id,
      updated_at = NOW()
    WHERE id = NEW.lease_id 
    AND statut IN ('fully_signed', 'pending_signature', 'partially_signed');
    
    RAISE NOTICE 'Bail % activé suite à la signature de l''EDL %', NEW.lease_id, NEW.id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. Création effective du trigger
DROP TRIGGER IF EXISTS auto_activate_lease_on_edl ON edl;
CREATE TRIGGER auto_activate_lease_on_edl
  AFTER UPDATE OF status ON edl
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_activate_lease_on_edl_signed();

-- 3. Correction immédiate pour les baux déjà signés avec EDL signé
UPDATE leases l
SET statut = 'active', 
    activated_at = NOW(),
    updated_at = NOW()
WHERE l.statut IN ('fully_signed', 'pending_signature', 'partially_signed')
AND EXISTS (
    SELECT 1 FROM edl e 
    WHERE e.lease_id = l.id 
    AND e.status = 'signed' 
    AND e.type = 'entree'
);




-- ========== 20260104000002_edl_finalization_and_lease_activation.sql ==========
-- Migration pour automatiser la finalisation de l'EDL et l'activation du bail
-- Correction des rôles pour la détection des signatures

CREATE OR REPLACE FUNCTION public.check_edl_finalization()
RETURNS TRIGGER AS $$
DECLARE
    v_has_owner BOOLEAN;
    v_has_tenant BOOLEAN;
    v_edl_type TEXT;
    v_lease_id UUID;
    v_edl_id UUID;
BEGIN
    v_edl_id := NEW.edl_id;

    -- 1. Vérifier les signatures pour cet EDL
    -- On est plus souple sur les noms de rôles
    SELECT 
        EXISTS (SELECT 1 FROM edl_signatures WHERE edl_id = v_edl_id AND (signer_role IN ('owner', 'proprietaire', 'bailleur')) AND signature_image_path IS NOT NULL),
        EXISTS (SELECT 1 FROM edl_signatures WHERE edl_id = v_edl_id AND (signer_role IN ('tenant', 'locataire', 'locataire_principal')) AND signature_image_path IS NOT NULL)
    INTO v_has_owner, v_has_tenant;

    -- 2. Si les deux ont signé
    IF v_has_owner AND v_has_tenant THEN
        -- Récupérer les infos de l'EDL
        SELECT type, lease_id INTO v_edl_type, v_lease_id FROM edl WHERE id = v_edl_id;

        -- Mettre l'EDL en statut 'signed'
        UPDATE edl SET 
            status = 'signed',
            completed_date = NOW(),
            updated_at = NOW()
        WHERE id = v_edl_id 
        AND status != 'signed';

        -- 3. Si c'est un EDL d'entrée, on active le bail
        IF v_edl_type = 'entree' THEN
            -- Vérifier si le bail est déjà au moins fully_signed
            UPDATE leases SET 
                statut = 'active',
                activated_at = NOW(),
                updated_at = NOW()
            WHERE id = v_lease_id 
            AND statut IN ('fully_signed', 'pending_signature', 'partially_signed', 'sent');

            -- Déclencher un événement outbox pour la facture initiale (sera traité par un worker)
            INSERT INTO outbox (event_type, payload)
            VALUES ('Lease.Activated', jsonb_build_object(
                'lease_id', v_lease_id,
                'edl_id', v_edl_id,
                'action', 'generate_initial_invoice'
            ));
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger sur edl_signatures
DROP TRIGGER IF EXISTS tr_check_edl_finalization ON edl_signatures;
CREATE TRIGGER tr_check_edl_finalization
AFTER INSERT OR UPDATE OF signature_image_path ON edl_signatures
FOR EACH ROW
EXECUTE FUNCTION public.check_edl_finalization();

-- Correction immédiate des EDL déjà signés mais bloqués en brouillon
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN 
        SELECT id FROM edl WHERE status != 'signed'
    LOOP
        -- Simuler un update pour déclencher la logique (ou appeler la fonction manuellement)
        -- Ici on appelle la logique pour chaque signature existante
        PERFORM check_edl_finalization();
    END LOOP;
END $$;



-- ========== 20260104000003_enrich_edl_schema.sql ==========
-- ============================================================================
-- MIGRATION: Enrichir le schéma EDL pour les compteurs et les clés
-- Date: 2026-01-04
-- ============================================================================

-- 1. Ajouter la colonne 'general_notes' et 'keys' à la table edl si elles n'existent pas
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl' AND column_name = 'general_notes') THEN
        ALTER TABLE edl ADD COLUMN general_notes TEXT;
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl' AND column_name = 'keys') THEN
        ALTER TABLE edl ADD COLUMN keys JSONB DEFAULT '[]'::jsonb;
    END IF;
END $$;

-- 2. Ajouter la colonne 'category' et 'description' à la table edl_items
-- Utile pour classer les items (ex: 'cles', 'compteurs') si on ne veut pas de tables séparées
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl_items' AND column_name = 'category') THEN
        ALTER TABLE edl_items ADD COLUMN category TEXT;
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl_items' AND column_name = 'description') THEN
        ALTER TABLE edl_items ADD COLUMN description TEXT;
    END IF;
END $$;

-- 3. Ajouter des indexes pour les performances
CREATE INDEX IF NOT EXISTS idx_edl_items_category ON edl_items(category);

-- 4. Commentaires
COMMENT ON COLUMN edl.keys IS 'Liste des clés remises (JSONB array: [{type, quantite, notes}])';
COMMENT ON COLUMN edl_items.category IS 'Catégorie de l''item (ex: cles, electricite, etc.)';
COMMENT ON COLUMN edl_items.description IS 'Description détaillée ou informations complémentaires sur l''item';



-- ========== 20260104000004_ensure_meter_columns.sql ==========
-- Migration: S'assurer que les colonnes meter_number, serial_number et location existent sur la table meters
-- Date: 2026-01-04

DO $$
BEGIN
    -- 1. Vérifier meter_number (devrait exister)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'meters' AND column_name = 'meter_number') THEN
        ALTER TABLE public.meters ADD COLUMN meter_number TEXT;
    END IF;

    -- 2. Vérifier serial_number (alias courant)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'meters' AND column_name = 'serial_number') THEN
        ALTER TABLE public.meters ADD COLUMN serial_number TEXT;
    END IF;

    -- 3. Vérifier location (essentiel pour l'EDL)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'meters' AND column_name = 'location') THEN
        ALTER TABLE public.meters ADD COLUMN location TEXT;
    END IF;

    -- 4. Synchroniser les données existantes entre meter_number et serial_number
    UPDATE public.meters SET serial_number = meter_number WHERE serial_number IS NULL AND meter_number IS NOT NULL;
    UPDATE public.meters SET meter_number = serial_number WHERE meter_number IS NULL AND serial_number IS NOT NULL;

END $$;



-- ========== 20260105000001_add_neuf_condition.sql ==========
-- Migration: Ajouter l'état "neuf" aux conditions d'éléments EDL
-- Date: 2026-01-05
-- Description: Ajoute "neuf" comme option de condition pour les éléments d'état des lieux

-- ============================================================================
-- 1. Mettre à jour la contrainte CHECK sur la colonne condition de edl_items
-- ============================================================================

-- Supprimer l'ancienne contrainte si elle existe
ALTER TABLE edl_items DROP CONSTRAINT IF EXISTS edl_items_condition_check;

-- Ajouter la nouvelle contrainte avec "neuf"
ALTER TABLE edl_items ADD CONSTRAINT edl_items_condition_check 
  CHECK (condition IN ('neuf', 'bon', 'moyen', 'mauvais', 'tres_mauvais'));

-- ============================================================================
-- 2. Ajouter un commentaire sur la colonne pour documentation
-- ============================================================================

COMMENT ON COLUMN edl_items.condition IS 'État de l''élément: neuf, bon, moyen, mauvais, tres_mauvais';

-- ============================================================================
-- 3. Confirmation
-- ============================================================================

DO $$
BEGIN
  RAISE NOTICE 'Migration réussie: état "neuf" ajouté aux conditions EDL';
END $$;



-- ========== 20260105000001_fix_handle_new_user_with_metadata.sql ==========
-- ============================================
-- Migration: Améliorer handle_new_user pour lire le rôle depuis les metadata
-- Date: 2026-01-05
-- Description: Le trigger lit maintenant le rôle, prénom, nom et téléphone 
--              depuis les raw_user_meta_data de l'utilisateur
-- ============================================

-- Recréer la fonction handle_new_user pour lire les metadata
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_role TEXT;
  v_prenom TEXT;
  v_nom TEXT;
  v_telephone TEXT;
BEGIN
  -- Lire le rôle depuis les metadata, avec fallback sur 'tenant'
  v_role := COALESCE(
    NEW.raw_user_meta_data->>'role',
    'tenant'
  );
  
  -- Valider le rôle
  IF v_role NOT IN ('admin', 'owner', 'tenant', 'provider') THEN
    v_role := 'tenant';
  END IF;
  
  -- Lire les autres données depuis les metadata
  v_prenom := NEW.raw_user_meta_data->>'prenom';
  v_nom := NEW.raw_user_meta_data->>'nom';
  v_telephone := NEW.raw_user_meta_data->>'telephone';
  
  -- Insérer le profil avec toutes les données
  INSERT INTO public.profiles (user_id, role, prenom, nom, telephone)
  VALUES (NEW.id, v_role, v_prenom, v_nom, v_telephone)
  ON CONFLICT (user_id) DO UPDATE SET
    role = EXCLUDED.role,
    prenom = COALESCE(EXCLUDED.prenom, profiles.prenom),
    nom = COALESCE(EXCLUDED.nom, profiles.nom),
    telephone = COALESCE(EXCLUDED.telephone, profiles.telephone),
    updated_at = NOW();
  
  RETURN NEW;
END;
$$;

-- Commenter la fonction
COMMENT ON FUNCTION public.handle_new_user() IS 
'Crée automatiquement un profil lors de la création d''un utilisateur.
Lit le rôle et les informations personnelles depuis les raw_user_meta_data.
Utilise ON CONFLICT pour gérer les cas où le profil existe déjà.';



-- ========== 20260105000002_edl_lease_sync_triggers.sql ==========
-- Migration: Triggers de synchronisation EDL/Bail
-- Date: 2026-01-05
-- Description: Assure la synchronisation automatique des statuts entre EDL et baux

-- ============================================================================
-- 1. Fonction de vérification et finalisation de l'EDL
-- ============================================================================
CREATE OR REPLACE FUNCTION public.check_edl_finalization()
RETURNS TRIGGER AS $$
DECLARE
    v_has_owner BOOLEAN;
    v_has_tenant BOOLEAN;
    v_edl_type TEXT;
    v_lease_id UUID;
    v_edl_id UUID;
BEGIN
    v_edl_id := NEW.edl_id;

    -- Vérifier les signatures (support des rôles FR et EN)
    SELECT 
        EXISTS (
            SELECT 1 FROM edl_signatures 
            WHERE edl_id = v_edl_id 
            AND signer_role IN ('owner', 'proprietaire', 'bailleur') 
            AND signature_image_path IS NOT NULL
            AND signed_at IS NOT NULL
        ),
        EXISTS (
            SELECT 1 FROM edl_signatures 
            WHERE edl_id = v_edl_id 
            AND signer_role IN ('tenant', 'locataire', 'locataire_principal') 
            AND signature_image_path IS NOT NULL
            AND signed_at IS NOT NULL
        )
    INTO v_has_owner, v_has_tenant;

    -- Si les deux parties ont signé
    IF v_has_owner AND v_has_tenant THEN
        -- Récupérer les infos de l'EDL
        SELECT type, lease_id INTO v_edl_type, v_lease_id 
        FROM edl WHERE id = v_edl_id;

        -- Mettre l'EDL en statut 'signed'
        UPDATE edl SET 
            status = 'signed',
            completed_date = CURRENT_DATE,
            updated_at = NOW()
        WHERE id = v_edl_id 
        AND status != 'signed';

        -- Si c'est un EDL d'entrée, activer le bail
        IF v_edl_type = 'entree' AND v_lease_id IS NOT NULL THEN
            UPDATE leases SET 
                statut = 'active',
                activated_at = NOW(),
                updated_at = NOW()
            WHERE id = v_lease_id 
            AND statut IN ('fully_signed', 'pending_signature', 'partially_signed', 'sent');

            -- Émettre un événement pour la facturation
            INSERT INTO outbox (event_type, payload)
            VALUES ('Lease.Activated', jsonb_build_object(
                'lease_id', v_lease_id,
                'edl_id', v_edl_id,
                'action', 'generate_initial_invoice',
                'triggered_by', 'edl_signature_trigger'
            ));
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- 2. Trigger sur edl_signatures (INSERT et UPDATE)
-- ============================================================================
DROP TRIGGER IF EXISTS tr_check_edl_finalization ON edl_signatures;
CREATE TRIGGER tr_check_edl_finalization
AFTER INSERT OR UPDATE OF signature_image_path, signed_at ON edl_signatures
FOR EACH ROW
EXECUTE FUNCTION public.check_edl_finalization();

-- ============================================================================
-- 3. Trigger sur edl pour activer le bail si statut passe à 'signed'
-- ============================================================================
CREATE OR REPLACE FUNCTION public.trigger_activate_lease_on_edl_signed()
RETURNS TRIGGER AS $$
BEGIN
    -- Si l'EDL d'entrée passe à "signed"
    IF NEW.type = 'entree' 
       AND NEW.status = 'signed' 
       AND (OLD.status IS NULL OR OLD.status != 'signed') 
    THEN
        UPDATE leases
        SET 
            statut = 'active',
            activated_at = NOW(),
            entry_edl_id = NEW.id,
            updated_at = NOW()
        WHERE id = NEW.lease_id 
        AND statut IN ('fully_signed', 'pending_signature', 'partially_signed', 'sent');
        
        RAISE NOTICE 'Bail % activé suite à la signature de l''EDL %', NEW.lease_id, NEW.id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS auto_activate_lease_on_edl ON edl;
CREATE TRIGGER auto_activate_lease_on_edl
AFTER UPDATE OF status ON edl
FOR EACH ROW
EXECUTE FUNCTION public.trigger_activate_lease_on_edl_signed();

-- ============================================================================
-- 4. Correction immédiate des données existantes
-- ============================================================================

-- 4a. Corriger les EDL avec signatures complètes mais pas en 'signed'
UPDATE edl e
SET 
    status = 'signed', 
    completed_date = CURRENT_DATE,
    updated_at = NOW()
WHERE status != 'signed'
AND EXISTS (
    SELECT 1 FROM edl_signatures s 
    WHERE s.edl_id = e.id 
    AND s.signer_role IN ('owner', 'proprietaire', 'bailleur')
    AND s.signature_image_path IS NOT NULL
    AND s.signed_at IS NOT NULL
)
AND EXISTS (
    SELECT 1 FROM edl_signatures s 
    WHERE s.edl_id = e.id 
    AND s.signer_role IN ('tenant', 'locataire', 'locataire_principal')
    AND s.signature_image_path IS NOT NULL
    AND s.signed_at IS NOT NULL
);

-- 4b. Activer les baux dont l'EDL d'entrée est signé
UPDATE leases l
SET 
    statut = 'active', 
    activated_at = NOW(),
    updated_at = NOW()
WHERE statut IN ('fully_signed', 'pending_signature', 'partially_signed', 'sent')
AND EXISTS (
    SELECT 1 FROM edl e 
    WHERE e.lease_id = l.id 
    AND e.status = 'signed' 
    AND e.type = 'entree'
);

-- ============================================================================
-- 5. Vérification
-- ============================================================================
DO $$
DECLARE
    v_edl_count INTEGER;
    v_lease_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_edl_count FROM edl WHERE status = 'signed';
    SELECT COUNT(*) INTO v_lease_count FROM leases WHERE statut = 'active';
    
    RAISE NOTICE 'Migration terminée: % EDL signés, % baux actifs', v_edl_count, v_lease_count;
END $$;

SELECT 'Migration EDL/Lease sync triggers appliquée avec succès' AS status;



-- ========== 20260105000002_update_rooms_type_piece_constraint.sql ==========
-- ============================================
-- Migration: Mise à jour contrainte type_piece pour rooms
-- Date: 2026-01-05
-- Description: Ajoute les nouveaux types de pièces V3 et pro/parking
-- ============================================

-- Supprimer l'ancienne contrainte
ALTER TABLE rooms DROP CONSTRAINT IF EXISTS rooms_type_piece_check;

-- Ajouter la nouvelle contrainte avec tous les types
ALTER TABLE rooms ADD CONSTRAINT rooms_type_piece_check 
  CHECK (type_piece IN (
    -- Types principaux habitation
    'sejour',
    'chambre',
    'cuisine',
    'salle_de_bain',
    'wc',
    'entree',
    'couloir',
    'balcon',
    'terrasse',
    'cave',
    'autre',
    -- Types additionnels V3
    'salon_cuisine',
    'bureau',
    'dressing',
    'suite_parentale',
    'mezzanine',
    'buanderie',
    'cellier',
    'jardin',
    -- Types pro/parking
    'stockage',
    'emplacement',
    'box'
  ));

COMMENT ON CONSTRAINT rooms_type_piece_check ON rooms IS 
'Types de pièces valides incluant habitation, V3 additionnels et pro/parking';



-- ========== 20260105000003_add_leases_missing_columns.sql ==========
-- ============================================
-- Migration: Ajouter les colonnes manquantes à leases
-- Date: 2026-01-05
-- Description: Ajoute charges_type, coloc_config et autres colonnes manquantes
-- ============================================

-- Ajouter charges_type si elle n'existe pas
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'leases' AND column_name = 'charges_type') THEN
    ALTER TABLE leases ADD COLUMN charges_type TEXT DEFAULT 'forfait' 
      CHECK (charges_type IN ('forfait', 'provisions'));
  END IF;
END $$;

-- Ajouter coloc_config (pour la configuration colocation) si elle n'existe pas
DO $$ 
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'leases' AND column_name = 'coloc_config') THEN
    ALTER TABLE leases ADD COLUMN coloc_config JSONB;
  END IF;
END $$;

-- Mettre à jour la contrainte type_bail pour inclure les nouveaux types
ALTER TABLE leases DROP CONSTRAINT IF EXISTS leases_type_bail_check;
ALTER TABLE leases ADD CONSTRAINT leases_type_bail_check 
  CHECK (type_bail IN ('nu', 'meuble', 'colocation', 'saisonnier', 'etudiant', 'mobilite'));

-- Ajouter un index sur charges_type pour les requêtes filtrées
CREATE INDEX IF NOT EXISTS idx_leases_charges_type ON leases(charges_type);

COMMENT ON COLUMN leases.charges_type IS 'Type de charges: forfait (fixe) ou provisions (régularisation annuelle)';
COMMENT ON COLUMN leases.coloc_config IS 'Configuration colocation: nb_places, bail_type, solidarite, split_mode, etc.';



-- ========== 20260105000003_lease_notices.sql ==========
-- Migration: Table des congés locataires
-- Date: 2026-01-05
-- Description: Permet aux locataires de donner congé avec gestion du préavis

-- ============================================================================
-- 1. Table lease_notices - Enregistrement des congés
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.lease_notices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
    tenant_profile_id UUID NOT NULL REFERENCES profiles(id),
    
    -- Dates
    notice_date DATE NOT NULL,               -- Date d'envoi du congé
    effective_end_date DATE NOT NULL,        -- Date de fin effective du bail
    notice_period_days INTEGER NOT NULL,     -- Durée du préavis en jours
    
    -- Préavis réduit
    is_reduced_notice BOOLEAN DEFAULT FALSE,
    reduced_notice_reason TEXT,              -- Motif légal pour préavis réduit
    
    -- Informations complémentaires
    forwarding_address TEXT,                 -- Nouvelle adresse du locataire
    notes TEXT,                              -- Commentaires additionnels
    
    -- Statut du congé
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'acknowledged', 'completed', 'cancelled')),
    acknowledged_at TIMESTAMPTZ,             -- Date d'accusé réception par le propriétaire
    acknowledged_by UUID REFERENCES auth.users(id),
    
    -- Documents générés
    notice_letter_path TEXT,                 -- Chemin vers la lettre de congé PDF
    
    -- Métadonnées
    created_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index pour performance
CREATE INDEX IF NOT EXISTS idx_lease_notices_lease_id ON lease_notices(lease_id);
CREATE INDEX IF NOT EXISTS idx_lease_notices_tenant ON lease_notices(tenant_profile_id);
CREATE INDEX IF NOT EXISTS idx_lease_notices_status ON lease_notices(status);
CREATE INDEX IF NOT EXISTS idx_lease_notices_end_date ON lease_notices(effective_end_date);

-- ============================================================================
-- 2. Mise à jour du statut possible des baux
-- ============================================================================
-- Ajouter le statut "notice_given" si pas déjà présent dans la contrainte
DO $$
BEGIN
    -- Vérifier si la contrainte existe et la mettre à jour
    IF EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'leases_statut_check' 
        AND conrelid = 'leases'::regclass
    ) THEN
        ALTER TABLE leases DROP CONSTRAINT IF EXISTS leases_statut_check;
    END IF;
    
    -- Ajouter la nouvelle contrainte avec tous les statuts
    ALTER TABLE leases ADD CONSTRAINT leases_statut_check 
        CHECK (statut IN (
            'draft', 
            'sent', 
            'pending_signature', 
            'partially_signed',
            'pending_owner_signature',
            'fully_signed', 
            'active', 
            'notice_given',     -- NOUVEAU: Congé donné
            'amended', 
            'terminated', 
            'archived'
        ));
EXCEPTION
    WHEN others THEN
        RAISE NOTICE 'Contrainte statut déjà à jour ou autre erreur: %', SQLERRM;
END $$;

-- ============================================================================
-- 3. RLS Policies
-- ============================================================================
ALTER TABLE lease_notices ENABLE ROW LEVEL SECURITY;

-- Locataire peut voir ses propres congés
CREATE POLICY "Tenant can view own notices" ON lease_notices
    FOR SELECT
    USING (
        tenant_profile_id IN (
            SELECT id FROM profiles WHERE user_id = auth.uid()
        )
    );

-- Locataire peut créer un congé pour son bail
CREATE POLICY "Tenant can create notice" ON lease_notices
    FOR INSERT
    WITH CHECK (
        tenant_profile_id IN (
            SELECT id FROM profiles WHERE user_id = auth.uid()
        )
        AND EXISTS (
            SELECT 1 FROM lease_signers ls
            WHERE ls.lease_id = lease_notices.lease_id
            AND ls.profile_id = lease_notices.tenant_profile_id
            AND ls.role IN ('locataire_principal', 'colocataire')
        )
    );

-- Propriétaire peut voir les congés de ses baux
CREATE POLICY "Owner can view notices" ON lease_notices
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM leases l
            JOIN properties p ON l.property_id = p.id
            JOIN profiles pr ON p.owner_id = pr.id
            WHERE l.id = lease_notices.lease_id
            AND pr.user_id = auth.uid()
        )
    );

-- Propriétaire peut mettre à jour le statut (acknowledged)
CREATE POLICY "Owner can update notice status" ON lease_notices
    FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM leases l
            JOIN properties p ON l.property_id = p.id
            JOIN profiles pr ON p.owner_id = pr.id
            WHERE l.id = lease_notices.lease_id
            AND pr.user_id = auth.uid()
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM leases l
            JOIN properties p ON l.property_id = p.id
            JOIN profiles pr ON p.owner_id = pr.id
            WHERE l.id = lease_notices.lease_id
            AND pr.user_id = auth.uid()
        )
    );

-- Admin a accès complet
CREATE POLICY "Admin full access notices" ON lease_notices
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin'
        )
    );

-- ============================================================================
-- 4. Trigger pour updated_at
-- ============================================================================
CREATE OR REPLACE FUNCTION update_lease_notices_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS tr_lease_notices_updated_at ON lease_notices;
CREATE TRIGGER tr_lease_notices_updated_at
    BEFORE UPDATE ON lease_notices
    FOR EACH ROW
    EXECUTE FUNCTION update_lease_notices_updated_at();

-- ============================================================================
-- 5. Vue pour les congés à venir (utile pour le propriétaire)
-- ============================================================================
CREATE OR REPLACE VIEW v_upcoming_lease_notices AS
SELECT 
    ln.id as notice_id,
    ln.lease_id,
    ln.notice_date,
    ln.effective_end_date,
    ln.notice_period_days,
    ln.is_reduced_notice,
    ln.reduced_notice_reason,
    ln.status,
    ln.forwarding_address,
    l.type_bail,
    l.loyer,
    p.adresse_complete,
    p.ville,
    p.owner_id,
    tp.prenom as tenant_prenom,
    tp.nom as tenant_nom,
    tp.email as tenant_email,
    (ln.effective_end_date - CURRENT_DATE) as days_until_end
FROM lease_notices ln
JOIN leases l ON ln.lease_id = l.id
JOIN properties p ON l.property_id = p.id
JOIN profiles tp ON ln.tenant_profile_id = tp.id
WHERE ln.status != 'cancelled'
AND ln.effective_end_date >= CURRENT_DATE
ORDER BY ln.effective_end_date ASC;

-- Confirmation
SELECT 'Migration lease_notices appliquée avec succès' AS status;



-- ========== 20260107000000_building_support.sql ==========
-- ============================================
-- Migration : Support des Immeubles (Buildings) SOTA 2026
-- 
-- Cette migration ajoute le support complet pour la gestion 
-- d'immeubles entiers avec plusieurs lots/unités.
-- ============================================

-- 1. Ajout du type "immeuble" dans properties
-- ============================================

-- Supprimer l'ancienne contrainte si elle existe
ALTER TABLE properties 
  DROP CONSTRAINT IF EXISTS properties_type_check;

-- Ajouter la nouvelle contrainte avec "immeuble"
ALTER TABLE properties 
  ADD CONSTRAINT properties_type_check 
  CHECK (type IN (
    'appartement', 
    'maison', 
    'studio', 
    'colocation', 
    'saisonnier',
    'parking', 
    'box', 
    'local_commercial', 
    'bureaux', 
    'entrepot', 
    'fonds_de_commerce', 
    'immeuble'  -- NOUVEAU SOTA 2026
  ));

-- 2. Table buildings (Immeubles)
-- ============================================

CREATE TABLE IF NOT EXISTS buildings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  property_id UUID REFERENCES properties(id) ON DELETE SET NULL,
  
  -- Identification
  name TEXT NOT NULL,
  
  -- Adresse
  adresse_complete TEXT NOT NULL,
  code_postal TEXT NOT NULL,
  ville TEXT NOT NULL,
  departement TEXT,
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  
  -- Structure physique
  floors INTEGER NOT NULL DEFAULT 1 CHECK (floors >= 1 AND floors <= 50),
  construction_year INTEGER CHECK (construction_year >= 1800 AND construction_year <= 2100),
  surface_totale DECIMAL(10, 2),
  
  -- Parties communes
  has_ascenseur BOOLEAN DEFAULT false,
  has_gardien BOOLEAN DEFAULT false,
  has_interphone BOOLEAN DEFAULT false,
  has_digicode BOOLEAN DEFAULT false,
  has_local_velo BOOLEAN DEFAULT false,
  has_local_poubelles BOOLEAN DEFAULT false,
  has_parking_commun BOOLEAN DEFAULT false,
  has_jardin_commun BOOLEAN DEFAULT false,
  
  -- Métadonnées
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour performance
CREATE INDEX IF NOT EXISTS idx_buildings_owner ON buildings(owner_id);
CREATE INDEX IF NOT EXISTS idx_buildings_property ON buildings(property_id);
CREATE INDEX IF NOT EXISTS idx_buildings_ville ON buildings(ville);
CREATE INDEX IF NOT EXISTS idx_buildings_code_postal ON buildings(code_postal);

-- 3. Table building_units (Lots d'un immeuble)
-- ============================================

CREATE TABLE IF NOT EXISTS building_units (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  building_id UUID NOT NULL REFERENCES buildings(id) ON DELETE CASCADE,
  
  -- Position dans l'immeuble
  floor INTEGER NOT NULL DEFAULT 0 CHECK (floor >= -5 AND floor <= 50),
  position TEXT NOT NULL DEFAULT 'A',
  
  -- Type et caractéristiques
  type TEXT NOT NULL CHECK (type IN (
    'appartement', 
    'studio', 
    'local_commercial', 
    'parking', 
    'cave', 
    'bureau'
  )),
  template TEXT CHECK (template IN (
    'studio', 't1', 't2', 't3', 't4', 't5', 
    'local', 'parking', 'cave'
  )),
  
  surface DECIMAL(8, 2) NOT NULL CHECK (surface > 0),
  nb_pieces INTEGER DEFAULT 1 CHECK (nb_pieces >= 0),
  
  -- Conditions de location
  loyer_hc DECIMAL(10, 2) DEFAULT 0 CHECK (loyer_hc >= 0),
  charges DECIMAL(10, 2) DEFAULT 0 CHECK (charges >= 0),
  depot_garantie DECIMAL(10, 2) DEFAULT 0 CHECK (depot_garantie >= 0),
  
  -- Statut
  status TEXT DEFAULT 'vacant' CHECK (status IN (
    'vacant', 
    'occupe', 
    'travaux', 
    'reserve'
  )),
  
  -- Liaison avec bail actif (optionnel)
  current_lease_id UUID REFERENCES leases(id) ON DELETE SET NULL,
  
  -- Métadonnées
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Contrainte d'unicité : un seul lot par position/étage/immeuble
  UNIQUE(building_id, floor, position)
);

-- Index pour performance
CREATE INDEX IF NOT EXISTS idx_building_units_building ON building_units(building_id);
CREATE INDEX IF NOT EXISTS idx_building_units_status ON building_units(status);
CREATE INDEX IF NOT EXISTS idx_building_units_type ON building_units(type);
CREATE INDEX IF NOT EXISTS idx_building_units_floor ON building_units(floor);
CREATE INDEX IF NOT EXISTS idx_building_units_lease ON building_units(current_lease_id);

-- 4. Vue pour statistiques des immeubles
-- ============================================

CREATE OR REPLACE VIEW building_stats AS
SELECT 
  b.id,
  b.name,
  b.owner_id,
  b.adresse_complete,
  b.ville,
  b.floors,
  
  -- Comptages par type
  COUNT(bu.id) FILTER (WHERE bu.type NOT IN ('parking', 'cave')) as total_units,
  COUNT(bu.id) FILTER (WHERE bu.type = 'parking') as total_parkings,
  COUNT(bu.id) FILTER (WHERE bu.type = 'cave') as total_caves,
  
  -- Surface
  COALESCE(SUM(bu.surface), 0) as surface_totale,
  
  -- Revenus
  COALESCE(SUM(bu.loyer_hc + bu.charges), 0) as revenus_potentiels,
  COALESCE(SUM(bu.loyer_hc + bu.charges) FILTER (WHERE bu.status = 'occupe'), 0) as revenus_actuels,
  
  -- Taux d'occupation (uniquement logements, pas parking/cave)
  ROUND(
    COUNT(bu.id) FILTER (WHERE bu.status = 'occupe' AND bu.type NOT IN ('parking', 'cave'))::DECIMAL / 
    NULLIF(COUNT(bu.id) FILTER (WHERE bu.type NOT IN ('parking', 'cave')), 0) * 100, 
    1
  ) as occupancy_rate,
  
  -- Comptages par statut
  COUNT(bu.id) FILTER (WHERE bu.status = 'vacant' AND bu.type NOT IN ('parking', 'cave')) as vacant_units,
  COUNT(bu.id) FILTER (WHERE bu.status = 'occupe' AND bu.type NOT IN ('parking', 'cave')) as occupied_units,
  COUNT(bu.id) FILTER (WHERE bu.status = 'travaux') as units_en_travaux

FROM buildings b
LEFT JOIN building_units bu ON bu.building_id = b.id
GROUP BY b.id;

-- 5. Triggers pour mise à jour automatique
-- ============================================

-- Trigger pour updated_at sur buildings
CREATE OR REPLACE FUNCTION update_buildings_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_buildings_updated_at ON buildings;
CREATE TRIGGER trigger_buildings_updated_at
  BEFORE UPDATE ON buildings
  FOR EACH ROW
  EXECUTE FUNCTION update_buildings_updated_at();

-- Trigger pour updated_at sur building_units
DROP TRIGGER IF EXISTS trigger_building_units_updated_at ON building_units;
CREATE TRIGGER trigger_building_units_updated_at
  BEFORE UPDATE ON building_units
  FOR EACH ROW
  EXECUTE FUNCTION update_buildings_updated_at();

-- 6. Row Level Security (RLS)
-- ============================================

ALTER TABLE buildings ENABLE ROW LEVEL SECURITY;
ALTER TABLE building_units ENABLE ROW LEVEL SECURITY;

-- Policies pour buildings
DROP POLICY IF EXISTS "Owners can view their buildings" ON buildings;
CREATE POLICY "Owners can view their buildings" ON buildings
  FOR SELECT USING (
    owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

DROP POLICY IF EXISTS "Owners can create buildings" ON buildings;
CREATE POLICY "Owners can create buildings" ON buildings
  FOR INSERT WITH CHECK (
    owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

DROP POLICY IF EXISTS "Owners can update their buildings" ON buildings;
CREATE POLICY "Owners can update their buildings" ON buildings
  FOR UPDATE USING (
    owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

DROP POLICY IF EXISTS "Owners can delete their buildings" ON buildings;
CREATE POLICY "Owners can delete their buildings" ON buildings
  FOR DELETE USING (
    owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Policies pour building_units
DROP POLICY IF EXISTS "Owners can view their building units" ON building_units;
CREATE POLICY "Owners can view their building units" ON building_units
  FOR SELECT USING (
    building_id IN (
      SELECT id FROM buildings 
      WHERE owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

DROP POLICY IF EXISTS "Owners can create building units" ON building_units;
CREATE POLICY "Owners can create building units" ON building_units
  FOR INSERT WITH CHECK (
    building_id IN (
      SELECT id FROM buildings 
      WHERE owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

DROP POLICY IF EXISTS "Owners can update their building units" ON building_units;
CREATE POLICY "Owners can update their building units" ON building_units
  FOR UPDATE USING (
    building_id IN (
      SELECT id FROM buildings 
      WHERE owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

DROP POLICY IF EXISTS "Owners can delete their building units" ON building_units;
CREATE POLICY "Owners can delete their building units" ON building_units
  FOR DELETE USING (
    building_id IN (
      SELECT id FROM buildings 
      WHERE owner_id = (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- 7. Fonctions utilitaires
-- ============================================

-- Fonction pour calculer les stats d'un immeuble
CREATE OR REPLACE FUNCTION get_building_stats(p_building_id UUID)
RETURNS TABLE (
  total_units INTEGER,
  total_parkings INTEGER,
  total_caves INTEGER,
  surface_totale DECIMAL,
  revenus_potentiels DECIMAL,
  revenus_actuels DECIMAL,
  occupancy_rate DECIMAL,
  vacant_units INTEGER,
  occupied_units INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(bu.id) FILTER (WHERE bu.type NOT IN ('parking', 'cave'))::INTEGER,
    COUNT(bu.id) FILTER (WHERE bu.type = 'parking')::INTEGER,
    COUNT(bu.id) FILTER (WHERE bu.type = 'cave')::INTEGER,
    COALESCE(SUM(bu.surface), 0)::DECIMAL,
    COALESCE(SUM(bu.loyer_hc + bu.charges), 0)::DECIMAL,
    COALESCE(SUM(bu.loyer_hc + bu.charges) FILTER (WHERE bu.status = 'occupe'), 0)::DECIMAL,
    ROUND(
      COUNT(bu.id) FILTER (WHERE bu.status = 'occupe' AND bu.type NOT IN ('parking', 'cave'))::DECIMAL / 
      NULLIF(COUNT(bu.id) FILTER (WHERE bu.type NOT IN ('parking', 'cave')), 0) * 100, 
      1
    )::DECIMAL,
    COUNT(bu.id) FILTER (WHERE bu.status = 'vacant' AND bu.type NOT IN ('parking', 'cave'))::INTEGER,
    COUNT(bu.id) FILTER (WHERE bu.status = 'occupe' AND bu.type NOT IN ('parking', 'cave'))::INTEGER
  FROM building_units bu
  WHERE bu.building_id = p_building_id;
END;
$$ LANGUAGE plpgsql STABLE;

-- Fonction pour dupliquer un lot sur plusieurs étages
CREATE OR REPLACE FUNCTION duplicate_unit_to_floors(
  p_unit_id UUID,
  p_target_floors INTEGER[]
)
RETURNS SETOF building_units AS $$
DECLARE
  v_unit building_units;
  v_floor INTEGER;
  v_position TEXT;
  v_new_unit building_units;
BEGIN
  -- Récupérer le lot source
  SELECT * INTO v_unit FROM building_units WHERE id = p_unit_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Unit not found: %', p_unit_id;
  END IF;
  
  -- Dupliquer sur chaque étage cible
  FOREACH v_floor IN ARRAY p_target_floors
  LOOP
    -- Calculer la prochaine position disponible
    SELECT COALESCE(
      CHR(65 + COUNT(*)::INTEGER), 
      'A'
    ) INTO v_position
    FROM building_units 
    WHERE building_id = v_unit.building_id AND floor = v_floor;
    
    -- Insérer le nouveau lot
    INSERT INTO building_units (
      building_id, floor, position, type, template, 
      surface, nb_pieces, loyer_hc, charges, depot_garantie, status
    ) VALUES (
      v_unit.building_id, v_floor, v_position, v_unit.type, v_unit.template,
      v_unit.surface, v_unit.nb_pieces, v_unit.loyer_hc, v_unit.charges, 
      v_unit.depot_garantie, 'vacant'
    )
    RETURNING * INTO v_new_unit;
    
    RETURN NEXT v_new_unit;
  END LOOP;
  
  RETURN;
END;
$$ LANGUAGE plpgsql;

-- 8. Commentaires de documentation
-- ============================================

COMMENT ON TABLE buildings IS 'Immeubles entiers avec plusieurs lots/unités (SOTA 2026)';
COMMENT ON TABLE building_units IS 'Lots individuels appartenant à un immeuble';
COMMENT ON VIEW building_stats IS 'Vue agrégée des statistiques par immeuble';
COMMENT ON FUNCTION get_building_stats IS 'Calcule les stats détaillées d''un immeuble';
COMMENT ON FUNCTION duplicate_unit_to_floors IS 'Duplique un lot sur plusieurs étages';



-- ========== 20260107000000_rebranding_to_talok.sql ==========
-- Migration : Rebranding global vers Talok
-- Date : 2026-01-07
-- Description : Met à jour les données de base (plans, providers, etc.) pour refléter le nouveau nom

BEGIN;

-- 1. Mise à jour des descriptions des plans d'abonnement
UPDATE subscription_plans 
SET description = REPLACE(description, 'la gestion locative', 'Talok')
WHERE description LIKE '%la gestion locative%';

UPDATE subscription_plans 
SET description = REPLACE(description, 'Gestion Locative', 'Talok')
WHERE description LIKE '%Gestion Locative%';

-- Mise à jour spécifique pour le plan gratuit si nécessaire
UPDATE subscription_plans 
SET description = 'Découvrez Talok et simplifiez la gestion de votre premier bien'
WHERE slug = 'gratuit';

-- 2. Mise à jour des métadonnées des providers API si nécessaire
-- (Par exemple, si des noms d'affichage par défaut étaient stockés en JSON)
UPDATE api_credentials
SET config = config || jsonb_build_object('email_from', REPLACE(config->>'email_from', 'Gestion Locative', 'Talok'))
WHERE config ? 'email_from' AND config->>'email_from' LIKE '%Gestion Locative%';

-- 3. Mise à jour des commentaires de table pour la cohérence
COMMENT ON TABLE subscription_plans IS 'Plans d''abonnement Talok';
COMMENT ON TABLE profiles IS 'Profils utilisateurs Talok';

-- 4. Nettoyage des anciennes références dans les fonctions si elles utilisaient le nom en dur
-- (Après vérification, la plupart utilisent des paramètres, mais on assure le coup pour les messages de log)

CREATE OR REPLACE FUNCTION create_owner_subscription()
RETURNS TRIGGER AS $$
DECLARE
  v_plan_id UUID;
BEGIN
  -- Seulement pour les propriétaires
  IF NEW.role = 'owner' THEN
    -- Récupérer l'ID du plan gratuit (nouveau défaut)
    SELECT id INTO v_plan_id 
    FROM subscription_plans 
    WHERE slug = 'gratuit' 
    LIMIT 1;
    
    -- Fallback sur starter si gratuit n'existe pas
    IF v_plan_id IS NULL THEN
      SELECT id INTO v_plan_id 
      FROM subscription_plans 
      WHERE slug = 'starter' 
      LIMIT 1;
    END IF;
    
    -- Créer l'abonnement si le plan existe
    IF v_plan_id IS NOT NULL THEN
      INSERT INTO subscriptions (
        owner_id, 
        plan_id, 
        status, 
        billing_cycle, 
        current_period_start,
        current_period_end,
        properties_count,
        leases_count
      )
      VALUES (
        NEW.id,
        v_plan_id,
        'active',
        'monthly',
        NOW(),
        NOW() + INTERVAL '1 month',
        0,
        0
      )
      ON CONFLICT (owner_id) DO NOTHING;
      
      RAISE NOTICE 'Abonnement Talok Gratuit créé pour le propriétaire %', NEW.id;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMIT;



-- ========== 20260107000001_sota_lease_status_constraint.sql ==========
-- =====================================================
-- MIGRATION: SOTA 2026 - Contrainte de statuts de bail
-- Date: 2026-01-07
-- Description: Garantit que tous les statuts légaux de bail sont autorisés
-- =====================================================

-- 1. Supprimer l'ancienne contrainte si elle existe
ALTER TABLE leases DROP CONSTRAINT IF EXISTS leases_statut_check;

-- 2. Ajouter la nouvelle contrainte avec TOUS les statuts SOTA 2026
ALTER TABLE leases ADD CONSTRAINT leases_statut_check 
  CHECK (statut IN (
    'draft',                   -- Brouillon initial
    'sent',                    -- Envoyé pour signature
    'pending_signature',       -- En attente de signatures
    'partially_signed',        -- Partiellement signé
    'pending_owner_signature', -- Locataire signé, attente propriétaire
    'fully_signed',            -- Entièrement signé (avant activation)
    'active',                  -- Bail en cours
    'notice_given',            -- Congé donné (préavis)
    'amended',                 -- Avenant en cours
    'terminated',              -- Terminé
    'archived'                 -- Archivé
  ));

-- 3. Créer un index pour optimiser les requêtes par statut
CREATE INDEX IF NOT EXISTS idx_leases_statut ON leases(statut);

-- 4. Index partiel pour les baux en attente d'action (les plus fréquemment consultés)
CREATE INDEX IF NOT EXISTS idx_leases_pending_action ON leases(statut) 
  WHERE statut IN ('pending_signature', 'partially_signed', 'pending_owner_signature', 'fully_signed');

-- 5. Commenter pour la documentation
COMMENT ON COLUMN leases.statut IS 'Statut du bail: draft, sent, pending_signature, partially_signed, pending_owner_signature, fully_signed, active, notice_given, amended, terminated, archived';

-- 6. Log de migration
DO $$
DECLARE
  v_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM leases;
  RAISE NOTICE '[MIGRATION] Contrainte statuts SOTA 2026 appliquée. % baux existants.', v_count;
END $$;



-- ========== 20260107000002_fix_existing_lease_statuses_sota.sql ==========
-- =====================================================
-- MIGRATION: SOTA 2026 - Correction des statuts de baux existants
-- Date: 2026-01-07
-- Description: Corrige les baux mal catégorisés après le fix de determineLeaseStatus
-- =====================================================

-- 1. CORRECTION : Baux marqués "active" mais sans EDL d'entrée signé
-- Ces baux auraient dû être "fully_signed" et attendre l'EDL
UPDATE leases SET 
  statut = 'fully_signed',
  updated_at = NOW()
WHERE statut = 'active'
  AND id NOT IN (
    -- Exclure les baux qui ont un EDL d'entrée signé
    SELECT DISTINCT lease_id FROM edl 
    WHERE type = 'entree' AND status = 'signed'
  )
  AND id IN (
    -- Seulement les baux où tous les signataires ont signé
    SELECT ls.lease_id
    FROM lease_signers ls
    GROUP BY ls.lease_id
    HAVING COUNT(*) > 1 
       AND COUNT(*) = COUNT(CASE WHEN ls.signature_status = 'signed' THEN 1 END)
  );

-- Log du nombre de corrections
DO $$
DECLARE
  v_count INTEGER;
BEGIN
  GET DIAGNOSTICS v_count = ROW_COUNT;
  IF v_count > 0 THEN
    RAISE NOTICE '[SOTA 2026] % bail(s) corrigé(s) de "active" vers "fully_signed"', v_count;
  ELSE
    RAISE NOTICE '[SOTA 2026] Aucun bail à corriger';
  END IF;
END $$;

-- 2. CORRECTION : Baux en "pending_signature" alors que tous ont signé
UPDATE leases SET 
  statut = 'fully_signed',
  updated_at = NOW()
WHERE statut IN ('pending_signature', 'partially_signed')
  AND id IN (
    -- Baux où tous les signataires ont signé
    SELECT ls.lease_id
    FROM lease_signers ls
    GROUP BY ls.lease_id
    HAVING COUNT(*) >= 2 -- Au moins propriétaire + locataire
       AND COUNT(*) = COUNT(CASE WHEN ls.signature_status = 'signed' THEN 1 END)
  );

-- 3. CORRECTION : Baux en "pending_signature" où locataire signé mais pas proprio
UPDATE leases SET 
  statut = 'pending_owner_signature',
  updated_at = NOW()
WHERE statut = 'pending_signature'
  AND id IN (
    SELECT ls.lease_id
    FROM lease_signers ls
    WHERE ls.role IN ('locataire_principal', 'locataire', 'tenant', 'colocataire')
      AND ls.signature_status = 'signed'
    GROUP BY ls.lease_id
  )
  AND id NOT IN (
    SELECT ls.lease_id
    FROM lease_signers ls
    WHERE ls.role IN ('proprietaire', 'owner')
      AND ls.signature_status = 'signed'
    GROUP BY ls.lease_id
  );

-- 4. Rapport final
DO $$
DECLARE
  v_draft INTEGER;
  v_pending INTEGER;
  v_fully_signed INTEGER;
  v_active INTEGER;
  v_terminated INTEGER;
BEGIN
  SELECT 
    COUNT(*) FILTER (WHERE statut = 'draft'),
    COUNT(*) FILTER (WHERE statut IN ('pending_signature', 'partially_signed', 'pending_owner_signature', 'sent')),
    COUNT(*) FILTER (WHERE statut = 'fully_signed'),
    COUNT(*) FILTER (WHERE statut = 'active'),
    COUNT(*) FILTER (WHERE statut IN ('terminated', 'archived'))
  INTO v_draft, v_pending, v_fully_signed, v_active, v_terminated
  FROM leases;
  
  RAISE NOTICE '=== RAPPORT STATUTS BAUX SOTA 2026 ===';
  RAISE NOTICE 'Brouillons: %', v_draft;
  RAISE NOTICE 'En attente de signature: %', v_pending;
  RAISE NOTICE 'Entièrement signés (attente EDL): %', v_fully_signed;
  RAISE NOTICE 'Actifs: %', v_active;
  RAISE NOTICE 'Terminés/Archivés: %', v_terminated;
  RAISE NOTICE '======================================';
END $$;



-- ========== 20260107100000_fix_auth_500_database_error.sql ==========
-- =====================================================
-- MIGRATION: Fix erreur "Database error querying schema" (500)
-- Date: 2026-01-07
-- Problème: L'authentification échoue avec une erreur 500
-- Cause: Fonctions RLS manquantes ou politiques mal configurées
-- =====================================================

-- 1. RECRÉER LES FONCTIONS HELPER AVEC SECURITY DEFINER
CREATE OR REPLACE FUNCTION public.user_profile_id()
RETURNS UUID
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT id FROM profiles WHERE user_id = auth.uid() LIMIT 1;
$$;

CREATE OR REPLACE FUNCTION public.user_role()
RETURNS TEXT
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT role FROM profiles WHERE user_id = auth.uid() LIMIT 1;
$$;

CREATE OR REPLACE FUNCTION public.user_profile_id(p_user_id UUID)
RETURNS UUID
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT id FROM profiles WHERE user_id = p_user_id LIMIT 1;
$$;

CREATE OR REPLACE FUNCTION public.user_role(p_user_id UUID)
RETURNS TEXT
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT role FROM profiles WHERE user_id = p_user_id LIMIT 1;
$$;

-- 2. S'ASSURER QUE RLS EST ACTIVÉ
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- 3. NETTOYER LES ANCIENNES POLITIQUES
DROP POLICY IF EXISTS "profiles_self_all" ON profiles;
DROP POLICY IF EXISTS "profiles_admin_all" ON profiles;
DROP POLICY IF EXISTS "profiles_owner_view_tenants" ON profiles;
DROP POLICY IF EXISTS "Users can view own profile" ON profiles;
DROP POLICY IF EXISTS "Users can update own profile" ON profiles;
DROP POLICY IF EXISTS "Admins can view all profiles" ON profiles;
DROP POLICY IF EXISTS "users_view_own_profile" ON profiles;
DROP POLICY IF EXISTS "users_update_own_profile" ON profiles;
DROP POLICY IF EXISTS "admins_view_all_profiles" ON profiles;

-- 4. CRÉER LES NOUVELLES POLITIQUES
CREATE POLICY "profiles_self_all" ON profiles 
FOR ALL TO authenticated 
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());

CREATE POLICY "profiles_admin_all" ON profiles 
FOR SELECT TO authenticated 
USING (public.user_role() = 'admin');

CREATE POLICY "profiles_owner_view_tenants" ON profiles 
FOR SELECT TO authenticated 
USING (
  EXISTS (
    SELECT 1 FROM lease_signers ls
    JOIN leases l ON l.id = ls.lease_id
    JOIN properties p ON p.id = l.property_id
    WHERE ls.profile_id = profiles.id
    AND p.owner_id = public.user_profile_id()
  )
);



-- ========== 20260107150000_fix_profiles_rls_recursion.sql ==========
-- =====================================================
-- MIGRATION: Correction DÉFINITIVE de la récursion RLS sur profiles
-- Date: 2026-01-07
-- Problème: "RLS recursion detected" - erreur 500 sur profiles
-- 
-- CAUSE: Les politiques RLS sur `profiles` appellent user_role() 
--        qui requête `profiles`, créant une boucle infinie.
--
-- SOLUTION: Utiliser auth.uid() directement dans les politiques
--           et des sous-requêtes avec SECURITY DEFINER
-- =====================================================

-- 1. DÉSACTIVER TEMPORAIREMENT RLS POUR LE NETTOYAGE
ALTER TABLE profiles DISABLE ROW LEVEL SECURITY;

-- 2. SUPPRIMER TOUTES LES ANCIENNES POLITIQUES SUR profiles
DO $$
DECLARE
  pol RECORD;
BEGIN
  FOR pol IN 
    SELECT policyname 
    FROM pg_policies 
    WHERE tablename = 'profiles' AND schemaname = 'public'
  LOOP
    EXECUTE format('DROP POLICY IF EXISTS %I ON profiles', pol.policyname);
  END LOOP;
END $$;

-- 3. CRÉER UNE FONCTION POUR VÉRIFIER SI L'UTILISATEUR EST ADMIN
-- Cette fonction utilise une vue matérialisée ou un cache pour éviter la récursion
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM profiles 
    WHERE user_id = auth.uid() 
    AND role = 'admin'
    LIMIT 1
  );
$$;

-- 4. CRÉER UNE FONCTION POUR OBTENIR LE ROLE SANS RLS
CREATE OR REPLACE FUNCTION public.get_my_role()
RETURNS TEXT
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT COALESCE(
    (SELECT role FROM profiles WHERE user_id = auth.uid() LIMIT 1),
    'anonymous'
  );
$$;

-- 5. CRÉER UNE FONCTION POUR OBTENIR MON PROFILE_ID SANS RLS  
CREATE OR REPLACE FUNCTION public.get_my_profile_id()
RETURNS UUID
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT id FROM profiles WHERE user_id = auth.uid() LIMIT 1;
$$;

-- 6. RÉACTIVER RLS
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- 7. CRÉER LES NOUVELLES POLITIQUES (SANS RÉCURSION)
-- Politique principale : chaque utilisateur peut voir/modifier son propre profil
CREATE POLICY "profiles_own_access" ON profiles 
FOR ALL TO authenticated 
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());

-- Politique admin : les admins peuvent voir tous les profils
-- Utilise is_admin() qui est SECURITY DEFINER et donc bypass RLS
CREATE POLICY "profiles_admin_read" ON profiles 
FOR SELECT TO authenticated 
USING (public.is_admin());

-- Politique propriétaire : peut voir les profils de ses locataires
-- Évite la récursion en utilisant get_my_profile_id()
CREATE POLICY "profiles_owner_read_tenants" ON profiles 
FOR SELECT TO authenticated 
USING (
  -- Je suis propriétaire et ce profil est un locataire d'un de mes baux
  EXISTS (
    SELECT 1 
    FROM lease_signers ls
    INNER JOIN leases l ON l.id = ls.lease_id
    INNER JOIN properties p ON p.id = l.property_id
    WHERE ls.profile_id = profiles.id
    AND p.owner_id = public.get_my_profile_id()
  )
);

-- 8. VÉRIFIER QUE LES FONCTIONS EXISTANTES SONT BIEN SECURITY DEFINER
-- user_profile_id et user_role sont utilisées ailleurs, on les garde compatibles
CREATE OR REPLACE FUNCTION public.user_profile_id()
RETURNS UUID
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT public.get_my_profile_id();
$$;

CREATE OR REPLACE FUNCTION public.user_role()
RETURNS TEXT
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT public.get_my_role();
$$;

-- Versions avec paramètre (pour usage admin)
CREATE OR REPLACE FUNCTION public.user_profile_id(p_user_id UUID)
RETURNS UUID
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT id FROM profiles WHERE user_id = p_user_id LIMIT 1;
$$;

CREATE OR REPLACE FUNCTION public.user_role(p_user_id UUID)
RETURNS TEXT
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT COALESCE(role, 'anonymous') FROM profiles WHERE user_id = p_user_id LIMIT 1;
$$;

-- 9. ACCORDER LES PERMISSIONS SUR LES FONCTIONS
GRANT EXECUTE ON FUNCTION public.is_admin() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_my_role() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_my_profile_id() TO authenticated;
GRANT EXECUTE ON FUNCTION public.user_profile_id() TO authenticated;
GRANT EXECUTE ON FUNCTION public.user_role() TO authenticated;
GRANT EXECUTE ON FUNCTION public.user_profile_id(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.user_role(UUID) TO authenticated;

-- 10. TEST : Vérifier qu'il n'y a pas de récursion
-- Cette requête ne devrait pas échouer
DO $$
BEGIN
  RAISE NOTICE 'Test des politiques RLS sur profiles...';
  -- Le test réel se fait en appelant les fonctions
  PERFORM public.is_admin();
  PERFORM public.get_my_role();
  PERFORM public.get_my_profile_id();
  RAISE NOTICE 'OK - Pas de récursion détectée';
EXCEPTION WHEN OTHERS THEN
  RAISE NOTICE 'ERREUR: %', SQLERRM;
END $$;

COMMENT ON FUNCTION public.is_admin() IS 'Vérifie si l''utilisateur actuel est admin (SECURITY DEFINER, pas de récursion RLS)';
COMMENT ON FUNCTION public.get_my_role() IS 'Retourne le rôle de l''utilisateur actuel (SECURITY DEFINER, pas de récursion RLS)';
COMMENT ON FUNCTION public.get_my_profile_id() IS 'Retourne le profile_id de l''utilisateur actuel (SECURITY DEFINER, pas de récursion RLS)';



-- ========== 20260108000000_normalize_signer_roles.sql ==========
-- ============================================
-- MIGRATION SSOT 2026: Normalisation des rôles de signataires
-- ============================================
-- Cette migration normalise tous les rôles de signataires vers les valeurs standard:
-- - proprietaire (anciennement: owner, bailleur, Proprietaire, etc.)
-- - locataire_principal (anciennement: locataire, tenant, principal, Locataire, etc.)
-- - colocataire (anciennement: co_locataire, cotenant, etc.)
-- - garant (anciennement: caution, guarantor, etc.)
-- ============================================

-- 1. Normaliser les rôles de propriétaires
UPDATE lease_signers
SET role = 'proprietaire'
WHERE LOWER(TRIM(role)) IN ('owner', 'bailleur', 'proprietaire');

-- 2. Normaliser les rôles de locataires principaux
UPDATE lease_signers
SET role = 'locataire_principal'
WHERE LOWER(TRIM(role)) IN ('locataire', 'tenant', 'principal', 'locataire_principal');

-- 3. Normaliser les rôles de colocataires
UPDATE lease_signers
SET role = 'colocataire'
WHERE LOWER(TRIM(role)) IN ('co_locataire', 'cotenant', 'colocataire');

-- 4. Normaliser les rôles de garants
UPDATE lease_signers
SET role = 'garant'
WHERE LOWER(TRIM(role)) IN ('caution', 'guarantor', 'garant');

-- ============================================
-- Ajouter une contrainte CHECK pour valider les rôles futurs
-- ============================================
DO $$
BEGIN
  -- Supprimer l'ancienne contrainte si elle existe
  ALTER TABLE lease_signers DROP CONSTRAINT IF EXISTS lease_signers_role_check;
  
  -- Ajouter la nouvelle contrainte
  ALTER TABLE lease_signers ADD CONSTRAINT lease_signers_role_check 
  CHECK (role IN ('proprietaire', 'locataire_principal', 'colocataire', 'garant'));
EXCEPTION
  WHEN duplicate_object THEN
    RAISE NOTICE 'Contrainte lease_signers_role_check existe déjà';
END $$;

-- ============================================
-- Logs de la migration
-- ============================================
DO $$
DECLARE
  owner_count INTEGER;
  tenant_count INTEGER;
  cotenant_count INTEGER;
  garant_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO owner_count FROM lease_signers WHERE role = 'proprietaire';
  SELECT COUNT(*) INTO tenant_count FROM lease_signers WHERE role = 'locataire_principal';
  SELECT COUNT(*) INTO cotenant_count FROM lease_signers WHERE role = 'colocataire';
  SELECT COUNT(*) INTO garant_count FROM lease_signers WHERE role = 'garant';
  
  RAISE NOTICE '=== Migration SSOT 2026 terminée ===';
  RAISE NOTICE 'Signataires propriétaires: %', owner_count;
  RAISE NOTICE 'Signataires locataires principaux: %', tenant_count;
  RAISE NOTICE 'Signataires colocataires: %', cotenant_count;
  RAISE NOTICE 'Signataires garants: %', garant_count;
END $$;



-- ========== 20260108100000_fix_depot_garantie_auto.sql ==========
-- ============================================
-- MIGRATION: Correction automatique des dépôts de garantie
-- ============================================
-- Cette migration recalcule les dépôts de garantie pour tous les baux
-- où le dépôt dépasse le maximum légal.
--
-- Règles légales:
-- - Bail nu: max 1 mois de loyer
-- - Bail meublé/colocation: max 2 mois de loyer
-- - Bail mobilité: 0€ (interdit)
-- ============================================

-- 1. Corriger les baux nus avec dépôt > 1 mois
UPDATE leases
SET depot_de_garantie = loyer
WHERE type_bail = 'nu'
  AND depot_de_garantie > loyer
  AND loyer > 0;

-- 2. Corriger les baux meublés avec dépôt > 2 mois
UPDATE leases
SET depot_de_garantie = loyer * 2
WHERE type_bail IN ('meuble', 'colocation', 'saisonnier')
  AND depot_de_garantie > (loyer * 2)
  AND loyer > 0;

-- 3. Corriger les baux mobilité avec dépôt > 0
UPDATE leases
SET depot_de_garantie = 0
WHERE type_bail = 'mobilite'
  AND depot_de_garantie > 0;

-- 4. Log du résultat
DO $$
DECLARE
  total_fixed INTEGER;
BEGIN
  SELECT COUNT(*) INTO total_fixed FROM leases;
  RAISE NOTICE 'Migration terminée. Baux vérifiés: %', total_fixed;
END $$;

-- 5. Vérification finale: aucun dépôt ne doit dépasser le max légal
DO $$
DECLARE
  invalid_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO invalid_count
  FROM leases
  WHERE 
    (type_bail = 'nu' AND depot_de_garantie > loyer AND loyer > 0)
    OR (type_bail IN ('meuble', 'colocation', 'saisonnier') AND depot_de_garantie > loyer * 2 AND loyer > 0)
    OR (type_bail = 'mobilite' AND depot_de_garantie > 0);
  
  IF invalid_count > 0 THEN
    RAISE WARNING 'ATTENTION: % baux ont encore un dépôt invalide', invalid_count;
  ELSE
    RAISE NOTICE '✅ Tous les dépôts sont conformes au maximum légal';
  END IF;
END $$;



-- ========== 20260108200000_tenant_notification_triggers.sql ==========
-- =====================================================
-- Migration SOTA 2026: Triggers de notifications pour LOCATAIRES
-- Date: 2026-01-08
-- Description: Génère des notifications automatiques pour les locataires
--              lorsque le propriétaire effectue des modifications
-- =====================================================

-- =====================================================
-- TRIGGER 1: Notification quand le loyer est modifié
-- =====================================================
CREATE OR REPLACE FUNCTION notify_tenant_lease_updated()
RETURNS TRIGGER AS $$
DECLARE
  v_tenant RECORD;
  v_property_address TEXT;
  v_change_description TEXT;
BEGIN
  -- Récupérer l'adresse du logement
  SELECT COALESCE(adresse_complete, 'Logement')
  INTO v_property_address
  FROM properties
  WHERE id = NEW.property_id;

  -- Construire la description des changements
  v_change_description := '';
  
  -- Changement de loyer
  IF OLD.loyer IS DISTINCT FROM NEW.loyer THEN
    v_change_description := format('Loyer: %s€ → %s€', OLD.loyer, NEW.loyer);
  END IF;
  
  -- Changement de charges
  IF OLD.charges_forfaitaires IS DISTINCT FROM NEW.charges_forfaitaires THEN
    IF v_change_description != '' THEN
      v_change_description := v_change_description || ', ';
    END IF;
    v_change_description := v_change_description || format('Charges: %s€ → %s€', COALESCE(OLD.charges_forfaitaires, 0), COALESCE(NEW.charges_forfaitaires, 0));
  END IF;
  
  -- Changement de dépôt
  IF OLD.depot_de_garantie IS DISTINCT FROM NEW.depot_de_garantie THEN
    IF v_change_description != '' THEN
      v_change_description := v_change_description || ', ';
    END IF;
    v_change_description := v_change_description || format('Dépôt: %s€ → %s€', COALESCE(OLD.depot_de_garantie, 0), COALESCE(NEW.depot_de_garantie, 0));
  END IF;

  -- Si des changements financiers ont été détectés
  IF v_change_description != '' THEN
    -- Notifier tous les locataires du bail
    FOR v_tenant IN
      SELECT DISTINCT ls.profile_id
      FROM lease_signers ls
      WHERE ls.lease_id = NEW.id
        AND ls.role IN ('locataire_principal', 'colocataire')
        AND ls.profile_id IS NOT NULL
    LOOP
      PERFORM create_notification(
        v_tenant.profile_id,
        'alert',
        'Modification de votre bail',
        format('%s - %s', v_property_address, v_change_description),
        '/tenant/lease',
        NEW.id,
        'lease'
      );
    END LOOP;
  END IF;
  
  -- Changement de statut vers "active"
  IF OLD.statut != 'active' AND NEW.statut = 'active' THEN
    FOR v_tenant IN
      SELECT DISTINCT ls.profile_id
      FROM lease_signers ls
      WHERE ls.lease_id = NEW.id
        AND ls.role IN ('locataire_principal', 'colocataire')
        AND ls.profile_id IS NOT NULL
    LOOP
      PERFORM create_notification(
        v_tenant.profile_id,
        'lease_signed',
        'Votre bail est actif ! 🎉',
        format('Bienvenue dans votre nouveau logement: %s', v_property_address),
        '/tenant/dashboard',
        NEW.id,
        'lease'
      );
    END LOOP;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_notify_tenant_lease_updated ON leases;
CREATE TRIGGER trigger_notify_tenant_lease_updated
  AFTER UPDATE ON leases
  FOR EACH ROW
  EXECUTE FUNCTION notify_tenant_lease_updated();

-- =====================================================
-- TRIGGER 2: Notification quand une quittance est générée
-- =====================================================
CREATE OR REPLACE FUNCTION notify_tenant_invoice_created()
RETURNS TRIGGER AS $$
DECLARE
  v_tenant RECORD;
  v_property_address TEXT;
BEGIN
  -- Seulement pour les factures envoyées (pas les brouillons)
  IF NEW.statut NOT IN ('sent', 'draft') THEN
    RETURN NEW;
  END IF;

  -- Récupérer l'adresse via le bail
  SELECT COALESCE(p.adresse_complete, 'Logement')
  INTO v_property_address
  FROM leases l
  JOIN properties p ON l.property_id = p.id
  WHERE l.id = NEW.lease_id;

  -- Notifier tous les locataires du bail
  FOR v_tenant IN
    SELECT DISTINCT ls.profile_id
    FROM lease_signers ls
    WHERE ls.lease_id = NEW.lease_id
      AND ls.role IN ('locataire_principal', 'colocataire')
      AND ls.profile_id IS NOT NULL
  LOOP
    PERFORM create_notification(
      v_tenant.profile_id,
      'payment_reminder',
      format('Loyer %s à payer', NEW.periode),
      format('%s€ pour %s', NEW.montant_total, v_property_address),
      '/tenant/payments',
      NEW.id,
      'invoice'
    );
  END LOOP;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_notify_tenant_invoice_created ON invoices;
CREATE TRIGGER trigger_notify_tenant_invoice_created
  AFTER INSERT ON invoices
  FOR EACH ROW
  EXECUTE FUNCTION notify_tenant_invoice_created();

-- =====================================================
-- TRIGGER 3: Notification quand un document est uploadé
-- =====================================================
CREATE OR REPLACE FUNCTION notify_tenant_document_uploaded()
RETURNS TRIGGER AS $$
DECLARE
  v_tenant_id UUID;
  v_doc_type_label TEXT;
  v_property_address TEXT;
BEGIN
  -- Labels lisibles pour les types de documents
  CASE NEW.type
    WHEN 'quittance' THEN v_doc_type_label := 'Quittance de loyer';
    WHEN 'bail' THEN v_doc_type_label := 'Contrat de bail';
    WHEN 'EDL_entree' THEN v_doc_type_label := 'État des lieux d''entrée';
    WHEN 'EDL_sortie' THEN v_doc_type_label := 'État des lieux de sortie';
    WHEN 'attestation_assurance' THEN v_doc_type_label := 'Attestation d''assurance';
    WHEN 'reglement_interieur' THEN v_doc_type_label := 'Règlement intérieur';
    ELSE v_doc_type_label := 'Document';
  END CASE;

  -- Récupérer l'adresse du logement
  IF NEW.property_id IS NOT NULL THEN
    SELECT COALESCE(adresse_complete, 'Logement')
    INTO v_property_address
    FROM properties
    WHERE id = NEW.property_id;
  ELSE
    v_property_address := 'Votre logement';
  END IF;

  -- Si le document est lié à un locataire spécifique
  IF NEW.tenant_id IS NOT NULL THEN
    PERFORM create_notification(
      NEW.tenant_id,
      'document_uploaded',
      format('Nouveau %s disponible', v_doc_type_label),
      format('Un document a été ajouté pour %s', v_property_address),
      '/tenant/documents',
      NEW.id,
      'document'
    );
  -- Sinon, notifier tous les locataires du bail
  ELSIF NEW.lease_id IS NOT NULL THEN
    FOR v_tenant_id IN
      SELECT DISTINCT ls.profile_id
      FROM lease_signers ls
      WHERE ls.lease_id = NEW.lease_id
        AND ls.role IN ('locataire_principal', 'colocataire')
        AND ls.profile_id IS NOT NULL
    LOOP
      PERFORM create_notification(
        v_tenant_id,
        'document_uploaded',
        format('Nouveau %s disponible', v_doc_type_label),
        format('Un document a été ajouté pour %s', v_property_address),
        '/tenant/documents',
        NEW.id,
        'document'
      );
    END LOOP;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_notify_tenant_document_uploaded ON documents;
CREATE TRIGGER trigger_notify_tenant_document_uploaded
  AFTER INSERT ON documents
  FOR EACH ROW
  EXECUTE FUNCTION notify_tenant_document_uploaded();

-- =====================================================
-- TRIGGER 4: Notification quand le propriétaire signe
-- =====================================================
CREATE OR REPLACE FUNCTION notify_tenant_owner_signed()
RETURNS TRIGGER AS $$
DECLARE
  v_tenant RECORD;
  v_property_address TEXT;
  v_signer_role TEXT;
BEGIN
  -- Seulement si la signature vient d'être complétée
  IF OLD.signature_status != 'signed' AND NEW.signature_status = 'signed' THEN
    -- Récupérer le rôle du signataire
    v_signer_role := NEW.role;
    
    -- Seulement si c'est le propriétaire qui vient de signer
    IF v_signer_role = 'proprietaire' THEN
      -- Récupérer l'adresse du logement
      SELECT COALESCE(p.adresse_complete, 'Logement')
      INTO v_property_address
      FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = NEW.lease_id;

      -- Notifier tous les locataires du bail
      FOR v_tenant IN
        SELECT DISTINCT ls.profile_id
        FROM lease_signers ls
        WHERE ls.lease_id = NEW.lease_id
          AND ls.role IN ('locataire_principal', 'colocataire')
          AND ls.profile_id IS NOT NULL
          AND ls.profile_id != NEW.profile_id -- Ne pas notifier le signataire lui-même
      LOOP
        PERFORM create_notification(
          v_tenant.profile_id,
          'document_signed',
          'Le propriétaire a signé le bail ! ✍️',
          format('Votre bail pour %s a été signé par le propriétaire', v_property_address),
          '/tenant/lease',
          NEW.lease_id,
          'lease'
        );
      END LOOP;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_notify_tenant_owner_signed ON lease_signers;
CREATE TRIGGER trigger_notify_tenant_owner_signed
  AFTER UPDATE ON lease_signers
  FOR EACH ROW
  EXECUTE FUNCTION notify_tenant_owner_signed();

-- =====================================================
-- TRIGGER 5: Notification quand un EDL est planifié
-- =====================================================
CREATE OR REPLACE FUNCTION notify_tenant_edl_scheduled()
RETURNS TRIGGER AS $$
DECLARE
  v_tenant RECORD;
  v_property_address TEXT;
  v_edl_type_label TEXT;
BEGIN
  -- Seulement pour les nouveaux EDLs ou changement de date
  IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.scheduled_at IS DISTINCT FROM NEW.scheduled_at) THEN
    -- Label du type d'EDL
    v_edl_type_label := CASE NEW.type
      WHEN 'entree' THEN 'État des lieux d''entrée'
      WHEN 'sortie' THEN 'État des lieux de sortie'
      ELSE 'État des lieux'
    END;

    -- Récupérer l'adresse du logement
    SELECT COALESCE(adresse_complete, 'Logement')
    INTO v_property_address
    FROM properties
    WHERE id = NEW.property_id;

    -- Notifier tous les signataires de l'EDL
    FOR v_tenant IN
      SELECT DISTINCT es.signer_profile_id
      FROM edl_signatures es
      WHERE es.edl_id = NEW.id
        AND es.signer_profile_id IS NOT NULL
    LOOP
      PERFORM create_notification(
        v_tenant.signer_profile_id,
        'reminder',
        format('%s planifié', v_edl_type_label),
        format('%s - %s le %s', 
          v_property_address,
          v_edl_type_label,
          to_char(NEW.scheduled_at, 'DD/MM/YYYY à HH24:MI')
        ),
        '/tenant/documents',
        NEW.id,
        'edl'
      );
    END LOOP;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_notify_tenant_edl_scheduled ON edls;
CREATE TRIGGER trigger_notify_tenant_edl_scheduled
  AFTER INSERT OR UPDATE ON edls
  FOR EACH ROW
  EXECUTE FUNCTION notify_tenant_edl_scheduled();

-- =====================================================
-- TRIGGER 6: Notification quand une signature est demandée
-- =====================================================
CREATE OR REPLACE FUNCTION notify_tenant_signature_requested()
RETURNS TRIGGER AS $$
DECLARE
  v_property_address TEXT;
  v_lease_type TEXT;
BEGIN
  -- Seulement pour les nouvelles entrées avec statut pending
  IF NEW.signature_status = 'pending' AND NEW.role IN ('locataire_principal', 'colocataire') THEN
    -- Récupérer les infos du bail
    SELECT 
      COALESCE(p.adresse_complete, 'Logement'),
      l.type_bail
    INTO v_property_address, v_lease_type
    FROM leases l
    JOIN properties p ON l.property_id = p.id
    WHERE l.id = NEW.lease_id;

    -- Notifier le locataire
    IF NEW.profile_id IS NOT NULL THEN
      PERFORM create_notification(
        NEW.profile_id,
        'lease_pending_signature',
        'Signature de bail requise ✍️',
        format('Votre bail %s pour %s est prêt à être signé', 
          COALESCE(v_lease_type, 'location'),
          v_property_address
        ),
        '/tenant/onboarding/sign',
        NEW.lease_id,
        'lease'
      );
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_notify_tenant_signature_requested ON lease_signers;
CREATE TRIGGER trigger_notify_tenant_signature_requested
  AFTER INSERT ON lease_signers
  FOR EACH ROW
  EXECUTE FUNCTION notify_tenant_signature_requested();

-- =====================================================
-- TRIGGER 7: Notification quand un ticket est mis à jour
-- =====================================================
CREATE OR REPLACE FUNCTION notify_tenant_ticket_updated()
RETURNS TRIGGER AS $$
DECLARE
  v_status_label TEXT;
BEGIN
  -- Seulement si le statut change
  IF OLD.statut IS DISTINCT FROM NEW.statut THEN
    -- Label du statut
    v_status_label := CASE NEW.statut
      WHEN 'in_progress' THEN 'est en cours de traitement'
      WHEN 'resolved' THEN 'a été résolu ✅'
      WHEN 'closed' THEN 'a été clôturé'
      ELSE format('a changé de statut: %s', NEW.statut)
    END;

    -- Notifier le créateur du ticket
    IF NEW.created_by_profile_id IS NOT NULL THEN
      PERFORM create_notification(
        NEW.created_by_profile_id,
        CASE NEW.statut
          WHEN 'resolved' THEN 'ticket_resolved'
          ELSE 'ticket_update'
        END,
        format('Ticket "%s" %s', LEFT(NEW.titre, 30), v_status_label),
        format('Votre demande concernant "%s" %s', NEW.titre, v_status_label),
        format('/tenant/requests/%s', NEW.id),
        NEW.id,
        'ticket'
      );
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_notify_tenant_ticket_updated ON tickets;
CREATE TRIGGER trigger_notify_tenant_ticket_updated
  AFTER UPDATE ON tickets
  FOR EACH ROW
  EXECUTE FUNCTION notify_tenant_ticket_updated();

-- =====================================================
-- INDEX pour optimiser les requêtes de notifications
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_lease_signers_profile_role 
  ON lease_signers(profile_id, role) 
  WHERE role IN ('locataire_principal', 'colocataire');

CREATE INDEX IF NOT EXISTS idx_notifications_recipient_type 
  ON notifications(recipient_id, type);

-- =====================================================
-- Logs de la migration
-- =====================================================
DO $$
BEGIN
  RAISE NOTICE '=== Migration SOTA 2026: Triggers notifications locataires ===';
  RAISE NOTICE '✅ Trigger 1: notify_tenant_lease_updated (loyer, charges, statut)';
  RAISE NOTICE '✅ Trigger 2: notify_tenant_invoice_created (nouvelles factures)';
  RAISE NOTICE '✅ Trigger 3: notify_tenant_document_uploaded (documents)';
  RAISE NOTICE '✅ Trigger 4: notify_tenant_owner_signed (signature propriétaire)';
  RAISE NOTICE '✅ Trigger 5: notify_tenant_edl_scheduled (EDL planifiés)';
  RAISE NOTICE '✅ Trigger 6: notify_tenant_signature_requested (demande signature)';
  RAISE NOTICE '✅ Trigger 7: notify_tenant_ticket_updated (tickets)';
  RAISE NOTICE '✅ Index optimisés créés';
  RAISE NOTICE '=== Synchronisation bidirectionnelle propriétaire ↔ locataire ACTIVÉE ===';
END $$;



-- ========== 20260108300000_property_soft_delete.sql ==========
-- =====================================================
-- Migration SOTA 2026: Soft-Delete pour les propriétés
-- Date: 2026-01-08
-- Description: 
--   - Ajoute les colonnes pour le soft-delete
--   - Crée un trigger de notification avant suppression
--   - Protège contre la suppression accidentelle
-- =====================================================

-- =====================================================
-- 1. Ajouter les colonnes de soft-delete
-- =====================================================
ALTER TABLE properties 
  ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS deleted_by UUID REFERENCES profiles(id) ON DELETE SET NULL;

-- Index pour filtrer les propriétés non supprimées
CREATE INDEX IF NOT EXISTS idx_properties_deleted_at ON properties(deleted_at) WHERE deleted_at IS NULL;

-- Ajouter 'deleted' comme état valide
DO $$
BEGIN
  -- Vérifier si la contrainte existe
  IF EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'properties_etat_check'
  ) THEN
    ALTER TABLE properties DROP CONSTRAINT properties_etat_check;
  END IF;
  
  -- Recréer avec 'deleted'
  ALTER TABLE properties ADD CONSTRAINT properties_etat_check 
    CHECK (etat IN ('draft', 'pending', 'published', 'rejected', 'deleted', 'archived'));
EXCEPTION
  WHEN others THEN
    RAISE NOTICE 'Contrainte etat non modifiée: %', SQLERRM;
END $$;

-- =====================================================
-- 2. Trigger de notification AVANT suppression hard
-- =====================================================
CREATE OR REPLACE FUNCTION notify_tenants_before_property_delete()
RETURNS TRIGGER AS $$
DECLARE
  v_tenant RECORD;
  v_address TEXT;
BEGIN
  -- Récupérer l'adresse
  v_address := COALESCE(OLD.adresse_complete, 'Logement');

  -- Notifier tous les locataires des baux de cette propriété
  FOR v_tenant IN
    SELECT DISTINCT ls.profile_id
    FROM leases l
    JOIN lease_signers ls ON ls.lease_id = l.id
    WHERE l.property_id = OLD.id
      AND ls.role IN ('locataire_principal', 'colocataire')
      AND ls.profile_id IS NOT NULL
  LOOP
    -- Vérifier que la fonction create_notification existe
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'create_notification') THEN
      PERFORM create_notification(
        v_tenant.profile_id,
        'alert',
        'Logement supprimé',
        format('Le logement "%s" a été supprimé. Vos documents restent accessibles.', v_address),
        '/tenant/documents',
        OLD.id,
        'property'
      );
    ELSE
      -- Fallback: insertion directe
      INSERT INTO notifications (recipient_id, type, title, message, link, related_id, related_type)
      VALUES (
        v_tenant.profile_id,
        'alert',
        'Logement supprimé',
        format('Le logement "%s" a été supprimé. Vos documents restent accessibles.', v_address),
        '/tenant/documents',
        OLD.id,
        'property'
      );
    END IF;
  END LOOP;

  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_notify_tenants_before_property_delete ON properties;
CREATE TRIGGER trigger_notify_tenants_before_property_delete
  BEFORE DELETE ON properties
  FOR EACH ROW
  EXECUTE FUNCTION notify_tenants_before_property_delete();

-- =====================================================
-- 3. Trigger pour empêcher la suppression si bail actif
-- =====================================================
CREATE OR REPLACE FUNCTION prevent_property_delete_with_active_lease()
RETURNS TRIGGER AS $$
DECLARE
  v_active_lease RECORD;
  v_tenant_name TEXT;
BEGIN
  -- Vérifier s'il y a un bail actif
  SELECT l.id, l.statut, 
         COALESCE(p.prenom || ' ' || p.nom, p.email, 'Locataire') as tenant_name
  INTO v_active_lease
  FROM leases l
  LEFT JOIN lease_signers ls ON ls.lease_id = l.id AND ls.role = 'locataire_principal'
  LEFT JOIN profiles p ON p.id = ls.profile_id
  WHERE l.property_id = OLD.id
    AND l.statut IN ('active', 'pending_signature', 'partially_signed', 'fully_signed')
  LIMIT 1;

  IF FOUND THEN
    RAISE EXCEPTION 'Impossible de supprimer : bail % avec %. Terminez d''abord le bail.', 
      v_active_lease.statut, 
      v_active_lease.tenant_name
    USING ERRCODE = 'P0001';
  END IF;

  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_prevent_property_delete_with_active_lease ON properties;
CREATE TRIGGER trigger_prevent_property_delete_with_active_lease
  BEFORE DELETE ON properties
  FOR EACH ROW
  EXECUTE FUNCTION prevent_property_delete_with_active_lease();

-- =====================================================
-- 4. Vue pour les propriétés actives (non supprimées)
-- =====================================================
CREATE OR REPLACE VIEW active_properties AS
SELECT *
FROM properties
WHERE deleted_at IS NULL
  AND (etat IS NULL OR etat != 'deleted');

-- =====================================================
-- 5. Fonction RPC pour restaurer une propriété
-- =====================================================
CREATE OR REPLACE FUNCTION restore_property(p_property_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
  v_owner_id UUID;
  v_caller_profile_id UUID;
BEGIN
  -- Récupérer le profil de l'appelant
  SELECT id INTO v_caller_profile_id
  FROM profiles
  WHERE user_id = auth.uid();

  IF v_caller_profile_id IS NULL THEN
    RAISE EXCEPTION 'Non authentifié';
  END IF;

  -- Récupérer le propriétaire
  SELECT owner_id INTO v_owner_id
  FROM properties
  WHERE id = p_property_id;

  IF v_owner_id IS NULL THEN
    RAISE EXCEPTION 'Propriété non trouvée';
  END IF;

  -- Vérifier les permissions
  IF v_owner_id != v_caller_profile_id THEN
    -- Vérifier si admin
    IF NOT EXISTS (SELECT 1 FROM profiles WHERE id = v_caller_profile_id AND role = 'admin') THEN
      RAISE EXCEPTION 'Accès non autorisé';
    END IF;
  END IF;

  -- Restaurer la propriété
  UPDATE properties
  SET deleted_at = NULL,
      deleted_by = NULL,
      etat = 'draft'
  WHERE id = p_property_id;

  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- Logs de la migration
-- =====================================================
DO $$
BEGIN
  RAISE NOTICE '=== Migration SOTA 2026: Soft-Delete Propriétés ===';
  RAISE NOTICE '✅ Colonnes deleted_at et deleted_by ajoutées';
  RAISE NOTICE '✅ Trigger notification locataires avant suppression';
  RAISE NOTICE '✅ Trigger blocage suppression si bail actif';
  RAISE NOTICE '✅ Vue active_properties créée';
  RAISE NOTICE '✅ Fonction restore_property créée';
  RAISE NOTICE '=== Protection complète des données activée ===';
END $$;



-- ========== 20260108400000_lease_lifecycle_sota2026.sql ==========
-- ============================================
-- MIGRATION SOTA 2026: Cycle de vie complet des baux
-- ============================================
-- Cette migration implémente:
-- 1. Protection contre la suppression des baux actifs/terminés
-- 2. Archivage automatique des baux terminés après 5 ans
-- 3. Nettoyage des documents orphelins
-- 4. Notifications aux locataires lors des modifications
-- ============================================

-- ============================================
-- 1. Colonne archived_at pour les baux
-- ============================================
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'leases' AND column_name = 'archived_at'
  ) THEN
    ALTER TABLE leases ADD COLUMN archived_at TIMESTAMPTZ;
    COMMENT ON COLUMN leases.archived_at IS 'Date d''archivage automatique (après 5 ans)';
  END IF;
END $$;

-- ============================================
-- 2. Contrainte CHECK sur statut des baux
-- ============================================
DO $$
BEGIN
  ALTER TABLE leases DROP CONSTRAINT IF EXISTS leases_statut_check;
  ALTER TABLE leases ADD CONSTRAINT leases_statut_check
    CHECK (statut IN (
      'draft', 
      'pending_signature', 
      'partially_signed',
      'fully_signed', 
      'active', 
      'terminated', 
      'archived',
      'cancelled'
    ));
EXCEPTION
  WHEN duplicate_object THEN
    RAISE NOTICE 'Contrainte statut existe déjà';
END $$;

-- ============================================
-- 3. Trigger: Bloquer suppression baux protégés
-- ============================================
CREATE OR REPLACE FUNCTION block_protected_lease_delete()
RETURNS TRIGGER AS $$
BEGIN
  -- Les baux actifs, terminés ou archivés ne peuvent pas être supprimés
  IF OLD.statut IN ('active', 'terminated', 'archived', 'fully_signed') THEN
    RAISE EXCEPTION 'Impossible de supprimer un bail avec statut: %. Raison légale: conservation obligatoire.', OLD.statut
      USING HINT = 'Utilisez le statut "cancelled" pour annuler un bail en cours de signature.';
  END IF;
  
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_block_protected_lease_delete ON leases;
CREATE TRIGGER trg_block_protected_lease_delete
  BEFORE DELETE ON leases
  FOR EACH ROW
  EXECUTE FUNCTION block_protected_lease_delete();

-- ============================================
-- 4. Trigger: Notifier locataires lors de modifications importantes
-- ============================================
CREATE OR REPLACE FUNCTION notify_tenant_lease_changes()
RETURNS TRIGGER AS $$
DECLARE
  tenant_profile_id UUID;
  change_type TEXT;
  message_text TEXT;
BEGIN
  -- Ne notifier que pour les changements importants
  IF TG_OP = 'UPDATE' THEN
    -- Changement de statut
    IF OLD.statut IS DISTINCT FROM NEW.statut THEN
      change_type := 'status_change';
      
      CASE NEW.statut
        WHEN 'active' THEN
          message_text := 'Votre bail est maintenant actif. Bienvenue dans votre nouveau logement !';
        WHEN 'terminated' THEN
          message_text := 'Votre bail a été officiellement terminé. Merci d''avoir été notre locataire.';
        WHEN 'cancelled' THEN
          message_text := 'Le bail a été annulé par le propriétaire.';
        ELSE
          message_text := 'Le statut de votre bail a été mis à jour: ' || NEW.statut;
      END CASE;
      
      -- Envoyer notification à tous les locataires du bail
      FOR tenant_profile_id IN 
        SELECT profile_id FROM lease_signers 
        WHERE lease_id = NEW.id 
          AND role IN ('locataire_principal', 'colocataire')
      LOOP
        INSERT INTO notifications (
          recipient_id,
          type,
          title,
          message,
          link,
          related_id,
          related_type
        ) VALUES (
          tenant_profile_id,
          CASE 
            WHEN NEW.statut = 'active' THEN 'success'
            WHEN NEW.statut IN ('terminated', 'cancelled') THEN 'alert'
            ELSE 'info'
          END,
          'Mise à jour du bail',
          message_text,
          '/tenant/leases/' || NEW.id,
          NEW.id,
          'lease'
        );
      END LOOP;
    END IF;
    
    -- Changement de loyer (important pour les locataires)
    IF OLD.loyer IS DISTINCT FROM NEW.loyer AND NEW.statut = 'active' THEN
      FOR tenant_profile_id IN 
        SELECT profile_id FROM lease_signers 
        WHERE lease_id = NEW.id 
          AND role IN ('locataire_principal', 'colocataire')
      LOOP
        INSERT INTO notifications (
          recipient_id,
          type,
          title,
          message,
          link,
          related_id,
          related_type
        ) VALUES (
          tenant_profile_id,
          'info',
          'Révision du loyer',
          'Le loyer a été révisé de ' || OLD.loyer || '€ à ' || NEW.loyer || '€.',
          '/tenant/leases/' || NEW.id,
          NEW.id,
          'lease'
        );
      END LOOP;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_notify_tenant_lease_changes ON leases;
CREATE TRIGGER trg_notify_tenant_lease_changes
  AFTER UPDATE ON leases
  FOR EACH ROW
  EXECUTE FUNCTION notify_tenant_lease_changes();

-- ============================================
-- 5. Fonction: Archivage automatique des baux terminés (> 5 ans)
-- ============================================
CREATE OR REPLACE FUNCTION archive_old_terminated_leases()
RETURNS INTEGER AS $$
DECLARE
  archived_count INTEGER := 0;
BEGIN
  -- Archiver les baux terminés depuis plus de 5 ans
  UPDATE leases
  SET 
    statut = 'archived',
    archived_at = NOW()
  WHERE 
    statut = 'terminated'
    AND date_fin IS NOT NULL
    AND date_fin < NOW() - INTERVAL '5 years'
    AND archived_at IS NULL;
  
  GET DIAGNOSTICS archived_count = ROW_COUNT;
  
  IF archived_count > 0 THEN
    RAISE NOTICE '% baux archivés automatiquement', archived_count;
  END IF;
  
  RETURN archived_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 6. Fonction: Nettoyage des documents orphelins
-- ============================================
CREATE OR REPLACE FUNCTION cleanup_orphan_documents()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER := 0;
BEGIN
  -- Supprimer les documents dont le bail n'existe plus
  -- (ne devrait pas arriver avec les cascades, mais au cas où)
  DELETE FROM documents
  WHERE lease_id IS NOT NULL
    AND lease_id NOT IN (SELECT id FROM leases);
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  
  -- Supprimer aussi les documents liés à des propriétés supprimées définitivement
  DELETE FROM documents
  WHERE property_id IS NOT NULL
    AND property_id NOT IN (SELECT id FROM properties);
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT + deleted_count;
  
  IF deleted_count > 0 THEN
    RAISE NOTICE '% documents orphelins supprimés', deleted_count;
  END IF;
  
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 7. Vue: Baux avec tous les éléments liés (pour l'UI)
-- ============================================
CREATE OR REPLACE VIEW lease_details_view AS
SELECT 
  l.id,
  l.type_bail,
  l.loyer,
  l.charges_forfaitaires,
  l.depot_de_garantie,
  l.date_debut,
  l.date_fin,
  l.statut,
  l.created_at,
  l.archived_at,
  p.id AS property_id,
  p.adresse_complete AS property_address,
  p.owner_id,
  p.etat AS property_status,
  p.deleted_at AS property_deleted_at,
  -- Compter les éléments liés
  (SELECT COUNT(*) FROM lease_signers WHERE lease_id = l.id) AS signer_count,
  (SELECT COUNT(*) FROM documents WHERE lease_id = l.id) AS document_count,
  (SELECT COUNT(*) FROM invoices WHERE lease_id = l.id) AS invoice_count,
  (SELECT COUNT(*) FROM edl WHERE lease_id = l.id) AS edl_count,
  -- Locataire principal
  (
    SELECT json_build_object(
      'id', pr.id,
      'prenom', pr.prenom,
      'nom', pr.nom,
      'email', pr.email
    )
    FROM lease_signers ls
    JOIN profiles pr ON ls.profile_id = pr.id
    WHERE ls.lease_id = l.id AND ls.role = 'locataire_principal'
    LIMIT 1
  ) AS main_tenant
FROM leases l
LEFT JOIN properties p ON l.property_id = p.id
WHERE l.statut != 'archived'; -- Exclure les archivés par défaut

-- ============================================
-- 8. Logs de la migration
-- ============================================
DO $$
BEGIN
  RAISE NOTICE '=== Migration SOTA 2026 - Cycle de vie des baux ===';
  RAISE NOTICE '✅ Colonne archived_at ajoutée';
  RAISE NOTICE '✅ Contrainte CHECK sur statut mise à jour';
  RAISE NOTICE '✅ Trigger de protection contre suppression créé';
  RAISE NOTICE '✅ Trigger de notification locataires créé';
  RAISE NOTICE '✅ Fonction d''archivage automatique créée';
  RAISE NOTICE '✅ Fonction de nettoyage orphelins créée';
  RAISE NOTICE '✅ Vue lease_details_view créée';
END $$;



-- ========== 20260108500000_orphan_cleanup_sota2026.sql ==========
-- ============================================
-- MIGRATION SOTA 2026: Nettoyage données orphelines
-- et cascade complète pour suppression de baux
-- ============================================
-- Cette migration:
-- 1. Nettoie toutes les données orphelines existantes
-- 2. Ajoute des triggers pour cascade complète
-- 3. Corrige les incohérences dans la BDD
-- ============================================

-- ============================================
-- PARTIE 1: NETTOYAGE DES DONNÉES ORPHELINES
-- ============================================

-- 1.1 Supprimer les lease_signers orphelins (bail supprimé)
DELETE FROM lease_signers
WHERE lease_id NOT IN (SELECT id FROM leases);

-- 1.2 Supprimer les invoices orphelines (bail supprimé)
DELETE FROM invoices
WHERE lease_id NOT IN (SELECT id FROM leases);

-- 1.3 Supprimer les documents avec lease_id invalide
DELETE FROM documents
WHERE lease_id IS NOT NULL 
  AND lease_id NOT IN (SELECT id FROM leases);

-- 1.4 Supprimer les documents avec property_id invalide
DELETE FROM documents
WHERE property_id IS NOT NULL 
  AND property_id NOT IN (SELECT id FROM properties);

-- 1.5 Supprimer les documents avec tenant_id invalide
DELETE FROM documents
WHERE tenant_id IS NOT NULL 
  AND tenant_id NOT IN (SELECT id FROM profiles);

-- 1.6 Supprimer les roommates orphelins
DELETE FROM roommates
WHERE lease_id NOT IN (SELECT id FROM leases);

-- 1.7 Supprimer les EDL orphelins
DELETE FROM edl
WHERE lease_id NOT IN (SELECT id FROM leases);

-- 1.8 Supprimer les tickets avec lease_id invalide
UPDATE tickets
SET lease_id = NULL
WHERE lease_id IS NOT NULL 
  AND lease_id NOT IN (SELECT id FROM leases);

-- 1.9 Supprimer les deposit_movements orphelins
DELETE FROM deposit_movements
WHERE lease_id NOT IN (SELECT id FROM leases);

-- 1.10 Supprimer les rent_calls orphelins
DELETE FROM rent_calls
WHERE lease_id NOT IN (SELECT id FROM leases);

-- 1.11 Supprimer les charge_regularizations orphelines
DELETE FROM charge_regularizations
WHERE lease_id NOT IN (SELECT id FROM leases);

-- 1.12 Supprimer les lease_events orphelins
DELETE FROM lease_events
WHERE lease_id NOT IN (SELECT id FROM leases);

-- 1.13 Supprimer les insurance_policies orphelines
DELETE FROM insurance_policies
WHERE lease_id NOT IN (SELECT id FROM leases);

-- 1.14 Supprimer les otp_codes orphelins
DELETE FROM otp_codes
WHERE lease_id IS NOT NULL 
  AND lease_id NOT IN (SELECT id FROM leases);

-- 1.15 Supprimer les notifications liées à des baux supprimés
DELETE FROM notifications
WHERE related_type = 'lease'
  AND related_id IS NOT NULL
  AND related_id::UUID NOT IN (SELECT id FROM leases);

-- ============================================
-- PARTIE 2: TRIGGER CASCADE COMPLÈTE
-- ============================================

-- 2.1 Fonction pour supprimer TOUS les documents liés à un bail
-- (même ceux liés via tenant_id ou property_id mais concernant ce bail)
CREATE OR REPLACE FUNCTION cascade_delete_lease_documents()
RETURNS TRIGGER AS $$
DECLARE
  v_property_id UUID;
  v_tenant_ids UUID[];
  v_deleted_count INTEGER := 0;
BEGIN
  -- Récupérer le property_id du bail
  v_property_id := OLD.property_id;
  
  -- Récupérer tous les tenant_ids des signataires du bail
  SELECT ARRAY_AGG(DISTINCT profile_id) INTO v_tenant_ids
  FROM lease_signers
  WHERE lease_id = OLD.id
    AND role IN ('locataire_principal', 'colocataire');

  -- Supprimer les documents directement liés au bail
  DELETE FROM documents WHERE lease_id = OLD.id;
  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
  
  -- Supprimer les documents de type bail pour cette propriété créés pendant la période du bail
  DELETE FROM documents 
  WHERE property_id = v_property_id
    AND type IN ('bail', 'EDL_entree', 'EDL_sortie', 'quittance')
    AND created_at >= OLD.date_debut
    AND (OLD.date_fin IS NULL OR created_at <= OLD.date_fin + INTERVAL '1 month')
    AND lease_id IS NULL; -- Documents pas déjà liés à un bail spécifique
  
  GET DIAGNOSTICS v_deleted_count = v_deleted_count + ROW_COUNT;
  
  -- Log pour audit
  RAISE NOTICE 'Cascade delete pour bail %: % documents supprimés', OLD.id, v_deleted_count;
  
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- 2.2 Trigger BEFORE DELETE pour nettoyer les documents
DROP TRIGGER IF EXISTS trg_cascade_delete_lease_documents ON leases;
CREATE TRIGGER trg_cascade_delete_lease_documents
  BEFORE DELETE ON leases
  FOR EACH ROW
  EXECUTE FUNCTION cascade_delete_lease_documents();

-- 2.3 Fonction pour nettoyer les EDL et leurs éléments
CREATE OR REPLACE FUNCTION cascade_delete_lease_edl()
RETURNS TRIGGER AS $$
DECLARE
  v_edl_ids UUID[];
BEGIN
  -- Récupérer tous les EDL du bail
  SELECT ARRAY_AGG(id) INTO v_edl_ids
  FROM edl
  WHERE lease_id = OLD.id;
  
  IF v_edl_ids IS NOT NULL AND array_length(v_edl_ids, 1) > 0 THEN
    -- Supprimer les items d'EDL
    DELETE FROM edl_items WHERE edl_id = ANY(v_edl_ids);
    
    -- Supprimer les médias d'EDL
    DELETE FROM edl_media WHERE edl_id = ANY(v_edl_ids);
    
    -- Supprimer les signatures d'EDL
    DELETE FROM edl_signatures WHERE edl_id = ANY(v_edl_ids);
    
    -- Supprimer les EDL eux-mêmes
    DELETE FROM edl WHERE id = ANY(v_edl_ids);
    
    RAISE NOTICE 'Cascade delete EDL pour bail %: % EDL supprimés', OLD.id, array_length(v_edl_ids, 1);
  END IF;
  
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- 2.4 Trigger BEFORE DELETE pour nettoyer les EDL
DROP TRIGGER IF EXISTS trg_cascade_delete_lease_edl ON leases;
CREATE TRIGGER trg_cascade_delete_lease_edl
  BEFORE DELETE ON leases
  FOR EACH ROW
  EXECUTE FUNCTION cascade_delete_lease_edl();

-- 2.5 Fonction pour nettoyer les paiements liés aux factures du bail
CREATE OR REPLACE FUNCTION cascade_delete_lease_payments()
RETURNS TRIGGER AS $$
DECLARE
  v_invoice_ids UUID[];
BEGIN
  -- Récupérer tous les invoice_ids du bail
  SELECT ARRAY_AGG(id) INTO v_invoice_ids
  FROM invoices
  WHERE lease_id = OLD.id;
  
  IF v_invoice_ids IS NOT NULL AND array_length(v_invoice_ids, 1) > 0 THEN
    -- Supprimer les paiements liés
    DELETE FROM payments WHERE invoice_id = ANY(v_invoice_ids);
    
    RAISE NOTICE 'Cascade delete payments pour bail %: factures concernées %', OLD.id, array_length(v_invoice_ids, 1);
  END IF;
  
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- 2.6 Trigger BEFORE DELETE pour nettoyer les paiements
DROP TRIGGER IF EXISTS trg_cascade_delete_lease_payments ON leases;
CREATE TRIGGER trg_cascade_delete_lease_payments
  BEFORE DELETE ON leases
  FOR EACH ROW
  EXECUTE FUNCTION cascade_delete_lease_payments();

-- ============================================
-- PARTIE 3: CORRECTION DES INCOHÉRENCES
-- ============================================

-- 3.1 Corriger les baux sans signataires (ajouter un warning)
DO $$
DECLARE
  v_orphan_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_orphan_count
  FROM leases l
  WHERE NOT EXISTS (
    SELECT 1 FROM lease_signers ls WHERE ls.lease_id = l.id
  )
  AND l.statut NOT IN ('draft', 'cancelled', 'archived');
  
  IF v_orphan_count > 0 THEN
    RAISE WARNING '⚠️ % baux sans signataires détectés (hors brouillons)', v_orphan_count;
  END IF;
END $$;

-- 3.2 Corriger les factures avec montants incohérents
UPDATE invoices
SET montant_total = montant_loyer + montant_charges
WHERE montant_total != montant_loyer + montant_charges;

-- 3.3 Corriger les baux avec dépôt de garantie supérieur au légal
UPDATE leases
SET depot_de_garantie = CASE
  WHEN type_bail = 'nu' THEN loyer
  WHEN type_bail IN ('meuble', 'colocation', 'saisonnier') THEN loyer * 2
  WHEN type_bail = 'mobilite' THEN 0
  ELSE loyer
END
WHERE depot_de_garantie > CASE
  WHEN type_bail = 'nu' THEN loyer
  WHEN type_bail IN ('meuble', 'colocation', 'saisonnier') THEN loyer * 2
  WHEN type_bail = 'mobilite' THEN 0
  ELSE loyer
END;

-- 3.4 Corriger les signataires avec rôles non standardisés
UPDATE lease_signers
SET role = 'proprietaire'
WHERE LOWER(TRIM(role)) IN ('owner', 'bailleur')
  AND role != 'proprietaire';

UPDATE lease_signers
SET role = 'locataire_principal'
WHERE LOWER(TRIM(role)) IN ('locataire', 'tenant', 'principal')
  AND role != 'locataire_principal';

UPDATE lease_signers
SET role = 'colocataire'
WHERE LOWER(TRIM(role)) IN ('co_locataire', 'cotenant')
  AND role != 'colocataire';

UPDATE lease_signers
SET role = 'garant'
WHERE LOWER(TRIM(role)) IN ('caution', 'guarantor')
  AND role != 'garant';

-- 3.5 Mettre à jour les statuts de baux incohérents
-- Baux "pending_signature" où tous ont signé → fully_signed
UPDATE leases l
SET statut = 'fully_signed'
WHERE l.statut = 'pending_signature'
  AND NOT EXISTS (
    SELECT 1 FROM lease_signers ls
    WHERE ls.lease_id = l.id
      AND ls.signature_status != 'signed'
  )
  AND EXISTS (
    SELECT 1 FROM lease_signers ls WHERE ls.lease_id = l.id
  );

-- ============================================
-- PARTIE 4: VUES POUR MONITORING
-- ============================================

-- 4.1 Vue des données orphelines (pour monitoring continu)
CREATE OR REPLACE VIEW orphan_data_monitor AS
SELECT 
  'documents_without_lease' AS type,
  COUNT(*) AS count,
  'Documents avec lease_id invalide' AS description
FROM documents
WHERE lease_id IS NOT NULL 
  AND lease_id NOT IN (SELECT id FROM leases)

UNION ALL

SELECT 
  'documents_without_property',
  COUNT(*),
  'Documents avec property_id invalide'
FROM documents
WHERE property_id IS NOT NULL 
  AND property_id NOT IN (SELECT id FROM properties)

UNION ALL

SELECT 
  'leases_without_signers',
  COUNT(*),
  'Baux actifs sans signataires'
FROM leases
WHERE statut NOT IN ('draft', 'cancelled', 'archived')
  AND id NOT IN (SELECT DISTINCT lease_id FROM lease_signers)

UNION ALL

SELECT 
  'invoices_orphaned',
  COUNT(*),
  'Factures avec bail supprimé'
FROM invoices
WHERE lease_id NOT IN (SELECT id FROM leases)

UNION ALL

SELECT 
  'deposit_inconsistent',
  COUNT(*),
  'Baux avec dépôt > maximum légal'
FROM leases
WHERE depot_de_garantie > CASE
  WHEN type_bail = 'nu' THEN loyer
  WHEN type_bail IN ('meuble', 'colocation', 'saisonnier') THEN loyer * 2
  WHEN type_bail = 'mobilite' THEN 0
  ELSE loyer
END;

-- ============================================
-- PARTIE 5: FONCTION DE NETTOYAGE PÉRIODIQUE
-- ============================================

-- Fonction à appeler périodiquement (via cron ou manuellement)
CREATE OR REPLACE FUNCTION run_orphan_cleanup()
RETURNS TABLE(
  cleanup_type TEXT,
  records_deleted INTEGER
) AS $$
DECLARE
  v_count INTEGER;
BEGIN
  -- Documents orphelins
  DELETE FROM documents
  WHERE lease_id IS NOT NULL 
    AND lease_id NOT IN (SELECT id FROM leases);
  GET DIAGNOSTICS v_count = ROW_COUNT;
  cleanup_type := 'documents_lease';
  records_deleted := v_count;
  RETURN NEXT;

  -- Documents sans propriété
  DELETE FROM documents
  WHERE property_id IS NOT NULL 
    AND property_id NOT IN (SELECT id FROM properties);
  GET DIAGNOSTICS v_count = ROW_COUNT;
  cleanup_type := 'documents_property';
  records_deleted := v_count;
  RETURN NEXT;

  -- Notifications obsolètes (> 90 jours, lues)
  DELETE FROM notifications
  WHERE is_read = true
    AND created_at < NOW() - INTERVAL '90 days';
  GET DIAGNOSTICS v_count = ROW_COUNT;
  cleanup_type := 'notifications_old';
  records_deleted := v_count;
  RETURN NEXT;

  -- OTP codes expirés
  DELETE FROM otp_codes
  WHERE expires_at < NOW() - INTERVAL '24 hours';
  GET DIAGNOSTICS v_count = ROW_COUNT;
  cleanup_type := 'otp_expired';
  records_deleted := v_count;
  RETURN NEXT;

  RETURN;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- PARTIE 6: FONCTIONS RPC POUR L'API
-- ============================================

-- 6.1 Compter les documents orphelins (lease_id invalide)
CREATE OR REPLACE FUNCTION count_orphan_documents_lease()
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)::INTEGER
    FROM documents d
    WHERE d.lease_id IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = d.lease_id)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6.2 Compter les documents orphelins (property_id invalide)
CREATE OR REPLACE FUNCTION count_orphan_documents_property()
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)::INTEGER
    FROM documents d
    WHERE d.property_id IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = d.property_id)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6.3 Compter les factures orphelines
CREATE OR REPLACE FUNCTION count_orphan_invoices()
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)::INTEGER
    FROM invoices i
    WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = i.lease_id)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6.4 Compter les signataires orphelins
CREATE OR REPLACE FUNCTION count_orphan_signers()
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)::INTEGER
    FROM lease_signers ls
    WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = ls.lease_id)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6.5 Compter les baux sans signataires
CREATE OR REPLACE FUNCTION count_leases_without_signers()
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)::INTEGER
    FROM leases l
    WHERE l.statut NOT IN ('draft', 'cancelled', 'archived')
      AND NOT EXISTS (SELECT 1 FROM lease_signers ls WHERE ls.lease_id = l.id)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6.6 Compter les dépôts incohérents
CREATE OR REPLACE FUNCTION count_inconsistent_deposits()
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)::INTEGER
    FROM leases
    WHERE depot_de_garantie > CASE
      WHEN type_bail = 'nu' THEN loyer
      WHEN type_bail IN ('meuble', 'colocation', 'saisonnier') THEN loyer * 2
      WHEN type_bail = 'mobilite' THEN 0
      ELSE loyer
    END
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6.7 Corriger les dépôts incohérents
CREATE OR REPLACE FUNCTION fix_inconsistent_deposits()
RETURNS INTEGER AS $$
DECLARE
  v_count INTEGER;
BEGIN
  UPDATE leases
  SET depot_de_garantie = CASE
    WHEN type_bail = 'nu' THEN loyer
    WHEN type_bail IN ('meuble', 'colocation', 'saisonnier') THEN loyer * 2
    WHEN type_bail = 'mobilite' THEN 0
    ELSE loyer
  END
  WHERE depot_de_garantie > CASE
    WHEN type_bail = 'nu' THEN loyer
    WHEN type_bail IN ('meuble', 'colocation', 'saisonnier') THEN loyer * 2
    WHEN type_bail = 'mobilite' THEN 0
    ELSE loyer
  END;
  
  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- LOGS DE MIGRATION
-- ============================================
DO $$
DECLARE
  v_doc_orphans INTEGER;
  v_invoice_orphans INTEGER;
  v_signer_orphans INTEGER;
BEGIN
  -- Compter ce qui a été nettoyé
  SELECT COUNT(*) INTO v_doc_orphans FROM documents WHERE lease_id NOT IN (SELECT id FROM leases WHERE TRUE);
  SELECT COUNT(*) INTO v_invoice_orphans FROM invoices WHERE lease_id NOT IN (SELECT id FROM leases WHERE TRUE);
  SELECT COUNT(*) INTO v_signer_orphans FROM lease_signers WHERE lease_id NOT IN (SELECT id FROM leases WHERE TRUE);

  RAISE NOTICE '=== Migration SOTA 2026 - Nettoyage orphelins ===';
  RAISE NOTICE '✅ Triggers cascade créés pour suppression baux';
  RAISE NOTICE '✅ Vue monitoring orphan_data_monitor créée';
  RAISE NOTICE '✅ Fonction run_orphan_cleanup() disponible';
  RAISE NOTICE '✅ Corrections incohérences appliquées';
END $$;



-- ========== 20260108600000_security_enhancements.sql ==========
-- ============================================
-- MIGRATION: Améliorations de sécurité SOTA 2026
-- ============================================
-- 
-- Cette migration ajoute:
-- 1. Colonnes pour IBAN chiffré dans owner_profiles
-- 2. Table audit_log améliorée avec niveaux de risque
-- 3. Contraintes 2FA pour les rôles sensibles
-- 4. Index pour les recherches sécurisées
--
-- Date: 2026-01-08
-- Auteur: Security Enhancement
-- ============================================

-- ============================================
-- 1. IBAN CHIFFRÉ POUR PROPRIÉTAIRES
-- ============================================

-- Ajouter colonnes pour IBAN chiffré
ALTER TABLE owner_profiles
  ADD COLUMN IF NOT EXISTS iban_encrypted TEXT,
  ADD COLUMN IF NOT EXISTS iban_hash TEXT,
  ADD COLUMN IF NOT EXISTS iban_last4 TEXT;

-- Index pour recherche par hash (sans déchiffrement)
CREATE INDEX IF NOT EXISTS idx_owner_profiles_iban_hash 
  ON owner_profiles(iban_hash);

-- Commentaires de documentation
COMMENT ON COLUMN owner_profiles.iban_encrypted IS 'IBAN chiffré avec AES-256-GCM (format: iv:tag:ciphertext)';
COMMENT ON COLUMN owner_profiles.iban_hash IS 'Hash SHA-256 de l''IBAN normalisé pour recherche';
COMMENT ON COLUMN owner_profiles.iban_last4 IS '4 derniers caractères de l''IBAN pour affichage';

-- ============================================
-- 2. TABLE AUDIT_LOG AMÉLIORÉE
-- ============================================

-- Créer ou recréer la table audit_log avec tous les champs
CREATE TABLE IF NOT EXISTS audit_log (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL,
  profile_id UUID,
  action TEXT NOT NULL,
  entity_type TEXT NOT NULL,
  entity_id TEXT,
  ip_address INET,
  user_agent TEXT,
  risk_level TEXT NOT NULL DEFAULT 'low' CHECK (risk_level IN ('low', 'medium', 'high', 'critical')),
  metadata JSONB DEFAULT '{}'::jsonb,
  success BOOLEAN NOT NULL DEFAULT true,
  error_message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour les requêtes fréquentes
CREATE INDEX IF NOT EXISTS idx_audit_log_user_id ON audit_log(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_created_at ON audit_log(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_log_entity_type ON audit_log(entity_type);
CREATE INDEX IF NOT EXISTS idx_audit_log_risk_level ON audit_log(risk_level);
CREATE INDEX IF NOT EXISTS idx_audit_log_action ON audit_log(action);

-- Index composite pour recherches combinées
CREATE INDEX IF NOT EXISTS idx_audit_log_user_action 
  ON audit_log(user_id, action, created_at DESC);

-- Partitionnement mensuel recommandé pour les logs volumineux
-- (À activer en production si volume > 1M lignes/mois)

-- Commentaires
COMMENT ON TABLE audit_log IS 'Journal d''audit pour traçabilité des accès aux données sensibles (RGPD Art. 30)';
COMMENT ON COLUMN audit_log.risk_level IS 'Niveau de risque: low, medium, high, critical';
COMMENT ON COLUMN audit_log.metadata IS 'Données contextuelles additionnelles (JSON)';

-- ============================================
-- 3. COLONNES 2FA AMÉLIORÉES
-- ============================================

-- S'assurer que les colonnes 2FA existent
ALTER TABLE profiles
  ADD COLUMN IF NOT EXISTS two_factor_secret TEXT,
  ADD COLUMN IF NOT EXISTS two_factor_enabled BOOLEAN NOT NULL DEFAULT false,
  ADD COLUMN IF NOT EXISTS two_factor_required BOOLEAN NOT NULL DEFAULT false,
  ADD COLUMN IF NOT EXISTS two_factor_backup_codes TEXT[],
  ADD COLUMN IF NOT EXISTS last_2fa_verified_at TIMESTAMPTZ;

-- Index pour requêtes 2FA
CREATE INDEX IF NOT EXISTS idx_profiles_2fa_required 
  ON profiles(two_factor_required) WHERE two_factor_required = true;

-- Commentaires
COMMENT ON COLUMN profiles.two_factor_required IS 'Si true, l''utilisateur DOIT activer le 2FA';
COMMENT ON COLUMN profiles.two_factor_backup_codes IS 'Codes de secours chiffrés pour récupération 2FA';
COMMENT ON COLUMN profiles.last_2fa_verified_at IS 'Dernière vérification 2FA réussie';

-- ============================================
-- 4. FONCTION: FORCER 2FA POUR ADMINS
-- ============================================

-- Trigger pour forcer 2FA sur les admins
CREATE OR REPLACE FUNCTION enforce_2fa_for_sensitive_roles()
RETURNS TRIGGER AS $$
BEGIN
  -- Les admins doivent avoir 2FA requis
  IF NEW.role = 'admin' THEN
    NEW.two_factor_required := true;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Créer le trigger si non existant
DROP TRIGGER IF EXISTS trigger_enforce_2fa_sensitive_roles ON profiles;
CREATE TRIGGER trigger_enforce_2fa_sensitive_roles
  BEFORE INSERT OR UPDATE OF role ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION enforce_2fa_for_sensitive_roles();

-- ============================================
-- 5. FONCTION: FORCER 2FA POUR GROS COMPTES
-- ============================================

-- Fonction pour vérifier et activer 2FA requis pour les gros propriétaires
CREATE OR REPLACE FUNCTION check_2fa_requirement_for_property_count()
RETURNS TRIGGER AS $$
DECLARE
  property_count INTEGER;
  owner_profile_id UUID;
BEGIN
  -- Récupérer le profile_id du propriétaire
  owner_profile_id := NEW.owner_id;
  
  -- Compter les biens de ce propriétaire
  SELECT COUNT(*) INTO property_count
  FROM properties
  WHERE owner_id = owner_profile_id
    AND deleted_at IS NULL;
  
  -- Si plus de 5 biens, forcer le 2FA
  IF property_count >= 5 THEN
    UPDATE profiles
    SET two_factor_required = true
    WHERE id = owner_profile_id
      AND two_factor_required = false;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger sur ajout de propriété
DROP TRIGGER IF EXISTS trigger_check_2fa_on_property_add ON properties;
CREATE TRIGGER trigger_check_2fa_on_property_add
  AFTER INSERT ON properties
  FOR EACH ROW
  EXECUTE FUNCTION check_2fa_requirement_for_property_count();

-- ============================================
-- 6. RLS POUR AUDIT_LOG
-- ============================================

ALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;

-- Seuls les admins peuvent lire les logs d'audit
CREATE POLICY "Admins can view all audit logs"
  ON audit_log FOR SELECT
  USING (public.user_role() = 'admin');

-- Les utilisateurs peuvent voir leurs propres logs
CREATE POLICY "Users can view own audit logs"
  ON audit_log FOR SELECT
  USING (user_id = auth.uid());

-- Seul le système peut insérer (via service role)
CREATE POLICY "System can insert audit logs"
  ON audit_log FOR INSERT
  WITH CHECK (true); -- Le service role bypasse RLS

-- ============================================
-- 7. TABLE POUR SESSIONS 2FA
-- ============================================

CREATE TABLE IF NOT EXISTS two_factor_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  verified_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_2fa_sessions_user_id 
  ON two_factor_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_2fa_sessions_expires_at 
  ON two_factor_sessions(expires_at);

-- Nettoyage automatique des sessions expirées
CREATE OR REPLACE FUNCTION cleanup_expired_2fa_sessions()
RETURNS void AS $$
BEGIN
  DELETE FROM two_factor_sessions
  WHERE expires_at < NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 8. MIGRATION DES IBAN EXISTANTS
-- ============================================

-- Note: Cette étape doit être exécutée via un script applicatif
-- pour chiffrer les IBAN existants. Voir: scripts/migrate-iban-encryption.ts

-- Marquer les IBAN non migrés
-- UPDATE owner_profiles 
-- SET iban_encrypted = NULL, iban_hash = NULL, iban_last4 = NULL
-- WHERE iban IS NOT NULL AND iban_encrypted IS NULL;

-- ============================================
-- 9. CONTRAINTES SUPPLÉMENTAIRES
-- ============================================

-- Empêcher la désactivation du 2FA pour les comptes qui le requièrent
CREATE OR REPLACE FUNCTION prevent_2fa_disable_if_required()
RETURNS TRIGGER AS $$
BEGIN
  IF OLD.two_factor_required = true AND NEW.two_factor_enabled = false AND OLD.two_factor_enabled = true THEN
    RAISE EXCEPTION 'Impossible de désactiver le 2FA car il est requis pour ce compte';
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_prevent_2fa_disable ON profiles;
CREATE TRIGGER trigger_prevent_2fa_disable
  BEFORE UPDATE OF two_factor_enabled ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION prevent_2fa_disable_if_required();

-- ============================================
-- 10. VUE POUR MONITORING SÉCURITÉ
-- ============================================

CREATE OR REPLACE VIEW security_dashboard AS
SELECT 
  COUNT(*) FILTER (WHERE risk_level = 'critical' AND created_at > NOW() - INTERVAL '24 hours') as critical_events_24h,
  COUNT(*) FILTER (WHERE risk_level = 'high' AND created_at > NOW() - INTERVAL '24 hours') as high_events_24h,
  COUNT(*) FILTER (WHERE action = 'failed_login' AND created_at > NOW() - INTERVAL '1 hour') as failed_logins_1h,
  COUNT(*) FILTER (WHERE entity_type = 'iban' AND action = 'decrypt' AND created_at > NOW() - INTERVAL '24 hours') as iban_decrypts_24h,
  COUNT(DISTINCT user_id) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as active_users_24h
FROM audit_log;

COMMENT ON VIEW security_dashboard IS 'Vue récapitulative pour le monitoring de sécurité';

-- ============================================
-- FIN DE LA MIGRATION
-- ============================================

-- Log de fin
DO $$
BEGIN
  RAISE NOTICE 'Migration 20260108600000_security_enhancements terminée avec succès';
END $$;



-- ========== 20260109000000_fix_property_deleted_at.sql ==========
-- ============================================
-- MIGRATION: Fix deleted_at column for properties
-- ============================================
-- 
-- Cette migration s'assure que la colonne deleted_at existe
-- dans la table properties (requise par le trigger de sécurité)
--
-- Date: 2026-01-09
-- ============================================

-- Ajouter la colonne deleted_at si elle n'existe pas
ALTER TABLE properties
  ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS deleted_by UUID REFERENCES profiles(id);

-- Créer l'index pour les requêtes filtrées
CREATE INDEX IF NOT EXISTS idx_properties_deleted_at 
  ON properties(deleted_at) WHERE deleted_at IS NULL;

-- Index pour le soft delete
CREATE INDEX IF NOT EXISTS idx_properties_active 
  ON properties(owner_id, deleted_at) WHERE deleted_at IS NULL;

-- Commentaires
COMMENT ON COLUMN properties.deleted_at IS 'Date de suppression soft (NULL = actif)';
COMMENT ON COLUMN properties.deleted_by IS 'Profile qui a supprimé le bien';

-- ============================================
-- FIN
-- ============================================
DO $$
BEGIN
  RAISE NOTICE '✅ Migration 20260109000000_fix_property_deleted_at terminée';
END $$;



-- ========== 20260109100000_signature_tracking_enhanced.sql ==========
-- Migration: Amélioration du tracking des signatures
-- Date: 2026-01-09
-- Description: Vue agrégée et fonctions pour le suivi des signatures mensuelles
-- Compatible avec subscription_usage existante

BEGIN;

-- ============================================
-- VUE AGRÉGÉE: Signatures par mois et subscription
-- ============================================

CREATE OR REPLACE VIEW signature_usage_monthly AS
SELECT
  su.subscription_id,
  su.period_month,
  COALESCE(SUM(su.quantity), 0)::INTEGER as signatures_used,
  COUNT(*)::INTEGER as signature_events,
  MAX(su.created_at) as last_signature_at
FROM subscription_usage su
WHERE su.usage_type = 'signature'
GROUP BY su.subscription_id, su.period_month;

-- ============================================
-- FONCTION: Obtenir usage signatures du mois courant
-- ============================================

CREATE OR REPLACE FUNCTION get_signature_usage(p_subscription_id UUID)
RETURNS TABLE (
  signatures_used INTEGER,
  signatures_limit INTEGER,
  signatures_remaining INTEGER,
  usage_percentage INTEGER,
  period_month TEXT,
  last_signature_at TIMESTAMPTZ
) AS $$
DECLARE
  v_current_month TEXT := TO_CHAR(NOW(), 'YYYY-MM');
  v_used INTEGER;
  v_limit INTEGER;
  v_last_at TIMESTAMPTZ;
BEGIN
  -- Récupérer l'usage du mois courant
  SELECT
    COALESCE(SUM(quantity), 0)::INTEGER,
    MAX(created_at)
  INTO v_used, v_last_at
  FROM subscription_usage
  WHERE subscription_id = p_subscription_id
    AND usage_type = 'signature'
    AND period_month = v_current_month;

  -- Récupérer la limite du plan
  SELECT
    COALESCE((sp.features->>'signatures_monthly_quota')::INTEGER, 0)
  INTO v_limit
  FROM subscriptions s
  JOIN subscription_plans sp ON s.plan_id = sp.id
  WHERE s.id = p_subscription_id;

  -- Si pas de limite trouvée, utiliser 0
  v_limit := COALESCE(v_limit, 0);
  v_used := COALESCE(v_used, 0);

  RETURN QUERY SELECT
    v_used,
    v_limit,
    CASE WHEN v_limit = -1 THEN 999999 ELSE GREATEST(0, v_limit - v_used) END,
    CASE
      WHEN v_limit = -1 THEN 0
      WHEN v_limit = 0 THEN 100
      ELSE LEAST(100, (v_used * 100) / NULLIF(v_limit, 0))
    END::INTEGER,
    v_current_month,
    v_last_at;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- ============================================
-- FONCTION: Incrémenter l'usage des signatures
-- ============================================

CREATE OR REPLACE FUNCTION increment_signature_usage(
  p_subscription_id UUID,
  p_quantity INTEGER DEFAULT 1,
  p_metadata JSONB DEFAULT '{}'::jsonb
) RETURNS BOOLEAN AS $$
DECLARE
  v_current_month TEXT := TO_CHAR(NOW(), 'YYYY-MM');
  v_used INTEGER;
  v_limit INTEGER;
BEGIN
  -- Vérifier la limite avant d'incrémenter
  SELECT
    COALESCE(SUM(quantity), 0)::INTEGER
  INTO v_used
  FROM subscription_usage
  WHERE subscription_id = p_subscription_id
    AND usage_type = 'signature'
    AND period_month = v_current_month;

  SELECT
    COALESCE((sp.features->>'signatures_monthly_quota')::INTEGER, 0)
  INTO v_limit
  FROM subscriptions s
  JOIN subscription_plans sp ON s.plan_id = sp.id
  WHERE s.id = p_subscription_id;

  -- Si limite atteinte et pas illimité, retourner false
  IF v_limit != -1 AND (COALESCE(v_used, 0) + p_quantity) > v_limit THEN
    RETURN false;
  END IF;

  -- Insérer l'usage
  INSERT INTO subscription_usage (
    subscription_id,
    usage_type,
    quantity,
    period_month,
    metadata
  ) VALUES (
    p_subscription_id,
    'signature',
    p_quantity,
    v_current_month,
    p_metadata
  );

  RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- FONCTION: Vérifier si une signature est possible
-- ============================================

CREATE OR REPLACE FUNCTION can_use_signature(p_subscription_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
  v_current_month TEXT := TO_CHAR(NOW(), 'YYYY-MM');
  v_used INTEGER;
  v_limit INTEGER;
BEGIN
  -- Récupérer l'usage actuel
  SELECT COALESCE(SUM(quantity), 0)::INTEGER
  INTO v_used
  FROM subscription_usage
  WHERE subscription_id = p_subscription_id
    AND usage_type = 'signature'
    AND period_month = v_current_month;

  -- Récupérer la limite
  SELECT
    COALESCE((sp.features->>'signatures_monthly_quota')::INTEGER, 0)
  INTO v_limit
  FROM subscriptions s
  JOIN subscription_plans sp ON s.plan_id = sp.id
  WHERE s.id = p_subscription_id;

  -- -1 = illimité
  IF v_limit = -1 THEN
    RETURN true;
  END IF;

  RETURN v_used < v_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- ============================================
-- FONCTION: Obtenir usage par owner_id (plus pratique)
-- ============================================

CREATE OR REPLACE FUNCTION get_signature_usage_by_owner(p_owner_id UUID)
RETURNS TABLE (
  subscription_id UUID,
  signatures_used INTEGER,
  signatures_limit INTEGER,
  signatures_remaining INTEGER,
  usage_percentage INTEGER,
  period_month TEXT,
  last_signature_at TIMESTAMPTZ,
  can_sign BOOLEAN
) AS $$
DECLARE
  v_sub_id UUID;
BEGIN
  -- Trouver la subscription de ce owner
  SELECT id INTO v_sub_id
  FROM subscriptions
  WHERE owner_id = p_owner_id
  LIMIT 1;

  IF v_sub_id IS NULL THEN
    -- Pas de subscription, retourner des valeurs par défaut (plan gratuit)
    RETURN QUERY SELECT
      NULL::UUID,
      0::INTEGER,
      0::INTEGER,  -- Plan gratuit = 0 signatures incluses
      0::INTEGER,
      0::INTEGER,
      TO_CHAR(NOW(), 'YYYY-MM'),
      NULL::TIMESTAMPTZ,
      false;
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    v_sub_id,
    su.signatures_used,
    su.signatures_limit,
    su.signatures_remaining,
    su.usage_percentage,
    su.period_month,
    su.last_signature_at,
    (su.signatures_limit = -1 OR su.signatures_used < su.signatures_limit)
  FROM get_signature_usage(v_sub_id) su;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- ============================================
-- INDEX pour performances
-- ============================================

CREATE INDEX IF NOT EXISTS idx_subscription_usage_signatures
  ON subscription_usage(subscription_id, period_month)
  WHERE usage_type = 'signature';

-- ============================================
-- MISE À JOUR subscription_plans: ajouter signatures_monthly_quota si manquant
-- ============================================

-- Mettre à jour les plans pour avoir signatures_monthly_quota dans features
UPDATE subscription_plans
SET features = features || jsonb_build_object('signatures_monthly_quota',
  CASE slug
    WHEN 'gratuit' THEN 0
    WHEN 'starter' THEN 0
    WHEN 'confort' THEN 2
    WHEN 'pro' THEN 10
    WHEN 'enterprise_s' THEN 25
    WHEN 'enterprise_m' THEN 40
    WHEN 'enterprise_l' THEN 60
    WHEN 'enterprise_xl' THEN -1
    WHEN 'enterprise' THEN -1
    ELSE 0
  END
)
WHERE NOT (features ? 'signatures_monthly_quota');

COMMIT;


-- ========== 20260110000000_admin_dashboard_sota2026.sql ==========
-- ============================================================================
-- ADMIN DASHBOARD SOTA 2026 - Migration complète
-- Modération IA-First, Comptabilité avancée, Suivi forfaits intelligent
-- ============================================================================

-- ============================================================================
-- 1. TABLE: moderation_rules - Règles de modération IA-First
-- ============================================================================
CREATE TABLE IF NOT EXISTS moderation_rules (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    flow_type VARCHAR(50) NOT NULL CHECK (flow_type IN ('profile', 'message', 'document', 'listing', 'payment', 'review')),

    -- Configuration IA
    ai_enabled BOOLEAN DEFAULT true,
    ai_model VARCHAR(100) DEFAULT 'gpt-4-turbo',
    ai_threshold DECIMAL(3,2) DEFAULT 0.75 CHECK (ai_threshold BETWEEN 0 AND 1),

    -- Règles JSON
    rule_config JSONB NOT NULL DEFAULT '{}',
    -- Exemple: {"keywords": ["spam", "arnaque"], "patterns": ["\\b\\d{10}\\b"], "severity": "high"}

    -- Actions automatiques
    auto_action VARCHAR(50) DEFAULT 'flag' CHECK (auto_action IN ('flag', 'quarantine', 'reject', 'escalate', 'notify')),
    escalation_delay_hours INTEGER DEFAULT 24,
    notify_admin BOOLEAN DEFAULT true,

    -- Métriques
    total_triggered INTEGER DEFAULT 0,
    total_false_positives INTEGER DEFAULT 0,
    accuracy_rate DECIMAL(5,2) DEFAULT 100.00,

    -- Statut
    is_active BOOLEAN DEFAULT true,
    priority INTEGER DEFAULT 50 CHECK (priority BETWEEN 1 AND 100),

    -- Audit
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index pour performance
CREATE INDEX IF NOT EXISTS idx_moderation_rules_flow_type ON moderation_rules(flow_type);
CREATE INDEX IF NOT EXISTS idx_moderation_rules_active ON moderation_rules(is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_moderation_rules_priority ON moderation_rules(priority DESC);

-- ============================================================================
-- 2. TABLE: moderation_queue - File d'attente de modération IA
-- ============================================================================
CREATE TABLE IF NOT EXISTS moderation_queue (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,

    -- Entité concernée
    entity_type VARCHAR(50) NOT NULL CHECK (entity_type IN ('profile', 'property', 'lease', 'message', 'document', 'review', 'payment')),
    entity_id UUID NOT NULL,

    -- Règle déclenchée
    rule_id UUID REFERENCES moderation_rules(id) ON DELETE SET NULL,

    -- Scoring IA
    ai_score DECIMAL(5,4) CHECK (ai_score BETWEEN 0 AND 1),
    ai_reasoning TEXT,
    ai_suggested_action VARCHAR(50),

    -- Contenu détecté
    flagged_content TEXT,
    matched_patterns JSONB DEFAULT '[]',

    -- Workflow
    status VARCHAR(30) DEFAULT 'pending' CHECK (status IN ('pending', 'reviewing', 'approved', 'rejected', 'escalated', 'auto_resolved')),
    priority VARCHAR(20) DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'critical')),

    -- Modérateur
    assigned_to UUID REFERENCES auth.users(id),
    reviewed_by UUID REFERENCES auth.users(id),
    reviewed_at TIMESTAMPTZ,
    review_notes TEXT,

    -- Actions prises
    action_taken VARCHAR(50),
    action_metadata JSONB DEFAULT '{}',

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ DEFAULT (NOW() + INTERVAL '7 days')
);

-- Index pour performance
CREATE INDEX IF NOT EXISTS idx_moderation_queue_status ON moderation_queue(status);
CREATE INDEX IF NOT EXISTS idx_moderation_queue_priority ON moderation_queue(priority);
CREATE INDEX IF NOT EXISTS idx_moderation_queue_entity ON moderation_queue(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_moderation_queue_assigned ON moderation_queue(assigned_to) WHERE assigned_to IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_moderation_queue_created ON moderation_queue(created_at DESC);

-- ============================================================================
-- 3. TABLE: admin_revenue_metrics - Métriques revenus réelles (pas simulées!)
-- ============================================================================
CREATE TABLE IF NOT EXISTS admin_revenue_metrics (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    period_date DATE NOT NULL,
    period_type VARCHAR(20) NOT NULL CHECK (period_type IN ('daily', 'weekly', 'monthly', 'quarterly', 'yearly')),

    -- Loyers
    total_rent_expected DECIMAL(12,2) DEFAULT 0,
    total_rent_collected DECIMAL(12,2) DEFAULT 0,
    rent_collection_rate DECIMAL(5,2) DEFAULT 0,

    -- Charges
    total_charges_expected DECIMAL(12,2) DEFAULT 0,
    total_charges_collected DECIMAL(12,2) DEFAULT 0,

    -- Impayés
    total_unpaid DECIMAL(12,2) DEFAULT 0,
    unpaid_count INTEGER DEFAULT 0,
    avg_days_late DECIMAL(5,2) DEFAULT 0,

    -- Abonnements plateforme
    subscription_revenue DECIMAL(12,2) DEFAULT 0,
    subscription_count INTEGER DEFAULT 0,
    churn_rate DECIMAL(5,2) DEFAULT 0,

    -- Commissions
    commission_revenue DECIMAL(12,2) DEFAULT 0,

    -- Métriques occupation
    total_properties INTEGER DEFAULT 0,
    occupied_properties INTEGER DEFAULT 0,
    occupancy_rate DECIMAL(5,2) DEFAULT 0,

    -- Timestamps
    calculated_at TIMESTAMPTZ DEFAULT NOW(),

    UNIQUE(period_date, period_type)
);

-- Index pour requêtes temporelles
CREATE INDEX IF NOT EXISTS idx_revenue_metrics_date ON admin_revenue_metrics(period_date DESC);
CREATE INDEX IF NOT EXISTS idx_revenue_metrics_period ON admin_revenue_metrics(period_type, period_date DESC);

-- ============================================================================
-- 4. TABLE: subscription_usage_metrics - Suivi utilisation forfaits
-- ============================================================================
CREATE TABLE IF NOT EXISTS subscription_usage_metrics (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,

    owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    subscription_id UUID REFERENCES subscriptions(id) ON DELETE SET NULL,
    plan_id VARCHAR(50) NOT NULL,

    -- Période
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,

    -- Utilisation
    properties_count INTEGER DEFAULT 0,
    properties_limit INTEGER DEFAULT 0,
    tenants_count INTEGER DEFAULT 0,
    tenants_limit INTEGER DEFAULT 0,
    documents_count INTEGER DEFAULT 0,
    documents_limit INTEGER DEFAULT 0,
    api_calls_count INTEGER DEFAULT 0,
    api_calls_limit INTEGER DEFAULT 0,
    storage_used_mb DECIMAL(10,2) DEFAULT 0,
    storage_limit_mb DECIMAL(10,2) DEFAULT 0,

    -- Alertes
    is_near_limit BOOLEAN DEFAULT false,
    limit_warnings JSONB DEFAULT '[]',

    -- Recommandations IA
    ai_upgrade_suggestion VARCHAR(50),
    ai_suggestion_reason TEXT,
    ai_potential_savings DECIMAL(10,2),

    -- Timestamps
    calculated_at TIMESTAMPTZ DEFAULT NOW(),

    UNIQUE(owner_id, period_start, period_end)
);

-- Index
CREATE INDEX IF NOT EXISTS idx_usage_metrics_owner ON subscription_usage_metrics(owner_id);
CREATE INDEX IF NOT EXISTS idx_usage_metrics_period ON subscription_usage_metrics(period_start, period_end);
CREATE INDEX IF NOT EXISTS idx_usage_metrics_near_limit ON subscription_usage_metrics(is_near_limit) WHERE is_near_limit = true;

-- ============================================================================
-- 5. TABLE: admin_accounting_entries - Écritures comptables détaillées
-- ============================================================================
CREATE TABLE IF NOT EXISTS admin_accounting_entries (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,

    -- Compte
    account_code VARCHAR(20) NOT NULL,
    account_name VARCHAR(255) NOT NULL,
    account_type VARCHAR(50) NOT NULL CHECK (account_type IN ('asset', 'liability', 'equity', 'revenue', 'expense')),

    -- Écriture
    entry_date DATE NOT NULL,
    entry_type VARCHAR(50) NOT NULL,
    reference VARCHAR(100),
    description TEXT,

    -- Montants
    debit DECIMAL(12,2) DEFAULT 0,
    credit DECIMAL(12,2) DEFAULT 0,
    balance DECIMAL(12,2) DEFAULT 0,

    -- Relations
    property_id UUID REFERENCES properties(id) ON DELETE SET NULL,
    tenant_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
    owner_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
    invoice_id UUID REFERENCES invoices(id) ON DELETE SET NULL,
    lease_id UUID REFERENCES leases(id) ON DELETE SET NULL,

    -- Statut
    is_reconciled BOOLEAN DEFAULT false,
    reconciled_at TIMESTAMPTZ,
    reconciled_by UUID REFERENCES auth.users(id),

    -- FEC (Format Échange Comptable)
    fec_journal_code VARCHAR(10),
    fec_piece_ref VARCHAR(50),
    fec_piece_date DATE,
    fec_echeance DATE,
    fec_lettrage VARCHAR(10),
    fec_date_lettrage DATE,

    -- Audit
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index pour grand livre et requêtes
CREATE INDEX IF NOT EXISTS idx_accounting_entries_date ON admin_accounting_entries(entry_date DESC);
CREATE INDEX IF NOT EXISTS idx_accounting_entries_account ON admin_accounting_entries(account_code);
CREATE INDEX IF NOT EXISTS idx_accounting_entries_property ON admin_accounting_entries(property_id) WHERE property_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_accounting_entries_reconciled ON admin_accounting_entries(is_reconciled) WHERE is_reconciled = false;

-- ============================================================================
-- 6. FONCTION RPC: admin_dashboard_stats_v2 - Stats dashboard avec vraies données
-- ============================================================================
CREATE OR REPLACE FUNCTION admin_dashboard_stats_v2()
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    result JSON;
    current_month_start DATE := date_trunc('month', CURRENT_DATE);
    previous_month_start DATE := date_trunc('month', CURRENT_DATE - INTERVAL '1 month');
BEGIN
    SELECT json_build_object(
        -- Utilisateurs
        'totalUsers', (SELECT COUNT(*) FROM profiles),
        'usersByRole', (
            SELECT json_build_object(
                'admin', COUNT(*) FILTER (WHERE role = 'admin'),
                'owner', COUNT(*) FILTER (WHERE role = 'owner'),
                'tenant', COUNT(*) FILTER (WHERE role = 'tenant'),
                'provider', COUNT(*) FILTER (WHERE role = 'provider')
            ) FROM profiles
        ),
        'newUsersThisMonth', (SELECT COUNT(*) FROM profiles WHERE created_at >= current_month_start),
        'newUsersPrevMonth', (SELECT COUNT(*) FROM profiles WHERE created_at >= previous_month_start AND created_at < current_month_start),

        -- Propriétés
        'totalProperties', (SELECT COUNT(*) FROM properties WHERE deleted_at IS NULL),
        'propertiesByStatus', (
            SELECT json_build_object(
                'active', COUNT(*) FILTER (WHERE status = 'active'),
                'rented', COUNT(*) FILTER (WHERE status = 'rented'),
                'draft', COUNT(*) FILTER (WHERE status = 'draft'),
                'archived', COUNT(*) FILTER (WHERE status = 'archived')
            ) FROM properties WHERE deleted_at IS NULL
        ),

        -- Baux
        'totalLeases', (SELECT COUNT(*) FROM leases),
        'activeLeases', (SELECT COUNT(*) FROM leases WHERE status = 'active'),
        'leasesByStatus', (
            SELECT json_build_object(
                'active', COUNT(*) FILTER (WHERE status = 'active'),
                'pending_signature', COUNT(*) FILTER (WHERE status = 'pending_signature'),
                'draft', COUNT(*) FILTER (WHERE status = 'draft'),
                'terminated', COUNT(*) FILTER (WHERE status IN ('terminated', 'expired'))
            ) FROM leases
        ),

        -- Factures
        'totalInvoices', (SELECT COUNT(*) FROM invoices),
        'unpaidInvoices', (SELECT COUNT(*) FROM invoices WHERE status IN ('sent', 'late', 'unpaid')),
        'invoicesByStatus', (
            SELECT json_build_object(
                'paid', COUNT(*) FILTER (WHERE status = 'paid'),
                'sent', COUNT(*) FILTER (WHERE status = 'sent'),
                'late', COUNT(*) FILTER (WHERE status = 'late'),
                'draft', COUNT(*) FILTER (WHERE status = 'draft')
            ) FROM invoices
        ),

        -- Tickets
        'totalTickets', (SELECT COUNT(*) FROM tickets),
        'openTickets', (SELECT COUNT(*) FROM tickets WHERE status IN ('open', 'in_progress')),
        'ticketsByStatus', (
            SELECT json_build_object(
                'open', COUNT(*) FILTER (WHERE status = 'open'),
                'in_progress', COUNT(*) FILTER (WHERE status = 'in_progress'),
                'resolved', COUNT(*) FILTER (WHERE status = 'resolved'),
                'closed', COUNT(*) FILTER (WHERE status = 'closed')
            ) FROM tickets
        ),

        -- Revenus mensuels (12 derniers mois - VRAIES DONNÉES)
        'monthlyRevenue', (
            SELECT COALESCE(json_agg(row_to_json(m) ORDER BY m.month_date), '[]'::json)
            FROM (
                SELECT
                    to_char(date_trunc('month', due_date), 'Mon') as month,
                    date_trunc('month', due_date) as month_date,
                    SUM(amount) as attendu,
                    SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) as encaisse
                FROM invoices
                WHERE due_date >= CURRENT_DATE - INTERVAL '12 months'
                GROUP BY date_trunc('month', due_date)
                ORDER BY date_trunc('month', due_date)
            ) m
        ),

        -- Tendances (évolution sur 7 derniers jours)
        'trends', json_build_object(
            'users', (
                SELECT json_agg(COALESCE(c, 0) ORDER BY d)
                FROM generate_series(CURRENT_DATE - INTERVAL '6 days', CURRENT_DATE, '1 day') d
                LEFT JOIN (
                    SELECT DATE(created_at) as date, COUNT(*) as c
                    FROM profiles
                    WHERE created_at >= CURRENT_DATE - INTERVAL '6 days'
                    GROUP BY DATE(created_at)
                ) p ON p.date = d
            ),
            'properties', (
                SELECT json_agg(COALESCE(c, 0) ORDER BY d)
                FROM generate_series(CURRENT_DATE - INTERVAL '6 days', CURRENT_DATE, '1 day') d
                LEFT JOIN (
                    SELECT DATE(created_at) as date, COUNT(*) as c
                    FROM properties
                    WHERE created_at >= CURRENT_DATE - INTERVAL '6 days' AND deleted_at IS NULL
                    GROUP BY DATE(created_at)
                ) p ON p.date = d
            ),
            'leases', (
                SELECT json_agg(COALESCE(c, 0) ORDER BY d)
                FROM generate_series(CURRENT_DATE - INTERVAL '6 days', CURRENT_DATE, '1 day') d
                LEFT JOIN (
                    SELECT DATE(created_at) as date, COUNT(*) as c
                    FROM leases
                    WHERE created_at >= CURRENT_DATE - INTERVAL '6 days'
                    GROUP BY DATE(created_at)
                ) p ON p.date = d
            )
        ),

        -- Taux de performance
        'occupancyRate', (
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE status = 'rented')::DECIMAL / NULLIF(COUNT(*), 0)) * 100, 1
            )
            FROM properties WHERE deleted_at IS NULL AND status IN ('active', 'rented')
        ),
        'collectionRate', (
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE status = 'paid')::DECIMAL / NULLIF(COUNT(*), 0)) * 100, 1
            )
            FROM invoices
            WHERE due_date >= CURRENT_DATE - INTERVAL '3 months'
        ),

        -- Documents et contenu
        'totalDocuments', (SELECT COUNT(*) FROM documents),
        'totalBlogPosts', (SELECT COUNT(*) FROM blog_posts),
        'publishedBlogPosts', (SELECT COUNT(*) FROM blog_posts WHERE is_published = true),

        -- Modération
        'moderationPending', (SELECT COUNT(*) FROM moderation_queue WHERE status = 'pending'),
        'moderationCritical', (SELECT COUNT(*) FROM moderation_queue WHERE status = 'pending' AND priority = 'critical'),

        -- Abonnements
        'subscriptionStats', (
            SELECT json_build_object(
                'total', COUNT(*),
                'active', COUNT(*) FILTER (WHERE status = 'active'),
                'trial', COUNT(*) FILTER (WHERE status = 'trialing'),
                'churned', COUNT(*) FILTER (WHERE status = 'canceled')
            ) FROM subscriptions
        ),

        -- Activité récente (vraies données)
        'recentActivity', (
            SELECT COALESCE(json_agg(activity ORDER BY activity.date DESC), '[]'::json)
            FROM (
                SELECT 'user' as type,
                       CONCAT('Nouvel utilisateur: ', prenom, ' ', nom) as description,
                       created_at as date
                FROM profiles
                ORDER BY created_at DESC
                LIMIT 3

                UNION ALL

                SELECT 'property' as type,
                       CONCAT('Nouveau bien: ', COALESCE(adresse_complete, 'Adresse non définie')) as description,
                       created_at as date
                FROM properties
                WHERE deleted_at IS NULL
                ORDER BY created_at DESC
                LIMIT 3

                UNION ALL

                SELECT 'lease' as type,
                       'Nouveau bail créé' as description,
                       created_at as date
                FROM leases
                ORDER BY created_at DESC
                LIMIT 2

                LIMIT 8
            ) activity
        )

    ) INTO result;

    RETURN result;
END;
$$;

-- ============================================================================
-- 7. FONCTION RPC: get_moderation_stats - Stats de modération
-- ============================================================================
CREATE OR REPLACE FUNCTION get_moderation_stats()
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN json_build_object(
        'pending', (SELECT COUNT(*) FROM moderation_queue WHERE status = 'pending'),
        'reviewing', (SELECT COUNT(*) FROM moderation_queue WHERE status = 'reviewing'),
        'approved', (SELECT COUNT(*) FROM moderation_queue WHERE status = 'approved' AND created_at >= CURRENT_DATE - INTERVAL '30 days'),
        'rejected', (SELECT COUNT(*) FROM moderation_queue WHERE status = 'rejected' AND created_at >= CURRENT_DATE - INTERVAL '30 days'),
        'escalated', (SELECT COUNT(*) FROM moderation_queue WHERE status = 'escalated'),
        'byPriority', json_build_object(
            'critical', (SELECT COUNT(*) FROM moderation_queue WHERE status = 'pending' AND priority = 'critical'),
            'high', (SELECT COUNT(*) FROM moderation_queue WHERE status = 'pending' AND priority = 'high'),
            'medium', (SELECT COUNT(*) FROM moderation_queue WHERE status = 'pending' AND priority = 'medium'),
            'low', (SELECT COUNT(*) FROM moderation_queue WHERE status = 'pending' AND priority = 'low')
        ),
        'byType', (
            SELECT json_object_agg(entity_type, cnt)
            FROM (
                SELECT entity_type, COUNT(*) as cnt
                FROM moderation_queue
                WHERE status = 'pending'
                GROUP BY entity_type
            ) t
        ),
        'rulesActive', (SELECT COUNT(*) FROM moderation_rules WHERE is_active = true),
        'avgResolutionHours', (
            SELECT ROUND(AVG(EXTRACT(EPOCH FROM (reviewed_at - created_at)) / 3600), 1)
            FROM moderation_queue
            WHERE reviewed_at IS NOT NULL AND created_at >= CURRENT_DATE - INTERVAL '30 days'
        )
    );
END;
$$;

-- ============================================================================
-- 8. FONCTION RPC: get_accounting_summary - Résumé comptable
-- ============================================================================
CREATE OR REPLACE FUNCTION get_accounting_summary(
    p_start_date DATE DEFAULT (CURRENT_DATE - INTERVAL '1 year'),
    p_end_date DATE DEFAULT CURRENT_DATE
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN json_build_object(
        'period', json_build_object('start', p_start_date, 'end', p_end_date),

        -- Totaux
        'totals', (
            SELECT json_build_object(
                'revenue', COALESCE(SUM(CASE WHEN account_type = 'revenue' THEN credit - debit END), 0),
                'expenses', COALESCE(SUM(CASE WHEN account_type = 'expense' THEN debit - credit END), 0),
                'assets', COALESCE(SUM(CASE WHEN account_type = 'asset' THEN balance END), 0),
                'liabilities', COALESCE(SUM(CASE WHEN account_type = 'liability' THEN balance END), 0)
            )
            FROM admin_accounting_entries
            WHERE entry_date BETWEEN p_start_date AND p_end_date
        ),

        -- Par mois
        'byMonth', (
            SELECT COALESCE(json_agg(row_to_json(m) ORDER BY m.month), '[]'::json)
            FROM (
                SELECT
                    to_char(entry_date, 'YYYY-MM') as month,
                    SUM(CASE WHEN account_type = 'revenue' THEN credit - debit ELSE 0 END) as revenue,
                    SUM(CASE WHEN account_type = 'expense' THEN debit - credit ELSE 0 END) as expenses
                FROM admin_accounting_entries
                WHERE entry_date BETWEEN p_start_date AND p_end_date
                GROUP BY to_char(entry_date, 'YYYY-MM')
            ) m
        ),

        -- Non rapprochées
        'unreconciled', (
            SELECT json_build_object(
                'count', COUNT(*),
                'totalDebit', COALESCE(SUM(debit), 0),
                'totalCredit', COALESCE(SUM(credit), 0)
            )
            FROM admin_accounting_entries
            WHERE is_reconciled = false
        ),

        -- Top 10 comptes par volume
        'topAccounts', (
            SELECT COALESCE(json_agg(row_to_json(a)), '[]'::json)
            FROM (
                SELECT
                    account_code,
                    account_name,
                    SUM(debit) as total_debit,
                    SUM(credit) as total_credit,
                    COUNT(*) as entries_count
                FROM admin_accounting_entries
                WHERE entry_date BETWEEN p_start_date AND p_end_date
                GROUP BY account_code, account_name
                ORDER BY SUM(debit) + SUM(credit) DESC
                LIMIT 10
            ) a
        )
    );
END;
$$;

-- ============================================================================
-- 9. TRIGGER: Mise à jour automatique updated_at
-- ============================================================================
CREATE OR REPLACE FUNCTION trigger_set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Appliquer aux nouvelles tables
DROP TRIGGER IF EXISTS set_updated_at_moderation_rules ON moderation_rules;
CREATE TRIGGER set_updated_at_moderation_rules
    BEFORE UPDATE ON moderation_rules
    FOR EACH ROW
    EXECUTE FUNCTION trigger_set_updated_at();

DROP TRIGGER IF EXISTS set_updated_at_moderation_queue ON moderation_queue;
CREATE TRIGGER set_updated_at_moderation_queue
    BEFORE UPDATE ON moderation_queue
    FOR EACH ROW
    EXECUTE FUNCTION trigger_set_updated_at();

-- ============================================================================
-- 10. RLS Policies
-- ============================================================================

-- Moderation Rules - Admin only
ALTER TABLE moderation_rules ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admin can manage moderation rules" ON moderation_rules;
CREATE POLICY "Admin can manage moderation rules" ON moderation_rules
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.user_id = auth.uid()
            AND profiles.role = 'admin'
        )
    );

-- Moderation Queue - Admin only
ALTER TABLE moderation_queue ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admin can manage moderation queue" ON moderation_queue;
CREATE POLICY "Admin can manage moderation queue" ON moderation_queue
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.user_id = auth.uid()
            AND profiles.role = 'admin'
        )
    );

-- Revenue Metrics - Admin only
ALTER TABLE admin_revenue_metrics ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admin can view revenue metrics" ON admin_revenue_metrics;
CREATE POLICY "Admin can view revenue metrics" ON admin_revenue_metrics
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.user_id = auth.uid()
            AND profiles.role = 'admin'
        )
    );

-- Accounting Entries - Admin only
ALTER TABLE admin_accounting_entries ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admin can manage accounting entries" ON admin_accounting_entries;
CREATE POLICY "Admin can manage accounting entries" ON admin_accounting_entries
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.user_id = auth.uid()
            AND profiles.role = 'admin'
        )
    );

-- Subscription Usage - Admin and Owner
ALTER TABLE subscription_usage_metrics ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admin can view all usage metrics" ON subscription_usage_metrics;
CREATE POLICY "Admin can view all usage metrics" ON subscription_usage_metrics
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.user_id = auth.uid()
            AND profiles.role = 'admin'
        )
    );

DROP POLICY IF EXISTS "Owner can view own usage metrics" ON subscription_usage_metrics;
CREATE POLICY "Owner can view own usage metrics" ON subscription_usage_metrics
    FOR SELECT
    USING (
        owner_id IN (
            SELECT id FROM profiles WHERE user_id = auth.uid()
        )
    );

-- ============================================================================
-- 11. Données initiales pour les règles de modération
-- ============================================================================
INSERT INTO moderation_rules (name, description, flow_type, ai_enabled, ai_threshold, rule_config, auto_action, priority)
VALUES
    (
        'Détection spam profils',
        'Détecte les profils suspects avec liens ou contenu spam',
        'profile',
        true,
        0.80,
        '{"keywords": ["http://", "https://", "gagnez", "gratuit", "cliquez"], "maxLinks": 2, "minNameLength": 2}',
        'quarantine',
        90
    ),
    (
        'Vérification documents',
        'Analyse automatique des documents d''identité',
        'document',
        true,
        0.85,
        '{"requiredFields": ["nom", "prenom", "date_naissance"], "checkExpiry": true, "ocrEnabled": true}',
        'flag',
        85
    ),
    (
        'Modération annonces',
        'Vérifie la conformité des annonces immobilières',
        'listing',
        true,
        0.75,
        '{"bannedWords": ["arnaque", "urgent cash"], "requirePhotos": true, "minDescription": 50}',
        'flag',
        80
    ),
    (
        'Détection fraude paiement',
        'Surveille les patterns de paiement suspects',
        'payment',
        true,
        0.90,
        '{"maxAmountAlert": 50000, "frequencyCheck": true, "geoCheck": true}',
        'escalate',
        95
    )
ON CONFLICT DO NOTHING;

-- ============================================================================
-- GRANT permissions
-- ============================================================================
GRANT SELECT, INSERT, UPDATE, DELETE ON moderation_rules TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON moderation_queue TO authenticated;
GRANT SELECT ON admin_revenue_metrics TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON admin_accounting_entries TO authenticated;
GRANT SELECT ON subscription_usage_metrics TO authenticated;

GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO authenticated;

COMMENT ON TABLE moderation_rules IS 'Règles de modération IA-First pour le dashboard admin SOTA 2026';
COMMENT ON TABLE moderation_queue IS 'File d''attente de modération avec scoring IA';
COMMENT ON TABLE admin_revenue_metrics IS 'Métriques revenus calculées (vraies données, pas simulées)';
COMMENT ON TABLE subscription_usage_metrics IS 'Suivi utilisation des forfaits par propriétaire';
COMMENT ON TABLE admin_accounting_entries IS 'Écritures comptables détaillées format FEC';


-- ========== 20260110000001_accounting_tables.sql ==========
-- ============================================================================
-- MIGRATION: Tables Comptabilité Complètes
-- Date: 2026-01-10
-- Description: Ajoute les tables nécessaires pour une comptabilité complète
-- ============================================================================

-- ============================================================================
-- 1. TABLE: accounting_journals (Journaux comptables)
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.accounting_journals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code VARCHAR(4) NOT NULL UNIQUE,
  libelle VARCHAR(100) NOT NULL,
  description TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insérer les journaux par défaut
INSERT INTO public.accounting_journals (code, libelle, description) VALUES
  ('VE', 'Ventes', 'Facturation des honoraires de gestion'),
  ('AC', 'Achats', 'Factures fournisseurs et prestataires'),
  ('BQ', 'Banque Agence', 'Mouvements du compte courant agence'),
  ('BM', 'Banque Mandant', 'Mouvements du compte mandant'),
  ('OD', 'Opérations Diverses', 'Régularisations et écritures diverses'),
  ('AN', 'À Nouveau', 'Report à nouveau des soldes')
ON CONFLICT (code) DO NOTHING;

-- ============================================================================
-- 2. TABLE: accounting_accounts (Plan comptable)
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.accounting_accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  numero VARCHAR(10) NOT NULL UNIQUE,
  libelle VARCHAR(255) NOT NULL,
  classe INTEGER NOT NULL CHECK (classe BETWEEN 1 AND 9),
  sens VARCHAR(10) CHECK (sens IN ('debit', 'credit', 'mixte')),
  is_active BOOLEAN DEFAULT true,
  parent_numero VARCHAR(10),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insérer les comptes principaux
INSERT INTO public.accounting_accounts (numero, libelle, classe, sens) VALUES
  -- Classe 4 - Tiers
  ('401000', 'Fournisseurs', 4, 'credit'),
  ('411000', 'Clients', 4, 'debit'),
  ('421000', 'Personnel - Rémunérations dues', 4, 'credit'),
  ('445710', 'TVA collectée', 4, 'credit'),
  ('445660', 'TVA déductible sur ABS', 4, 'debit'),
  ('467000', 'Autres comptes débiteurs ou créditeurs', 4, 'mixte'),
  ('467100', 'Propriétaires - Comptes mandants', 4, 'credit'),
  ('467200', 'Locataires - Comptes mandants', 4, 'debit'),
  ('467300', 'Dépôts de garantie reçus', 4, 'credit'),
  -- Classe 5 - Financiers
  ('512000', 'Banque compte courant', 5, 'debit'),
  ('545000', 'Banque compte mandant', 5, 'debit'),
  ('530000', 'Caisse', 5, 'debit'),
  -- Classe 6 - Charges
  ('606100', 'Fournitures non stockables', 6, 'debit'),
  ('613500', 'Locations mobilières (SaaS)', 6, 'debit'),
  ('616000', 'Primes d''assurance', 6, 'debit'),
  ('622600', 'Honoraires comptables', 6, 'debit'),
  ('626000', 'Frais postaux et télécommunications', 6, 'debit'),
  ('627100', 'Frais bancaires', 6, 'debit'),
  -- Classe 7 - Produits
  ('706000', 'Prestations de services', 7, 'credit'),
  ('706100', 'Honoraires de gestion locative', 7, 'credit'),
  ('706200', 'Honoraires de mise en location', 7, 'credit'),
  ('706300', 'Honoraires d''état des lieux', 7, 'credit')
ON CONFLICT (numero) DO NOTHING;

-- ============================================================================
-- 3. TABLE: accounting_entries (Écritures comptables)
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.accounting_entries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Identification
  journal_code VARCHAR(4) NOT NULL REFERENCES public.accounting_journals(code),
  ecriture_num VARCHAR(30) NOT NULL,
  ecriture_date DATE NOT NULL,

  -- Compte
  compte_num VARCHAR(10) NOT NULL,
  compte_lib VARCHAR(255) NOT NULL,
  compte_aux_num VARCHAR(20),
  compte_aux_lib VARCHAR(255),

  -- Pièce
  piece_ref VARCHAR(50) NOT NULL,
  piece_date DATE NOT NULL,

  -- Montants
  ecriture_lib VARCHAR(255) NOT NULL,
  debit DECIMAL(15, 2) NOT NULL DEFAULT 0,
  credit DECIMAL(15, 2) NOT NULL DEFAULT 0,

  -- Lettrage
  ecriture_let VARCHAR(10),
  date_let DATE,

  -- Validation
  valid_date DATE,

  -- Devise
  montant_devise DECIMAL(15, 2) DEFAULT 0,
  idevise VARCHAR(3) DEFAULT 'EUR',

  -- Métadonnées
  owner_id UUID REFERENCES public.profiles(id),
  property_id UUID REFERENCES public.properties(id),
  invoice_id UUID REFERENCES public.invoices(id),
  payment_id UUID REFERENCES public.payments(id),

  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id),

  -- Contraintes
  CONSTRAINT check_debit_or_credit CHECK (
    (debit > 0 AND credit = 0) OR (credit > 0 AND debit = 0) OR (debit = 0 AND credit = 0)
  )
);

-- Index pour recherche rapide
CREATE INDEX IF NOT EXISTS idx_accounting_entries_journal ON public.accounting_entries(journal_code);
CREATE INDEX IF NOT EXISTS idx_accounting_entries_date ON public.accounting_entries(ecriture_date);
CREATE INDEX IF NOT EXISTS idx_accounting_entries_compte ON public.accounting_entries(compte_num);
CREATE INDEX IF NOT EXISTS idx_accounting_entries_piece ON public.accounting_entries(piece_ref);
CREATE INDEX IF NOT EXISTS idx_accounting_entries_owner ON public.accounting_entries(owner_id);
CREATE INDEX IF NOT EXISTS idx_accounting_entries_invoice ON public.accounting_entries(invoice_id);

-- ============================================================================
-- 4. TABLE: mandant_accounts (Comptes mandants individuels)
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.mandant_accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Identification
  account_number VARCHAR(20) NOT NULL UNIQUE,
  account_type VARCHAR(20) NOT NULL CHECK (account_type IN ('proprietaire', 'locataire')),

  -- Liens
  profile_id UUID NOT NULL REFERENCES public.profiles(id),
  property_id UUID REFERENCES public.properties(id),

  -- Soldes
  solde_debit DECIMAL(15, 2) DEFAULT 0,
  solde_credit DECIMAL(15, 2) DEFAULT 0,
  solde_net DECIMAL(15, 2) GENERATED ALWAYS AS (solde_credit - solde_debit) STORED,

  -- Dates
  last_movement_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- Contraintes
  CONSTRAINT unique_mandant_profile_property UNIQUE (profile_id, property_id, account_type)
);

CREATE INDEX IF NOT EXISTS idx_mandant_accounts_profile ON public.mandant_accounts(profile_id);
CREATE INDEX IF NOT EXISTS idx_mandant_accounts_type ON public.mandant_accounts(account_type);

-- ============================================================================
-- 5. TABLE: charge_regularisations (Régularisation des charges)
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.charge_regularisations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Liens
  lease_id UUID NOT NULL REFERENCES public.leases(id),
  property_id UUID NOT NULL REFERENCES public.properties(id),
  tenant_id UUID NOT NULL REFERENCES public.profiles(id),

  -- Période
  annee INTEGER NOT NULL,
  date_debut DATE NOT NULL,
  date_fin DATE NOT NULL,

  -- Montants
  provisions_versees DECIMAL(15, 2) NOT NULL DEFAULT 0,
  charges_reelles DECIMAL(15, 2) NOT NULL DEFAULT 0,
  solde DECIMAL(15, 2) GENERATED ALWAYS AS (charges_reelles - provisions_versees) STORED,

  -- Détail charges
  detail_charges JSONB DEFAULT '[]',

  -- Statut
  statut VARCHAR(20) DEFAULT 'draft' CHECK (statut IN ('draft', 'sent', 'paid', 'disputed', 'cancelled')),

  -- Dates
  date_emission DATE,
  date_echeance DATE,
  date_paiement DATE,

  -- Ajustement
  nouvelle_provision DECIMAL(15, 2),
  date_effet_nouvelle_provision DATE,

  -- Métadonnées
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id),

  CONSTRAINT unique_regularisation_lease_annee UNIQUE (lease_id, annee)
);

CREATE INDEX IF NOT EXISTS idx_charge_regularisations_lease ON public.charge_regularisations(lease_id);
CREATE INDEX IF NOT EXISTS idx_charge_regularisations_annee ON public.charge_regularisations(annee);

-- ============================================================================
-- 6. TABLE: deposit_operations (Opérations sur dépôts de garantie)
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.deposit_operations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Liens
  lease_id UUID NOT NULL REFERENCES public.leases(id),
  property_id UUID NOT NULL REFERENCES public.properties(id),
  tenant_id UUID NOT NULL REFERENCES public.profiles(id),
  owner_id UUID NOT NULL REFERENCES public.profiles(id),

  -- Type d'opération
  operation_type VARCHAR(20) NOT NULL CHECK (operation_type IN ('reception', 'restitution', 'retenue', 'complement')),

  -- Montants
  montant DECIMAL(15, 2) NOT NULL,

  -- Pour les retenues
  motif_retenue TEXT,
  detail_retenues JSONB DEFAULT '[]',

  -- Références
  payment_id UUID REFERENCES public.payments(id),
  edl_sortie_id UUID,

  -- Dates
  date_operation DATE NOT NULL,
  date_limite_restitution DATE,

  -- Statut
  statut VARCHAR(20) DEFAULT 'pending' CHECK (statut IN ('pending', 'completed', 'disputed', 'cancelled')),

  -- Documents
  documents JSONB DEFAULT '[]',

  -- Métadonnées
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id)
);

CREATE INDEX IF NOT EXISTS idx_deposit_operations_lease ON public.deposit_operations(lease_id);
CREATE INDEX IF NOT EXISTS idx_deposit_operations_tenant ON public.deposit_operations(tenant_id);

-- ============================================================================
-- 7. TABLE: bank_reconciliations (Rapprochements bancaires)
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.bank_reconciliations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Période
  periode VARCHAR(7) NOT NULL, -- YYYY-MM
  date_reconciliation DATE NOT NULL,

  -- Compte
  compte_type VARCHAR(20) NOT NULL CHECK (compte_type IN ('agence', 'mandant')),

  -- Soldes
  solde_banque DECIMAL(15, 2) NOT NULL,
  solde_comptable DECIMAL(15, 2) NOT NULL,
  ecart DECIMAL(15, 2) GENERATED ALWAYS AS (solde_banque - solde_comptable) STORED,

  -- Détail
  operations_non_pointees JSONB DEFAULT '[]',

  -- Statut
  statut VARCHAR(20) DEFAULT 'draft' CHECK (statut IN ('draft', 'validated', 'locked')),
  is_balanced BOOLEAN GENERATED ALWAYS AS (ABS(solde_banque - solde_comptable) < 0.01) STORED,

  -- Validation
  validated_at TIMESTAMPTZ,
  validated_by UUID REFERENCES auth.users(id),

  -- Métadonnées
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id),

  CONSTRAINT unique_reconciliation_periode_compte UNIQUE (periode, compte_type)
);

-- ============================================================================
-- 8. FONCTION: Enregistrer une écriture comptable
-- ============================================================================
CREATE OR REPLACE FUNCTION public.record_accounting_entry(
  p_journal_code VARCHAR(4),
  p_compte_num VARCHAR(10),
  p_compte_lib VARCHAR(255),
  p_piece_ref VARCHAR(50),
  p_ecriture_lib VARCHAR(255),
  p_debit DECIMAL(15, 2),
  p_credit DECIMAL(15, 2),
  p_owner_id UUID DEFAULT NULL,
  p_property_id UUID DEFAULT NULL,
  p_invoice_id UUID DEFAULT NULL,
  p_payment_id UUID DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
  v_entry_id UUID;
  v_ecriture_num VARCHAR(30);
  v_today DATE := CURRENT_DATE;
BEGIN
  -- Générer le numéro d'écriture
  v_ecriture_num := p_journal_code || '-' || TO_CHAR(v_today, 'YYYY') || '-' ||
    LPAD(COALESCE(
      (SELECT COUNT(*) + 1 FROM public.accounting_entries
       WHERE journal_code = p_journal_code
       AND EXTRACT(YEAR FROM ecriture_date) = EXTRACT(YEAR FROM v_today))::TEXT,
      '1'
    ), 6, '0');

  -- Insérer l'écriture
  INSERT INTO public.accounting_entries (
    journal_code, ecriture_num, ecriture_date,
    compte_num, compte_lib,
    piece_ref, piece_date,
    ecriture_lib, debit, credit,
    owner_id, property_id, invoice_id, payment_id
  ) VALUES (
    p_journal_code, v_ecriture_num, v_today,
    p_compte_num, p_compte_lib,
    p_piece_ref, v_today,
    p_ecriture_lib, p_debit, p_credit,
    p_owner_id, p_property_id, p_invoice_id, p_payment_id
  ) RETURNING id INTO v_entry_id;

  RETURN v_entry_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- 9. FONCTION: Mettre à jour le solde mandant
-- ============================================================================
CREATE OR REPLACE FUNCTION public.update_mandant_balance(
  p_profile_id UUID,
  p_property_id UUID,
  p_account_type VARCHAR(20),
  p_debit DECIMAL(15, 2) DEFAULT 0,
  p_credit DECIMAL(15, 2) DEFAULT 0
) RETURNS UUID AS $$
DECLARE
  v_account_id UUID;
  v_account_number VARCHAR(20);
BEGIN
  -- Générer le numéro de compte
  v_account_number := CASE p_account_type
    WHEN 'proprietaire' THEN '4671' || UPPER(SUBSTRING(p_profile_id::TEXT, 1, 5))
    WHEN 'locataire' THEN '4672' || UPPER(SUBSTRING(p_profile_id::TEXT, 1, 5))
  END;

  -- Upsert le compte mandant
  INSERT INTO public.mandant_accounts (
    account_number, account_type, profile_id, property_id,
    solde_debit, solde_credit, last_movement_at
  ) VALUES (
    v_account_number, p_account_type, p_profile_id, p_property_id,
    p_debit, p_credit, NOW()
  )
  ON CONFLICT (profile_id, property_id, account_type) DO UPDATE SET
    solde_debit = public.mandant_accounts.solde_debit + p_debit,
    solde_credit = public.mandant_accounts.solde_credit + p_credit,
    last_movement_at = NOW(),
    updated_at = NOW()
  RETURNING id INTO v_account_id;

  RETURN v_account_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- 10. RLS Policies
-- ============================================================================

-- accounting_entries
ALTER TABLE public.accounting_entries ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can view all entries" ON public.accounting_entries
  FOR SELECT TO authenticated
  USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

CREATE POLICY "Owners can view their entries" ON public.accounting_entries
  FOR SELECT TO authenticated
  USING (
    owner_id IN (SELECT id FROM public.profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Admins can insert entries" ON public.accounting_entries
  FOR INSERT TO authenticated
  WITH CHECK (
    EXISTS (SELECT 1 FROM public.profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- mandant_accounts
ALTER TABLE public.mandant_accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can view all mandant accounts" ON public.mandant_accounts
  FOR SELECT TO authenticated
  USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

CREATE POLICY "Users can view their own mandant account" ON public.mandant_accounts
  FOR SELECT TO authenticated
  USING (
    profile_id IN (SELECT id FROM public.profiles WHERE user_id = auth.uid())
  );

-- charge_regularisations
ALTER TABLE public.charge_regularisations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can manage regularisations" ON public.charge_regularisations
  FOR ALL TO authenticated
  USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

CREATE POLICY "Tenants can view their regularisations" ON public.charge_regularisations
  FOR SELECT TO authenticated
  USING (
    tenant_id IN (SELECT id FROM public.profiles WHERE user_id = auth.uid())
  );

-- deposit_operations
ALTER TABLE public.deposit_operations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can manage deposits" ON public.deposit_operations
  FOR ALL TO authenticated
  USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

CREATE POLICY "Owners can view their deposit operations" ON public.deposit_operations
  FOR SELECT TO authenticated
  USING (
    owner_id IN (SELECT id FROM public.profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Tenants can view their deposit operations" ON public.deposit_operations
  FOR SELECT TO authenticated
  USING (
    tenant_id IN (SELECT id FROM public.profiles WHERE user_id = auth.uid())
  );

-- bank_reconciliations
ALTER TABLE public.bank_reconciliations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins only for reconciliations" ON public.bank_reconciliations
  FOR ALL TO authenticated
  USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- ============================================================================
-- 11. Triggers pour mise à jour automatique
-- ============================================================================

-- Trigger pour updated_at
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_mandant_accounts_updated_at
  BEFORE UPDATE ON public.mandant_accounts
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_charge_regularisations_updated_at
  BEFORE UPDATE ON public.charge_regularisations
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_deposit_operations_updated_at
  BEFORE UPDATE ON public.deposit_operations
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_bank_reconciliations_updated_at
  BEFORE UPDATE ON public.bank_reconciliations
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- ============================================================================
-- FIN DE LA MIGRATION
-- ============================================================================


-- ========== 20260110000001_passkeys_and_2fa_sota.sql ==========
-- Migration: Passkeys (WebAuthn) et 2FA SOTA 2026
-- Date: 2026-01-10
-- Description: Ajoute le support des Passkeys et améliore le système 2FA

-- =============================================================================
-- TABLE: passkey_credentials
-- Stocke les credentials WebAuthn des utilisateurs
-- =============================================================================
CREATE TABLE IF NOT EXISTS passkey_credentials (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  credential_id TEXT NOT NULL UNIQUE,
  public_key TEXT NOT NULL,
  counter BIGINT NOT NULL DEFAULT 0,
  device_type TEXT NOT NULL CHECK (device_type IN ('singleDevice', 'multiDevice')),
  backed_up BOOLEAN NOT NULL DEFAULT false,
  transports TEXT[] DEFAULT '{}',
  friendly_name TEXT DEFAULT 'Ma passkey',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_used_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour lookup rapide par user_id et credential_id
CREATE INDEX IF NOT EXISTS idx_passkey_credentials_user_id ON passkey_credentials(user_id);
CREATE INDEX IF NOT EXISTS idx_passkey_credentials_credential_id ON passkey_credentials(credential_id);

-- =============================================================================
-- TABLE: passkey_challenges
-- Stocke les challenges WebAuthn temporaires
-- =============================================================================
CREATE TABLE IF NOT EXISTS passkey_challenges (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  challenge TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('registration', 'authentication')),
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour nettoyage des challenges expirés
CREATE INDEX IF NOT EXISTS idx_passkey_challenges_expires_at ON passkey_challenges(expires_at);
CREATE INDEX IF NOT EXISTS idx_passkey_challenges_user_type ON passkey_challenges(user_id, type);

-- =============================================================================
-- TABLE: user_2fa
-- Configuration 2FA améliorée avec recovery codes
-- =============================================================================
CREATE TABLE IF NOT EXISTS user_2fa (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  totp_secret TEXT,
  recovery_codes JSONB DEFAULT '[]'::jsonb,
  enabled BOOLEAN NOT NULL DEFAULT false,
  pending_activation BOOLEAN NOT NULL DEFAULT false,
  activated_at TIMESTAMPTZ,
  disabled_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour lookup rapide
CREATE INDEX IF NOT EXISTS idx_user_2fa_user_id ON user_2fa(user_id);
CREATE INDEX IF NOT EXISTS idx_user_2fa_enabled ON user_2fa(enabled) WHERE enabled = true;

-- =============================================================================
-- RLS POLICIES
-- =============================================================================

-- Activer RLS sur toutes les tables
ALTER TABLE passkey_credentials ENABLE ROW LEVEL SECURITY;
ALTER TABLE passkey_challenges ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_2fa ENABLE ROW LEVEL SECURITY;

-- Policies pour passkey_credentials
CREATE POLICY "Users can view their own passkeys"
  ON passkey_credentials FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own passkeys"
  ON passkey_credentials FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own passkeys"
  ON passkey_credentials FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own passkeys"
  ON passkey_credentials FOR DELETE
  USING (auth.uid() = user_id);

-- Policy service-role pour passkey_challenges (géré côté serveur)
CREATE POLICY "Service role full access to challenges"
  ON passkey_challenges FOR ALL
  USING (true)
  WITH CHECK (true);

-- Policies pour user_2fa
CREATE POLICY "Users can view their own 2FA config"
  ON user_2fa FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own 2FA config"
  ON user_2fa FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own 2FA config"
  ON user_2fa FOR UPDATE
  USING (auth.uid() = user_id);

-- =============================================================================
-- TRIGGERS
-- =============================================================================

-- Trigger pour updated_at sur passkey_credentials
CREATE OR REPLACE FUNCTION update_passkey_credentials_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_passkey_credentials_updated_at ON passkey_credentials;
CREATE TRIGGER trigger_passkey_credentials_updated_at
  BEFORE UPDATE ON passkey_credentials
  FOR EACH ROW
  EXECUTE FUNCTION update_passkey_credentials_updated_at();

-- Trigger pour updated_at sur user_2fa
CREATE OR REPLACE FUNCTION update_user_2fa_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_user_2fa_updated_at ON user_2fa;
CREATE TRIGGER trigger_user_2fa_updated_at
  BEFORE UPDATE ON user_2fa
  FOR EACH ROW
  EXECUTE FUNCTION update_user_2fa_updated_at();

-- =============================================================================
-- CLEANUP FUNCTION
-- Nettoie les challenges expirés (à appeler via cron)
-- =============================================================================
CREATE OR REPLACE FUNCTION cleanup_expired_passkey_challenges()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM passkey_challenges
  WHERE expires_at < NOW();

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- COMMENTS
-- =============================================================================
COMMENT ON TABLE passkey_credentials IS 'Stocke les credentials WebAuthn (Passkeys) des utilisateurs - SOTA 2026';
COMMENT ON TABLE passkey_challenges IS 'Stocke les challenges WebAuthn temporaires pour registration/authentication';
COMMENT ON TABLE user_2fa IS 'Configuration 2FA TOTP avec recovery codes - SOTA 2026';

COMMENT ON COLUMN passkey_credentials.device_type IS 'singleDevice = clé physique, multiDevice = passkey synchronisée (iCloud, Google)';
COMMENT ON COLUMN passkey_credentials.backed_up IS 'true si la passkey est synchronisée dans le cloud';
COMMENT ON COLUMN user_2fa.recovery_codes IS 'Array JSON de {code, used, used_at}';


-- ========== 20260110100000_fix_accounting_schema_gaps.sql ==========
-- ============================================================================
-- MIGRATION: Correction des écarts entre services et schéma DB
-- Date: 2026-01-10
-- Description: Aligne le schéma avec les attentes des services comptables
-- ============================================================================

-- ============================================================================
-- 1. TABLE charges - Ajouter colonnes manquantes
-- ============================================================================

-- Ajouter libelle si non existant
ALTER TABLE public.charges
  ADD COLUMN IF NOT EXISTS libelle TEXT;

-- Ajouter quote_part (pourcentage récupérable sur le locataire)
ALTER TABLE public.charges
  ADD COLUMN IF NOT EXISTS quote_part DECIMAL(5, 2) DEFAULT 100.00
  CHECK (quote_part >= 0 AND quote_part <= 100);

-- Ajouter date_debut pour prorata
ALTER TABLE public.charges
  ADD COLUMN IF NOT EXISTS date_debut DATE;

-- Ajouter date_fin pour prorata
ALTER TABLE public.charges
  ADD COLUMN IF NOT EXISTS date_fin DATE;

-- Commenter les colonnes
COMMENT ON COLUMN public.charges.libelle IS 'Libellé descriptif de la charge (ex: "Eau froide et chaude")';
COMMENT ON COLUMN public.charges.quote_part IS 'Pourcentage récupérable sur le locataire (0-100)';
COMMENT ON COLUMN public.charges.date_debut IS 'Date de début d''application de la charge';
COMMENT ON COLUMN public.charges.date_fin IS 'Date de fin d''application de la charge (null = en cours)';

-- ============================================================================
-- 2. TABLE leases - Ajouter tenant_id direct
-- ============================================================================

-- Ajouter tenant_id direct pour simplifier les requêtes
ALTER TABLE public.leases
  ADD COLUMN IF NOT EXISTS tenant_id UUID REFERENCES public.profiles(id);

-- Index pour performance
CREATE INDEX IF NOT EXISTS idx_leases_tenant_id ON public.leases(tenant_id);

-- Commenter la colonne
COMMENT ON COLUMN public.leases.tenant_id IS 'ID du locataire principal (dénormalisé depuis lease_signers)';

-- ============================================================================
-- 3. Backfill tenant_id depuis lease_signers
-- ============================================================================

-- Peupler tenant_id depuis lease_signers (locataire_principal seulement)
UPDATE public.leases l
SET tenant_id = (
  SELECT ls.profile_id
  FROM public.lease_signers ls
  WHERE ls.lease_id = l.id
    AND ls.role IN ('locataire_principal', 'locataire')
  ORDER BY ls.created_at ASC
  LIMIT 1
)
WHERE l.tenant_id IS NULL;

-- ============================================================================
-- 4. TABLE charge_regularisations - Corriger noms colonnes
-- ============================================================================

-- La table existe déjà avec des noms français, ajouter des alias anglais
-- pour compatibilité avec le service

-- Ajouter colonnes avec noms anglais si pas existants
DO $$
BEGIN
  -- Vérifier si les colonnes anglaises existent
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'charge_regularisations' AND column_name = 'year'
  ) THEN
    -- Renommer ou ajouter les colonnes
    ALTER TABLE public.charge_regularisations
      ADD COLUMN IF NOT EXISTS year INTEGER;

    -- Copier les données
    UPDATE public.charge_regularisations SET year = annee WHERE year IS NULL;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'charge_regularisations' AND column_name = 'period_start'
  ) THEN
    ALTER TABLE public.charge_regularisations
      ADD COLUMN IF NOT EXISTS period_start DATE;
    UPDATE public.charge_regularisations SET period_start = date_debut WHERE period_start IS NULL;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'charge_regularisations' AND column_name = 'period_end'
  ) THEN
    ALTER TABLE public.charge_regularisations
      ADD COLUMN IF NOT EXISTS period_end DATE;
    UPDATE public.charge_regularisations SET period_end = date_fin WHERE period_end IS NULL;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'charge_regularisations' AND column_name = 'provisions_received'
  ) THEN
    ALTER TABLE public.charge_regularisations
      ADD COLUMN IF NOT EXISTS provisions_received DECIMAL(15, 2) DEFAULT 0;
    UPDATE public.charge_regularisations SET provisions_received = provisions_versees WHERE provisions_received IS NULL OR provisions_received = 0;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'charge_regularisations' AND column_name = 'actual_charges'
  ) THEN
    ALTER TABLE public.charge_regularisations
      ADD COLUMN IF NOT EXISTS actual_charges DECIMAL(15, 2) DEFAULT 0;
    UPDATE public.charge_regularisations SET actual_charges = charges_reelles WHERE actual_charges IS NULL OR actual_charges = 0;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'charge_regularisations' AND column_name = 'balance'
  ) THEN
    ALTER TABLE public.charge_regularisations
      ADD COLUMN IF NOT EXISTS balance DECIMAL(15, 2) DEFAULT 0;
    UPDATE public.charge_regularisations SET balance = solde WHERE balance IS NULL OR balance = 0;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'charge_regularisations' AND column_name = 'status'
  ) THEN
    ALTER TABLE public.charge_regularisations
      ADD COLUMN IF NOT EXISTS status VARCHAR(20) DEFAULT 'draft';
    UPDATE public.charge_regularisations SET status = statut WHERE status IS NULL OR status = 'draft';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'charge_regularisations' AND column_name = 'details'
  ) THEN
    ALTER TABLE public.charge_regularisations
      ADD COLUMN IF NOT EXISTS details JSONB DEFAULT '{}';
    UPDATE public.charge_regularisations SET details = detail_charges WHERE details = '{}' OR details IS NULL;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'charge_regularisations' AND column_name = 'applied_at'
  ) THEN
    ALTER TABLE public.charge_regularisations
      ADD COLUMN IF NOT EXISTS applied_at TIMESTAMPTZ;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'charge_regularisations' AND column_name = 'invoice_id'
  ) THEN
    ALTER TABLE public.charge_regularisations
      ADD COLUMN IF NOT EXISTS invoice_id UUID REFERENCES public.invoices(id);
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'charge_regularisations' AND column_name = 'credit_note_id'
  ) THEN
    ALTER TABLE public.charge_regularisations
      ADD COLUMN IF NOT EXISTS credit_note_id UUID REFERENCES public.invoices(id);
  END IF;
END $$;

-- Ajouter property_id si manquant
ALTER TABLE public.charge_regularisations
  ADD COLUMN IF NOT EXISTS property_id UUID REFERENCES public.properties(id);

-- Backfill property_id depuis leases
UPDATE public.charge_regularisations cr
SET property_id = (
  SELECT COALESCE(l.property_id, u.property_id)
  FROM public.leases l
  LEFT JOIN public.units u ON l.unit_id = u.id
  WHERE l.id = cr.lease_id
)
WHERE cr.property_id IS NULL;

-- ============================================================================
-- 5. TABLE invoices - Ajouter champ type et metadata
-- ============================================================================

ALTER TABLE public.invoices
  ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}';

ALTER TABLE public.invoices
  ADD COLUMN IF NOT EXISTS type VARCHAR(30) DEFAULT 'loyer';

-- Commenter
COMMENT ON COLUMN public.invoices.metadata IS 'Métadonnées additionnelles (type régularisation, etc.)';
COMMENT ON COLUMN public.invoices.type IS 'Type de facture: loyer, regularisation_charges, avoir_regularisation, depot_garantie';

-- ============================================================================
-- 6. TRIGGER: Synchroniser tenant_id depuis lease_signers
-- ============================================================================

CREATE OR REPLACE FUNCTION public.sync_lease_tenant_id()
RETURNS TRIGGER AS $$
BEGIN
  -- Quand un signataire locataire est ajouté, mettre à jour tenant_id du bail
  IF NEW.role IN ('locataire_principal', 'locataire') THEN
    UPDATE public.leases
    SET tenant_id = NEW.profile_id
    WHERE id = NEW.lease_id
      AND tenant_id IS NULL;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Supprimer le trigger s'il existe
DROP TRIGGER IF EXISTS trigger_sync_lease_tenant_id ON public.lease_signers;

-- Créer le trigger
CREATE TRIGGER trigger_sync_lease_tenant_id
  AFTER INSERT ON public.lease_signers
  FOR EACH ROW
  EXECUTE FUNCTION public.sync_lease_tenant_id();

-- ============================================================================
-- 7. TRIGGER: Écritures comptables automatiques sur paiement
-- ============================================================================

CREATE OR REPLACE FUNCTION public.auto_record_payment_entries()
RETURNS TRIGGER AS $$
DECLARE
  v_invoice RECORD;
  v_lease RECORD;
  v_owner_id UUID;
  v_tenant_id UUID;
  v_property_id UUID;
  v_code_postal TEXT;
  v_taux_tva DECIMAL;
  v_honoraires_ht DECIMAL;
  v_tva_montant DECIMAL;
  v_honoraires_ttc DECIMAL;
  v_net_proprietaire DECIMAL;
BEGIN
  -- Ne traiter que les paiements confirmés
  IF NEW.statut != 'succeeded' THEN
    RETURN NEW;
  END IF;

  -- Récupérer les infos de la facture
  SELECT * INTO v_invoice FROM public.invoices WHERE id = NEW.invoice_id;
  IF NOT FOUND THEN
    RETURN NEW;
  END IF;

  -- Récupérer le bail
  SELECT
    l.*,
    COALESCE(p.id, (SELECT property_id FROM units WHERE id = l.unit_id)) as prop_id,
    COALESCE(p.code_postal, '75000') as code_postal,
    p.owner_id as owner_id
  INTO v_lease
  FROM public.leases l
  LEFT JOIN public.properties p ON l.property_id = p.id
  LEFT JOIN public.units u ON l.unit_id = u.id
  LEFT JOIN public.properties p2 ON u.property_id = p2.id
  WHERE l.id = v_invoice.lease_id;

  IF NOT FOUND THEN
    RETURN NEW;
  END IF;

  v_owner_id := v_invoice.owner_id;
  v_tenant_id := v_invoice.tenant_id;
  v_property_id := v_lease.prop_id;
  v_code_postal := v_lease.code_postal;

  -- Calculer TVA selon code postal
  v_taux_tva := CASE
    WHEN v_code_postal LIKE '97%' THEN
      CASE
        WHEN v_code_postal LIKE '973%' OR v_code_postal LIKE '976%' THEN 0.00
        ELSE 0.085
      END
    ELSE 0.20
  END;

  -- Calculer honoraires (7% HT du loyer)
  v_honoraires_ht := ROUND((v_invoice.montant_loyer * 0.07)::NUMERIC, 2);
  v_tva_montant := ROUND((v_honoraires_ht * v_taux_tva)::NUMERIC, 2);
  v_honoraires_ttc := v_honoraires_ht + v_tva_montant;
  v_net_proprietaire := v_invoice.montant_loyer - v_honoraires_ttc;

  -- 1. Écriture: Encaissement locataire → Banque mandant
  PERFORM public.record_accounting_entry(
    'BM', '545000', 'Banque compte mandant',
    COALESCE(NEW.provider_ref, 'PAY-' || NEW.id::TEXT),
    'Encaissement loyer ' || v_invoice.periode,
    NEW.montant, 0,
    v_owner_id, v_property_id, v_invoice.id, NEW.id
  );

  -- 2. Écriture: Crédit compte locataire
  PERFORM public.record_accounting_entry(
    'BM', '467200', 'Locataires - Comptes mandants',
    COALESCE(NEW.provider_ref, 'PAY-' || NEW.id::TEXT),
    'Paiement locataire ' || v_invoice.periode,
    0, NEW.montant,
    v_owner_id, v_property_id, v_invoice.id, NEW.id
  );

  -- 3. Écriture: Honoraires de gestion HT
  PERFORM public.record_accounting_entry(
    'VE', '706100', 'Honoraires de gestion locative',
    'HON-' || v_invoice.periode,
    'Honoraires gestion ' || v_invoice.periode,
    0, v_honoraires_ht,
    v_owner_id, v_property_id, v_invoice.id, NEW.id
  );

  -- 4. Écriture: TVA collectée
  IF v_tva_montant > 0 THEN
    PERFORM public.record_accounting_entry(
      'VE', '445710', 'TVA collectée',
      'HON-' || v_invoice.periode,
      'TVA sur honoraires ' || v_invoice.periode,
      0, v_tva_montant,
      v_owner_id, v_property_id, v_invoice.id, NEW.id
    );
  END IF;

  -- 5. Écriture: Crédit compte propriétaire (net)
  PERFORM public.record_accounting_entry(
    'BM', '467100', 'Propriétaires - Comptes mandants',
    'CRG-' || v_invoice.periode,
    'Net propriétaire ' || v_invoice.periode,
    0, v_net_proprietaire,
    v_owner_id, v_property_id, v_invoice.id, NEW.id
  );

  -- 6. Mettre à jour le solde mandant propriétaire
  PERFORM public.update_mandant_balance(
    v_owner_id, v_property_id, 'proprietaire',
    0, v_net_proprietaire
  );

  -- 7. Mettre à jour le solde mandant locataire
  PERFORM public.update_mandant_balance(
    v_tenant_id, v_property_id, 'locataire',
    0, NEW.montant
  );

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Supprimer le trigger s'il existe
DROP TRIGGER IF EXISTS trigger_auto_payment_entries ON public.payments;

-- Créer le trigger
CREATE TRIGGER trigger_auto_payment_entries
  AFTER INSERT OR UPDATE OF statut ON public.payments
  FOR EACH ROW
  WHEN (NEW.statut = 'succeeded')
  EXECUTE FUNCTION public.auto_record_payment_entries();

-- ============================================================================
-- 8. Contraintes et validations
-- ============================================================================

-- Contrainte pour status charge_regularisations
DO $$
BEGIN
  ALTER TABLE public.charge_regularisations
    DROP CONSTRAINT IF EXISTS charge_regularisations_status_check;

  ALTER TABLE public.charge_regularisations
    ADD CONSTRAINT charge_regularisations_status_check
    CHECK (status IS NULL OR status IN ('draft', 'sent', 'applied', 'paid', 'disputed', 'cancelled'));
EXCEPTION WHEN OTHERS THEN
  NULL; -- Ignorer si contrainte existe déjà
END $$;

-- ============================================================================
-- 9. Index supplémentaires pour performance
-- ============================================================================

CREATE INDEX IF NOT EXISTS idx_charges_quote_part ON public.charges(quote_part);
CREATE INDEX IF NOT EXISTS idx_charges_date_debut ON public.charges(date_debut);
CREATE INDEX IF NOT EXISTS idx_charge_regularisations_year ON public.charge_regularisations(year);
CREATE INDEX IF NOT EXISTS idx_charge_regularisations_status ON public.charge_regularisations(status);
CREATE INDEX IF NOT EXISTS idx_invoices_type ON public.invoices(type);

-- ============================================================================
-- FIN DE LA MIGRATION
-- ============================================================================


-- ========== 20260110100001_init_historical_accounting_data.sql ==========
-- ============================================================================
-- MIGRATION: Initialisation des données comptables historiques
-- Date: 2026-01-10
-- Description: Initialise deposit_operations et accounting_entries pour les
--              baux et paiements existants
-- ============================================================================

-- ============================================================================
-- 1. Initialiser deposit_operations pour les baux avec dépôt de garantie
-- ============================================================================

INSERT INTO public.deposit_operations (
  lease_id,
  property_id,
  tenant_id,
  owner_id,
  operation_type,
  montant,
  date_operation,
  statut,
  notes
)
SELECT
  l.id as lease_id,
  COALESCE(l.property_id, u.property_id) as property_id,
  l.tenant_id,
  p.owner_id,
  'reception' as operation_type,
  l.depot_de_garantie as montant,
  l.date_debut as date_operation,
  'completed' as statut,
  'Migration automatique - Dépôt de garantie initial' as notes
FROM public.leases l
LEFT JOIN public.units u ON l.unit_id = u.id
LEFT JOIN public.properties p ON COALESCE(l.property_id, u.property_id) = p.id
WHERE l.depot_de_garantie > 0
  AND l.tenant_id IS NOT NULL
  AND l.statut IN ('active', 'terminated')
  AND NOT EXISTS (
    SELECT 1 FROM public.deposit_operations dep
    WHERE dep.lease_id = l.id AND dep.operation_type = 'reception'
  )
ON CONFLICT DO NOTHING;

-- ============================================================================
-- 2. Créer les écritures comptables pour les paiements existants
-- ============================================================================

-- Fonction temporaire pour migrer les paiements
CREATE OR REPLACE FUNCTION public.migrate_historical_payments()
RETURNS INTEGER AS $$
DECLARE
  v_count INTEGER := 0;
  v_payment RECORD;
  v_invoice RECORD;
  v_lease RECORD;
  v_property_id UUID;
  v_owner_id UUID;
  v_code_postal TEXT;
  v_taux_tva DECIMAL;
  v_honoraires_ht DECIMAL;
  v_tva_montant DECIMAL;
  v_net_proprietaire DECIMAL;
BEGIN
  -- Parcourir tous les paiements succeeded sans écritures comptables
  FOR v_payment IN
    SELECT pay.*
    FROM public.payments pay
    WHERE pay.statut = 'succeeded'
      AND NOT EXISTS (
        SELECT 1 FROM public.accounting_entries ae
        WHERE ae.payment_id = pay.id
      )
  LOOP
    BEGIN
      -- Récupérer la facture
      SELECT * INTO v_invoice FROM public.invoices WHERE id = v_payment.invoice_id;
      IF NOT FOUND THEN
        CONTINUE;
      END IF;

      -- Récupérer le bail et propriété
      SELECT
        l.*,
        COALESCE(l.property_id, u.property_id) as prop_id,
        COALESCE(p.code_postal, '75000') as code_postal,
        p.owner_id
      INTO v_lease
      FROM public.leases l
      LEFT JOIN public.units u ON l.unit_id = u.id
      LEFT JOIN public.properties p ON COALESCE(l.property_id, u.property_id) = p.id
      WHERE l.id = v_invoice.lease_id;

      IF NOT FOUND THEN
        CONTINUE;
      END IF;

      v_property_id := v_lease.prop_id;
      v_owner_id := v_invoice.owner_id;
      v_code_postal := v_lease.code_postal;

      -- Calculer TVA selon code postal
      v_taux_tva := CASE
        WHEN v_code_postal LIKE '97%' THEN
          CASE
            WHEN v_code_postal LIKE '973%' OR v_code_postal LIKE '976%' THEN 0.00
            ELSE 0.085
          END
        ELSE 0.20
      END;

      -- Calculer honoraires
      v_honoraires_ht := ROUND((v_invoice.montant_loyer * 0.07)::NUMERIC, 2);
      v_tva_montant := ROUND((v_honoraires_ht * v_taux_tva)::NUMERIC, 2);
      v_net_proprietaire := v_invoice.montant_loyer - v_honoraires_ht - v_tva_montant;

      -- Créer les écritures comptables
      -- 1. Encaissement banque mandant
      PERFORM public.record_accounting_entry(
        'BM', '545000', 'Banque compte mandant',
        'MIG-' || v_payment.id::TEXT,
        'Migration - Encaissement ' || v_invoice.periode,
        v_payment.montant, 0,
        v_owner_id, v_property_id, v_invoice.id, v_payment.id
      );

      -- 2. Crédit compte locataire
      PERFORM public.record_accounting_entry(
        'BM', '467200', 'Locataires - Comptes mandants',
        'MIG-' || v_payment.id::TEXT,
        'Migration - Paiement ' || v_invoice.periode,
        0, v_payment.montant,
        v_owner_id, v_property_id, v_invoice.id, v_payment.id
      );

      -- 3. Honoraires HT
      PERFORM public.record_accounting_entry(
        'VE', '706100', 'Honoraires de gestion locative',
        'MIG-HON-' || v_invoice.periode,
        'Migration - Honoraires ' || v_invoice.periode,
        0, v_honoraires_ht,
        v_owner_id, v_property_id, v_invoice.id, v_payment.id
      );

      -- 4. TVA si applicable
      IF v_tva_montant > 0 THEN
        PERFORM public.record_accounting_entry(
          'VE', '445710', 'TVA collectée',
          'MIG-HON-' || v_invoice.periode,
          'Migration - TVA honoraires ' || v_invoice.periode,
          0, v_tva_montant,
          v_owner_id, v_property_id, v_invoice.id, v_payment.id
        );
      END IF;

      -- 5. Net propriétaire
      PERFORM public.record_accounting_entry(
        'BM', '467100', 'Propriétaires - Comptes mandants',
        'MIG-CRG-' || v_invoice.periode,
        'Migration - Net propriétaire ' || v_invoice.periode,
        0, v_net_proprietaire,
        v_owner_id, v_property_id, v_invoice.id, v_payment.id
      );

      -- Mettre à jour les soldes mandants
      PERFORM public.update_mandant_balance(
        v_owner_id, v_property_id, 'proprietaire',
        0, v_net_proprietaire
      );

      IF v_invoice.tenant_id IS NOT NULL THEN
        PERFORM public.update_mandant_balance(
          v_invoice.tenant_id, v_property_id, 'locataire',
          0, v_payment.montant
        );
      END IF;

      v_count := v_count + 1;

    EXCEPTION WHEN OTHERS THEN
      -- Log et continuer en cas d'erreur
      RAISE NOTICE 'Erreur migration paiement %: %', v_payment.id, SQLERRM;
      CONTINUE;
    END;
  END LOOP;

  RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- Exécuter la migration des paiements
DO $$
DECLARE
  v_migrated INTEGER;
BEGIN
  SELECT public.migrate_historical_payments() INTO v_migrated;
  RAISE NOTICE 'Paiements migrés: %', v_migrated;
END $$;

-- Supprimer la fonction temporaire
DROP FUNCTION IF EXISTS public.migrate_historical_payments();

-- ============================================================================
-- 3. Créer les écritures pour les dépôts de garantie
-- ============================================================================

-- Fonction temporaire pour migrer les dépôts
CREATE OR REPLACE FUNCTION public.migrate_historical_deposits()
RETURNS INTEGER AS $$
DECLARE
  v_count INTEGER := 0;
  v_deposit RECORD;
BEGIN
  FOR v_deposit IN
    SELECT dep.*
    FROM public.deposit_operations dep
    WHERE dep.operation_type = 'reception'
      AND dep.statut = 'completed'
      AND NOT EXISTS (
        SELECT 1 FROM public.accounting_entries ae
        WHERE ae.piece_ref LIKE 'DEP-' || dep.id::TEXT || '%'
      )
  LOOP
    BEGIN
      -- 1. Encaissement banque mandant
      PERFORM public.record_accounting_entry(
        'BM', '545000', 'Banque compte mandant',
        'DEP-' || v_deposit.id::TEXT,
        'Dépôt de garantie - Encaissement',
        v_deposit.montant, 0,
        v_deposit.owner_id, v_deposit.property_id, NULL, NULL
      );

      -- 2. Crédit compte dépôts de garantie
      PERFORM public.record_accounting_entry(
        'BM', '467300', 'Dépôts de garantie reçus',
        'DEP-' || v_deposit.id::TEXT,
        'Dépôt de garantie - Réception',
        0, v_deposit.montant,
        v_deposit.owner_id, v_deposit.property_id, NULL, NULL
      );

      v_count := v_count + 1;

    EXCEPTION WHEN OTHERS THEN
      RAISE NOTICE 'Erreur migration dépôt %: %', v_deposit.id, SQLERRM;
      CONTINUE;
    END;
  END LOOP;

  RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- Exécuter la migration des dépôts
DO $$
DECLARE
  v_migrated INTEGER;
BEGIN
  SELECT public.migrate_historical_deposits() INTO v_migrated;
  RAISE NOTICE 'Dépôts migrés: %', v_migrated;
END $$;

-- Supprimer la fonction temporaire
DROP FUNCTION IF EXISTS public.migrate_historical_deposits();

-- ============================================================================
-- 4. Trigger pour nouveaux dépôts de garantie
-- ============================================================================

CREATE OR REPLACE FUNCTION public.auto_record_deposit_entries()
RETURNS TRIGGER AS $$
BEGIN
  -- Ne traiter que les opérations complétées
  IF NEW.statut != 'completed' THEN
    RETURN NEW;
  END IF;

  IF NEW.operation_type = 'reception' THEN
    -- Encaissement
    PERFORM public.record_accounting_entry(
      'BM', '545000', 'Banque compte mandant',
      'DEP-' || NEW.id::TEXT,
      'Dépôt de garantie - Encaissement',
      NEW.montant, 0,
      NEW.owner_id, NEW.property_id, NULL, NULL
    );
    PERFORM public.record_accounting_entry(
      'BM', '467300', 'Dépôts de garantie reçus',
      'DEP-' || NEW.id::TEXT,
      'Dépôt de garantie - Réception',
      0, NEW.montant,
      NEW.owner_id, NEW.property_id, NULL, NULL
    );

  ELSIF NEW.operation_type = 'restitution' THEN
    -- Restitution
    PERFORM public.record_accounting_entry(
      'BM', '467300', 'Dépôts de garantie reçus',
      'DEP-REST-' || NEW.id::TEXT,
      'Dépôt de garantie - Restitution',
      NEW.montant, 0,
      NEW.owner_id, NEW.property_id, NULL, NULL
    );
    PERFORM public.record_accounting_entry(
      'BM', '545000', 'Banque compte mandant',
      'DEP-REST-' || NEW.id::TEXT,
      'Dépôt de garantie - Virement restitution',
      0, NEW.montant,
      NEW.owner_id, NEW.property_id, NULL, NULL
    );

  ELSIF NEW.operation_type = 'retenue' THEN
    -- Retenue (transfert vers produits)
    PERFORM public.record_accounting_entry(
      'BM', '467300', 'Dépôts de garantie reçus',
      'DEP-RET-' || NEW.id::TEXT,
      'Dépôt de garantie - Retenue: ' || COALESCE(NEW.motif_retenue, 'Dégradations'),
      NEW.montant, 0,
      NEW.owner_id, NEW.property_id, NULL, NULL
    );
    PERFORM public.record_accounting_entry(
      'OD', '467100', 'Propriétaires - Comptes mandants',
      'DEP-RET-' || NEW.id::TEXT,
      'Indemnisation propriétaire - Retenue dépôt',
      0, NEW.montant,
      NEW.owner_id, NEW.property_id, NULL, NULL
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Supprimer le trigger s'il existe
DROP TRIGGER IF EXISTS trigger_auto_deposit_entries ON public.deposit_operations;

-- Créer le trigger
CREATE TRIGGER trigger_auto_deposit_entries
  AFTER INSERT OR UPDATE OF statut ON public.deposit_operations
  FOR EACH ROW
  WHEN (NEW.statut = 'completed')
  EXECUTE FUNCTION public.auto_record_deposit_entries();

-- ============================================================================
-- 5. Vérification de la migration
-- ============================================================================

DO $$
DECLARE
  v_deposits_count INTEGER;
  v_entries_count INTEGER;
  v_mandant_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_deposits_count FROM public.deposit_operations;
  SELECT COUNT(*) INTO v_entries_count FROM public.accounting_entries;
  SELECT COUNT(*) INTO v_mandant_count FROM public.mandant_accounts;

  RAISE NOTICE '=== Résumé Migration Comptabilité ===';
  RAISE NOTICE 'Opérations sur dépôts: %', v_deposits_count;
  RAISE NOTICE 'Écritures comptables: %', v_entries_count;
  RAISE NOTICE 'Comptes mandants: %', v_mandant_count;
END $$;

-- ============================================================================
-- FIN DE LA MIGRATION
-- ============================================================================


-- ========== 20260110500000_subscription_limits_enforcement.sql ==========
-- =====================================================
-- Migration: Subscription Limits Enforcement
-- SOTA 2026: Backend enforcement des limites de forfait
-- =====================================================

-- =====================================================
-- 1. Fonction de vérification des limites de propriétés
-- =====================================================
CREATE OR REPLACE FUNCTION enforce_property_limit()
RETURNS TRIGGER AS $$
DECLARE
  current_count INTEGER;
  max_allowed INTEGER;
  plan_slug TEXT;
BEGIN
  -- Récupérer le compteur actuel et la limite du plan
  SELECT
    s.properties_count,
    COALESCE(sp.max_properties, -1),
    COALESCE(s.plan_slug, 'gratuit')
  INTO current_count, max_allowed, plan_slug
  FROM subscriptions s
  LEFT JOIN subscription_plans sp ON sp.slug = s.plan_slug
  WHERE s.owner_id = NEW.owner_id;

  -- Si pas de subscription trouvée, utiliser les limites du plan gratuit
  IF max_allowed IS NULL THEN
    max_allowed := 1; -- Plan gratuit = 1 bien
  END IF;

  -- Vérifier la limite (sauf si illimité = -1)
  IF max_allowed != -1 AND current_count >= max_allowed THEN
    RAISE EXCEPTION 'SUBSCRIPTION_LIMIT_REACHED: Limite de % bien(s) atteinte pour le forfait "%". Passez à un forfait supérieur pour ajouter plus de biens.', max_allowed, plan_slug
      USING ERRCODE = 'P0001';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger sur INSERT properties
DROP TRIGGER IF EXISTS check_property_limit_before_insert ON properties;
CREATE TRIGGER check_property_limit_before_insert
  BEFORE INSERT ON properties
  FOR EACH ROW
  EXECUTE FUNCTION enforce_property_limit();

-- =====================================================
-- 2. Fonction de vérification des limites de baux
-- =====================================================
CREATE OR REPLACE FUNCTION enforce_lease_limit()
RETURNS TRIGGER AS $$
DECLARE
  current_count INTEGER;
  max_allowed INTEGER;
  plan_slug TEXT;
  property_owner_id UUID;
BEGIN
  -- Récupérer l'owner_id depuis la propriété
  SELECT owner_id INTO property_owner_id
  FROM properties
  WHERE id = NEW.property_id;

  IF property_owner_id IS NULL THEN
    RAISE EXCEPTION 'Propriété non trouvée';
  END IF;

  -- Récupérer le compteur actuel et la limite du plan
  SELECT
    s.leases_count,
    COALESCE(sp.max_leases, -1),
    COALESCE(s.plan_slug, 'gratuit')
  INTO current_count, max_allowed, plan_slug
  FROM subscriptions s
  LEFT JOIN subscription_plans sp ON sp.slug = s.plan_slug
  WHERE s.owner_id = property_owner_id;

  -- Si pas de subscription trouvée, utiliser les limites du plan gratuit
  IF max_allowed IS NULL THEN
    max_allowed := 1; -- Plan gratuit = 1 bail
  END IF;

  -- Vérifier la limite (sauf si illimité = -1)
  IF max_allowed != -1 AND current_count >= max_allowed THEN
    RAISE EXCEPTION 'SUBSCRIPTION_LIMIT_REACHED: Limite de % bail(s) atteinte pour le forfait "%". Passez à un forfait supérieur pour créer plus de baux.', max_allowed, plan_slug
      USING ERRCODE = 'P0001';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger sur INSERT leases
DROP TRIGGER IF EXISTS check_lease_limit_before_insert ON leases;
CREATE TRIGGER check_lease_limit_before_insert
  BEFORE INSERT ON leases
  FOR EACH ROW
  EXECUTE FUNCTION enforce_lease_limit();

-- =====================================================
-- 3. Fonction de vérification des limites d'utilisateurs
-- =====================================================
CREATE OR REPLACE FUNCTION enforce_user_limit()
RETURNS TRIGGER AS $$
DECLARE
  current_count INTEGER;
  max_allowed INTEGER;
  plan_slug TEXT;
BEGIN
  -- Compter les utilisateurs actuels pour cet owner
  SELECT COUNT(*) INTO current_count
  FROM team_members
  WHERE owner_id = NEW.owner_id AND status = 'active';

  -- Récupérer la limite du plan
  SELECT
    COALESCE(sp.max_users, -1),
    COALESCE(s.plan_slug, 'gratuit')
  INTO max_allowed, plan_slug
  FROM subscriptions s
  LEFT JOIN subscription_plans sp ON sp.slug = s.plan_slug
  WHERE s.owner_id = NEW.owner_id;

  -- Si pas de subscription trouvée, utiliser les limites du plan gratuit
  IF max_allowed IS NULL THEN
    max_allowed := 1; -- Plan gratuit = 1 utilisateur (le propriétaire)
  END IF;

  -- Vérifier la limite (sauf si illimité = -1)
  IF max_allowed != -1 AND current_count >= max_allowed THEN
    RAISE EXCEPTION 'SUBSCRIPTION_LIMIT_REACHED: Limite de % utilisateur(s) atteinte pour le forfait "%". Passez à un forfait supérieur pour inviter plus de collaborateurs.', max_allowed, plan_slug
      USING ERRCODE = 'P0001';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger sur INSERT team_members (si la table existe)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'team_members') THEN
    DROP TRIGGER IF EXISTS check_user_limit_before_insert ON team_members;
    CREATE TRIGGER check_user_limit_before_insert
      BEFORE INSERT ON team_members
      FOR EACH ROW
      EXECUTE FUNCTION enforce_user_limit();
  END IF;
END $$;

-- =====================================================
-- 4. Fonction de vérification du quota de signatures
-- =====================================================
CREATE OR REPLACE FUNCTION check_signature_quota(p_owner_id UUID)
RETURNS JSONB AS $$
DECLARE
  result JSONB;
  monthly_quota INTEGER;
  used_this_month INTEGER;
  plan_slug TEXT;
  current_month TEXT;
BEGIN
  current_month := to_char(NOW(), 'YYYY-MM');

  -- Récupérer le quota du plan
  SELECT
    COALESCE(sp.signatures_monthly_quota, 0),
    COALESCE(s.plan_slug, 'gratuit')
  INTO monthly_quota, plan_slug
  FROM subscriptions s
  LEFT JOIN subscription_plans sp ON sp.slug = s.plan_slug
  WHERE s.owner_id = p_owner_id;

  -- Compter les signatures utilisées ce mois
  SELECT COUNT(*) INTO used_this_month
  FROM signature_requests sr
  JOIN leases l ON sr.lease_id = l.id
  JOIN properties p ON l.property_id = p.id
  WHERE p.owner_id = p_owner_id
    AND to_char(sr.created_at, 'YYYY-MM') = current_month
    AND sr.status != 'cancelled';

  -- Si quota illimité (-1), toujours OK
  IF monthly_quota = -1 THEN
    result := jsonb_build_object(
      'can_sign', true,
      'quota', -1,
      'used', used_this_month,
      'remaining', -1,
      'plan', plan_slug
    );
  ELSE
    result := jsonb_build_object(
      'can_sign', used_this_month < monthly_quota,
      'quota', monthly_quota,
      'used', used_this_month,
      'remaining', GREATEST(0, monthly_quota - used_this_month),
      'plan', plan_slug
    );
  END IF;

  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 5. Fonction de vérification d'accès à une feature
-- =====================================================
CREATE OR REPLACE FUNCTION has_subscription_feature(p_owner_id UUID, p_feature TEXT)
RETURNS BOOLEAN AS $$
DECLARE
  plan_slug TEXT;
  feature_value BOOLEAN;
BEGIN
  -- Récupérer le plan de l'utilisateur
  SELECT COALESCE(s.plan_slug, 'gratuit')
  INTO plan_slug
  FROM subscriptions s
  WHERE s.owner_id = p_owner_id;

  -- Vérifier si la feature est disponible selon le plan
  -- Cette logique est simplifiée, la vraie vérification devrait
  -- consulter la table subscription_plans pour les features
  SELECT
    CASE
      WHEN sp.features ? p_feature THEN (sp.features->>p_feature)::boolean
      ELSE false
    END
  INTO feature_value
  FROM subscription_plans sp
  WHERE sp.slug = COALESCE(plan_slug, 'gratuit');

  RETURN COALESCE(feature_value, false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 6. Index pour optimiser les requêtes de vérification
-- =====================================================
CREATE INDEX IF NOT EXISTS idx_subscriptions_owner_id ON subscriptions(owner_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_plan_slug ON subscriptions(plan_slug);

-- =====================================================
-- Commentaires
-- =====================================================
COMMENT ON FUNCTION enforce_property_limit() IS 'Vérifie et bloque l''ajout de biens au-delà de la limite du forfait';
COMMENT ON FUNCTION enforce_lease_limit() IS 'Vérifie et bloque la création de baux au-delà de la limite du forfait';
COMMENT ON FUNCTION check_signature_quota(UUID) IS 'Retourne le quota de signatures et l''utilisation actuelle';
COMMENT ON FUNCTION has_subscription_feature(UUID, TEXT) IS 'Vérifie si un owner a accès à une feature selon son forfait';


-- ========== 20260111000000_tax_verification_logs.sql ==========
-- Migration: Table de logs pour la vérification d'avis d'imposition
-- Date: 2026-01-11
-- Description: Crée la table pour stocker l'historique des vérifications d'avis d'imposition

-- ============================================================================
-- TABLE: tax_verification_logs
-- ============================================================================

CREATE TABLE IF NOT EXISTS tax_verification_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Utilisateur qui a effectué la vérification
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Références optionnelles au locataire/candidature
  tenant_id UUID REFERENCES tenants(id) ON DELETE SET NULL,
  application_id UUID REFERENCES applications(id) ON DELETE SET NULL,

  -- Données hachées pour confidentialité (SHA-256)
  numero_fiscal_hash TEXT NOT NULL,
  reference_avis_hash TEXT NOT NULL,

  -- Résultat de la vérification
  status TEXT NOT NULL CHECK (status IN (
    'conforme',
    'non_conforme',
    'situation_partielle',
    'introuvable',
    'erreur'
  )),

  -- Mode de vérification utilisé
  verification_mode TEXT NOT NULL DEFAULT 'api_particulier' CHECK (verification_mode IN (
    'web_scraping',
    'api_particulier',
    '2d_doc'
  )),

  -- Informations d'audit
  ip_address INET,
  user_agent TEXT,

  -- Horodatage
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- INDEXES
-- ============================================================================

-- Index pour les requêtes par utilisateur
CREATE INDEX idx_tax_verification_logs_user_id
  ON tax_verification_logs(user_id);

-- Index pour les requêtes par locataire
CREATE INDEX idx_tax_verification_logs_tenant_id
  ON tax_verification_logs(tenant_id)
  WHERE tenant_id IS NOT NULL;

-- Index pour les requêtes par candidature
CREATE INDEX idx_tax_verification_logs_application_id
  ON tax_verification_logs(application_id)
  WHERE application_id IS NOT NULL;

-- Index pour les statistiques par statut
CREATE INDEX idx_tax_verification_logs_status
  ON tax_verification_logs(status);

-- Index pour les requêtes temporelles
CREATE INDEX idx_tax_verification_logs_created_at
  ON tax_verification_logs(created_at DESC);

-- Index composite pour détecter les vérifications répétées
CREATE INDEX idx_tax_verification_logs_dedup
  ON tax_verification_logs(numero_fiscal_hash, reference_avis_hash, created_at DESC);

-- ============================================================================
-- RLS (Row Level Security)
-- ============================================================================

ALTER TABLE tax_verification_logs ENABLE ROW LEVEL SECURITY;

-- Politique : Les utilisateurs ne voient que leurs propres vérifications
CREATE POLICY "Users can view their own verification logs"
  ON tax_verification_logs
  FOR SELECT
  USING (auth.uid() = user_id);

-- Politique : Les utilisateurs peuvent créer leurs propres logs
CREATE POLICY "Users can create their own verification logs"
  ON tax_verification_logs
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Politique : Les admins peuvent tout voir
CREATE POLICY "Admins can view all verification logs"
  ON tax_verification_logs
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE id = auth.uid()
      AND role = 'admin'
    )
  );

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE tax_verification_logs IS
  'Historique des vérifications d''avis d''imposition français via API Particulier';

COMMENT ON COLUMN tax_verification_logs.numero_fiscal_hash IS
  'Hash SHA-256 du numéro fiscal (13 chiffres) pour confidentialité';

COMMENT ON COLUMN tax_verification_logs.reference_avis_hash IS
  'Hash SHA-256 de la référence d''avis (13 caractères) pour confidentialité';

COMMENT ON COLUMN tax_verification_logs.status IS
  'Résultat: conforme, non_conforme, situation_partielle, introuvable, erreur';

COMMENT ON COLUMN tax_verification_logs.verification_mode IS
  'Mode utilisé: api_particulier (recommandé), web_scraping, 2d_doc';


-- ========== 20260111000000_visit_scheduling_sota2026.sql ==========
-- ============================================
-- Migration: Visit Scheduling System SOTA 2026
-- Description: Complete visit scheduling for property visits
-- Tables: owner_availability_patterns, availability_exceptions, visit_slots, visit_bookings, calendar_connections
-- ============================================

-- ============================================
-- 1. OWNER AVAILABILITY PATTERNS
-- Patterns de disponibilité récurrents du propriétaire
-- ============================================

CREATE TABLE IF NOT EXISTS owner_availability_patterns (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  property_id UUID REFERENCES properties(id) ON DELETE CASCADE, -- NULL = toutes propriétés

  -- Pattern de récurrence
  recurrence_type TEXT NOT NULL DEFAULT 'weekly'
    CHECK (recurrence_type IN ('daily', 'weekly', 'monthly', 'custom')),
  day_of_week INTEGER[] DEFAULT '{6}'::INTEGER[], -- 0=Dimanche, 1=Lundi... 6=Samedi

  -- Plage horaire
  start_time TIME NOT NULL DEFAULT '10:00',
  end_time TIME NOT NULL DEFAULT '18:00',
  slot_duration_minutes INTEGER NOT NULL DEFAULT 30 CHECK (slot_duration_minutes >= 15 AND slot_duration_minutes <= 180),
  buffer_minutes INTEGER NOT NULL DEFAULT 15 CHECK (buffer_minutes >= 0 AND buffer_minutes <= 60),

  -- Période de validité
  valid_from DATE NOT NULL DEFAULT CURRENT_DATE,
  valid_until DATE,

  -- Configuration
  max_bookings_per_slot INTEGER NOT NULL DEFAULT 1, -- Pour visites groupées
  auto_confirm BOOLEAN NOT NULL DEFAULT false, -- Confirmation automatique

  -- Métadonnées
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Contraintes
  CONSTRAINT valid_time_range CHECK (start_time < end_time),
  CONSTRAINT valid_date_range CHECK (valid_until IS NULL OR valid_until >= valid_from)
);

-- Indexes
CREATE INDEX idx_availability_patterns_owner ON owner_availability_patterns(owner_id);
CREATE INDEX idx_availability_patterns_property ON owner_availability_patterns(property_id);
CREATE INDEX idx_availability_patterns_active ON owner_availability_patterns(is_active) WHERE is_active = true;
CREATE INDEX idx_availability_patterns_valid ON owner_availability_patterns(valid_from, valid_until);

-- ============================================
-- 2. AVAILABILITY EXCEPTIONS
-- Exceptions aux patterns (vacances, indisponibilités ponctuelles)
-- ============================================

CREATE TABLE IF NOT EXISTS availability_exceptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  pattern_id UUID REFERENCES owner_availability_patterns(id) ON DELETE CASCADE,
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  property_id UUID REFERENCES properties(id) ON DELETE CASCADE,

  -- Exception
  exception_date DATE NOT NULL,
  exception_type TEXT NOT NULL CHECK (exception_type IN ('unavailable', 'modified')),

  -- Si modifié, nouvelles heures (optionnel)
  modified_start_time TIME,
  modified_end_time TIME,

  -- Métadonnées
  reason TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Contraintes
  CONSTRAINT modified_times_check CHECK (
    exception_type = 'unavailable' OR
    (modified_start_time IS NOT NULL AND modified_end_time IS NOT NULL AND modified_start_time < modified_end_time)
  )
);

-- Indexes
CREATE INDEX idx_availability_exceptions_owner ON availability_exceptions(owner_id);
CREATE INDEX idx_availability_exceptions_pattern ON availability_exceptions(pattern_id);
CREATE INDEX idx_availability_exceptions_date ON availability_exceptions(exception_date);
CREATE UNIQUE INDEX idx_availability_exceptions_unique ON availability_exceptions(owner_id, property_id, exception_date)
  WHERE property_id IS NOT NULL;

-- ============================================
-- 3. VISIT SLOTS
-- Créneaux de visite matérialisés (générés à partir des patterns)
-- ============================================

CREATE TABLE IF NOT EXISTS visit_slots (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  pattern_id UUID REFERENCES owner_availability_patterns(id) ON DELETE SET NULL,

  -- Créneau
  slot_date DATE NOT NULL,
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ NOT NULL,

  -- Statut
  status TEXT NOT NULL DEFAULT 'available'
    CHECK (status IN ('available', 'booked', 'blocked', 'cancelled', 'completed')),

  -- Capacité (pour visites groupées)
  max_visitors INTEGER NOT NULL DEFAULT 1,
  current_visitors INTEGER NOT NULL DEFAULT 0,

  -- Métadonnées
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Contraintes
  CONSTRAINT valid_slot_times CHECK (start_time < end_time),
  CONSTRAINT valid_visitor_count CHECK (current_visitors >= 0 AND current_visitors <= max_visitors)
);

-- Indexes pour performance
CREATE INDEX idx_visit_slots_property ON visit_slots(property_id);
CREATE INDEX idx_visit_slots_owner ON visit_slots(owner_id);
CREATE INDEX idx_visit_slots_date ON visit_slots(slot_date);
CREATE INDEX idx_visit_slots_status ON visit_slots(status);
CREATE INDEX idx_visit_slots_available ON visit_slots(property_id, slot_date, status) WHERE status = 'available';
CREATE UNIQUE INDEX idx_visit_slots_unique ON visit_slots(property_id, start_time);

-- ============================================
-- 4. VISIT BOOKINGS
-- Réservations de visites par les locataires
-- ============================================

CREATE TABLE IF NOT EXISTS visit_bookings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  slot_id UUID NOT NULL REFERENCES visit_slots(id) ON DELETE CASCADE,
  property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
  tenant_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,

  -- Statut de la visite
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN (
      'pending',      -- En attente de confirmation
      'confirmed',    -- Confirmée par le propriétaire
      'cancelled',    -- Annulée
      'completed',    -- Visite effectuée
      'no_show'       -- Le locataire ne s'est pas présenté
    )),

  -- Informations complémentaires
  tenant_message TEXT,
  owner_notes TEXT,

  -- Contact du locataire pour la visite
  contact_phone TEXT,
  contact_email TEXT,

  -- Nombre de personnes
  party_size INTEGER NOT NULL DEFAULT 1 CHECK (party_size >= 1 AND party_size <= 5),

  -- Rappels
  reminder_sent_at TIMESTAMPTZ,
  reminder_24h_sent BOOLEAN NOT NULL DEFAULT false,
  reminder_1h_sent BOOLEAN NOT NULL DEFAULT false,

  -- Calendrier externe
  external_calendar_event_id TEXT,
  external_calendar_provider TEXT CHECK (external_calendar_provider IS NULL OR external_calendar_provider IN ('google', 'outlook', 'apple', 'caldav')),

  -- Feedback après visite (optionnel)
  feedback_rating INTEGER CHECK (feedback_rating IS NULL OR (feedback_rating >= 1 AND feedback_rating <= 5)),
  feedback_comment TEXT,

  -- Métadonnées
  booked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  confirmed_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,
  cancellation_reason TEXT,
  cancelled_by UUID REFERENCES profiles(id) ON DELETE SET NULL,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_visit_bookings_slot ON visit_bookings(slot_id);
CREATE INDEX idx_visit_bookings_property ON visit_bookings(property_id);
CREATE INDEX idx_visit_bookings_tenant ON visit_bookings(tenant_id);
CREATE INDEX idx_visit_bookings_status ON visit_bookings(status);
CREATE INDEX idx_visit_bookings_pending ON visit_bookings(status, booked_at) WHERE status = 'pending';
CREATE INDEX idx_visit_bookings_upcoming ON visit_bookings(status) WHERE status IN ('pending', 'confirmed');

-- Un locataire ne peut avoir qu'une réservation active par bien
CREATE UNIQUE INDEX idx_visit_bookings_tenant_property_active
  ON visit_bookings(tenant_id, property_id)
  WHERE status IN ('pending', 'confirmed');

-- ============================================
-- 5. CALENDAR CONNECTIONS
-- Connexions aux calendriers externes
-- ============================================

CREATE TABLE IF NOT EXISTS calendar_connections (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,

  provider TEXT NOT NULL CHECK (provider IN ('google', 'outlook', 'apple', 'caldav')),

  -- OAuth tokens (stockés encryptés via extension pgcrypto)
  access_token_encrypted TEXT NOT NULL,
  refresh_token_encrypted TEXT,
  token_expires_at TIMESTAMPTZ,

  -- Calendar info
  calendar_id TEXT NOT NULL,
  calendar_name TEXT,
  calendar_color TEXT, -- Couleur du calendrier (hex)

  -- Sync settings
  sync_enabled BOOLEAN NOT NULL DEFAULT true,
  sync_direction TEXT NOT NULL DEFAULT 'both'
    CHECK (sync_direction IN ('to_external', 'from_external', 'both')),
  last_sync_at TIMESTAMPTZ,
  last_sync_error TEXT,

  -- Métadonnées
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(user_id, provider, calendar_id)
);

-- Indexes
CREATE INDEX idx_calendar_connections_user ON calendar_connections(user_id);
CREATE INDEX idx_calendar_connections_provider ON calendar_connections(provider);
CREATE INDEX idx_calendar_connections_sync ON calendar_connections(sync_enabled, last_sync_at) WHERE sync_enabled = true;

-- ============================================
-- 6. FUNCTION: generate_visit_slots
-- Génère les créneaux à partir des patterns pour une propriété
-- ============================================

CREATE OR REPLACE FUNCTION generate_visit_slots(
  p_property_id UUID,
  p_start_date DATE,
  p_end_date DATE
) RETURNS INTEGER AS $$
DECLARE
  v_pattern RECORD;
  v_date DATE;
  v_slot_start TIMESTAMPTZ;
  v_slot_end TIMESTAMPTZ;
  v_count INTEGER := 0;
  v_day_of_week INTEGER;
BEGIN
  -- Parcourir tous les patterns actifs pour cette propriété
  FOR v_pattern IN
    SELECT * FROM owner_availability_patterns
    WHERE (property_id = p_property_id OR property_id IS NULL)
      AND is_active = true
      AND valid_from <= p_end_date
      AND (valid_until IS NULL OR valid_until >= p_start_date)
      AND EXISTS (
        SELECT 1 FROM properties p
        WHERE p.id = p_property_id
        AND p.owner_id = owner_availability_patterns.owner_id
      )
  LOOP
    v_date := GREATEST(p_start_date, v_pattern.valid_from);

    -- Boucle sur chaque jour de la période
    WHILE v_date <= LEAST(p_end_date, COALESCE(v_pattern.valid_until, p_end_date)) LOOP
      v_day_of_week := EXTRACT(DOW FROM v_date)::INTEGER;

      -- Vérifier si le jour correspond au pattern
      IF v_pattern.day_of_week IS NULL
         OR v_day_of_week = ANY(v_pattern.day_of_week) THEN

        -- Vérifier les exceptions (indisponibilité)
        IF NOT EXISTS (
          SELECT 1 FROM availability_exceptions
          WHERE (pattern_id = v_pattern.id OR (owner_id = v_pattern.owner_id AND (property_id = p_property_id OR property_id IS NULL)))
            AND exception_date = v_date
            AND exception_type = 'unavailable'
        ) THEN
          -- Générer les créneaux pour cette journée
          v_slot_start := v_date + v_pattern.start_time;

          WHILE (v_slot_start::TIME) < v_pattern.end_time LOOP
            v_slot_end := v_slot_start + (v_pattern.slot_duration_minutes || ' minutes')::INTERVAL;

            -- Ne pas dépasser l'heure de fin
            IF (v_slot_end::TIME) <= v_pattern.end_time THEN
              INSERT INTO visit_slots (
                property_id,
                owner_id,
                pattern_id,
                slot_date,
                start_time,
                end_time,
                max_visitors
              )
              VALUES (
                p_property_id,
                v_pattern.owner_id,
                v_pattern.id,
                v_date,
                v_slot_start,
                v_slot_end,
                v_pattern.max_bookings_per_slot
              )
              ON CONFLICT (property_id, start_time) DO NOTHING;

              v_count := v_count + 1;
            END IF;

            -- Prochain créneau = fin du créneau actuel + buffer
            v_slot_start := v_slot_end + (v_pattern.buffer_minutes || ' minutes')::INTERVAL;
          END LOOP;
        END IF;
      END IF;

      v_date := v_date + INTERVAL '1 day';
    END LOOP;
  END LOOP;

  RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 7. FUNCTION: cleanup_old_visit_slots
-- Nettoie les créneaux passés non réservés
-- ============================================

CREATE OR REPLACE FUNCTION cleanup_old_visit_slots() RETURNS INTEGER AS $$
DECLARE
  v_deleted INTEGER;
BEGIN
  DELETE FROM visit_slots
  WHERE slot_date < CURRENT_DATE - INTERVAL '7 days'
    AND status = 'available';

  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  RETURN v_deleted;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 8. FUNCTION: book_visit_slot
-- Réserve un créneau de visite (avec vérification atomique)
-- ============================================

CREATE OR REPLACE FUNCTION book_visit_slot(
  p_slot_id UUID,
  p_tenant_id UUID,
  p_message TEXT DEFAULT NULL,
  p_contact_phone TEXT DEFAULT NULL,
  p_contact_email TEXT DEFAULT NULL,
  p_party_size INTEGER DEFAULT 1
) RETURNS UUID AS $$
DECLARE
  v_slot visit_slots%ROWTYPE;
  v_booking_id UUID;
  v_pattern_auto_confirm BOOLEAN;
BEGIN
  -- Verrouiller le créneau pour éviter les doubles réservations
  SELECT * INTO v_slot
  FROM visit_slots
  WHERE id = p_slot_id
  FOR UPDATE;

  IF v_slot IS NULL THEN
    RAISE EXCEPTION 'Créneau non trouvé';
  END IF;

  IF v_slot.status != 'available' THEN
    RAISE EXCEPTION 'Ce créneau n''est plus disponible';
  END IF;

  IF v_slot.current_visitors + p_party_size > v_slot.max_visitors THEN
    RAISE EXCEPTION 'Capacité maximale dépassée';
  END IF;

  -- Vérifier si le locataire n'a pas déjà une réservation active sur ce bien
  IF EXISTS (
    SELECT 1 FROM visit_bookings
    WHERE tenant_id = p_tenant_id
      AND property_id = v_slot.property_id
      AND status IN ('pending', 'confirmed')
  ) THEN
    RAISE EXCEPTION 'Vous avez déjà une réservation en cours pour ce bien';
  END IF;

  -- Récupérer le paramètre auto_confirm du pattern
  SELECT auto_confirm INTO v_pattern_auto_confirm
  FROM owner_availability_patterns
  WHERE id = v_slot.pattern_id;

  -- Créer la réservation
  INSERT INTO visit_bookings (
    slot_id,
    property_id,
    tenant_id,
    status,
    tenant_message,
    contact_phone,
    contact_email,
    party_size,
    confirmed_at
  ) VALUES (
    p_slot_id,
    v_slot.property_id,
    p_tenant_id,
    CASE WHEN COALESCE(v_pattern_auto_confirm, false) THEN 'confirmed' ELSE 'pending' END,
    p_message,
    p_contact_phone,
    p_contact_email,
    p_party_size,
    CASE WHEN COALESCE(v_pattern_auto_confirm, false) THEN NOW() ELSE NULL END
  )
  RETURNING id INTO v_booking_id;

  -- Mettre à jour le créneau
  UPDATE visit_slots
  SET
    current_visitors = current_visitors + p_party_size,
    status = CASE
      WHEN current_visitors + p_party_size >= max_visitors THEN 'booked'
      ELSE status
    END,
    updated_at = NOW()
  WHERE id = p_slot_id;

  RETURN v_booking_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 9. FUNCTION: cancel_visit_booking
-- Annule une réservation et libère le créneau
-- ============================================

CREATE OR REPLACE FUNCTION cancel_visit_booking(
  p_booking_id UUID,
  p_cancelled_by UUID,
  p_reason TEXT DEFAULT NULL
) RETURNS BOOLEAN AS $$
DECLARE
  v_booking visit_bookings%ROWTYPE;
BEGIN
  SELECT * INTO v_booking
  FROM visit_bookings
  WHERE id = p_booking_id
  FOR UPDATE;

  IF v_booking IS NULL THEN
    RAISE EXCEPTION 'Réservation non trouvée';
  END IF;

  IF v_booking.status NOT IN ('pending', 'confirmed') THEN
    RAISE EXCEPTION 'Cette réservation ne peut plus être annulée';
  END IF;

  -- Mettre à jour la réservation
  UPDATE visit_bookings
  SET
    status = 'cancelled',
    cancelled_at = NOW(),
    cancelled_by = p_cancelled_by,
    cancellation_reason = p_reason,
    updated_at = NOW()
  WHERE id = p_booking_id;

  -- Libérer le créneau
  UPDATE visit_slots
  SET
    current_visitors = GREATEST(0, current_visitors - v_booking.party_size),
    status = 'available',
    updated_at = NOW()
  WHERE id = v_booking.slot_id
    AND status = 'booked';

  RETURN true;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 10. TRIGGERS
-- ============================================

-- Trigger updated_at pour toutes les tables
CREATE TRIGGER update_owner_availability_patterns_updated_at
  BEFORE UPDATE ON owner_availability_patterns
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_visit_slots_updated_at
  BEFORE UPDATE ON visit_slots
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_visit_bookings_updated_at
  BEFORE UPDATE ON visit_bookings
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_calendar_connections_updated_at
  BEFORE UPDATE ON calendar_connections
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- 11. ROW LEVEL SECURITY (RLS)
-- ============================================

ALTER TABLE owner_availability_patterns ENABLE ROW LEVEL SECURITY;
ALTER TABLE availability_exceptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE visit_slots ENABLE ROW LEVEL SECURITY;
ALTER TABLE visit_bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE calendar_connections ENABLE ROW LEVEL SECURITY;

-- Policies pour owner_availability_patterns
CREATE POLICY "Owners can manage their availability patterns"
  ON owner_availability_patterns
  FOR ALL
  USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Admins can view all availability patterns"
  ON owner_availability_patterns
  FOR SELECT
  USING (
    EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- Policies pour availability_exceptions
CREATE POLICY "Owners can manage their exceptions"
  ON availability_exceptions
  FOR ALL
  USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Policies pour visit_slots
CREATE POLICY "Owners can manage their visit slots"
  ON visit_slots
  FOR ALL
  USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Tenants can view available slots"
  ON visit_slots
  FOR SELECT
  USING (
    status = 'available' AND slot_date >= CURRENT_DATE
  );

-- Policies pour visit_bookings
CREATE POLICY "Owners can view and manage bookings for their properties"
  ON visit_bookings
  FOR ALL
  USING (
    property_id IN (
      SELECT id FROM properties
      WHERE owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

CREATE POLICY "Tenants can view and manage their own bookings"
  ON visit_bookings
  FOR ALL
  USING (
    tenant_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Admins can view all bookings"
  ON visit_bookings
  FOR SELECT
  USING (
    EXISTS (SELECT 1 FROM profiles WHERE user_id = auth.uid() AND role = 'admin')
  );

-- Policies pour calendar_connections
CREATE POLICY "Users can manage their calendar connections"
  ON calendar_connections
  FOR ALL
  USING (
    user_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- ============================================
-- 12. COMMENTS (Documentation)
-- ============================================

COMMENT ON TABLE owner_availability_patterns IS 'Patterns de disponibilité récurrents des propriétaires pour les visites';
COMMENT ON TABLE availability_exceptions IS 'Exceptions aux patterns (vacances, indisponibilités ponctuelles)';
COMMENT ON TABLE visit_slots IS 'Créneaux de visite matérialisés générés à partir des patterns';
COMMENT ON TABLE visit_bookings IS 'Réservations de visites par les locataires potentiels';
COMMENT ON TABLE calendar_connections IS 'Connexions OAuth aux calendriers externes (Google, Outlook, etc.)';

COMMENT ON FUNCTION generate_visit_slots(UUID, DATE, DATE) IS 'Génère les créneaux de visite pour une propriété sur une période donnée';
COMMENT ON FUNCTION book_visit_slot(UUID, UUID, TEXT, TEXT, TEXT, INTEGER) IS 'Réserve un créneau de visite de manière atomique';
COMMENT ON FUNCTION cancel_visit_booking(UUID, UUID, TEXT) IS 'Annule une réservation et libère le créneau';


-- ========== 20260114000000_first_login_and_onboarding_tracking.sql ==========
-- Migration : Ajout du suivi de première connexion et complétion d'onboarding
-- Date: 2026-01-14

-- ============================================
-- 1. AJOUT DES COLONNES DE SUIVI À PROFILES
-- ============================================

-- Ajouter les colonnes de suivi de première connexion
ALTER TABLE profiles
ADD COLUMN IF NOT EXISTS first_login_at TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS onboarding_completed_at TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS login_count INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS last_login_at TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS onboarding_skipped_at TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS welcome_seen_at TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS tour_completed_at TIMESTAMPTZ;

-- Index pour les requêtes fréquentes
CREATE INDEX IF NOT EXISTS idx_profiles_first_login_at ON profiles(first_login_at);
CREATE INDEX IF NOT EXISTS idx_profiles_onboarding_completed_at ON profiles(onboarding_completed_at);

-- ============================================
-- 2. TABLE D'ANALYTICS D'ONBOARDING
-- ============================================

CREATE TABLE IF NOT EXISTS onboarding_analytics (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  profile_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('owner', 'tenant', 'provider', 'guarantor')),

  -- Métriques de temps
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  total_duration_seconds INTEGER,

  -- Métriques par étape
  steps_data JSONB NOT NULL DEFAULT '[]'::jsonb,
  -- Format: [{ step: "profile", started_at, completed_at, duration_seconds, skipped: false, attempts: 1 }]

  -- Métriques de comportement
  total_steps INTEGER NOT NULL DEFAULT 0,
  completed_steps INTEGER NOT NULL DEFAULT 0,
  skipped_steps INTEGER NOT NULL DEFAULT 0,
  dropped_at_step TEXT,

  -- Source et contexte
  referrer TEXT,
  utm_source TEXT,
  utm_medium TEXT,
  utm_campaign TEXT,
  device_type TEXT,
  browser TEXT,

  -- Métadonnées
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_onboarding_analytics_user_id ON onboarding_analytics(user_id);
CREATE INDEX IF NOT EXISTS idx_onboarding_analytics_profile_id ON onboarding_analytics(profile_id);
CREATE INDEX IF NOT EXISTS idx_onboarding_analytics_role ON onboarding_analytics(role);
CREATE INDEX IF NOT EXISTS idx_onboarding_analytics_completed_at ON onboarding_analytics(completed_at);
CREATE INDEX IF NOT EXISTS idx_onboarding_analytics_dropped_at_step ON onboarding_analytics(dropped_at_step) WHERE dropped_at_step IS NOT NULL;

-- Trigger updated_at
CREATE TRIGGER update_onboarding_analytics_updated_at
  BEFORE UPDATE ON onboarding_analytics
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- RLS
ALTER TABLE onboarding_analytics ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own analytics"
  ON onboarding_analytics FOR SELECT
  USING (user_id = auth.uid());

CREATE POLICY "Users can insert own analytics"
  ON onboarding_analytics FOR INSERT
  WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own analytics"
  ON onboarding_analytics FOR UPDATE
  USING (user_id = auth.uid());

-- ============================================
-- 3. TABLE DE RAPPELS D'ONBOARDING
-- ============================================

CREATE TABLE IF NOT EXISTS onboarding_reminders (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  profile_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('owner', 'tenant', 'provider', 'guarantor')),

  -- Type de rappel
  reminder_type TEXT NOT NULL CHECK (reminder_type IN ('24h', '72h', '7d', '14d', '30d')),

  -- Statut
  scheduled_at TIMESTAMPTZ NOT NULL,
  sent_at TIMESTAMPTZ,
  opened_at TIMESTAMPTZ,
  clicked_at TIMESTAMPTZ,

  -- Canal
  channel TEXT NOT NULL DEFAULT 'email' CHECK (channel IN ('email', 'push', 'sms')),

  -- Contenu
  email_sent_to TEXT,
  subject TEXT,

  -- État
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'opened', 'clicked', 'cancelled', 'failed')),
  error_message TEXT,

  -- Métadonnées
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Éviter les doublons
  UNIQUE(user_id, reminder_type)
);

CREATE INDEX IF NOT EXISTS idx_onboarding_reminders_user_id ON onboarding_reminders(user_id);
CREATE INDEX IF NOT EXISTS idx_onboarding_reminders_scheduled_at ON onboarding_reminders(scheduled_at);
CREATE INDEX IF NOT EXISTS idx_onboarding_reminders_status ON onboarding_reminders(status);
CREATE INDEX IF NOT EXISTS idx_onboarding_reminders_pending ON onboarding_reminders(scheduled_at)
  WHERE status = 'pending';

-- Trigger updated_at
CREATE TRIGGER update_onboarding_reminders_updated_at
  BEFORE UPDATE ON onboarding_reminders
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- RLS
ALTER TABLE onboarding_reminders ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own reminders"
  ON onboarding_reminders FOR SELECT
  USING (user_id = auth.uid());

-- ============================================
-- 4. TABLE FEATURES DÉCOUVERTES
-- ============================================

CREATE TABLE IF NOT EXISTS user_feature_discoveries (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  profile_id UUID REFERENCES profiles(id) ON DELETE CASCADE,

  -- Feature découverte
  feature_key TEXT NOT NULL,
  -- Exemples: 'dashboard', 'properties', 'leases', 'payments', 'tickets', 'messages'

  -- Timestamps
  first_seen_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  tooltip_dismissed_at TIMESTAMPTZ,
  tour_step_completed_at TIMESTAMPTZ,

  -- Métadonnées
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,

  -- Éviter les doublons
  UNIQUE(user_id, feature_key)
);

CREATE INDEX IF NOT EXISTS idx_user_feature_discoveries_user_id ON user_feature_discoveries(user_id);
CREATE INDEX IF NOT EXISTS idx_user_feature_discoveries_feature_key ON user_feature_discoveries(feature_key);

-- RLS
ALTER TABLE user_feature_discoveries ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own discoveries"
  ON user_feature_discoveries FOR ALL
  USING (user_id = auth.uid());

-- ============================================
-- 5. FONCTION DE MISE À JOUR DU PREMIER LOGIN
-- ============================================

CREATE OR REPLACE FUNCTION handle_first_login()
RETURNS TRIGGER AS $$
BEGIN
  -- Si c'est la première connexion (first_login_at est NULL)
  IF OLD.first_login_at IS NULL AND NEW.last_login_at IS NOT NULL THEN
    NEW.first_login_at := NEW.last_login_at;
    NEW.login_count := 1;
  ELSIF NEW.last_login_at IS NOT NULL AND NEW.last_login_at != OLD.last_login_at THEN
    NEW.login_count := COALESCE(OLD.login_count, 0) + 1;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger pour gérer le premier login
DROP TRIGGER IF EXISTS trigger_handle_first_login ON profiles;
CREATE TRIGGER trigger_handle_first_login
  BEFORE UPDATE ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION handle_first_login();

-- ============================================
-- 6. FONCTION RPC POUR ENREGISTRER UN LOGIN
-- ============================================

CREATE OR REPLACE FUNCTION record_user_login(p_profile_id UUID)
RETURNS JSONB AS $$
DECLARE
  v_is_first_login BOOLEAN;
  v_profile RECORD;
BEGIN
  -- Récupérer le profil actuel
  SELECT * INTO v_profile FROM profiles WHERE id = p_profile_id;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Profile not found');
  END IF;

  -- Vérifier si c'est le premier login
  v_is_first_login := v_profile.first_login_at IS NULL;

  -- Mettre à jour le profil
  UPDATE profiles
  SET
    last_login_at = NOW(),
    first_login_at = COALESCE(first_login_at, NOW()),
    login_count = COALESCE(login_count, 0) + 1
  WHERE id = p_profile_id;

  RETURN jsonb_build_object(
    'success', true,
    'is_first_login', v_is_first_login,
    'login_count', COALESCE(v_profile.login_count, 0) + 1
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 7. FONCTION RPC POUR STATS D'ONBOARDING (ADMIN)
-- ============================================

CREATE OR REPLACE FUNCTION get_onboarding_stats(p_days INTEGER DEFAULT 30)
RETURNS JSONB AS $$
DECLARE
  v_stats JSONB;
BEGIN
  SELECT jsonb_build_object(
    'total_started', (SELECT COUNT(*) FROM onboarding_analytics WHERE started_at > NOW() - (p_days || ' days')::INTERVAL),
    'total_completed', (SELECT COUNT(*) FROM onboarding_analytics WHERE completed_at IS NOT NULL AND started_at > NOW() - (p_days || ' days')::INTERVAL),
    'completion_rate', (
      SELECT ROUND(
        (COUNT(*) FILTER (WHERE completed_at IS NOT NULL)::NUMERIC / NULLIF(COUNT(*)::NUMERIC, 0)) * 100,
        2
      )
      FROM onboarding_analytics
      WHERE started_at > NOW() - (p_days || ' days')::INTERVAL
    ),
    'avg_completion_time_seconds', (
      SELECT ROUND(AVG(total_duration_seconds))
      FROM onboarding_analytics
      WHERE completed_at IS NOT NULL
      AND started_at > NOW() - (p_days || ' days')::INTERVAL
    ),
    'dropout_by_step', (
      SELECT jsonb_object_agg(dropped_at_step, count)
      FROM (
        SELECT dropped_at_step, COUNT(*) as count
        FROM onboarding_analytics
        WHERE dropped_at_step IS NOT NULL
        AND started_at > NOW() - (p_days || ' days')::INTERVAL
        GROUP BY dropped_at_step
        ORDER BY count DESC
      ) sub
    ),
    'by_role', (
      SELECT jsonb_object_agg(role, stats)
      FROM (
        SELECT
          role,
          jsonb_build_object(
            'started', COUNT(*),
            'completed', COUNT(*) FILTER (WHERE completed_at IS NOT NULL),
            'rate', ROUND(
              (COUNT(*) FILTER (WHERE completed_at IS NOT NULL)::NUMERIC / NULLIF(COUNT(*)::NUMERIC, 0)) * 100,
              2
            )
          ) as stats
        FROM onboarding_analytics
        WHERE started_at > NOW() - (p_days || ' days')::INTERVAL
        GROUP BY role
      ) sub
    )
  ) INTO v_stats;

  RETURN v_stats;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 8. AJOUTER LES COLONNES OWNER/TENANT/PROVIDER PROFILES
-- ============================================

-- Owner profiles
ALTER TABLE owner_profiles
ADD COLUMN IF NOT EXISTS onboarding_completed BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS onboarding_completed_at TIMESTAMPTZ;

-- Tenant profiles
ALTER TABLE tenant_profiles
ADD COLUMN IF NOT EXISTS onboarding_completed BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS onboarding_completed_at TIMESTAMPTZ;

-- Provider profiles
ALTER TABLE provider_profiles
ADD COLUMN IF NOT EXISTS onboarding_completed BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS onboarding_completed_at TIMESTAMPTZ;

-- Note: guarantor_profiles a déjà ces colonnes

-- ============================================
-- 9. TEMPLATES DE NOTIFICATION ONBOARDING
-- ============================================

INSERT INTO notification_templates (code, name, description, category, channels, priority, in_app_title, in_app_message, in_app_icon, email_subject, variables, is_active)
VALUES
  (
    'onboarding_welcome',
    'Bienvenue',
    'Notification de bienvenue lors de la première connexion',
    'onboarding',
    ARRAY['in_app', 'email']::text[],
    'normal',
    'Bienvenue sur Talok !',
    'Nous sommes ravis de vous accueillir. Complétez votre profil pour commencer.',
    'wave',
    'Bienvenue sur Talok !',
    ARRAY['user_name', 'role']::text[],
    true
  ),
  (
    'onboarding_step_completed',
    'Étape complétée',
    'Notification quand une étape d''onboarding est complétée',
    'onboarding',
    ARRAY['in_app']::text[],
    'low',
    'Bravo !',
    'Vous avez complété l''étape {{step_name}}. Continuez !',
    'check_circle',
    NULL,
    ARRAY['step_name', 'progress_percent']::text[],
    true
  ),
  (
    'onboarding_almost_done',
    'Presque terminé',
    'Notification quand l''onboarding est à 80%+',
    'onboarding',
    ARRAY['in_app', 'push']::text[],
    'normal',
    'Vous y êtes presque !',
    'Plus que {{remaining_steps}} étape(s) pour finaliser votre profil.',
    'rocket',
    NULL,
    ARRAY['remaining_steps', 'progress_percent']::text[],
    true
  ),
  (
    'onboarding_completed',
    'Onboarding terminé',
    'Notification quand l''onboarding est 100% complété',
    'onboarding',
    ARRAY['in_app', 'email', 'push']::text[],
    'normal',
    'Profil complété !',
    'Félicitations ! Votre espace est maintenant entièrement configuré.',
    'trophy',
    'Votre profil Talok est complet !',
    ARRAY['user_name', 'role']::text[],
    true
  ),
  (
    'onboarding_reminder_24h',
    'Rappel 24h',
    'Rappel après 24h d''onboarding incomplet',
    'onboarding',
    ARRAY['email']::text[],
    'normal',
    'N''oubliez pas de finaliser votre profil',
    'Vous êtes à {{progress_percent}}% de compléter votre profil.',
    'bell',
    'Finalisez votre inscription sur Talok',
    ARRAY['user_name', 'progress_percent', 'next_step']::text[],
    true
  ),
  (
    'onboarding_reminder_72h',
    'Rappel 72h',
    'Rappel après 72h d''onboarding incomplet',
    'onboarding',
    ARRAY['email', 'push']::text[],
    'normal',
    'Votre profil vous attend',
    'Reprenez là où vous en étiez et finalisez votre inscription.',
    'clock',
    'Votre compte Talok n''est pas encore complet',
    ARRAY['user_name', 'progress_percent', 'next_step']::text[],
    true
  ),
  (
    'onboarding_reminder_7d',
    'Rappel 7 jours',
    'Rappel après 7 jours d''onboarding incomplet',
    'onboarding',
    ARRAY['email']::text[],
    'low',
    'On vous attend !',
    'Votre espace Talok est presque prêt. Finalisez votre inscription.',
    'hourglass',
    'Nous vous attendons sur Talok',
    ARRAY['user_name', 'progress_percent']::text[],
    true
  )
ON CONFLICT (code) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  category = EXCLUDED.category,
  channels = EXCLUDED.channels,
  priority = EXCLUDED.priority,
  in_app_title = EXCLUDED.in_app_title,
  in_app_message = EXCLUDED.in_app_message,
  in_app_icon = EXCLUDED.in_app_icon,
  email_subject = EXCLUDED.email_subject,
  variables = EXCLUDED.variables,
  is_active = EXCLUDED.is_active;

COMMENT ON TABLE onboarding_analytics IS 'Analytics détaillées du parcours d''onboarding des utilisateurs';
COMMENT ON TABLE onboarding_reminders IS 'Rappels programmés pour les utilisateurs n''ayant pas terminé l''onboarding';
COMMENT ON TABLE user_feature_discoveries IS 'Suivi des fonctionnalités découvertes par l''utilisateur (pour tooltips et tours)';
COMMENT ON COLUMN profiles.first_login_at IS 'Date/heure de la première connexion de l''utilisateur';
COMMENT ON COLUMN profiles.onboarding_completed_at IS 'Date/heure de complétion de l''onboarding';
COMMENT ON COLUMN profiles.login_count IS 'Nombre total de connexions';
COMMENT ON COLUMN profiles.welcome_seen_at IS 'Date/heure où le modal de bienvenue a été vu';
COMMENT ON COLUMN profiles.tour_completed_at IS 'Date/heure où le tour guidé a été complété';


-- ========== 20260115000000_create_edl_meter_readings.sql ==========
-- Migration: Créer la table edl_meter_readings
-- Date: 2026-01-15
-- Raison: La table était référencée dans le code mais n'existait pas dans les migrations

-- 1. Créer la table edl_meter_readings si elle n'existe pas
CREATE TABLE IF NOT EXISTS edl_meter_readings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  edl_id UUID NOT NULL REFERENCES edl(id) ON DELETE CASCADE,
  meter_id UUID REFERENCES meters(id) ON DELETE SET NULL,

  -- Valeur du relevé
  reading_value NUMERIC(12, 2),
  reading_unit TEXT DEFAULT 'kWh',

  -- Photo preuve
  photo_path TEXT,
  photo_taken_at TIMESTAMPTZ,

  -- Résultat OCR
  ocr_value NUMERIC(12, 2),
  ocr_confidence INTEGER DEFAULT 0 CHECK (ocr_confidence >= 0 AND ocr_confidence <= 100),
  ocr_provider TEXT,
  ocr_raw_text TEXT,

  -- Validation humaine
  is_validated BOOLEAN DEFAULT false,
  validated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  validated_at TIMESTAMPTZ,
  validation_comment TEXT,

  -- Qui a effectué le relevé
  recorded_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  recorded_by_role TEXT DEFAULT 'owner' CHECK (recorded_by_role IN ('owner', 'tenant')),

  -- Métadonnées
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 2. Index pour performance
CREATE INDEX IF NOT EXISTS idx_edl_meter_readings_edl_id ON edl_meter_readings(edl_id);
CREATE INDEX IF NOT EXISTS idx_edl_meter_readings_meter_id ON edl_meter_readings(meter_id);

-- 3. Trigger pour updated_at
CREATE OR REPLACE FUNCTION update_edl_meter_readings_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_edl_meter_readings_updated_at ON edl_meter_readings;
CREATE TRIGGER trigger_edl_meter_readings_updated_at
  BEFORE UPDATE ON edl_meter_readings
  FOR EACH ROW
  EXECUTE FUNCTION update_edl_meter_readings_updated_at();

-- 4. RLS Policies
ALTER TABLE edl_meter_readings ENABLE ROW LEVEL SECURITY;

-- Policy: Les admins voient tout
DROP POLICY IF EXISTS "edl_meter_readings_admin_all" ON edl_meter_readings;
CREATE POLICY "edl_meter_readings_admin_all" ON edl_meter_readings
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.user_id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

-- Policy: Les propriétaires voient les relevés de leurs biens
DROP POLICY IF EXISTS "edl_meter_readings_owner_select" ON edl_meter_readings;
CREATE POLICY "edl_meter_readings_owner_select" ON edl_meter_readings
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM edl
      JOIN leases ON leases.id = edl.lease_id
      JOIN properties ON properties.id = leases.property_id
      JOIN profiles ON profiles.id = properties.owner_id
      WHERE edl.id = edl_meter_readings.edl_id
      AND profiles.user_id = auth.uid()
    )
  );

-- Policy: Les propriétaires peuvent créer/modifier les relevés
DROP POLICY IF EXISTS "edl_meter_readings_owner_insert" ON edl_meter_readings;
CREATE POLICY "edl_meter_readings_owner_insert" ON edl_meter_readings
  FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM edl
      JOIN leases ON leases.id = edl.lease_id
      JOIN properties ON properties.id = leases.property_id
      JOIN profiles ON profiles.id = properties.owner_id
      WHERE edl.id = edl_meter_readings.edl_id
      AND profiles.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "edl_meter_readings_owner_update" ON edl_meter_readings;
CREATE POLICY "edl_meter_readings_owner_update" ON edl_meter_readings
  FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM edl
      JOIN leases ON leases.id = edl.lease_id
      JOIN properties ON properties.id = leases.property_id
      JOIN profiles ON profiles.id = properties.owner_id
      WHERE edl.id = edl_meter_readings.edl_id
      AND profiles.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "edl_meter_readings_owner_delete" ON edl_meter_readings;
CREATE POLICY "edl_meter_readings_owner_delete" ON edl_meter_readings
  FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM edl
      JOIN leases ON leases.id = edl.lease_id
      JOIN properties ON properties.id = leases.property_id
      JOIN profiles ON profiles.id = properties.owner_id
      WHERE edl.id = edl_meter_readings.edl_id
      AND profiles.user_id = auth.uid()
    )
  );

-- Policy: Les locataires voient leurs propres relevés
DROP POLICY IF EXISTS "edl_meter_readings_tenant_select" ON edl_meter_readings;
CREATE POLICY "edl_meter_readings_tenant_select" ON edl_meter_readings
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM edl
      JOIN leases ON leases.id = edl.lease_id
      JOIN lease_signers ON lease_signers.lease_id = leases.id
      JOIN profiles ON profiles.id = lease_signers.profile_id
      WHERE edl.id = edl_meter_readings.edl_id
      AND profiles.user_id = auth.uid()
    )
  );

-- Policy: Les locataires peuvent créer des relevés sur leurs EDL
DROP POLICY IF EXISTS "edl_meter_readings_tenant_insert" ON edl_meter_readings;
CREATE POLICY "edl_meter_readings_tenant_insert" ON edl_meter_readings
  FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM edl
      JOIN leases ON leases.id = edl.lease_id
      JOIN lease_signers ON lease_signers.lease_id = leases.id
      JOIN profiles ON profiles.id = lease_signers.profile_id
      WHERE edl.id = edl_meter_readings.edl_id
      AND profiles.user_id = auth.uid()
    )
  );

-- 5. Commentaires
COMMENT ON TABLE edl_meter_readings IS 'Relevés de compteurs associés aux états des lieux (EDL)';
COMMENT ON COLUMN edl_meter_readings.meter_id IS 'Référence vers le compteur (peut être null si compteur créé dynamiquement)';
COMMENT ON COLUMN edl_meter_readings.reading_value IS 'Valeur finale du relevé (manuelle ou OCR validée)';
COMMENT ON COLUMN edl_meter_readings.ocr_confidence IS 'Confiance OCR de 0 à 100';
COMMENT ON COLUMN edl_meter_readings.is_validated IS 'True si le relevé a été validé manuellement';


-- ========== 20260115000000_multi_entity_architecture.sql ==========
-- Migration: Architecture Multi-Entités pour gestion multi-SCI/sociétés
-- SOTA 2026 - Support complet des structures juridiques françaises
-- Permet à un propriétaire de gérer plusieurs sociétés (SCI, SARL, etc.)

BEGIN;

-- ============================================
-- TABLE: legal_entities (Entités juridiques)
-- ============================================
-- Représente les structures juridiques: SCI, SARL, SAS, etc.
-- Un owner_profile peut avoir plusieurs legal_entities

CREATE TABLE IF NOT EXISTS legal_entities (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  owner_profile_id UUID NOT NULL REFERENCES owner_profiles(profile_id) ON DELETE CASCADE,

  -- Type d'entité juridique
  entity_type TEXT NOT NULL CHECK (entity_type IN (
    'particulier',            -- Détention directe (personne physique)
    'sci_ir',                 -- SCI à l'Impôt sur le Revenu
    'sci_is',                 -- SCI à l'Impôt sur les Sociétés
    'sci_construction_vente', -- SCCV (promotion)
    'sarl',                   -- SARL classique
    'sarl_famille',           -- SARL de famille (option IR possible)
    'eurl',                   -- EURL
    'sas',                    -- SAS
    'sasu',                   -- SASU
    'sa',                     -- SA
    'snc',                    -- Société en Nom Collectif
    'indivision',             -- Indivision (héritage, achat commun)
    'demembrement_usufruit',  -- Usufruit seul
    'demembrement_nue_propriete', -- Nue-propriété seule
    'holding'                 -- Société holding
  )),

  -- Identité de l'entité
  nom TEXT NOT NULL,                          -- Raison sociale ou "Patrimoine personnel"
  nom_commercial TEXT,                        -- Nom d'usage/enseigne

  -- Immatriculation (pour sociétés)
  siren TEXT CHECK (siren IS NULL OR LENGTH(siren) = 9),
  siret TEXT CHECK (siret IS NULL OR LENGTH(siret) = 14),
  rcs_ville TEXT,                             -- Ville du RCS
  rcs_numero TEXT,                            -- Numéro RCS complet
  numero_tva TEXT,                            -- Numéro TVA intracommunautaire
  code_ape TEXT,                              -- Code APE/NAF

  -- Adresse du siège social
  adresse_siege TEXT,
  complement_adresse TEXT,
  code_postal_siege TEXT,
  ville_siege TEXT,
  pays_siege TEXT DEFAULT 'France',

  -- Forme juridique détaillée
  forme_juridique TEXT,                       -- "SCI", "SARL", etc.
  capital_social DECIMAL(12,2),               -- Capital en euros
  capital_variable BOOLEAN DEFAULT false,     -- Capital variable ?
  capital_min DECIMAL(12,2),                  -- Si variable: minimum
  capital_max DECIMAL(12,2),                  -- Si variable: maximum

  -- Parts sociales
  nombre_parts INTEGER,                       -- Nombre total de parts
  valeur_nominale_part DECIMAL(10,2),         -- Valeur nominale d'une part

  -- Fiscalité
  regime_fiscal TEXT CHECK (regime_fiscal IN ('ir', 'is', 'ir_option_is', 'is_option_ir')) DEFAULT 'ir',
  date_option_fiscale DATE,                   -- Date de l'option IS/IR
  tva_assujetti BOOLEAN DEFAULT false,
  tva_regime TEXT CHECK (tva_regime IS NULL OR tva_regime IN (
    'franchise',              -- Franchise en base (pas de TVA)
    'reel_simplifie',         -- Réel simplifié
    'reel_normal',            -- Réel normal
    'mini_reel'               -- Mini-réel
  )),
  tva_taux_defaut DECIMAL(5,2) DEFAULT 20.00,

  -- Exercice comptable
  date_creation DATE,                         -- Date de création/immatriculation
  date_cloture_exercice TEXT,                 -- Format "MM-DD" (ex: "12-31")
  duree_exercice_mois INTEGER DEFAULT 12,
  premier_exercice_debut DATE,
  premier_exercice_fin DATE,

  -- Coordonnées bancaires
  iban TEXT,
  bic TEXT,
  banque_nom TEXT,
  titulaire_compte TEXT,                      -- Nom sur le compte

  -- Gérance/Direction
  type_gerance TEXT CHECK (type_gerance IS NULL OR type_gerance IN (
    'gerant_unique',
    'co_gerance',
    'gerance_collegiale',
    'president',
    'directeur_general',
    'conseil_administration'
  )),

  -- Statut
  is_active BOOLEAN DEFAULT true,
  date_radiation DATE,                        -- Si société radiée
  motif_radiation TEXT,

  -- Métadonnées
  couleur TEXT,                               -- Couleur pour l'UI (hex)
  icone TEXT,                                 -- Icône pour l'UI
  notes TEXT,
  metadata JSONB DEFAULT '{}'::jsonb,

  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour legal_entities
CREATE INDEX idx_legal_entities_owner ON legal_entities(owner_profile_id);
CREATE INDEX idx_legal_entities_type ON legal_entities(entity_type);
CREATE INDEX idx_legal_entities_siren ON legal_entities(siren) WHERE siren IS NOT NULL;
CREATE INDEX idx_legal_entities_siret ON legal_entities(siret) WHERE siret IS NOT NULL;
CREATE INDEX idx_legal_entities_active ON legal_entities(is_active);
CREATE INDEX idx_legal_entities_regime ON legal_entities(regime_fiscal);

-- ============================================
-- TABLE: entity_associates (Associés des entités)
-- ============================================
-- Gère les associés/actionnaires des sociétés

CREATE TABLE IF NOT EXISTS entity_associates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  legal_entity_id UUID NOT NULL REFERENCES legal_entities(id) ON DELETE CASCADE,

  -- L'associé peut être une personne ou une autre entité (holding)
  profile_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
  parent_entity_id UUID REFERENCES legal_entities(id) ON DELETE SET NULL,

  -- Identité (si associé externe non enregistré)
  civilite TEXT CHECK (civilite IS NULL OR civilite IN ('M', 'Mme', 'Société')),
  nom TEXT,
  prenom TEXT,
  date_naissance DATE,
  lieu_naissance TEXT,
  nationalite TEXT DEFAULT 'Française',
  adresse TEXT,
  code_postal TEXT,
  ville TEXT,

  -- Pour les personnes morales associées
  denomination_sociale TEXT,
  forme_juridique_associe TEXT,
  siren_associe TEXT,
  representant_legal TEXT,

  -- Participation
  nombre_parts INTEGER NOT NULL DEFAULT 0,
  pourcentage_capital DECIMAL(6,3),           -- Précision 0.001%
  pourcentage_droits_vote DECIMAL(6,3),       -- Peut différer du capital
  valeur_parts DECIMAL(12,2),                 -- Valeur totale des parts

  -- Apports
  apport_initial DECIMAL(12,2),
  type_apport TEXT CHECK (type_apport IS NULL OR type_apport IN (
    'numeraire',              -- Apport en argent
    'nature_immobilier',      -- Apport d'immeuble
    'nature_mobilier',        -- Apport de biens mobiliers
    'industrie'               -- Apport en industrie (travail)
  )),
  date_apport DATE,

  -- Type de détention
  type_detention TEXT DEFAULT 'pleine_propriete' CHECK (type_detention IN (
    'pleine_propriete',
    'nue_propriete',
    'usufruit',
    'indivision'
  )),

  -- Rôles
  is_gerant BOOLEAN DEFAULT false,
  is_president BOOLEAN DEFAULT false,
  is_directeur_general BOOLEAN DEFAULT false,
  is_associe_fondateur BOOLEAN DEFAULT false,
  role_autre TEXT,

  -- Dates mandat gérance
  date_debut_mandat DATE,
  date_fin_mandat DATE,
  duree_mandat_annees INTEGER,

  -- Pouvoirs
  pouvoirs TEXT,                              -- Description des pouvoirs
  limitations_pouvoirs TEXT,
  signature_autorisee BOOLEAN DEFAULT false,
  plafond_engagement DECIMAL(12,2),           -- Montant max engagement sans AG

  -- Statut
  is_current BOOLEAN DEFAULT true,            -- Associé actuel ?
  date_entree DATE,
  date_sortie DATE,
  motif_sortie TEXT,

  -- Documents
  piece_identite_document_id UUID,
  justificatif_domicile_document_id UUID,

  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Contraintes
  CONSTRAINT check_associate_identity CHECK (
    profile_id IS NOT NULL OR
    parent_entity_id IS NOT NULL OR
    (nom IS NOT NULL AND prenom IS NOT NULL) OR
    denomination_sociale IS NOT NULL
  )
);

-- Index pour entity_associates
CREATE INDEX idx_entity_associates_entity ON entity_associates(legal_entity_id);
CREATE INDEX idx_entity_associates_profile ON entity_associates(profile_id) WHERE profile_id IS NOT NULL;
CREATE INDEX idx_entity_associates_parent ON entity_associates(parent_entity_id) WHERE parent_entity_id IS NOT NULL;
CREATE INDEX idx_entity_associates_gerant ON entity_associates(legal_entity_id) WHERE is_gerant = true;
CREATE INDEX idx_entity_associates_current ON entity_associates(legal_entity_id) WHERE is_current = true;

-- ============================================
-- TABLE: property_ownership (Détention des biens)
-- ============================================
-- Permet la multi-détention, l'indivision et le démembrement

CREATE TABLE IF NOT EXISTS property_ownership (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,

  -- Détenteur (entité juridique ou personne directe)
  legal_entity_id UUID REFERENCES legal_entities(id) ON DELETE CASCADE,
  profile_id UUID REFERENCES profiles(id) ON DELETE CASCADE,

  -- Quote-part (pour indivision)
  quote_part_numerateur INTEGER NOT NULL DEFAULT 1,
  quote_part_denominateur INTEGER NOT NULL DEFAULT 1,
  pourcentage_detention DECIMAL(6,3) GENERATED ALWAYS AS (
    (quote_part_numerateur::DECIMAL / quote_part_denominateur::DECIMAL) * 100
  ) STORED,

  -- Type de détention
  detention_type TEXT NOT NULL DEFAULT 'pleine_propriete' CHECK (detention_type IN (
    'pleine_propriete',       -- Propriété pleine et entière
    'nue_propriete',          -- Nue-propriété (sans usufruit)
    'usufruit',               -- Usufruit (droit de jouissance)
    'usufruit_temporaire',    -- Usufruit à durée limitée
    'indivision'              -- Part d'indivision
  )),

  -- Pour usufruit temporaire
  usufruit_duree_annees INTEGER,
  usufruit_date_fin DATE,

  -- Acquisition
  date_acquisition DATE,
  mode_acquisition TEXT CHECK (mode_acquisition IS NULL OR mode_acquisition IN (
    'achat',
    'apport',                 -- Apport à société
    'donation',
    'succession',
    'echange',
    'construction',
    'licitation'              -- Sortie d'indivision
  )),
  prix_acquisition DECIMAL(12,2),
  frais_acquisition DECIMAL(12,2),            -- Frais de notaire, etc.

  -- Notaire
  notaire_nom TEXT,
  notaire_ville TEXT,
  reference_acte TEXT,
  date_acte DATE,

  -- Financement
  finance_par_emprunt BOOLEAN DEFAULT false,
  montant_emprunt DECIMAL(12,2),
  banque_emprunt TEXT,

  -- Sortie
  date_cession DATE,
  mode_cession TEXT CHECK (mode_cession IS NULL OR mode_cession IN (
    'vente',
    'donation',
    'apport_societe',
    'succession',
    'echange',
    'expropriation'
  )),
  prix_cession DECIMAL(12,2),

  -- Statut
  is_current BOOLEAN DEFAULT true,

  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Un bien doit avoir soit une entité soit un profil comme détenteur
  CONSTRAINT check_ownership_holder CHECK (
    (legal_entity_id IS NOT NULL AND profile_id IS NULL) OR
    (legal_entity_id IS NULL AND profile_id IS NOT NULL)
  )
);

-- Index pour property_ownership
CREATE INDEX idx_property_ownership_property ON property_ownership(property_id);
CREATE INDEX idx_property_ownership_entity ON property_ownership(legal_entity_id) WHERE legal_entity_id IS NOT NULL;
CREATE INDEX idx_property_ownership_profile ON property_ownership(profile_id) WHERE profile_id IS NOT NULL;
CREATE INDEX idx_property_ownership_current ON property_ownership(property_id) WHERE is_current = true;
CREATE INDEX idx_property_ownership_type ON property_ownership(detention_type);

-- ============================================
-- MODIFICATIONS: Table properties
-- ============================================
-- Ajout du lien vers l'entité juridique

ALTER TABLE properties
  ADD COLUMN IF NOT EXISTS legal_entity_id UUID REFERENCES legal_entities(id) ON DELETE SET NULL,
  ADD COLUMN IF NOT EXISTS detention_mode TEXT DEFAULT 'direct' CHECK (detention_mode IN (
    'direct',                 -- Détention directe (via owner_id)
    'societe',                -- Via une société (legal_entity_id)
    'indivision',             -- Multi-détenteurs
    'demembrement'            -- Démembrement NP/usufruit
  ));

CREATE INDEX IF NOT EXISTS idx_properties_legal_entity ON properties(legal_entity_id) WHERE legal_entity_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_properties_detention_mode ON properties(detention_mode);

-- ============================================
-- MODIFICATIONS: Table leases
-- ============================================
-- Le bailleur peut être une entité juridique

ALTER TABLE leases
  ADD COLUMN IF NOT EXISTS signatory_entity_id UUID REFERENCES legal_entities(id) ON DELETE SET NULL,
  ADD COLUMN IF NOT EXISTS bailleur_nom TEXT,
  ADD COLUMN IF NOT EXISTS bailleur_adresse TEXT,
  ADD COLUMN IF NOT EXISTS bailleur_siret TEXT;

CREATE INDEX IF NOT EXISTS idx_leases_signatory_entity ON leases(signatory_entity_id) WHERE signatory_entity_id IS NOT NULL;

-- ============================================
-- MODIFICATIONS: Table invoices
-- ============================================
-- La facture est émise par l'entité juridique

ALTER TABLE invoices
  ADD COLUMN IF NOT EXISTS issuer_entity_id UUID REFERENCES legal_entities(id) ON DELETE SET NULL,
  ADD COLUMN IF NOT EXISTS issuer_nom TEXT,
  ADD COLUMN IF NOT EXISTS issuer_adresse TEXT,
  ADD COLUMN IF NOT EXISTS issuer_siret TEXT,
  ADD COLUMN IF NOT EXISTS issuer_tva TEXT;

CREATE INDEX IF NOT EXISTS idx_invoices_issuer_entity ON invoices(issuer_entity_id) WHERE issuer_entity_id IS NOT NULL;

-- ============================================
-- FONCTION: Créer une entité "particulier" par défaut
-- ============================================
-- Crée automatiquement une entité "particulier" pour les propriétaires existants

CREATE OR REPLACE FUNCTION create_default_particulier_entity()
RETURNS TRIGGER AS $$
BEGIN
  -- Créer une entité "particulier" par défaut pour le nouveau propriétaire
  INSERT INTO legal_entities (
    owner_profile_id,
    entity_type,
    nom,
    regime_fiscal,
    is_active
  )
  SELECT
    NEW.profile_id,
    'particulier',
    COALESCE(
      (SELECT CONCAT(prenom, ' ', nom) FROM profiles WHERE id = NEW.profile_id),
      'Patrimoine personnel'
    ),
    'ir',
    true
  WHERE NEW.type = 'particulier';

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger pour créer l'entité par défaut
DROP TRIGGER IF EXISTS trigger_create_default_entity ON owner_profiles;
CREATE TRIGGER trigger_create_default_entity
  AFTER INSERT ON owner_profiles
  FOR EACH ROW
  EXECUTE FUNCTION create_default_particulier_entity();

-- ============================================
-- FONCTION: Calculer le pourcentage de détention
-- ============================================

CREATE OR REPLACE FUNCTION calculate_ownership_percentage(
  p_property_id UUID
) RETURNS TABLE (
  holder_type TEXT,
  holder_id UUID,
  holder_name TEXT,
  detention_type TEXT,
  percentage DECIMAL(6,3)
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    CASE
      WHEN po.legal_entity_id IS NOT NULL THEN 'entity'
      ELSE 'profile'
    END AS holder_type,
    COALESCE(po.legal_entity_id, po.profile_id) AS holder_id,
    COALESCE(le.nom, CONCAT(p.prenom, ' ', p.nom)) AS holder_name,
    po.detention_type,
    po.pourcentage_detention AS percentage
  FROM property_ownership po
  LEFT JOIN legal_entities le ON po.legal_entity_id = le.id
  LEFT JOIN profiles p ON po.profile_id = p.id
  WHERE po.property_id = p_property_id
    AND po.is_current = true
  ORDER BY po.pourcentage_detention DESC;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- FONCTION: Obtenir les stats par entité
-- ============================================

CREATE OR REPLACE FUNCTION get_entity_stats(
  p_owner_profile_id UUID
) RETURNS TABLE (
  entity_id UUID,
  entity_name TEXT,
  entity_type TEXT,
  regime_fiscal TEXT,
  properties_count BIGINT,
  total_value DECIMAL(14,2),
  monthly_rent DECIMAL(12,2),
  active_leases BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    le.id AS entity_id,
    le.nom AS entity_name,
    le.entity_type,
    le.regime_fiscal,
    COUNT(DISTINCT p.id) AS properties_count,
    COALESCE(SUM(
      CASE WHEN po.is_current THEN po.prix_acquisition ELSE 0 END
    ), 0) AS total_value,
    COALESCE(SUM(p.loyer_hc), 0) AS monthly_rent,
    COUNT(DISTINCT CASE WHEN l.statut = 'active' THEN l.id END) AS active_leases
  FROM legal_entities le
  LEFT JOIN property_ownership po ON po.legal_entity_id = le.id AND po.is_current = true
  LEFT JOIN properties p ON po.property_id = p.id
  LEFT JOIN leases l ON l.property_id = p.id
  WHERE le.owner_profile_id = p_owner_profile_id
    AND le.is_active = true
  GROUP BY le.id, le.nom, le.entity_type, le.regime_fiscal
  ORDER BY properties_count DESC, le.nom;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- RLS POLICIES
-- ============================================

-- Activer RLS
ALTER TABLE legal_entities ENABLE ROW LEVEL SECURITY;
ALTER TABLE entity_associates ENABLE ROW LEVEL SECURITY;
ALTER TABLE property_ownership ENABLE ROW LEVEL SECURITY;

-- Policies pour legal_entities
CREATE POLICY "Users can view their own entities"
  ON legal_entities FOR SELECT
  USING (
    owner_profile_id IN (
      SELECT profile_id FROM owner_profiles
      WHERE profile_id IN (
        SELECT id FROM profiles WHERE user_id = auth.uid()
      )
    )
  );

CREATE POLICY "Users can insert their own entities"
  ON legal_entities FOR INSERT
  WITH CHECK (
    owner_profile_id IN (
      SELECT profile_id FROM owner_profiles
      WHERE profile_id IN (
        SELECT id FROM profiles WHERE user_id = auth.uid()
      )
    )
  );

CREATE POLICY "Users can update their own entities"
  ON legal_entities FOR UPDATE
  USING (
    owner_profile_id IN (
      SELECT profile_id FROM owner_profiles
      WHERE profile_id IN (
        SELECT id FROM profiles WHERE user_id = auth.uid()
      )
    )
  );

CREATE POLICY "Users can delete their own entities"
  ON legal_entities FOR DELETE
  USING (
    owner_profile_id IN (
      SELECT profile_id FROM owner_profiles
      WHERE profile_id IN (
        SELECT id FROM profiles WHERE user_id = auth.uid()
      )
    )
  );

-- Policies pour entity_associates
CREATE POLICY "Users can view associates of their entities"
  ON entity_associates FOR SELECT
  USING (
    legal_entity_id IN (
      SELECT id FROM legal_entities WHERE owner_profile_id IN (
        SELECT profile_id FROM owner_profiles
        WHERE profile_id IN (
          SELECT id FROM profiles WHERE user_id = auth.uid()
        )
      )
    )
  );

CREATE POLICY "Users can manage associates of their entities"
  ON entity_associates FOR ALL
  USING (
    legal_entity_id IN (
      SELECT id FROM legal_entities WHERE owner_profile_id IN (
        SELECT profile_id FROM owner_profiles
        WHERE profile_id IN (
          SELECT id FROM profiles WHERE user_id = auth.uid()
        )
      )
    )
  );

-- Policies pour property_ownership
CREATE POLICY "Users can view ownership of their properties"
  ON property_ownership FOR SELECT
  USING (
    property_id IN (
      SELECT id FROM properties WHERE owner_id IN (
        SELECT id FROM profiles WHERE user_id = auth.uid()
      )
    )
    OR
    legal_entity_id IN (
      SELECT id FROM legal_entities WHERE owner_profile_id IN (
        SELECT profile_id FROM owner_profiles
        WHERE profile_id IN (
          SELECT id FROM profiles WHERE user_id = auth.uid()
        )
      )
    )
  );

CREATE POLICY "Users can manage ownership of their properties"
  ON property_ownership FOR ALL
  USING (
    property_id IN (
      SELECT id FROM properties WHERE owner_id IN (
        SELECT id FROM profiles WHERE user_id = auth.uid()
      )
    )
  );

-- Policy admin pour toutes les tables
CREATE POLICY "Admins can do everything on legal_entities"
  ON legal_entities FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

CREATE POLICY "Admins can do everything on entity_associates"
  ON entity_associates FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

CREATE POLICY "Admins can do everything on property_ownership"
  ON property_ownership FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- ============================================
-- TRIGGERS updated_at
-- ============================================

CREATE TRIGGER update_legal_entities_updated_at
  BEFORE UPDATE ON legal_entities
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_entity_associates_updated_at
  BEFORE UPDATE ON entity_associates
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_property_ownership_updated_at
  BEFORE UPDATE ON property_ownership
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- MIGRATION DES DONNÉES EXISTANTES
-- ============================================

-- Créer une entité "particulier" pour chaque propriétaire existant qui n'en a pas
INSERT INTO legal_entities (
  owner_profile_id,
  entity_type,
  nom,
  regime_fiscal,
  is_active,
  siret,
  adresse_siege,
  iban
)
SELECT
  op.profile_id,
  CASE
    WHEN op.type = 'societe' THEN 'sci_ir'
    ELSE 'particulier'
  END,
  COALESCE(
    op.raison_sociale,
    CONCAT(p.prenom, ' ', p.nom),
    'Patrimoine personnel'
  ),
  'ir',
  true,
  op.siret,
  op.adresse_facturation,
  op.iban
FROM owner_profiles op
JOIN profiles p ON op.profile_id = p.id
WHERE NOT EXISTS (
  SELECT 1 FROM legal_entities le
  WHERE le.owner_profile_id = op.profile_id
);

-- Lier les propriétés existantes à l'entité par défaut
UPDATE properties p
SET legal_entity_id = (
  SELECT le.id
  FROM legal_entities le
  WHERE le.owner_profile_id = p.owner_id
  ORDER BY le.created_at ASC
  LIMIT 1
),
detention_mode = 'direct'
WHERE p.legal_entity_id IS NULL
  AND EXISTS (
    SELECT 1 FROM legal_entities le
    WHERE le.owner_profile_id = p.owner_id
  );

-- Créer les enregistrements property_ownership pour les propriétés existantes
INSERT INTO property_ownership (
  property_id,
  legal_entity_id,
  profile_id,
  quote_part_numerateur,
  quote_part_denominateur,
  detention_type,
  date_acquisition,
  mode_acquisition,
  is_current
)
SELECT
  p.id,
  p.legal_entity_id,
  NULL,
  1,
  1,
  'pleine_propriete',
  p.created_at::DATE,
  'achat',
  true
FROM properties p
WHERE p.legal_entity_id IS NOT NULL
  AND NOT EXISTS (
    SELECT 1 FROM property_ownership po
    WHERE po.property_id = p.id
  );

COMMIT;


-- ========== 20260115000000_white_label_system.sql ==========
-- ============================================
-- Migration: Système White-Label complet
-- Date: 2026-01-15
-- Description: Tables pour organisations, branding et domaines personnalisés
-- ============================================

-- ============================================
-- TYPE ENUM pour les niveaux white-label
-- ============================================

CREATE TYPE white_label_level AS ENUM ('none', 'basic', 'full', 'premium');
CREATE TYPE domain_verification_method AS ENUM ('dns_txt', 'dns_cname', 'file');
CREATE TYPE ssl_status AS ENUM ('pending', 'active', 'failed', 'expired');
CREATE TYPE sso_provider AS ENUM ('saml', 'oidc');

-- ============================================
-- TABLE: organizations
-- Organisation/entreprise utilisant le white-label
-- ============================================

CREATE TABLE IF NOT EXISTS organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Informations de base
  name VARCHAR(255) NOT NULL,
  slug VARCHAR(100) UNIQUE NOT NULL,
  description TEXT,

  -- Propriétaire (user_id du propriétaire principal)
  owner_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Lien avec l'abonnement
  subscription_id UUID REFERENCES subscriptions(id) ON DELETE SET NULL,

  -- Niveau white-label (déterminé par le plan)
  white_label_level white_label_level NOT NULL DEFAULT 'none',

  -- État
  is_active BOOLEAN NOT NULL DEFAULT true,

  -- Métadonnées
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX idx_organizations_owner ON organizations(owner_id);
CREATE INDEX idx_organizations_slug ON organizations(slug);
CREATE INDEX idx_organizations_subscription ON organizations(subscription_id);

-- ============================================
-- TABLE: organization_members
-- Membres d'une organisation
-- ============================================

CREATE TABLE IF NOT EXISTS organization_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Rôle dans l'organisation
  role VARCHAR(50) NOT NULL DEFAULT 'member', -- owner, admin, member

  -- État
  is_active BOOLEAN NOT NULL DEFAULT true,
  invited_at TIMESTAMPTZ,
  joined_at TIMESTAMPTZ DEFAULT NOW(),

  -- Métadonnées
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Contrainte unique
  UNIQUE(organization_id, user_id)
);

-- Index
CREATE INDEX idx_org_members_org ON organization_members(organization_id);
CREATE INDEX idx_org_members_user ON organization_members(user_id);

-- ============================================
-- TABLE: organization_branding
-- Configuration du branding pour une organisation
-- ============================================

CREATE TABLE IF NOT EXISTS organization_branding (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID UNIQUE NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

  -- ============================================
  -- NIVEAU BASIC (Enterprise M - 349€)
  -- ============================================

  -- Nom et identité
  company_name VARCHAR(255),
  tagline VARCHAR(500),

  -- Logo principal
  logo_url TEXT,
  logo_dark_url TEXT, -- Version pour dark mode

  -- Couleur principale
  primary_color VARCHAR(7), -- Format #RRGGBB

  -- Email basique
  email_from_name VARCHAR(255),
  email_from_address VARCHAR(255),
  email_logo_url TEXT,

  -- ============================================
  -- NIVEAU FULL (Enterprise L - 499€)
  -- ============================================

  -- Favicon
  favicon_url TEXT,

  -- Couleurs complètes
  secondary_color VARCHAR(7),
  accent_color VARCHAR(7),

  -- Background page connexion
  login_background_url TEXT,
  login_background_color VARCHAR(7),

  -- Email avancé
  email_reply_to VARCHAR(255),
  email_footer_html TEXT,
  email_primary_color VARCHAR(7),
  email_secondary_color VARCHAR(7),

  -- Options
  remove_powered_by BOOLEAN NOT NULL DEFAULT false,

  -- ============================================
  -- NIVEAU PREMIUM (Enterprise XL - 799€)
  -- ============================================

  -- CSS personnalisé
  custom_css TEXT,

  -- SSO
  sso_enabled BOOLEAN NOT NULL DEFAULT false,
  sso_provider sso_provider,
  sso_entity_id VARCHAR(255),
  sso_metadata_url TEXT,
  sso_certificate TEXT,
  sso_config JSONB DEFAULT '{}',

  -- API Branding
  api_branding_enabled BOOLEAN NOT NULL DEFAULT false,

  -- ============================================
  -- Métadonnées
  -- ============================================

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX idx_org_branding_org ON organization_branding(organization_id);

-- ============================================
-- TABLE: custom_domains
-- Domaines personnalisés pour une organisation
-- ============================================

CREATE TABLE IF NOT EXISTS custom_domains (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

  -- Domaine
  domain VARCHAR(255) NOT NULL,
  subdomain VARCHAR(100), -- Si sous-domaine de talok.app

  -- Vérification
  verified BOOLEAN NOT NULL DEFAULT false,
  verification_token VARCHAR(64) NOT NULL DEFAULT encode(gen_random_bytes(32), 'hex'),
  verification_method domain_verification_method NOT NULL DEFAULT 'dns_txt',
  verification_attempts INTEGER NOT NULL DEFAULT 0,
  last_verification_at TIMESTAMPTZ,
  verified_at TIMESTAMPTZ,

  -- SSL/TLS
  ssl_status ssl_status NOT NULL DEFAULT 'pending',
  ssl_certificate_id VARCHAR(255), -- ID chez le provider (Let's Encrypt, etc.)
  ssl_issued_at TIMESTAMPTZ,
  ssl_expires_at TIMESTAMPTZ,

  -- État
  is_primary BOOLEAN NOT NULL DEFAULT false,
  is_active BOOLEAN NOT NULL DEFAULT true,

  -- Métadonnées
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Contraintes
  UNIQUE(domain)
);

-- Index
CREATE INDEX idx_custom_domains_org ON custom_domains(organization_id);
CREATE INDEX idx_custom_domains_domain ON custom_domains(domain);
CREATE INDEX idx_custom_domains_verified ON custom_domains(verified) WHERE verified = true;

-- ============================================
-- TABLE: branding_assets
-- Assets uploadés (logos, images, etc.)
-- ============================================

CREATE TABLE IF NOT EXISTS branding_assets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,

  -- Type d'asset
  asset_type VARCHAR(50) NOT NULL, -- logo, favicon, login_bg, email_logo

  -- Fichier
  file_name VARCHAR(255) NOT NULL,
  file_path TEXT NOT NULL,
  file_size INTEGER NOT NULL,
  mime_type VARCHAR(100) NOT NULL,

  -- Dimensions (pour images)
  width INTEGER,
  height INTEGER,

  -- État
  is_active BOOLEAN NOT NULL DEFAULT true,

  -- Métadonnées
  uploaded_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX idx_branding_assets_org ON branding_assets(organization_id);
CREATE INDEX idx_branding_assets_type ON branding_assets(asset_type);

-- ============================================
-- FONCTIONS
-- ============================================

-- Fonction pour obtenir le branding d'une organisation
CREATE OR REPLACE FUNCTION get_organization_branding(p_organization_id UUID)
RETURNS TABLE (
  organization_id UUID,
  organization_name VARCHAR,
  white_label_level white_label_level,
  branding JSONB,
  primary_domain VARCHAR
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    o.id AS organization_id,
    o.name AS organization_name,
    o.white_label_level,
    CASE
      WHEN ob.id IS NOT NULL THEN
        jsonb_build_object(
          'company_name', COALESCE(ob.company_name, o.name),
          'tagline', ob.tagline,
          'logo_url', ob.logo_url,
          'logo_dark_url', ob.logo_dark_url,
          'favicon_url', ob.favicon_url,
          'primary_color', COALESCE(ob.primary_color, '#2563eb'),
          'secondary_color', ob.secondary_color,
          'accent_color', ob.accent_color,
          'email_from_name', ob.email_from_name,
          'email_from_address', ob.email_from_address,
          'email_logo_url', ob.email_logo_url,
          'email_footer_html', ob.email_footer_html,
          'email_primary_color', ob.email_primary_color,
          'remove_powered_by', ob.remove_powered_by,
          'custom_css', ob.custom_css,
          'sso_enabled', ob.sso_enabled,
          'sso_provider', ob.sso_provider
        )
      ELSE
        jsonb_build_object(
          'company_name', o.name,
          'primary_color', '#2563eb'
        )
    END AS branding,
    cd.domain AS primary_domain
  FROM organizations o
  LEFT JOIN organization_branding ob ON ob.organization_id = o.id
  LEFT JOIN custom_domains cd ON cd.organization_id = o.id AND cd.is_primary = true AND cd.verified = true
  WHERE o.id = p_organization_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Fonction pour obtenir l'organisation par domaine
CREATE OR REPLACE FUNCTION get_organization_by_domain(p_domain VARCHAR)
RETURNS TABLE (
  organization_id UUID,
  organization_slug VARCHAR,
  white_label_level white_label_level
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    o.id AS organization_id,
    o.slug AS organization_slug,
    o.white_label_level
  FROM organizations o
  INNER JOIN custom_domains cd ON cd.organization_id = o.id
  WHERE cd.domain = p_domain
    AND cd.verified = true
    AND cd.is_active = true
    AND o.is_active = true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Fonction pour vérifier si une feature white-label est disponible
CREATE OR REPLACE FUNCTION check_white_label_feature(
  p_organization_id UUID,
  p_feature VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
  v_level white_label_level;
  v_basic_features VARCHAR[] := ARRAY['custom_logo', 'primary_color', 'company_name', 'custom_email_from', 'custom_email_logo'];
  v_full_features VARCHAR[] := ARRAY['custom_favicon', 'secondary_color', 'accent_color', 'custom_email_footer', 'custom_email_colors', 'branded_login_page', 'remove_powered_by', 'custom_domain'];
  v_premium_features VARCHAR[] := ARRAY['custom_css', 'sso_saml', 'sso_oidc', 'multi_organizations', 'branding_api'];
BEGIN
  -- Récupérer le niveau
  SELECT white_label_level INTO v_level
  FROM organizations
  WHERE id = p_organization_id;

  IF v_level IS NULL THEN
    RETURN false;
  END IF;

  -- Vérifier selon le niveau
  CASE v_level
    WHEN 'none' THEN
      RETURN false;
    WHEN 'basic' THEN
      RETURN p_feature = ANY(v_basic_features);
    WHEN 'full' THEN
      RETURN p_feature = ANY(v_basic_features) OR p_feature = ANY(v_full_features);
    WHEN 'premium' THEN
      RETURN true; -- Toutes les features
    ELSE
      RETURN false;
  END CASE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- TRIGGERS
-- ============================================

-- Trigger pour updated_at sur organizations
CREATE TRIGGER update_organizations_updated_at
  BEFORE UPDATE ON organizations
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Trigger pour updated_at sur organization_members
CREATE TRIGGER update_org_members_updated_at
  BEFORE UPDATE ON organization_members
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Trigger pour updated_at sur organization_branding
CREATE TRIGGER update_org_branding_updated_at
  BEFORE UPDATE ON organization_branding
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Trigger pour updated_at sur custom_domains
CREATE TRIGGER update_custom_domains_updated_at
  BEFORE UPDATE ON custom_domains
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Trigger pour créer automatiquement le branding quand une organisation est créée
CREATE OR REPLACE FUNCTION create_default_branding()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO organization_branding (organization_id, company_name)
  VALUES (NEW.id, NEW.name);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER create_org_branding_on_create
  AFTER INSERT ON organizations
  FOR EACH ROW
  EXECUTE FUNCTION create_default_branding();

-- Trigger pour s'assurer qu'il n'y a qu'un seul domaine primaire par organisation
CREATE OR REPLACE FUNCTION ensure_single_primary_domain()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.is_primary = true THEN
    UPDATE custom_domains
    SET is_primary = false
    WHERE organization_id = NEW.organization_id
      AND id != NEW.id
      AND is_primary = true;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER ensure_single_primary_domain_trigger
  BEFORE INSERT OR UPDATE ON custom_domains
  FOR EACH ROW
  WHEN (NEW.is_primary = true)
  EXECUTE FUNCTION ensure_single_primary_domain();

-- ============================================
-- ROW LEVEL SECURITY
-- ============================================

-- Enable RLS
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_branding ENABLE ROW LEVEL SECURITY;
ALTER TABLE custom_domains ENABLE ROW LEVEL SECURITY;
ALTER TABLE branding_assets ENABLE ROW LEVEL SECURITY;

-- Policies pour organizations
CREATE POLICY "Users can view their organizations"
  ON organizations FOR SELECT
  USING (
    owner_id = auth.uid()
    OR id IN (
      SELECT organization_id FROM organization_members
      WHERE user_id = auth.uid() AND is_active = true
    )
  );

CREATE POLICY "Owners can update their organizations"
  ON organizations FOR UPDATE
  USING (owner_id = auth.uid());

CREATE POLICY "Owners can delete their organizations"
  ON organizations FOR DELETE
  USING (owner_id = auth.uid());

CREATE POLICY "Users can create organizations"
  ON organizations FOR INSERT
  WITH CHECK (owner_id = auth.uid());

-- Policies pour organization_members
CREATE POLICY "Members can view their organization members"
  ON organization_members FOR SELECT
  USING (
    organization_id IN (
      SELECT id FROM organizations WHERE owner_id = auth.uid()
    )
    OR organization_id IN (
      SELECT organization_id FROM organization_members
      WHERE user_id = auth.uid() AND is_active = true
    )
  );

CREATE POLICY "Org owners can manage members"
  ON organization_members FOR ALL
  USING (
    organization_id IN (
      SELECT id FROM organizations WHERE owner_id = auth.uid()
    )
  );

-- Policies pour organization_branding
CREATE POLICY "Members can view branding"
  ON organization_branding FOR SELECT
  USING (
    organization_id IN (
      SELECT id FROM organizations WHERE owner_id = auth.uid()
    )
    OR organization_id IN (
      SELECT organization_id FROM organization_members
      WHERE user_id = auth.uid() AND is_active = true
    )
  );

CREATE POLICY "Org owners/admins can update branding"
  ON organization_branding FOR UPDATE
  USING (
    organization_id IN (
      SELECT id FROM organizations WHERE owner_id = auth.uid()
    )
    OR organization_id IN (
      SELECT organization_id FROM organization_members
      WHERE user_id = auth.uid() AND role IN ('owner', 'admin') AND is_active = true
    )
  );

-- Policies pour custom_domains
CREATE POLICY "Members can view domains"
  ON custom_domains FOR SELECT
  USING (
    organization_id IN (
      SELECT id FROM organizations WHERE owner_id = auth.uid()
    )
    OR organization_id IN (
      SELECT organization_id FROM organization_members
      WHERE user_id = auth.uid() AND is_active = true
    )
  );

CREATE POLICY "Org owners/admins can manage domains"
  ON custom_domains FOR ALL
  USING (
    organization_id IN (
      SELECT id FROM organizations WHERE owner_id = auth.uid()
    )
    OR organization_id IN (
      SELECT organization_id FROM organization_members
      WHERE user_id = auth.uid() AND role IN ('owner', 'admin') AND is_active = true
    )
  );

-- Policies pour branding_assets
CREATE POLICY "Members can view assets"
  ON branding_assets FOR SELECT
  USING (
    organization_id IN (
      SELECT id FROM organizations WHERE owner_id = auth.uid()
    )
    OR organization_id IN (
      SELECT organization_id FROM organization_members
      WHERE user_id = auth.uid() AND is_active = true
    )
  );

CREATE POLICY "Org owners/admins can manage assets"
  ON branding_assets FOR ALL
  USING (
    organization_id IN (
      SELECT id FROM organizations WHERE owner_id = auth.uid()
    )
    OR organization_id IN (
      SELECT organization_id FROM organization_members
      WHERE user_id = auth.uid() AND role IN ('owner', 'admin') AND is_active = true
    )
  );

-- ============================================
-- AJOUT COLONNE organization_id à profiles
-- ============================================

ALTER TABLE profiles
ADD COLUMN IF NOT EXISTS organization_id UUID REFERENCES organizations(id) ON DELETE SET NULL;

CREATE INDEX IF NOT EXISTS idx_profiles_organization ON profiles(organization_id);

-- ============================================
-- STORAGE BUCKET pour les assets
-- ============================================

-- Créer le bucket pour les assets de branding (à exécuter manuellement ou via API)
-- INSERT INTO storage.buckets (id, name, public)
-- VALUES ('branding-assets', 'branding-assets', true)
-- ON CONFLICT (id) DO NOTHING;

COMMENT ON TABLE organizations IS 'Organisations utilisant le white-label';
COMMENT ON TABLE organization_branding IS 'Configuration du branding par organisation';
COMMENT ON TABLE custom_domains IS 'Domaines personnalisés pour le white-label';
COMMENT ON TABLE branding_assets IS 'Assets uploadés (logos, images)';


-- ========== 20260115000001_add_performance_indexes.sql ==========
-- Migration: Add performance indexes for frequent queries
-- Date: 2026-01-15
-- Purpose: Improve query performance on commonly accessed columns

-- ============================================
-- 1. Index on leases.tenant_id
-- Purpose: Optimize frequent tenant lookup queries
-- Used for: Dashboard views, tenant-specific lease retrieval
-- ============================================
CREATE INDEX IF NOT EXISTS idx_leases_tenant_id_perf
ON leases(tenant_id);

COMMENT ON INDEX idx_leases_tenant_id_perf IS
'Performance index for frequent tenant lookup queries on leases';

-- ============================================
-- 2. Index on documents.verified_by
-- Purpose: Speed up document verification queries
-- Used for: Admin verification workflows, audit trails
-- ============================================
CREATE INDEX IF NOT EXISTS idx_documents_verified_by
ON documents(verified_by);

COMMENT ON INDEX idx_documents_verified_by IS
'Performance index for document verification lookups and audit queries';

-- ============================================
-- 3. Composite index on payments(invoice_id, statut)
-- Purpose: Optimize payment tracking and status queries
-- Used for: Payment status reports, invoice reconciliation
-- ============================================
CREATE INDEX IF NOT EXISTS idx_payments_invoice_statut
ON payments(invoice_id, statut);

COMMENT ON INDEX idx_payments_invoice_statut IS
'Composite index for efficient payment tracking by invoice and status';

-- ============================================
-- 4. Composite index on invoices(owner_id, periode)
-- Purpose: Speed up financial summary queries per owner
-- Used for: Owner dashboards, monthly/yearly financial reports
-- ============================================
CREATE INDEX IF NOT EXISTS idx_invoices_owner_periode
ON invoices(owner_id, periode);

COMMENT ON INDEX idx_invoices_owner_periode IS
'Composite index for owner financial summaries grouped by period';

-- ============================================
-- 5. Composite index on payment_adjustments(month, roommate_id)
-- Purpose: Optimize tenant payment adjustment reports
-- Used for: Colocation billing, roommate payment history
-- ============================================
CREATE INDEX IF NOT EXISTS idx_payment_adjustments_month_roommate
ON payment_adjustments(month, roommate_id);

COMMENT ON INDEX idx_payment_adjustments_month_roommate IS
'Composite index for tenant payment adjustment reports by month and roommate';


-- ========== 20260115000001_fix_edl_meter_readings_nullable.sql ==========
-- Migration: Rendre photo_path nullable dans edl_meter_readings
-- Date: 2026-01-05
-- Raison: Permettre l'enregistrement de relevés de compteurs sans photo (saisie manuelle)

-- 1. Supprimer la contrainte NOT NULL sur photo_path
ALTER TABLE edl_meter_readings ALTER COLUMN photo_path DROP NOT NULL;

-- 2. Ajouter les colonnes OCR et validation si elles n'existent pas
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl_meter_readings' AND column_name = 'ocr_value') THEN
        ALTER TABLE edl_meter_readings ADD COLUMN ocr_value NUMERIC;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl_meter_readings' AND column_name = 'ocr_confidence') THEN
        ALTER TABLE edl_meter_readings ADD COLUMN ocr_confidence INTEGER DEFAULT 0;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl_meter_readings' AND column_name = 'ocr_provider') THEN
        ALTER TABLE edl_meter_readings ADD COLUMN ocr_provider TEXT;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl_meter_readings' AND column_name = 'ocr_raw_text') THEN
        ALTER TABLE edl_meter_readings ADD COLUMN ocr_raw_text TEXT;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl_meter_readings' AND column_name = 'is_validated') THEN
        ALTER TABLE edl_meter_readings ADD COLUMN is_validated BOOLEAN DEFAULT false;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl_meter_readings' AND column_name = 'validated_by') THEN
        ALTER TABLE edl_meter_readings ADD COLUMN validated_by UUID REFERENCES auth.users(id);
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl_meter_readings' AND column_name = 'validated_at') THEN
        ALTER TABLE edl_meter_readings ADD COLUMN validated_at TIMESTAMPTZ;
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'edl_meter_readings' AND column_name = 'validation_comment') THEN
        ALTER TABLE edl_meter_readings ADD COLUMN validation_comment TEXT;
    END IF;
END $$;

-- 3. Commentaires
COMMENT ON COLUMN edl_meter_readings.photo_path IS 'Chemin vers la photo du compteur (optionnel)';
COMMENT ON COLUMN edl_meter_readings.ocr_value IS 'Valeur détectée par OCR';
COMMENT ON COLUMN edl_meter_readings.ocr_confidence IS 'Niveau de confiance de l''OCR (0-100)';
COMMENT ON COLUMN edl_meter_readings.is_validated IS 'Indique si le relevé a été validé manuellement';



-- ========== 20260119000000_fix_edl_meter_readings_rls.sql ==========
-- Migration: Corriger les RLS policies pour edl_meter_readings
-- Date: 2026-01-19
-- Raison: Les jointures utilisaient owner_profiles.id qui n'existe pas
--         properties.owner_id référence profiles(id) directement

-- Recréer les policies avec la bonne jointure (profiles.id = properties.owner_id)

-- 1. Policy: Les propriétaires voient les relevés de leurs biens
DROP POLICY IF EXISTS "edl_meter_readings_owner_select" ON edl_meter_readings;
CREATE POLICY "edl_meter_readings_owner_select" ON edl_meter_readings
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM edl
      JOIN leases ON leases.id = edl.lease_id
      JOIN properties ON properties.id = leases.property_id
      JOIN profiles ON profiles.id = properties.owner_id
      WHERE edl.id = edl_meter_readings.edl_id
      AND profiles.user_id = auth.uid()
    )
  );

-- 2. Policy: Les propriétaires peuvent créer des relevés
DROP POLICY IF EXISTS "edl_meter_readings_owner_insert" ON edl_meter_readings;
CREATE POLICY "edl_meter_readings_owner_insert" ON edl_meter_readings
  FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM edl
      JOIN leases ON leases.id = edl.lease_id
      JOIN properties ON properties.id = leases.property_id
      JOIN profiles ON profiles.id = properties.owner_id
      WHERE edl.id = edl_meter_readings.edl_id
      AND profiles.user_id = auth.uid()
    )
  );

-- 3. Policy: Les propriétaires peuvent modifier les relevés
DROP POLICY IF EXISTS "edl_meter_readings_owner_update" ON edl_meter_readings;
CREATE POLICY "edl_meter_readings_owner_update" ON edl_meter_readings
  FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM edl
      JOIN leases ON leases.id = edl.lease_id
      JOIN properties ON properties.id = leases.property_id
      JOIN profiles ON profiles.id = properties.owner_id
      WHERE edl.id = edl_meter_readings.edl_id
      AND profiles.user_id = auth.uid()
    )
  );

-- 4. Policy: Les propriétaires peuvent supprimer les relevés
DROP POLICY IF EXISTS "edl_meter_readings_owner_delete" ON edl_meter_readings;
CREATE POLICY "edl_meter_readings_owner_delete" ON edl_meter_readings
  FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM edl
      JOIN leases ON leases.id = edl.lease_id
      JOIN properties ON properties.id = leases.property_id
      JOIN profiles ON profiles.id = properties.owner_id
      WHERE edl.id = edl_meter_readings.edl_id
      AND profiles.user_id = auth.uid()
    )
  );

-- Note: Les policies pour les locataires et admins restent inchangées
-- car elles n'utilisaient pas la jointure owner_profiles incorrecte


-- ========== 20260121000001_unified_signature_system.sql ==========
-- ============================================================================
-- MIGRATION: Unified Signature System (SOTA 2026)
-- ============================================================================
--
-- Cette migration crée un système de signature unifié qui remplace progressivement:
-- - lease_signers (utilisé pour baux)
-- - signatures (eIDAS avancé)
-- - edl_signatures (états des lieux)
-- - signature_requests/signature_request_signers (demandes génériques)
--
-- Architecture:
-- 1. signature_sessions - Contexte et workflow de signature
-- 2. signature_participants - Signataires (flexibles: profile ou invitation)
-- 3. signature_proofs - Preuves cryptographiques eIDAS
-- 4. signature_audit_log - Journal d'audit immutable
--
-- IMPORTANT: Cette migration est NON-DESTRUCTIVE
-- Les anciennes tables restent fonctionnelles pendant la transition
-- ============================================================================

BEGIN;

-- ============================================================================
-- 1. ENUM TYPES
-- ============================================================================

-- Type de document signable
CREATE TYPE signature_document_type AS ENUM (
  'bail',
  'avenant',
  'edl_entree',
  'edl_sortie',
  'quittance',
  'caution',
  'devis',
  'facture',
  'note_service',
  'reglement_interieur',
  'autre'
);

-- Type d'entité liée
CREATE TYPE signature_entity_type AS ENUM (
  'lease',
  'edl',
  'quote',
  'invoice',
  'internal'
);

-- Statut de la session
CREATE TYPE signature_session_status AS ENUM (
  'draft',           -- Brouillon, pas encore envoyé
  'pending',         -- Prêt à être envoyé
  'ongoing',         -- En cours de signature
  'done',            -- Toutes signatures complètes
  'rejected',        -- Au moins un refus
  'expired',         -- Deadline dépassée
  'canceled'         -- Annulée manuellement
);

-- Statut du participant
CREATE TYPE signature_participant_status AS ENUM (
  'pending',         -- En attente de notification
  'notified',        -- Notifié (email envoyé)
  'opened',          -- A ouvert le document
  'signed',          -- A signé
  'refused',         -- A refusé
  'error'            -- Erreur technique
);

-- Rôle du signataire
CREATE TYPE signature_role AS ENUM (
  'proprietaire',
  'locataire_principal',
  'colocataire',
  'garant',
  'representant_legal',
  'temoin',
  'autre'
);

-- Niveau eIDAS
CREATE TYPE signature_level AS ENUM (
  'SES',  -- Simple Electronic Signature
  'AES',  -- Advanced Electronic Signature
  'QES'   -- Qualified Electronic Signature
);

-- Actions d'audit
CREATE TYPE signature_audit_action AS ENUM (
  'session_created',
  'session_sent',
  'session_completed',
  'session_rejected',
  'session_expired',
  'session_canceled',
  'participant_added',
  'participant_notified',
  'participant_opened',
  'participant_signed',
  'participant_refused',
  'proof_generated',
  'proof_verified'
);

-- ============================================================================
-- 2. TABLE: signature_sessions
-- ============================================================================

CREATE TABLE signature_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- CONTEXTE
  document_type signature_document_type NOT NULL,
  entity_type signature_entity_type NOT NULL,
  entity_id UUID NOT NULL,  -- ID du bail, EDL, devis, etc.

  -- DOCUMENTS
  source_document_id UUID,  -- Document à signer (dans documents table)
  signed_document_id UUID,  -- Document signé final
  proof_document_id UUID,   -- PDF de preuve consolidé

  -- METADATA
  name TEXT NOT NULL,
  description TEXT,

  -- WORKFLOW
  status signature_session_status NOT NULL DEFAULT 'draft',
  signature_level signature_level NOT NULL DEFAULT 'SES',
  is_ordered_signatures BOOLEAN DEFAULT false,  -- Signatures dans l'ordre
  otp_required BOOLEAN DEFAULT false,           -- OTP obligatoire

  -- OWNERSHIP
  created_by UUID NOT NULL REFERENCES profiles(id),
  owner_id UUID NOT NULL REFERENCES profiles(id),

  -- DATES
  deadline TIMESTAMPTZ,
  sent_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour recherche par entité
CREATE INDEX idx_signature_sessions_entity
ON signature_sessions(entity_type, entity_id);

-- Index pour recherche par statut et propriétaire
CREATE INDEX idx_signature_sessions_status_owner
ON signature_sessions(status, owner_id);

-- Index pour sessions actives
CREATE INDEX idx_signature_sessions_active
ON signature_sessions(status)
WHERE status IN ('pending', 'ongoing');

-- Commentaires
COMMENT ON TABLE signature_sessions IS 'Sessions de signature unifiées (SOTA 2026)';
COMMENT ON COLUMN signature_sessions.entity_id IS 'UUID de l''entité liée (lease.id, edl.id, etc.)';
COMMENT ON COLUMN signature_sessions.signature_level IS 'Niveau eIDAS: SES (simple), AES (avancé), QES (qualifié)';

-- ============================================================================
-- 3. TABLE: signature_participants
-- ============================================================================

CREATE TABLE signature_participants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- LIEN SESSION
  session_id UUID NOT NULL REFERENCES signature_sessions(id) ON DELETE CASCADE,

  -- IDENTITÉ (flexible: profil existant OU invitation)
  profile_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
  email TEXT NOT NULL,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  phone TEXT,

  -- RÔLE ET ORDRE
  role signature_role NOT NULL,
  signing_order INT,  -- NULL = pas d'ordre, sinon 1,2,3...

  -- STATUT
  status signature_participant_status NOT NULL DEFAULT 'pending',

  -- SIGNATURE
  signature_image_path TEXT,        -- Chemin storage (pas de base64!)
  signature_timestamp TIMESTAMPTZ,
  signature_ip INET,
  signature_user_agent TEXT,

  -- OTP (si requis)
  otp_code TEXT,
  otp_expires_at TIMESTAMPTZ,
  otp_verified BOOLEAN DEFAULT false,

  -- REFUS
  refused_reason TEXT,
  refused_at TIMESTAMPTZ,

  -- INVITATION
  invitation_token TEXT UNIQUE,
  invitation_token_expires_at TIMESTAMPTZ,
  invitation_sent_at TIMESTAMPTZ,

  -- TRACKING
  notified_at TIMESTAMPTZ,
  opened_at TIMESTAMPTZ,

  -- DATES
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index unique partiel pour profiles
CREATE UNIQUE INDEX idx_signature_participants_session_profile
ON signature_participants(session_id, profile_id)
WHERE profile_id IS NOT NULL;

-- Index unique partiel pour emails (invitations)
CREATE UNIQUE INDEX idx_signature_participants_session_email
ON signature_participants(session_id, email)
WHERE profile_id IS NULL;

-- Index pour recherche par token
CREATE INDEX idx_signature_participants_token
ON signature_participants(invitation_token)
WHERE invitation_token IS NOT NULL;

-- Index pour recherche par email
CREATE INDEX idx_signature_participants_email
ON signature_participants(email);

-- Index pour statut
CREATE INDEX idx_signature_participants_status
ON signature_participants(status);

-- Index pour ordre de signature
CREATE INDEX idx_signature_participants_order
ON signature_participants(session_id, signing_order)
WHERE signing_order IS NOT NULL;

-- Commentaires
COMMENT ON TABLE signature_participants IS 'Participants aux sessions de signature';
COMMENT ON COLUMN signature_participants.profile_id IS 'NULL si invitation email (pas encore inscrit)';
COMMENT ON COLUMN signature_participants.signature_image_path IS 'Chemin Supabase Storage - jamais de base64!';

-- ============================================================================
-- 4. TABLE: signature_proofs
-- ============================================================================

CREATE TABLE signature_proofs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- LIENS
  participant_id UUID NOT NULL REFERENCES signature_participants(id) ON DELETE CASCADE,
  session_id UUID NOT NULL REFERENCES signature_sessions(id) ON DELETE CASCADE,

  -- IDENTIFIANT UNIQUE DE PREUVE
  proof_id TEXT UNIQUE NOT NULL,  -- Format: SIG-[timestamp]-[random]

  -- HASHES CRYPTOGRAPHIQUES (SHA-256)
  document_hash TEXT NOT NULL,    -- Hash du document signé
  signature_hash TEXT NOT NULL,   -- Hash de l'image de signature
  proof_hash TEXT NOT NULL,       -- Hash de toute la preuve

  -- MÉTADONNÉES COMPLÈTES (conforme eIDAS)
  metadata JSONB NOT NULL,
  /*
    Structure metadata:
    {
      "signer": {
        "name": "Jean Dupont",
        "email": "jean@example.com",
        "profileId": "uuid",
        "identityVerified": true,
        "identityMethod": "cni_scan"
      },
      "document": {
        "type": "bail",
        "id": "uuid",
        "name": "Bail appartement 123",
        "hash": "sha256..."
      },
      "signature": {
        "type": "draw" | "text",
        "imageData": "sha256...",
        "timestamp": "2026-01-21T10:00:00Z"
      },
      "technical": {
        "ipAddress": "1.2.3.4",
        "userAgent": "...",
        "screenSize": "1920x1080",
        "touchDevice": false,
        "geolocation": { "lat": 48.8, "lng": 2.3 }
      },
      "integrity": {
        "algorithm": "SHA-256",
        "proofHash": "sha256..."
      }
    }
  */

  -- VÉRIFICATION
  verified_at TIMESTAMPTZ,
  verification_errors TEXT[],  -- Erreurs si échec

  -- DATES
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour recherche par proof_id
CREATE INDEX idx_signature_proofs_proof_id
ON signature_proofs(proof_id);

-- Index pour recherche par session
CREATE INDEX idx_signature_proofs_session
ON signature_proofs(session_id);

-- Index pour recherche par participant
CREATE INDEX idx_signature_proofs_participant
ON signature_proofs(participant_id);

-- Commentaires
COMMENT ON TABLE signature_proofs IS 'Preuves cryptographiques de signature (eIDAS)';
COMMENT ON COLUMN signature_proofs.proof_id IS 'Format: SIG-YYYYMMDD-HHMMSS-RANDOM';
COMMENT ON COLUMN signature_proofs.metadata IS 'Métadonnées complètes conformes eIDAS';

-- ============================================================================
-- 5. TABLE: signature_audit_log (IMMUTABLE)
-- ============================================================================

CREATE TABLE signature_audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- RÉFÉRENCES
  session_id UUID NOT NULL REFERENCES signature_sessions(id) ON DELETE CASCADE,
  participant_id UUID REFERENCES signature_participants(id) ON DELETE SET NULL,

  -- ACTION
  action signature_audit_action NOT NULL,

  -- CONTEXTE
  actor_id UUID REFERENCES profiles(id),  -- Qui a effectué l'action
  ip_address INET,
  user_agent TEXT,

  -- DONNÉES SUPPLÉMENTAIRES
  metadata JSONB,

  -- TIMESTAMP (immutable)
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour recherche par session
CREATE INDEX idx_signature_audit_session
ON signature_audit_log(session_id);

-- Index pour recherche par action
CREATE INDEX idx_signature_audit_action
ON signature_audit_log(action);

-- Index pour recherche temporelle
CREATE INDEX idx_signature_audit_created
ON signature_audit_log(created_at);

-- RÈGLES D'IMMUTABILITÉ
CREATE RULE signature_audit_log_no_update
AS ON UPDATE TO signature_audit_log DO INSTEAD NOTHING;

CREATE RULE signature_audit_log_no_delete
AS ON DELETE TO signature_audit_log DO INSTEAD NOTHING;

-- Commentaires
COMMENT ON TABLE signature_audit_log IS 'Journal d''audit immutable des signatures';

-- ============================================================================
-- 6. TRIGGERS: Auto-update et workflow
-- ============================================================================

-- Fonction pour mettre à jour updated_at
CREATE OR REPLACE FUNCTION update_signature_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger sur signature_sessions
CREATE TRIGGER tr_signature_sessions_updated
BEFORE UPDATE ON signature_sessions
FOR EACH ROW
EXECUTE FUNCTION update_signature_timestamp();

-- Trigger sur signature_participants
CREATE TRIGGER tr_signature_participants_updated
BEFORE UPDATE ON signature_participants
FOR EACH ROW
EXECUTE FUNCTION update_signature_timestamp();

-- ============================================================================
-- 7. FONCTION: Vérifier si session complète
-- ============================================================================

CREATE OR REPLACE FUNCTION check_signature_session_completion()
RETURNS TRIGGER AS $$
DECLARE
  v_session_id UUID;
  v_total_participants INT;
  v_signed_participants INT;
  v_refused_participants INT;
BEGIN
  -- Récupérer session_id
  v_session_id := NEW.session_id;

  -- Compter les participants
  SELECT
    COUNT(*),
    COUNT(*) FILTER (WHERE status = 'signed'),
    COUNT(*) FILTER (WHERE status = 'refused')
  INTO v_total_participants, v_signed_participants, v_refused_participants
  FROM signature_participants
  WHERE session_id = v_session_id;

  -- Mettre à jour le statut de la session
  IF v_refused_participants > 0 THEN
    -- Au moins un refus
    UPDATE signature_sessions
    SET status = 'rejected', updated_at = NOW()
    WHERE id = v_session_id AND status NOT IN ('rejected', 'canceled');

  ELSIF v_signed_participants = v_total_participants THEN
    -- Tous ont signé
    UPDATE signature_sessions
    SET status = 'done', completed_at = NOW(), updated_at = NOW()
    WHERE id = v_session_id AND status = 'ongoing';

  ELSIF v_signed_participants > 0 THEN
    -- Au moins un a signé (mais pas tous)
    UPDATE signature_sessions
    SET status = 'ongoing', updated_at = NOW()
    WHERE id = v_session_id AND status IN ('pending', 'draft');
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger pour vérifier completion
CREATE TRIGGER tr_check_signature_session_completion
AFTER UPDATE OF status ON signature_participants
FOR EACH ROW
WHEN (NEW.status IN ('signed', 'refused'))
EXECUTE FUNCTION check_signature_session_completion();

-- ============================================================================
-- 8. FONCTION: Synchroniser avec entités liées (lease, edl)
-- ============================================================================

CREATE OR REPLACE FUNCTION sync_signature_session_to_entity()
RETURNS TRIGGER AS $$
BEGIN
  -- Quand une session est complète (done)
  IF NEW.status = 'done' AND OLD.status != 'done' THEN

    -- Synchroniser avec bail
    IF NEW.entity_type = 'lease' THEN
      UPDATE leases
      SET
        statut = CASE
          WHEN NEW.document_type = 'bail' THEN 'fully_signed'
          ELSE statut
        END,
        signature_completed_at = NOW(),
        updated_at = NOW()
      WHERE id = NEW.entity_id;

    -- Synchroniser avec EDL
    ELSIF NEW.entity_type = 'edl' THEN
      UPDATE edl
      SET
        status = 'signed',
        updated_at = NOW()
      WHERE id = NEW.entity_id;

      -- Si EDL d'entrée signé, activer le bail
      UPDATE leases l
      SET statut = 'active', updated_at = NOW()
      FROM edl e
      WHERE e.id = NEW.entity_id
        AND e.lease_id = l.id
        AND e.type = 'entree'
        AND l.statut = 'fully_signed';
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger pour synchronisation
CREATE TRIGGER tr_sync_signature_to_entity
AFTER UPDATE OF status ON signature_sessions
FOR EACH ROW
EXECUTE FUNCTION sync_signature_session_to_entity();

-- ============================================================================
-- 9. FONCTION: Générer token d'invitation
-- ============================================================================

CREATE OR REPLACE FUNCTION generate_signature_invitation_token()
RETURNS TEXT AS $$
DECLARE
  v_token TEXT;
BEGIN
  -- Générer un token unique de 32 caractères
  v_token := encode(gen_random_bytes(24), 'base64');
  -- Remplacer caractères problématiques pour URL
  v_token := replace(replace(v_token, '+', '-'), '/', '_');
  RETURN v_token;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- 10. RLS POLICIES
-- ============================================================================

-- Activer RLS
ALTER TABLE signature_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE signature_participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE signature_proofs ENABLE ROW LEVEL SECURITY;
ALTER TABLE signature_audit_log ENABLE ROW LEVEL SECURITY;

-- Service role a accès total
CREATE POLICY "service_all_signature_sessions" ON signature_sessions
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_all_signature_participants" ON signature_participants
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_all_signature_proofs" ON signature_proofs
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_all_signature_audit_log" ON signature_audit_log
  FOR ALL TO service_role USING (true) WITH CHECK (true);

-- Propriétaires voient leurs sessions
CREATE POLICY "owner_select_signature_sessions" ON signature_sessions
  FOR SELECT TO authenticated
  USING (owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

-- Participants voient leurs sessions
CREATE POLICY "participant_select_signature_sessions" ON signature_sessions
  FOR SELECT TO authenticated
  USING (id IN (
    SELECT session_id FROM signature_participants
    WHERE profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  ));

-- Participants voient leurs propres données
CREATE POLICY "participant_select_own" ON signature_participants
  FOR SELECT TO authenticated
  USING (profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

-- Participants peuvent mettre à jour leur signature
CREATE POLICY "participant_update_own" ON signature_participants
  FOR UPDATE TO authenticated
  USING (profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()))
  WITH CHECK (profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid()));

-- Preuves visibles par participants de la session
CREATE POLICY "participant_select_proofs" ON signature_proofs
  FOR SELECT TO authenticated
  USING (session_id IN (
    SELECT session_id FROM signature_participants
    WHERE profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  ));

-- Audit visible par propriétaire
CREATE POLICY "owner_select_audit" ON signature_audit_log
  FOR SELECT TO authenticated
  USING (session_id IN (
    SELECT id FROM signature_sessions
    WHERE owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  ));

-- ============================================================================
-- 11. VUES UTILITAIRES
-- ============================================================================

-- Vue des sessions avec compteurs
CREATE OR REPLACE VIEW v_signature_sessions_summary AS
SELECT
  s.*,
  COUNT(p.id) AS total_participants,
  COUNT(p.id) FILTER (WHERE p.status = 'signed') AS signed_count,
  COUNT(p.id) FILTER (WHERE p.status = 'refused') AS refused_count,
  COUNT(p.id) FILTER (WHERE p.status = 'pending') AS pending_count
FROM signature_sessions s
LEFT JOIN signature_participants p ON p.session_id = s.id
GROUP BY s.id;

-- Vue des signatures en attente par utilisateur
CREATE OR REPLACE VIEW v_pending_signatures AS
SELECT
  p.*,
  s.name AS session_name,
  s.document_type,
  s.entity_type,
  s.entity_id,
  s.deadline,
  s.signature_level
FROM signature_participants p
JOIN signature_sessions s ON s.id = p.session_id
WHERE p.status IN ('pending', 'notified', 'opened')
  AND s.status IN ('pending', 'ongoing');

COMMENT ON VIEW v_signature_sessions_summary IS 'Sessions avec compteurs de participants';
COMMENT ON VIEW v_pending_signatures IS 'Signatures en attente par utilisateur';

-- ============================================================================
-- 12. DEPRECATION: Colonnes obsolètes
-- ============================================================================

-- Marquer colonnes Yousign comme obsolètes (ne pas supprimer pour compatibilité)
COMMENT ON COLUMN leases.yousign_signature_request_id IS
  'DEPRECATED (SOTA 2026): Utiliser signature_sessions.id à la place';
COMMENT ON COLUMN leases.yousign_document_id IS
  'DEPRECATED (SOTA 2026): Utiliser signature_sessions.source_document_id';
COMMENT ON COLUMN leases.signature_started_at IS
  'DEPRECATED (SOTA 2026): Utiliser signature_sessions.sent_at';
COMMENT ON COLUMN leases.signature_completed_at IS
  'DEPRECATED (SOTA 2026): Utiliser signature_sessions.completed_at';

COMMIT;

-- ============================================================================
-- POST-MIGRATION NOTES
-- ============================================================================
--
-- PROCHAINES ÉTAPES (à faire dans migrations séparées):
--
-- 1. Migration des données existantes:
--    - lease_signers → signature_sessions + signature_participants
--    - signatures → signature_proofs
--    - edl_signatures → signature_sessions + signature_participants
--    - signature_requests → signature_sessions
--
-- 2. Mise à jour du code application:
--    - Services: lib/signatures/service.ts
--    - Routes API: app/api/signature/**
--    - Types: lib/supabase/database.types.ts
--
-- 3. Tests de régression:
--    - Flux signature bail
--    - Flux signature EDL
--    - Activation automatique bail après EDL
--
-- 4. Suppression anciennes tables (après période de transition):
--    - DROP TABLE signatures CASCADE;
--    - DROP TABLE signature_requests CASCADE;
--    - DROP TABLE signature_request_signers CASCADE;
--    - ALTER TABLE leases DROP COLUMN yousign_*;
-- ============================================================================


-- ========== 20260121000002_naming_normalization_fr_to_en.sql ==========
-- ============================================================================
-- P2: NORMALISATION DU NOMMAGE FR → EN (SOTA 2026)
-- ============================================================================
-- Date: 2026-01-21
-- Description: Migration progressive du nommage français vers anglais
-- Strategy: Add English aliases via views, keep original columns for backward compatibility
-- ============================================================================

-- ============================================================================
-- PHASE 1: CREATE VIEWS WITH ENGLISH COLUMN NAMES
-- These views provide English-named access without breaking existing code
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 1.1 PROPERTIES VIEW (biens)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW v_properties_en AS
SELECT
  id,
  owner_id,
  unique_code,
  type,
  -- Address fields
  adresse_complete AS full_address,
  code_postal AS postal_code,
  ville AS city,
  departement AS department_code,
  pays AS country,
  -- Property details
  surface AS area_sqm,
  nb_pieces AS room_count,
  etage AS floor_number,
  ascenseur AS has_elevator,
  meuble AS is_furnished,
  -- Financial
  loyer_base AS base_rent,
  loyer_hc AS rent_excluding_charges,
  charges_mensuelles AS monthly_charges,
  depot_garantie AS security_deposit,
  -- Energy
  energie AS energy_class,
  ges AS ghg_class,
  dpe_classe_energie AS dpe_energy_class,
  dpe_classe_climat AS dpe_climate_class,
  dpe_date AS dpe_date,
  dpe_numero AS dpe_number,
  -- Rent control
  zone_encadrement AS rent_control_zone,
  loyer_reference AS reference_rent,
  loyer_reference_majore AS max_reference_rent,
  complement_loyer AS rent_supplement,
  encadrement_applicable AS rent_control_applicable,
  -- Building
  annee_construction AS construction_year,
  nom_residence AS residence_name,
  batiment AS building,
  escalier AS staircase,
  numero_lot AS lot_number,
  -- Syndic
  syndic_name AS property_manager_name,
  syndic_email AS property_manager_email,
  syndic_phone AS property_manager_phone,
  -- Status
  etat AS status,
  deleted_at,
  created_at,
  updated_at
FROM properties;

COMMENT ON VIEW v_properties_en IS 'English-named view for properties table (P2 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 1.2 PROFILES VIEW (utilisateurs)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW v_profiles_en AS
SELECT
  id,
  user_id,
  role,
  -- Identity
  prenom AS first_name,
  nom AS last_name,
  email,
  telephone AS phone,
  -- Birth info
  date_naissance AS birth_date,
  lieu_naissance AS birth_place,
  nationalite AS nationality,
  -- Address
  adresse AS address,
  adresse_complement AS address_line2,
  code_postal AS postal_code,
  ville AS city,
  pays AS country,
  -- Professional
  siret,
  raison_sociale AS company_name,
  -- Account
  avatar_url,
  account_status,
  two_factor_enabled,
  suspended_at,
  suspended_reason,
  -- Timestamps
  created_at,
  updated_at
FROM profiles;

COMMENT ON VIEW v_profiles_en IS 'English-named view for profiles table (P2 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 1.3 LEASES VIEW (baux)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW v_leases_en AS
SELECT
  id,
  property_id,
  unit_id,
  -- Type
  type_bail AS lease_type,
  -- Financial
  loyer AS rent_amount,
  charges_forfaitaires AS fixed_charges,
  charges_type AS charges_type,
  depot_de_garantie AS security_deposit,
  prorata_first_month AS first_month_prorata,
  -- Dates
  date_debut AS start_date,
  date_fin AS end_date,
  date_signature AS signature_date,
  -- Status
  statut AS status,
  -- Indexation
  indexation_enabled AS indexation_enabled,
  dernier_indice_ref AS last_reference_index,
  date_derniere_revision AS last_revision_date,
  -- Rent control
  encadrement_applicable AS rent_control_applicable,
  loyer_reference_majore AS max_reference_rent,
  complement_loyer AS rent_supplement,
  justification_complement AS supplement_justification,
  -- Documents
  pdf_url AS lease_pdf_url,
  pdf_signed_url AS signed_lease_pdf_url,
  -- Colocation
  coloc_config AS shared_housing_config,
  -- Invitation
  invite_token,
  invite_token_expires_at,
  tenant_email_pending AS pending_tenant_email,
  tenant_name_pending AS pending_tenant_name,
  -- Identity verification
  tenant_identity_verified,
  tenant_identity_method,
  tenant_identity_data,
  -- Yousign integration
  yousign_signature_request_id,
  yousign_document_id,
  signature_started_at,
  signature_completed_at,
  signature_status,
  -- Timestamps
  created_at,
  updated_at
FROM leases;

COMMENT ON VIEW v_leases_en IS 'English-named view for leases table (P2 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 1.4 INVOICES VIEW (factures)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW v_invoices_en AS
SELECT
  id,
  lease_id,
  owner_id,
  tenant_id,
  -- Period
  periode AS period,
  -- Amounts
  montant_loyer AS rent_amount,
  montant_charges AS charges_amount,
  montant_tva AS vat_amount,
  tva_taux AS vat_rate,
  montant_total AS total_amount,
  -- Status
  statut AS status,
  -- Dates
  date_echeance AS due_date,
  date_paiement AS payment_date,
  date_envoi AS sent_date,
  -- Reference
  invoice_number,
  -- Timestamps
  created_at,
  updated_at
FROM invoices;

COMMENT ON VIEW v_invoices_en IS 'English-named view for invoices table (P2 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 1.5 PAYMENTS VIEW (paiements)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW v_payments_en AS
SELECT
  id,
  invoice_id,
  -- Amount
  montant AS amount,
  -- Method
  moyen AS payment_method,
  -- Status
  statut AS status,
  -- Provider
  provider_ref AS provider_reference,
  -- Dates
  date_paiement AS payment_date,
  -- Reference
  reference,
  -- Timestamps
  created_at
FROM payments;

COMMENT ON VIEW v_payments_en IS 'English-named view for payments table (P2 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 1.6 CHARGES VIEW (charges récurrentes)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW v_charges_en AS
SELECT
  id,
  property_id,
  -- Type and description
  type,
  libelle AS label,
  description,
  -- Amount
  montant AS amount,
  -- Frequency
  periodicite AS frequency,
  jour_prelevement AS billing_day,
  -- Tenant recharge
  refacturable_locataire AS rechargeable_to_tenant,
  pourcentage_refacturable AS rechargeable_percentage,
  -- Dates
  date_debut AS start_date,
  date_fin AS end_date,
  -- Status
  is_active,
  -- Timestamps
  created_at,
  updated_at
FROM charges;

COMMENT ON VIEW v_charges_en IS 'English-named view for charges table (P2 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 1.7 TICKETS VIEW (interventions)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW v_tickets_en AS
SELECT
  id,
  property_id,
  lease_id,
  created_by,
  assigned_to,
  -- Content
  titre AS title,
  description,
  -- Priority and status
  priorite AS priority,
  statut AS status,
  -- Category
  categorie AS category,
  sous_categorie AS subcategory,
  -- Location
  localisation AS location,
  -- Resolution
  date_resolution AS resolution_date,
  resolution_notes,
  -- Timestamps
  created_at,
  updated_at
FROM tickets;

COMMENT ON VIEW v_tickets_en IS 'English-named view for tickets table (P2 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 1.8 EDL VIEW (états des lieux)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW v_inspections_en AS
SELECT
  id,
  lease_id,
  -- Type
  type,
  -- Status
  status,
  -- Dates
  scheduled_date,
  completed_date AS completion_date,
  -- Creator
  created_by,
  -- Timestamps
  created_at,
  updated_at
FROM edl;

COMMENT ON VIEW v_inspections_en IS 'English-named view for edl (inspections) table (P2 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 1.9 EDL_ITEMS VIEW (éléments d'état des lieux)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW v_inspection_items_en AS
SELECT
  id,
  edl_id AS inspection_id,
  -- Location
  room_name,
  item_name,
  -- Assessment
  condition,
  notes AS comments,
  -- Timestamps
  created_at
FROM edl_items;

COMMENT ON VIEW v_inspection_items_en IS 'English-named view for edl_items (inspection_items) table (P2 SOTA 2026)';

-- ============================================================================
-- PHASE 2: CREATE TRANSLATION FUNCTIONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 2.1 Status translation function
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION translate_status_fr_to_en(status_fr TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN CASE status_fr
    -- Lease statuses
    WHEN 'brouillon' THEN 'draft'
    WHEN 'en_attente_signature' THEN 'pending_signature'
    WHEN 'partiellement_signe' THEN 'partially_signed'
    WHEN 'signe' THEN 'fully_signed'
    WHEN 'actif' THEN 'active'
    WHEN 'conge_donne' THEN 'notice_given'
    WHEN 'termine' THEN 'terminated'
    WHEN 'archive' THEN 'archived'
    -- Invoice statuses
    WHEN 'envoyee' THEN 'sent'
    WHEN 'payee' THEN 'paid'
    WHEN 'en_retard' THEN 'overdue'
    WHEN 'annulee' THEN 'cancelled'
    -- Payment statuses
    WHEN 'en_attente' THEN 'pending'
    WHEN 'reussi' THEN 'succeeded'
    WHEN 'echoue' THEN 'failed'
    WHEN 'rembourse' THEN 'refunded'
    -- Ticket statuses
    WHEN 'ouvert' THEN 'open'
    WHEN 'en_cours' THEN 'in_progress'
    WHEN 'en_pause' THEN 'paused'
    WHEN 'resolu' THEN 'resolved'
    WHEN 'ferme' THEN 'closed'
    -- Default: return original
    ELSE status_fr
  END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

COMMENT ON FUNCTION translate_status_fr_to_en IS 'Translates French status values to English (P2 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 2.2 Property type translation function
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION translate_property_type_fr_to_en(type_fr TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN CASE type_fr
    WHEN 'appartement' THEN 'apartment'
    WHEN 'maison' THEN 'house'
    WHEN 'studio' THEN 'studio'
    WHEN 'colocation' THEN 'shared_housing'
    WHEN 'saisonnier' THEN 'seasonal'
    WHEN 'local_commercial' THEN 'commercial'
    WHEN 'bureaux' THEN 'office'
    WHEN 'parking' THEN 'parking'
    WHEN 'cave' THEN 'cellar'
    WHEN 'garage' THEN 'garage'
    ELSE type_fr
  END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

COMMENT ON FUNCTION translate_property_type_fr_to_en IS 'Translates French property types to English (P2 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 2.3 Lease type translation function
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION translate_lease_type_fr_to_en(type_fr TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN CASE type_fr
    WHEN 'nu' THEN 'unfurnished'
    WHEN 'meuble' THEN 'furnished'
    WHEN 'colocation' THEN 'shared'
    WHEN 'saisonnier' THEN 'seasonal'
    WHEN 'bail_mobilite' THEN 'mobility'
    WHEN 'etudiant' THEN 'student'
    WHEN 'commercial_3_6_9' THEN 'commercial'
    ELSE type_fr
  END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

COMMENT ON FUNCTION translate_lease_type_fr_to_en IS 'Translates French lease types to English (P2 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 2.4 Charge type translation function
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION translate_charge_type_fr_to_en(type_fr TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN CASE type_fr
    WHEN 'eau' THEN 'water'
    WHEN 'electricite' THEN 'electricity'
    WHEN 'gaz' THEN 'gas'
    WHEN 'copro' THEN 'condo_fees'
    WHEN 'taxe' THEN 'tax'
    WHEN 'ordures' THEN 'waste'
    WHEN 'assurance' THEN 'insurance'
    WHEN 'travaux' THEN 'repairs'
    WHEN 'entretien' THEN 'maintenance'
    WHEN 'autre' THEN 'other'
    ELSE type_fr
  END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

COMMENT ON FUNCTION translate_charge_type_fr_to_en IS 'Translates French charge types to English (P2 SOTA 2026)';

-- ============================================================================
-- PHASE 3: CREATE MAPPING TABLE FOR DOCUMENTATION
-- ============================================================================

CREATE TABLE IF NOT EXISTS _schema_translations (
  id SERIAL PRIMARY KEY,
  table_name TEXT NOT NULL,
  column_fr TEXT NOT NULL,
  column_en TEXT NOT NULL,
  data_type TEXT,
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(table_name, column_fr)
);

COMMENT ON TABLE _schema_translations IS 'Documentation of FR→EN column name translations (P2 SOTA 2026)';

-- Insert translation mappings
INSERT INTO _schema_translations (table_name, column_fr, column_en, data_type, description) VALUES
  -- Properties
  ('properties', 'adresse_complete', 'full_address', 'TEXT', 'Complete street address'),
  ('properties', 'code_postal', 'postal_code', 'VARCHAR(5)', 'Postal/ZIP code'),
  ('properties', 'ville', 'city', 'TEXT', 'City name'),
  ('properties', 'departement', 'department_code', 'VARCHAR(3)', 'French department code'),
  ('properties', 'surface', 'area_sqm', 'NUMERIC', 'Area in square meters'),
  ('properties', 'nb_pieces', 'room_count', 'INTEGER', 'Number of rooms'),
  ('properties', 'etage', 'floor_number', 'INTEGER', 'Floor number'),
  ('properties', 'ascenseur', 'has_elevator', 'BOOLEAN', 'Building has elevator'),
  ('properties', 'meuble', 'is_furnished', 'BOOLEAN', 'Property is furnished'),
  ('properties', 'loyer_base', 'base_rent', 'NUMERIC', 'Base rent amount'),
  ('properties', 'charges_mensuelles', 'monthly_charges', 'NUMERIC', 'Monthly charges'),
  ('properties', 'depot_garantie', 'security_deposit', 'NUMERIC', 'Security deposit'),
  ('properties', 'etat', 'status', 'TEXT', 'Property status'),
  -- Profiles
  ('profiles', 'prenom', 'first_name', 'TEXT', 'First name'),
  ('profiles', 'nom', 'last_name', 'TEXT', 'Last name'),
  ('profiles', 'telephone', 'phone', 'TEXT', 'Phone number'),
  ('profiles', 'date_naissance', 'birth_date', 'DATE', 'Date of birth'),
  ('profiles', 'lieu_naissance', 'birth_place', 'VARCHAR(255)', 'Place of birth'),
  ('profiles', 'nationalite', 'nationality', 'VARCHAR(100)', 'Nationality'),
  ('profiles', 'adresse', 'address', 'TEXT', 'Street address'),
  ('profiles', 'raison_sociale', 'company_name', 'TEXT', 'Company name'),
  -- Leases
  ('leases', 'type_bail', 'lease_type', 'TEXT', 'Type of lease'),
  ('leases', 'loyer', 'rent_amount', 'NUMERIC', 'Rent amount'),
  ('leases', 'charges_forfaitaires', 'fixed_charges', 'NUMERIC', 'Fixed charges'),
  ('leases', 'depot_de_garantie', 'security_deposit', 'NUMERIC', 'Security deposit'),
  ('leases', 'date_debut', 'start_date', 'DATE', 'Lease start date'),
  ('leases', 'date_fin', 'end_date', 'DATE', 'Lease end date'),
  ('leases', 'statut', 'status', 'TEXT', 'Lease status'),
  -- Invoices
  ('invoices', 'periode', 'period', 'VARCHAR(7)', 'Billing period (YYYY-MM)'),
  ('invoices', 'montant_loyer', 'rent_amount', 'NUMERIC', 'Rent portion'),
  ('invoices', 'montant_charges', 'charges_amount', 'NUMERIC', 'Charges portion'),
  ('invoices', 'montant_total', 'total_amount', 'NUMERIC', 'Total amount'),
  ('invoices', 'statut', 'status', 'TEXT', 'Invoice status'),
  ('invoices', 'date_echeance', 'due_date', 'DATE', 'Payment due date'),
  -- Payments
  ('payments', 'montant', 'amount', 'NUMERIC', 'Payment amount'),
  ('payments', 'moyen', 'payment_method', 'TEXT', 'Payment method'),
  ('payments', 'statut', 'status', 'TEXT', 'Payment status'),
  ('payments', 'date_paiement', 'payment_date', 'TIMESTAMPTZ', 'Payment date'),
  -- Charges
  ('charges', 'libelle', 'label', 'TEXT', 'Charge label'),
  ('charges', 'montant', 'amount', 'NUMERIC', 'Charge amount'),
  ('charges', 'periodicite', 'frequency', 'TEXT', 'Billing frequency'),
  ('charges', 'refacturable_locataire', 'rechargeable_to_tenant', 'BOOLEAN', 'Can be charged to tenant'),
  -- Tickets
  ('tickets', 'titre', 'title', 'TEXT', 'Ticket title'),
  ('tickets', 'priorite', 'priority', 'TEXT', 'Priority level'),
  ('tickets', 'statut', 'status', 'TEXT', 'Ticket status'),
  ('tickets', 'categorie', 'category', 'TEXT', 'Category'),
  ('tickets', 'localisation', 'location', 'TEXT', 'Location in property')
ON CONFLICT (table_name, column_fr) DO NOTHING;

-- ============================================================================
-- PHASE 4: CREATE TYPE MAPPING FOR TYPESCRIPT GENERATION
-- ============================================================================

-- Create a function to generate TypeScript interface from view
CREATE OR REPLACE FUNCTION generate_typescript_interface(view_name TEXT)
RETURNS TEXT AS $$
DECLARE
  result TEXT := '';
  col RECORD;
  ts_type TEXT;
BEGIN
  result := 'export interface ' || initcap(replace(view_name, 'v_', '')) || 'Row {' || E'\n';

  FOR col IN
    SELECT
      column_name,
      data_type,
      is_nullable
    FROM information_schema.columns
    WHERE table_name = view_name
    ORDER BY ordinal_position
  LOOP
    -- Map SQL types to TypeScript
    ts_type := CASE
      WHEN col.data_type IN ('uuid', 'text', 'character varying', 'varchar', 'char') THEN 'string'
      WHEN col.data_type IN ('integer', 'bigint', 'smallint', 'numeric', 'decimal', 'real', 'double precision') THEN 'number'
      WHEN col.data_type = 'boolean' THEN 'boolean'
      WHEN col.data_type IN ('timestamp with time zone', 'timestamp without time zone', 'date', 'time') THEN 'string'
      WHEN col.data_type = 'jsonb' OR col.data_type = 'json' THEN 'Record<string, unknown>'
      WHEN col.data_type = 'inet' THEN 'string'
      ELSE 'unknown'
    END;

    -- Add nullable marker
    IF col.is_nullable = 'YES' THEN
      ts_type := ts_type || ' | null';
    END IF;

    result := result || '  ' || col.column_name || ': ' || ts_type || ';' || E'\n';
  END LOOP;

  result := result || '}';

  RETURN result;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION generate_typescript_interface IS 'Generates TypeScript interface from view definition (P2 SOTA 2026)';

-- ============================================================================
-- PHASE 5: GRANTS FOR VIEWS
-- ============================================================================

-- Grant select on all views to authenticated users
GRANT SELECT ON v_properties_en TO authenticated;
GRANT SELECT ON v_profiles_en TO authenticated;
GRANT SELECT ON v_leases_en TO authenticated;
GRANT SELECT ON v_invoices_en TO authenticated;
GRANT SELECT ON v_payments_en TO authenticated;
GRANT SELECT ON v_charges_en TO authenticated;
GRANT SELECT ON v_tickets_en TO authenticated;
GRANT SELECT ON v_inspections_en TO authenticated;
GRANT SELECT ON v_inspection_items_en TO authenticated;

-- ============================================================================
-- DOCUMENTATION
-- ============================================================================

COMMENT ON SCHEMA public IS 'P2 SOTA 2026: Added English-named views for all major tables.
Use v_*_en views for English column names while maintaining backward compatibility with original tables.

Views available:
- v_properties_en
- v_profiles_en
- v_leases_en
- v_invoices_en
- v_payments_en
- v_charges_en
- v_tickets_en
- v_inspections_en
- v_inspection_items_en

Translation functions:
- translate_status_fr_to_en(status)
- translate_property_type_fr_to_en(type)
- translate_lease_type_fr_to_en(type)
- translate_charge_type_fr_to_en(type)

See _schema_translations table for complete column mappings.';


-- ========== 20260121000003_event_sourcing_audit_system.sql ==========
-- ============================================================================
-- P4: EVENT SOURCING & AUDIT SYSTEM (SOTA 2026)
-- ============================================================================
-- Date: 2026-01-21
-- Description: Complete event sourcing implementation with immutable audit trail
-- Features:
--   - Partitioned audit_events table for performance
--   - Automatic event capture via triggers
--   - Actor tracking (user, system, webhook, cron)
--   - Full payload capture with before/after states
--   - Compliance-ready (GDPR, legal retention)
-- ============================================================================

-- ============================================================================
-- PHASE 1: ENUM TYPES
-- ============================================================================

-- Actor types (who performed the action)
CREATE TYPE audit_actor_type AS ENUM (
  'user',           -- Authenticated user action
  'system',         -- System/application action
  'webhook',        -- External webhook callback
  'cron',           -- Scheduled job
  'migration',      -- Database migration
  'admin',          -- Admin override
  'anonymous'       -- Unauthenticated action
);

-- Event categories for grouping
CREATE TYPE audit_event_category AS ENUM (
  'auth',           -- Authentication events
  'property',       -- Property management
  'lease',          -- Lease lifecycle
  'signature',      -- Signature events
  'inspection',     -- EDL events
  'financial',      -- Invoices, payments
  'tenant',         -- Tenant management
  'ticket',         -- Support tickets
  'document',       -- Document operations
  'communication',  -- Messages, notifications
  'admin',          -- Admin operations
  'gdpr',           -- Privacy/GDPR events
  'system'          -- System events
);

-- ============================================================================
-- PHASE 2: MAIN AUDIT_EVENTS TABLE (PARTITIONED BY MONTH)
-- ============================================================================

CREATE TABLE audit_events (
  id UUID NOT NULL DEFAULT gen_random_uuid(),

  -- Event identification
  event_type TEXT NOT NULL,              -- e.g., 'lease.created', 'payment.received'
  event_category audit_event_category NOT NULL,
  event_version INTEGER NOT NULL DEFAULT 1,

  -- Actor information
  actor_type audit_actor_type NOT NULL DEFAULT 'user',
  actor_id UUID,                          -- Profile ID if user
  actor_email TEXT,                       -- For audit trail
  actor_role TEXT,                        -- Role at time of action

  -- Target entity
  entity_type TEXT NOT NULL,              -- e.g., 'lease', 'invoice', 'property'
  entity_id UUID NOT NULL,
  entity_name TEXT,                       -- Human-readable identifier

  -- Parent entity (for nested resources)
  parent_entity_type TEXT,
  parent_entity_id UUID,

  -- Payload
  payload JSONB NOT NULL DEFAULT '{}',
  old_values JSONB,                       -- Previous state (for updates)
  new_values JSONB,                       -- New state (for creates/updates)

  -- Context
  request_id UUID,                        -- Correlation ID
  session_id UUID,                        -- User session
  ip_address INET,
  user_agent TEXT,
  origin TEXT,                            -- 'web', 'mobile', 'api'

  -- Geolocation (optional)
  geo_country TEXT,
  geo_city TEXT,

  -- Timestamps (immutable)
  occurred_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  server_time TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Partition key
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- Create comment
COMMENT ON TABLE audit_events IS 'Immutable event log for complete audit trail (P4 SOTA 2026). Partitioned by month for performance.';

-- ============================================================================
-- PHASE 3: CREATE PARTITIONS (2025-2027)
-- ============================================================================

-- 2025 partitions
CREATE TABLE audit_events_2025_01 PARTITION OF audit_events
  FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
CREATE TABLE audit_events_2025_02 PARTITION OF audit_events
  FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
CREATE TABLE audit_events_2025_03 PARTITION OF audit_events
  FOR VALUES FROM ('2025-03-01') TO ('2025-04-01');
CREATE TABLE audit_events_2025_04 PARTITION OF audit_events
  FOR VALUES FROM ('2025-04-01') TO ('2025-05-01');
CREATE TABLE audit_events_2025_05 PARTITION OF audit_events
  FOR VALUES FROM ('2025-05-01') TO ('2025-06-01');
CREATE TABLE audit_events_2025_06 PARTITION OF audit_events
  FOR VALUES FROM ('2025-06-01') TO ('2025-07-01');
CREATE TABLE audit_events_2025_07 PARTITION OF audit_events
  FOR VALUES FROM ('2025-07-01') TO ('2025-08-01');
CREATE TABLE audit_events_2025_08 PARTITION OF audit_events
  FOR VALUES FROM ('2025-08-01') TO ('2025-09-01');
CREATE TABLE audit_events_2025_09 PARTITION OF audit_events
  FOR VALUES FROM ('2025-09-01') TO ('2025-10-01');
CREATE TABLE audit_events_2025_10 PARTITION OF audit_events
  FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');
CREATE TABLE audit_events_2025_11 PARTITION OF audit_events
  FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
CREATE TABLE audit_events_2025_12 PARTITION OF audit_events
  FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

-- 2026 partitions
CREATE TABLE audit_events_2026_01 PARTITION OF audit_events
  FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');
CREATE TABLE audit_events_2026_02 PARTITION OF audit_events
  FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');
CREATE TABLE audit_events_2026_03 PARTITION OF audit_events
  FOR VALUES FROM ('2026-03-01') TO ('2026-04-01');
CREATE TABLE audit_events_2026_04 PARTITION OF audit_events
  FOR VALUES FROM ('2026-04-01') TO ('2026-05-01');
CREATE TABLE audit_events_2026_05 PARTITION OF audit_events
  FOR VALUES FROM ('2026-05-01') TO ('2026-06-01');
CREATE TABLE audit_events_2026_06 PARTITION OF audit_events
  FOR VALUES FROM ('2026-06-01') TO ('2026-07-01');
CREATE TABLE audit_events_2026_07 PARTITION OF audit_events
  FOR VALUES FROM ('2026-07-01') TO ('2026-08-01');
CREATE TABLE audit_events_2026_08 PARTITION OF audit_events
  FOR VALUES FROM ('2026-08-01') TO ('2026-09-01');
CREATE TABLE audit_events_2026_09 PARTITION OF audit_events
  FOR VALUES FROM ('2026-09-01') TO ('2026-10-01');
CREATE TABLE audit_events_2026_10 PARTITION OF audit_events
  FOR VALUES FROM ('2026-10-01') TO ('2026-11-01');
CREATE TABLE audit_events_2026_11 PARTITION OF audit_events
  FOR VALUES FROM ('2026-11-01') TO ('2026-12-01');
CREATE TABLE audit_events_2026_12 PARTITION OF audit_events
  FOR VALUES FROM ('2026-12-01') TO ('2027-01-01');

-- 2027 partitions (first half)
CREATE TABLE audit_events_2027_01 PARTITION OF audit_events
  FOR VALUES FROM ('2027-01-01') TO ('2027-02-01');
CREATE TABLE audit_events_2027_02 PARTITION OF audit_events
  FOR VALUES FROM ('2027-02-01') TO ('2027-03-01');
CREATE TABLE audit_events_2027_03 PARTITION OF audit_events
  FOR VALUES FROM ('2027-03-01') TO ('2027-04-01');
CREATE TABLE audit_events_2027_04 PARTITION OF audit_events
  FOR VALUES FROM ('2027-04-01') TO ('2027-05-01');
CREATE TABLE audit_events_2027_05 PARTITION OF audit_events
  FOR VALUES FROM ('2027-05-01') TO ('2027-06-01');
CREATE TABLE audit_events_2027_06 PARTITION OF audit_events
  FOR VALUES FROM ('2027-06-01') TO ('2027-07-01');

-- Default partition for future dates
CREATE TABLE audit_events_future PARTITION OF audit_events
  FOR VALUES FROM ('2027-07-01') TO (MAXVALUE);

-- ============================================================================
-- PHASE 4: INDEXES FOR PERFORMANCE
-- ============================================================================

-- Primary lookup indexes
CREATE INDEX idx_audit_events_entity ON audit_events (entity_type, entity_id, created_at DESC);
CREATE INDEX idx_audit_events_actor ON audit_events (actor_id, created_at DESC) WHERE actor_id IS NOT NULL;
CREATE INDEX idx_audit_events_type ON audit_events (event_type, created_at DESC);
CREATE INDEX idx_audit_events_category ON audit_events (event_category, created_at DESC);

-- Time-based indexes
CREATE INDEX idx_audit_events_occurred ON audit_events (occurred_at DESC);
CREATE INDEX idx_audit_events_request ON audit_events (request_id) WHERE request_id IS NOT NULL;

-- Full-text search on payload
CREATE INDEX idx_audit_events_payload_gin ON audit_events USING gin (payload jsonb_path_ops);

-- ============================================================================
-- PHASE 5: IMMUTABILITY RULES
-- ============================================================================

-- Prevent updates
CREATE RULE audit_events_no_update AS ON UPDATE TO audit_events
DO INSTEAD NOTHING;

-- Prevent deletes (except for GDPR compliance - admin only)
CREATE OR REPLACE FUNCTION check_audit_delete_permission()
RETURNS TRIGGER AS $$
BEGIN
  -- Only allow delete via explicit GDPR erasure function
  IF current_setting('app.audit_gdpr_delete', true) = 'true' THEN
    RETURN OLD;
  END IF;
  RAISE EXCEPTION 'Direct deletion of audit_events is prohibited. Use gdpr_erase_user_data() function.';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_audit_events_prevent_delete
  BEFORE DELETE ON audit_events
  FOR EACH ROW
  EXECUTE FUNCTION check_audit_delete_permission();

-- ============================================================================
-- PHASE 6: HELPER FUNCTIONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 6.1 Record audit event (main function)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION record_audit_event(
  p_event_type TEXT,
  p_event_category audit_event_category,
  p_entity_type TEXT,
  p_entity_id UUID,
  p_payload JSONB DEFAULT '{}',
  p_old_values JSONB DEFAULT NULL,
  p_new_values JSONB DEFAULT NULL,
  p_entity_name TEXT DEFAULT NULL,
  p_parent_entity_type TEXT DEFAULT NULL,
  p_parent_entity_id UUID DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_actor_id UUID;
  v_actor_email TEXT;
  v_actor_role TEXT;
  v_event_id UUID;
BEGIN
  -- Get current user context
  v_actor_id := NULLIF(current_setting('app.current_user_id', true), '')::UUID;
  v_actor_email := current_setting('app.current_user_email', true);
  v_actor_role := current_setting('app.current_user_role', true);

  INSERT INTO audit_events (
    event_type,
    event_category,
    actor_type,
    actor_id,
    actor_email,
    actor_role,
    entity_type,
    entity_id,
    entity_name,
    parent_entity_type,
    parent_entity_id,
    payload,
    old_values,
    new_values,
    request_id,
    ip_address,
    user_agent
  ) VALUES (
    p_event_type,
    p_event_category,
    CASE
      WHEN v_actor_id IS NOT NULL THEN 'user'::audit_actor_type
      WHEN current_setting('app.cron_job', true) = 'true' THEN 'cron'::audit_actor_type
      WHEN current_setting('app.webhook', true) = 'true' THEN 'webhook'::audit_actor_type
      ELSE 'system'::audit_actor_type
    END,
    v_actor_id,
    v_actor_email,
    v_actor_role,
    p_entity_type,
    p_entity_id,
    p_entity_name,
    p_parent_entity_type,
    p_parent_entity_id,
    p_payload,
    p_old_values,
    p_new_values,
    NULLIF(current_setting('app.request_id', true), '')::UUID,
    NULLIF(current_setting('app.ip_address', true), '')::INET,
    current_setting('app.user_agent', true)
  )
  RETURNING id INTO v_event_id;

  RETURN v_event_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION record_audit_event IS 'Records an audit event with full context (P4 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 6.2 Get entity history
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION get_entity_history(
  p_entity_type TEXT,
  p_entity_id UUID,
  p_limit INTEGER DEFAULT 100,
  p_offset INTEGER DEFAULT 0
)
RETURNS TABLE (
  event_id UUID,
  event_type TEXT,
  event_category audit_event_category,
  actor_email TEXT,
  actor_role TEXT,
  payload JSONB,
  old_values JSONB,
  new_values JSONB,
  occurred_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    ae.id,
    ae.event_type,
    ae.event_category,
    ae.actor_email,
    ae.actor_role,
    ae.payload,
    ae.old_values,
    ae.new_values,
    ae.occurred_at
  FROM audit_events ae
  WHERE ae.entity_type = p_entity_type
    AND ae.entity_id = p_entity_id
  ORDER BY ae.occurred_at DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

COMMENT ON FUNCTION get_entity_history IS 'Retrieves audit history for a specific entity (P4 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 6.3 Get user activity
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION get_user_activity(
  p_user_id UUID,
  p_from_date TIMESTAMPTZ DEFAULT now() - interval '30 days',
  p_to_date TIMESTAMPTZ DEFAULT now(),
  p_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
  event_id UUID,
  event_type TEXT,
  event_category audit_event_category,
  entity_type TEXT,
  entity_id UUID,
  entity_name TEXT,
  occurred_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    ae.id,
    ae.event_type,
    ae.event_category,
    ae.entity_type,
    ae.entity_id,
    ae.entity_name,
    ae.occurred_at
  FROM audit_events ae
  WHERE ae.actor_id = p_user_id
    AND ae.occurred_at BETWEEN p_from_date AND p_to_date
  ORDER BY ae.occurred_at DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

COMMENT ON FUNCTION get_user_activity IS 'Retrieves audit activity for a specific user (P4 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 6.4 GDPR data export
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION gdpr_export_user_audit_data(p_user_id UUID)
RETURNS JSONB AS $$
DECLARE
  v_result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'user_id', p_user_id,
    'exported_at', now(),
    'events', COALESCE(jsonb_agg(
      jsonb_build_object(
        'event_type', event_type,
        'entity_type', entity_type,
        'entity_id', entity_id,
        'payload', payload,
        'occurred_at', occurred_at
      ) ORDER BY occurred_at
    ), '[]'::jsonb)
  ) INTO v_result
  FROM audit_events
  WHERE actor_id = p_user_id;

  -- Record the export itself
  PERFORM record_audit_event(
    'gdpr.data_exported',
    'gdpr',
    'profile',
    p_user_id,
    jsonb_build_object('event_count', (v_result->'events')::jsonb)
  );

  RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION gdpr_export_user_audit_data IS 'Exports all audit data for a user (GDPR compliance)';

-- ----------------------------------------------------------------------------
-- 6.5 GDPR data erasure (pseudonymization)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION gdpr_erase_user_data(p_user_id UUID, p_reason TEXT)
RETURNS INTEGER AS $$
DECLARE
  v_count INTEGER;
BEGIN
  -- Enable delete permission
  PERFORM set_config('app.audit_gdpr_delete', 'true', true);

  -- Pseudonymize actor information in audit events
  UPDATE audit_events
  SET
    actor_email = 'GDPR_ERASED_' || substring(actor_id::text, 1, 8),
    actor_role = 'erased',
    payload = payload - 'email' - 'name' - 'phone' - 'address',
    ip_address = NULL,
    user_agent = NULL
  WHERE actor_id = p_user_id;

  GET DIAGNOSTICS v_count = ROW_COUNT;

  -- Record the erasure
  PERFORM record_audit_event(
    'gdpr.data_erased',
    'gdpr',
    'profile',
    p_user_id,
    jsonb_build_object(
      'reason', p_reason,
      'events_affected', v_count
    )
  );

  -- Reset delete permission
  PERFORM set_config('app.audit_gdpr_delete', 'false', true);

  RETURN v_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION gdpr_erase_user_data IS 'Pseudonymizes user data in audit events (GDPR compliance)';

-- ============================================================================
-- PHASE 7: AUTOMATIC AUDIT TRIGGERS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 7.1 Generic audit trigger function
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
  v_event_type TEXT;
  v_category audit_event_category;
  v_entity_name TEXT;
  v_old_values JSONB;
  v_new_values JSONB;
BEGIN
  -- Determine event type
  v_event_type := TG_TABLE_NAME || '.' || lower(TG_OP);

  -- Determine category based on table
  v_category := CASE TG_TABLE_NAME
    WHEN 'profiles' THEN 'auth'
    WHEN 'properties' THEN 'property'
    WHEN 'leases' THEN 'lease'
    WHEN 'signature_sessions' THEN 'signature'
    WHEN 'signature_participants' THEN 'signature'
    WHEN 'edl' THEN 'inspection'
    WHEN 'invoices' THEN 'financial'
    WHEN 'payments' THEN 'financial'
    WHEN 'tickets' THEN 'ticket'
    WHEN 'documents' THEN 'document'
    WHEN 'chat_messages' THEN 'communication'
    ELSE 'system'
  END;

  -- Build values based on operation
  IF TG_OP = 'DELETE' THEN
    v_old_values := to_jsonb(OLD);
    v_new_values := NULL;
    v_entity_name := COALESCE(
      OLD.name,
      OLD.titre,
      OLD.title,
      OLD.email,
      OLD.id::TEXT
    );
  ELSIF TG_OP = 'UPDATE' THEN
    v_old_values := to_jsonb(OLD);
    v_new_values := to_jsonb(NEW);
    v_entity_name := COALESCE(
      NEW.name,
      NEW.titre,
      NEW.title,
      NEW.email,
      NEW.id::TEXT
    );
  ELSE -- INSERT
    v_old_values := NULL;
    v_new_values := to_jsonb(NEW);
    v_entity_name := COALESCE(
      NEW.name,
      NEW.titre,
      NEW.title,
      NEW.email,
      NEW.id::TEXT
    );
  END IF;

  -- Record the event
  PERFORM record_audit_event(
    v_event_type,
    v_category,
    TG_TABLE_NAME,
    COALESCE(NEW.id, OLD.id),
    jsonb_build_object('trigger', TG_NAME, 'operation', TG_OP),
    v_old_values,
    v_new_values,
    v_entity_name
  );

  -- Return appropriate row
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION audit_trigger_function IS 'Generic trigger function for automatic audit logging (P4 SOTA 2026)';

-- ----------------------------------------------------------------------------
-- 7.2 Create audit triggers for main tables
-- ----------------------------------------------------------------------------

-- Properties
DROP TRIGGER IF EXISTS trg_audit_properties ON properties;
CREATE TRIGGER trg_audit_properties
  AFTER INSERT OR UPDATE OR DELETE ON properties
  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

-- Leases
DROP TRIGGER IF EXISTS trg_audit_leases ON leases;
CREATE TRIGGER trg_audit_leases
  AFTER INSERT OR UPDATE OR DELETE ON leases
  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

-- Invoices
DROP TRIGGER IF EXISTS trg_audit_invoices ON invoices;
CREATE TRIGGER trg_audit_invoices
  AFTER INSERT OR UPDATE OR DELETE ON invoices
  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

-- Payments
DROP TRIGGER IF EXISTS trg_audit_payments ON payments;
CREATE TRIGGER trg_audit_payments
  AFTER INSERT OR UPDATE OR DELETE ON payments
  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

-- Signature sessions (P1)
DROP TRIGGER IF EXISTS trg_audit_signature_sessions ON signature_sessions;
CREATE TRIGGER trg_audit_signature_sessions
  AFTER INSERT OR UPDATE OR DELETE ON signature_sessions
  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

-- EDL
DROP TRIGGER IF EXISTS trg_audit_edl ON edl;
CREATE TRIGGER trg_audit_edl
  AFTER INSERT OR UPDATE OR DELETE ON edl
  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

-- Tickets
DROP TRIGGER IF EXISTS trg_audit_tickets ON tickets;
CREATE TRIGGER trg_audit_tickets
  AFTER INSERT OR UPDATE OR DELETE ON tickets
  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

-- ============================================================================
-- PHASE 8: STATISTICS VIEWS
-- ============================================================================

-- Daily event summary
CREATE OR REPLACE VIEW v_audit_daily_stats AS
SELECT
  date_trunc('day', occurred_at) AS day,
  event_category,
  count(*) AS event_count,
  count(DISTINCT actor_id) AS unique_actors,
  count(DISTINCT entity_id) AS unique_entities
FROM audit_events
WHERE occurred_at > now() - interval '90 days'
GROUP BY 1, 2
ORDER BY 1 DESC, 2;

COMMENT ON VIEW v_audit_daily_stats IS 'Daily audit event statistics (P4 SOTA 2026)';

-- Event type distribution
CREATE OR REPLACE VIEW v_audit_event_distribution AS
SELECT
  event_type,
  event_category,
  count(*) AS total_count,
  count(*) FILTER (WHERE occurred_at > now() - interval '7 days') AS last_7_days,
  count(*) FILTER (WHERE occurred_at > now() - interval '30 days') AS last_30_days
FROM audit_events
GROUP BY event_type, event_category
ORDER BY total_count DESC;

COMMENT ON VIEW v_audit_event_distribution IS 'Audit event type distribution (P4 SOTA 2026)';

-- Recent high-impact events
CREATE OR REPLACE VIEW v_audit_recent_important AS
SELECT
  id,
  event_type,
  event_category,
  actor_email,
  entity_type,
  entity_id,
  entity_name,
  occurred_at
FROM audit_events
WHERE event_type IN (
  'lease.created',
  'lease.deleted',
  'payment.created',
  'signature_sessions.updated',
  'gdpr.data_exported',
  'gdpr.data_erased'
)
ORDER BY occurred_at DESC
LIMIT 100;

COMMENT ON VIEW v_audit_recent_important IS 'Recent high-impact audit events (P4 SOTA 2026)';

-- ============================================================================
-- PHASE 9: RLS POLICIES
-- ============================================================================

ALTER TABLE audit_events ENABLE ROW LEVEL SECURITY;

-- Admins can see all events
CREATE POLICY audit_events_admin_all ON audit_events
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.user_id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

-- Users can see events they created
CREATE POLICY audit_events_own_events ON audit_events
  FOR SELECT
  TO authenticated
  USING (
    actor_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  );

-- Users can see events for entities they own
CREATE POLICY audit_events_owned_entities ON audit_events
  FOR SELECT
  TO authenticated
  USING (
    -- Properties they own
    (entity_type = 'properties' AND entity_id IN (
      SELECT id FROM properties WHERE owner_id IN (
        SELECT id FROM profiles WHERE user_id = auth.uid()
      )
    ))
    OR
    -- Leases they're part of
    (entity_type = 'leases' AND entity_id IN (
      SELECT id FROM leases WHERE property_id IN (
        SELECT id FROM properties WHERE owner_id IN (
          SELECT id FROM profiles WHERE user_id = auth.uid()
        )
      )
    ))
  );

-- ============================================================================
-- PHASE 10: GRANTS
-- ============================================================================

-- Statistics views
GRANT SELECT ON v_audit_daily_stats TO authenticated;
GRANT SELECT ON v_audit_event_distribution TO authenticated;
GRANT SELECT ON v_audit_recent_important TO authenticated;

-- Functions
GRANT EXECUTE ON FUNCTION record_audit_event TO authenticated;
GRANT EXECUTE ON FUNCTION get_entity_history TO authenticated;
GRANT EXECUTE ON FUNCTION get_user_activity TO authenticated;

-- GDPR functions (admin only)
REVOKE ALL ON FUNCTION gdpr_export_user_audit_data FROM PUBLIC;
REVOKE ALL ON FUNCTION gdpr_erase_user_data FROM PUBLIC;
-- Admin grant would be done separately

-- ============================================================================
-- DOCUMENTATION
-- ============================================================================

COMMENT ON TABLE audit_events IS 'P4 SOTA 2026: Immutable event sourcing audit trail.

Features:
- Partitioned by month for performance
- Automatic event capture via triggers
- Full before/after state capture
- GDPR-compliant with export/erasure functions
- RLS policies for access control

Usage:
- Direct: INSERT into audit_events or use record_audit_event()
- Automatic: Triggers on main tables (properties, leases, invoices, etc.)
- Query: Use get_entity_history() or get_user_activity()
- Admin: v_audit_daily_stats, v_audit_event_distribution views

Event naming convention: {table}.{operation}
Examples: lease.created, payment.updated, signature_sessions.deleted';


-- ========== 20260122000000_receipt_performance_indexes.sql ==========
-- ============================================
-- MIGRATION: Performance Indexes for Receipts & Invoices
-- SOTA 2026 - Optimisation des requêtes quittances
-- ============================================

-- Index composite pour les recherches de factures par bail et période
-- Utilisé par: InvoicesService.getInvoicesByLease(), filtres période
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_invoices_lease_periode
  ON invoices(lease_id, periode DESC);

-- Index composite pour les recherches par propriétaire
-- Utilisé par: InvoicesService.getInvoicesByOwner(), dashboard propriétaire
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_invoices_owner_periode
  ON invoices(owner_id, periode DESC);

-- Index composite pour les recherches par locataire
-- Utilisé par: InvoicesService.getInvoicesByTenant(), dashboard locataire
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_invoices_tenant_periode
  ON invoices(tenant_id, periode DESC);

-- Index pour les factures impayées (filtre très fréquent)
-- Utilisé par: InvoicesService.getUnpaidInvoicesByLease(), relances
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_invoices_lease_unpaid
  ON invoices(lease_id, periode DESC)
  WHERE statut IN ('draft', 'sent', 'partial');

-- Index composite pour les paiements par facture et statut
-- Utilisé par: vérification des paiements réussis
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_payments_invoice_succeeded
  ON payments(invoice_id, statut)
  WHERE statut = 'succeeded';

-- Index composite pour les reçus espèces par propriétaire
-- Utilisé par: GET /api/payments/cash-receipt (liste propriétaire)
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_cash_receipts_owner_created
  ON cash_receipts(owner_id, created_at DESC);

-- Index composite pour les reçus espèces par locataire
-- Utilisé par: GET /api/payments/cash-receipt (liste locataire)
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_cash_receipts_tenant_created
  ON cash_receipts(tenant_id, created_at DESC);

-- Index pour les reçus par période (reporting mensuel)
-- Utilisé par: rapports et statistiques
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_cash_receipts_periode
  ON cash_receipts(periode DESC, created_at DESC);

-- Index pour la recherche de numéro de reçu (unicité + recherche rapide)
-- Utilisé par: recherche par numéro de quittance
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_cash_receipts_receipt_number
  ON cash_receipts(receipt_number)
  WHERE receipt_number IS NOT NULL;

-- ============================================
-- COMMENTAIRES SUR LES INDEX
-- ============================================
COMMENT ON INDEX idx_invoices_lease_periode IS
  'SOTA 2026: Optimise getInvoicesByLease() - O(log n) vs O(n) scan';

COMMENT ON INDEX idx_invoices_owner_periode IS
  'SOTA 2026: Optimise dashboard propriétaire - filtres période';

COMMENT ON INDEX idx_invoices_tenant_periode IS
  'SOTA 2026: Optimise dashboard locataire - filtres période';

COMMENT ON INDEX idx_invoices_lease_unpaid IS
  'SOTA 2026: Partial index pour factures impayées - relances automatiques';

COMMENT ON INDEX idx_payments_invoice_succeeded IS
  'SOTA 2026: Partial index pour paiements réussis - calcul totaux';

COMMENT ON INDEX idx_cash_receipts_owner_created IS
  'SOTA 2026: Optimise liste reçus propriétaire - pagination';

COMMENT ON INDEX idx_cash_receipts_tenant_created IS
  'SOTA 2026: Optimise liste reçus locataire - pagination';


-- ========== 20260127000000_lease_types_and_inventory.sql ==========
-- ============================================
-- Migration: Types de baux complets + Inventaire mobilier
-- Date: 2026-01-27
-- Description: Ajout des types de baux manquants et de l'inventaire mobilier pour EDL
-- Conformité: Décret 2015-981, Loi ELAN, Code commerce, Code rural
-- ============================================

BEGIN;

-- ============================================
-- 1. MISE À JOUR DE LA CONTRAINTE TYPE_BAIL
-- ============================================

ALTER TABLE leases DROP CONSTRAINT IF EXISTS leases_type_bail_check;

ALTER TABLE leases ADD CONSTRAINT leases_type_bail_check
  CHECK (
    type_bail IN (
      -- Habitation
      'nu',
      'meuble',
      'colocation',
      'saisonnier',
      'bail_mobilite',
      'etudiant',
      'bail_mixte',
      -- Commercial
      'commercial_3_6_9',
      'commercial_derogatoire',
      'professionnel',
      'location_gerance',
      -- Stationnement
      'contrat_parking',
      -- Agricole
      'bail_rural'
    )
  );

COMMENT ON CONSTRAINT leases_type_bail_check ON leases IS
  'Types de baux légaux français - SSOT 2026 - Conforme ALUR, ELAN, Code commerce, Code rural';

-- ============================================
-- 2. TABLE INVENTAIRE MOBILIER (Décret 2015-981)
-- ============================================

CREATE TABLE IF NOT EXISTS edl_furniture_inventory (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_id UUID NOT NULL REFERENCES edl(id) ON DELETE CASCADE,
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,

  -- Statut
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'completed', 'signed')),
  completed_at TIMESTAMPTZ,

  -- Signatures
  signed_by_owner BOOLEAN DEFAULT FALSE,
  signed_by_tenant BOOLEAN DEFAULT FALSE,
  owner_signed_at TIMESTAMPTZ,
  tenant_signed_at TIMESTAMPTZ,

  -- Métadonnées
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(edl_id)
);

-- Index pour recherche rapide
CREATE INDEX IF NOT EXISTS idx_edl_furniture_inventory_edl_id ON edl_furniture_inventory(edl_id);
CREATE INDEX IF NOT EXISTS idx_edl_furniture_inventory_lease_id ON edl_furniture_inventory(lease_id);

COMMENT ON TABLE edl_furniture_inventory IS
  'Inventaire mobilier pour baux meublés - Décret n°2015-981 du 31 juillet 2015';

-- ============================================
-- 3. ÉLÉMENTS OBLIGATOIRES DU MOBILIER
-- ============================================

CREATE TABLE IF NOT EXISTS edl_mandatory_furniture (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  inventory_id UUID NOT NULL REFERENCES edl_furniture_inventory(id) ON DELETE CASCADE,

  -- Clé de l'élément obligatoire (conforme au décret)
  item_key TEXT NOT NULL CHECK (
    item_key IN (
      'literie_couette_couverture',
      'volets_rideaux_chambres',
      'plaques_cuisson',
      'four_ou_micro_ondes',
      'refrigerateur_congelateur',
      'vaisselle_ustensiles',
      'table_sieges',
      'rangements',
      'luminaires',
      'materiel_entretien'
    )
  ),

  -- État de l'élément
  present BOOLEAN NOT NULL DEFAULT FALSE,
  quantity INTEGER DEFAULT 1 CHECK (quantity >= 0),
  condition TEXT CHECK (condition IN ('neuf', 'bon_etat', 'usage', 'mauvais_etat')),
  notes TEXT,
  photo_url TEXT,

  -- Métadonnées
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(inventory_id, item_key)
);

CREATE INDEX IF NOT EXISTS idx_edl_mandatory_furniture_inventory_id ON edl_mandatory_furniture(inventory_id);

COMMENT ON TABLE edl_mandatory_furniture IS
  'Éléments obligatoires selon Article 25-4 de la loi du 6 juillet 1989';

-- ============================================
-- 4. MOBILIER SUPPLÉMENTAIRE
-- ============================================

CREATE TABLE IF NOT EXISTS edl_additional_furniture (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  inventory_id UUID NOT NULL REFERENCES edl_furniture_inventory(id) ON DELETE CASCADE,

  -- Description
  designation TEXT NOT NULL,
  quantity INTEGER NOT NULL DEFAULT 1 CHECK (quantity >= 1),
  condition TEXT NOT NULL CHECK (condition IN ('neuf', 'bon_etat', 'usage', 'mauvais_etat')),
  room TEXT,
  notes TEXT,
  photo_url TEXT,

  -- Métadonnées
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_edl_additional_furniture_inventory_id ON edl_additional_furniture(inventory_id);

COMMENT ON TABLE edl_additional_furniture IS
  'Mobilier supplémentaire au-delà des éléments obligatoires';

-- ============================================
-- 5. DIAGNOSTICS DOM-TOM
-- ============================================

-- Table pour les diagnostics termites (obligatoire en DOM-TOM)
CREATE TABLE IF NOT EXISTS property_diagnostic_termites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,

  -- Informations diagnostiqueur
  diagnostiqueur_nom TEXT NOT NULL,
  diagnostiqueur_certification TEXT,

  -- Dates
  date_realisation DATE NOT NULL,
  date_validite DATE NOT NULL, -- 6 mois de validité

  -- Résultats
  presence_termites BOOLEAN NOT NULL DEFAULT FALSE,
  zones_infestees JSONB, -- Liste des zones affectées
  traitement_realise BOOLEAN DEFAULT FALSE,
  date_traitement DATE,
  type_traitement TEXT,

  -- Localisation
  departement TEXT NOT NULL, -- Code département (971, 972, 973, 974, 976)

  -- Document
  document_url TEXT,

  -- Métadonnées
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_property_diagnostic_termites_property_id ON property_diagnostic_termites(property_id);
CREATE INDEX IF NOT EXISTS idx_property_diagnostic_termites_departement ON property_diagnostic_termites(departement);

COMMENT ON TABLE property_diagnostic_termites IS
  'Diagnostic termites obligatoire en DOM-TOM et zones infestées métropole';

-- Table pour les risques naturels spécifiques DOM-TOM
CREATE TABLE IF NOT EXISTS property_risques_naturels_domtom (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,

  -- Dates
  date_realisation DATE NOT NULL,

  -- Risque cyclonique
  zone_cyclonique TEXT CHECK (zone_cyclonique IN ('forte', 'moyenne', 'faible')),
  construction_paracyclonique BOOLEAN,

  -- Risque sismique (zones 3, 4, 5 pour DOM-TOM)
  zone_sismique TEXT CHECK (zone_sismique IN ('3', '4', '5')),
  norme_parasismique BOOLEAN,

  -- Risque volcanique
  zone_volcanique BOOLEAN DEFAULT FALSE,
  proximite_volcan_actif BOOLEAN DEFAULT FALSE,

  -- Risque tsunami
  zone_tsunami BOOLEAN DEFAULT FALSE,

  -- Mouvements de terrain
  zone_mouvement_terrain BOOLEAN DEFAULT FALSE,
  type_mouvement TEXT CHECK (type_mouvement IN ('glissement', 'eboulement', 'affaissement')),

  -- Inondations
  zone_inondation BOOLEAN DEFAULT FALSE,
  niveau_risque_inondation TEXT CHECK (niveau_risque_inondation IN ('fort', 'moyen', 'faible')),

  -- Document
  document_url TEXT,

  -- Métadonnées
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(property_id)
);

CREATE INDEX IF NOT EXISTS idx_property_risques_naturels_domtom_property_id ON property_risques_naturels_domtom(property_id);

COMMENT ON TABLE property_risques_naturels_domtom IS
  'Risques naturels spécifiques aux DOM-TOM (cyclones, séismes, volcans, tsunamis)';

-- ============================================
-- 6. FONCTION POUR INITIALISER L'INVENTAIRE
-- ============================================

CREATE OR REPLACE FUNCTION initialize_furniture_inventory(p_edl_id UUID, p_lease_id UUID)
RETURNS UUID AS $$
DECLARE
  v_inventory_id UUID;
  v_item_key TEXT;
BEGIN
  -- Créer l'inventaire
  INSERT INTO edl_furniture_inventory (edl_id, lease_id)
  VALUES (p_edl_id, p_lease_id)
  ON CONFLICT (edl_id) DO UPDATE SET updated_at = NOW()
  RETURNING id INTO v_inventory_id;

  -- Initialiser les éléments obligatoires
  FOR v_item_key IN
    SELECT unnest(ARRAY[
      'literie_couette_couverture',
      'volets_rideaux_chambres',
      'plaques_cuisson',
      'four_ou_micro_ondes',
      'refrigerateur_congelateur',
      'vaisselle_ustensiles',
      'table_sieges',
      'rangements',
      'luminaires',
      'materiel_entretien'
    ])
  LOOP
    INSERT INTO edl_mandatory_furniture (inventory_id, item_key, present, quantity, condition)
    VALUES (v_inventory_id, v_item_key, FALSE, 1, 'bon_etat')
    ON CONFLICT (inventory_id, item_key) DO NOTHING;
  END LOOP;

  RETURN v_inventory_id;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION initialize_furniture_inventory IS
  'Initialise un inventaire mobilier avec les 10 éléments obligatoires du décret 2015-981';

-- ============================================
-- 7. TRIGGER POUR MISE À JOUR AUTOMATIQUE
-- ============================================

CREATE OR REPLACE FUNCTION update_furniture_inventory_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_edl_furniture_inventory_updated ON edl_furniture_inventory;
CREATE TRIGGER trg_edl_furniture_inventory_updated
  BEFORE UPDATE ON edl_furniture_inventory
  FOR EACH ROW
  EXECUTE FUNCTION update_furniture_inventory_timestamp();

DROP TRIGGER IF EXISTS trg_edl_mandatory_furniture_updated ON edl_mandatory_furniture;
CREATE TRIGGER trg_edl_mandatory_furniture_updated
  BEFORE UPDATE ON edl_mandatory_furniture
  FOR EACH ROW
  EXECUTE FUNCTION update_furniture_inventory_timestamp();

DROP TRIGGER IF EXISTS trg_edl_additional_furniture_updated ON edl_additional_furniture;
CREATE TRIGGER trg_edl_additional_furniture_updated
  BEFORE UPDATE ON edl_additional_furniture
  FOR EACH ROW
  EXECUTE FUNCTION update_furniture_inventory_timestamp();

-- ============================================
-- 8. RLS POLICIES
-- ============================================

ALTER TABLE edl_furniture_inventory ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_mandatory_furniture ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_additional_furniture ENABLE ROW LEVEL SECURITY;
ALTER TABLE property_diagnostic_termites ENABLE ROW LEVEL SECURITY;
ALTER TABLE property_risques_naturels_domtom ENABLE ROW LEVEL SECURITY;

-- Policies pour edl_furniture_inventory
CREATE POLICY "Owners can manage furniture inventory for their leases" ON edl_furniture_inventory
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = edl_furniture_inventory.lease_id
      AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "Tenants can view furniture inventory for their leases" ON edl_furniture_inventory
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM lease_signers ls
      WHERE ls.lease_id = edl_furniture_inventory.lease_id
      AND ls.profile_id = auth.uid()
    )
  );

-- Policies pour edl_mandatory_furniture
CREATE POLICY "Users can manage mandatory furniture via inventory" ON edl_mandatory_furniture
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM edl_furniture_inventory fi
      JOIN leases l ON fi.lease_id = l.id
      JOIN properties p ON l.property_id = p.id
      WHERE fi.id = edl_mandatory_furniture.inventory_id
      AND (p.owner_id = auth.uid() OR EXISTS (
        SELECT 1 FROM lease_signers ls WHERE ls.lease_id = l.id AND ls.profile_id = auth.uid()
      ))
    )
  );

-- Policies pour edl_additional_furniture
CREATE POLICY "Users can manage additional furniture via inventory" ON edl_additional_furniture
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM edl_furniture_inventory fi
      JOIN leases l ON fi.lease_id = l.id
      JOIN properties p ON l.property_id = p.id
      WHERE fi.id = edl_additional_furniture.inventory_id
      AND (p.owner_id = auth.uid() OR EXISTS (
        SELECT 1 FROM lease_signers ls WHERE ls.lease_id = l.id AND ls.profile_id = auth.uid()
      ))
    )
  );

-- Policies pour diagnostics termites
CREATE POLICY "Owners can manage termites diagnostics" ON property_diagnostic_termites
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = property_diagnostic_termites.property_id
      AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "Tenants can view termites diagnostics" ON property_diagnostic_termites
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN lease_signers ls ON l.id = ls.lease_id
      WHERE l.property_id = property_diagnostic_termites.property_id
      AND ls.profile_id = auth.uid()
    )
  );

-- Policies pour risques naturels DOM-TOM
CREATE POLICY "Owners can manage risques naturels domtom" ON property_risques_naturels_domtom
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = property_risques_naturels_domtom.property_id
      AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "Tenants can view risques naturels domtom" ON property_risques_naturels_domtom
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN lease_signers ls ON l.id = ls.lease_id
      WHERE l.property_id = property_risques_naturels_domtom.property_id
      AND ls.profile_id = auth.uid()
    )
  );

-- ============================================
-- 9. VÉRIFICATION
-- ============================================

DO $$
BEGIN
  RAISE NOTICE 'Migration 20260127000000_lease_types_and_inventory completed successfully';
  RAISE NOTICE 'New lease types: etudiant, bail_mixte, bail_rural added';
  RAISE NOTICE 'Furniture inventory tables created (Décret 2015-981)';
  RAISE NOTICE 'DOM-TOM diagnostics tables created (termites, risques naturels)';
END $$;

COMMIT;


-- ========== 20260127000000_stripe_connect_accounts.sql ==========
-- Migration: Stripe Connect pour les reversements aux propriétaires
-- Date: 2026-01-27
-- Description: Ajoute le support de Stripe Connect Express pour les paiements directs aux propriétaires

-- Table des comptes Stripe Connect
CREATE TABLE IF NOT EXISTS stripe_connect_accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  stripe_account_id TEXT NOT NULL UNIQUE,
  account_type TEXT NOT NULL DEFAULT 'express' CHECK (account_type IN ('express', 'standard', 'custom')),

  -- Statut du compte
  charges_enabled BOOLEAN DEFAULT FALSE,
  payouts_enabled BOOLEAN DEFAULT FALSE,
  details_submitted BOOLEAN DEFAULT FALSE,

  -- Informations KYC
  requirements_currently_due JSONB DEFAULT '[]',
  requirements_eventually_due JSONB DEFAULT '[]',
  requirements_past_due JSONB DEFAULT '[]',
  requirements_disabled_reason TEXT,

  -- Informations bancaires (masquées)
  bank_account_last4 TEXT,
  bank_account_bank_name TEXT,
  default_currency TEXT DEFAULT 'eur',

  -- Métadonnées
  business_type TEXT CHECK (business_type IN ('individual', 'company')),
  country TEXT DEFAULT 'FR',

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  onboarding_completed_at TIMESTAMPTZ,

  CONSTRAINT unique_profile_connect UNIQUE (profile_id)
);

-- Index pour les recherches
CREATE INDEX IF NOT EXISTS idx_stripe_connect_profile ON stripe_connect_accounts(profile_id);
CREATE INDEX IF NOT EXISTS idx_stripe_connect_stripe_id ON stripe_connect_accounts(stripe_account_id);
CREATE INDEX IF NOT EXISTS idx_stripe_connect_charges_enabled ON stripe_connect_accounts(charges_enabled) WHERE charges_enabled = TRUE;

-- Table des transferts vers les propriétaires
CREATE TABLE IF NOT EXISTS stripe_transfers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  connect_account_id UUID NOT NULL REFERENCES stripe_connect_accounts(id),
  payment_id UUID REFERENCES payments(id),
  invoice_id UUID REFERENCES invoices(id),

  -- Identifiants Stripe
  stripe_transfer_id TEXT NOT NULL UNIQUE,
  stripe_payment_intent_id TEXT,

  -- Montants
  amount INTEGER NOT NULL, -- en centimes
  currency TEXT DEFAULT 'eur',
  platform_fee INTEGER DEFAULT 0, -- commission Talok en centimes
  stripe_fee INTEGER DEFAULT 0, -- frais Stripe en centimes
  net_amount INTEGER NOT NULL, -- montant net pour le propriétaire

  -- Statut
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'paid', 'failed', 'canceled', 'reversed')),
  failure_reason TEXT,

  -- Métadonnées
  description TEXT,
  metadata JSONB DEFAULT '{}',

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,

  CONSTRAINT positive_amounts CHECK (amount > 0 AND net_amount > 0)
);

-- Index pour les transferts
CREATE INDEX IF NOT EXISTS idx_transfers_connect ON stripe_transfers(connect_account_id);
CREATE INDEX IF NOT EXISTS idx_transfers_payment ON stripe_transfers(payment_id);
CREATE INDEX IF NOT EXISTS idx_transfers_status ON stripe_transfers(status);
CREATE INDEX IF NOT EXISTS idx_transfers_created ON stripe_transfers(created_at DESC);

-- RLS Policies
ALTER TABLE stripe_connect_accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE stripe_transfers ENABLE ROW LEVEL SECURITY;

-- Propriétaires peuvent voir leur propre compte Connect
CREATE POLICY "Owners can view own connect account" ON stripe_connect_accounts
  FOR SELECT USING (profile_id = auth.uid() OR EXISTS (
    SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'
  ));

-- Propriétaires peuvent créer leur compte Connect
CREATE POLICY "Owners can create own connect account" ON stripe_connect_accounts
  FOR INSERT WITH CHECK (profile_id = auth.uid());

-- Service role peut tout faire
CREATE POLICY "Service role full access connect" ON stripe_connect_accounts
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

-- Propriétaires peuvent voir leurs transferts
CREATE POLICY "Owners can view own transfers" ON stripe_transfers
  FOR SELECT USING (
    connect_account_id IN (
      SELECT id FROM stripe_connect_accounts WHERE profile_id = auth.uid()
    ) OR EXISTS (
      SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'
    )
  );

-- Service role peut tout faire sur les transferts
CREATE POLICY "Service role full access transfers" ON stripe_transfers
  FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

-- Trigger pour updated_at
CREATE TRIGGER update_stripe_connect_timestamp
  BEFORE UPDATE ON stripe_connect_accounts
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Fonction pour obtenir le compte Connect d'un propriétaire par property_id
CREATE OR REPLACE FUNCTION get_property_owner_connect_account(property_id UUID)
RETURNS TABLE (
  connect_account_id UUID,
  stripe_account_id TEXT,
  charges_enabled BOOLEAN,
  payouts_enabled BOOLEAN
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    sca.id,
    sca.stripe_account_id,
    sca.charges_enabled,
    sca.payouts_enabled
  FROM stripe_connect_accounts sca
  JOIN properties p ON p.owner_id = sca.profile_id
  WHERE p.id = property_id
  LIMIT 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Commentaires
COMMENT ON TABLE stripe_connect_accounts IS 'Comptes Stripe Connect des propriétaires pour les reversements directs';
COMMENT ON TABLE stripe_transfers IS 'Historique des transferts vers les propriétaires via Stripe Connect';
COMMENT ON FUNCTION get_property_owner_connect_account IS 'Récupère le compte Connect du propriétaire d''une propriété';


-- ========== 20260127000001_gap001_block_dg_bail_mobilite.sql ==========
-- ============================================
-- GAP-001: Bloquer dépôt de garantie pour bail mobilité
-- Article 25-13 de la Loi ELAN (2018)
-- ============================================
--
-- Cette migration ajoute une contrainte CHECK au niveau base de données
-- pour garantir qu'aucun bail mobilité ne puisse avoir un dépôt de garantie.
--
-- Référence légale:
-- "Le contrat de bail mobilité ne peut pas prévoir le versement d'un dépôt de garantie"
-- - Article 25-13 de la loi n° 2018-1021 du 23 novembre 2018 (Loi ELAN)

-- Ajouter la contrainte CHECK sur la table leases
ALTER TABLE leases
ADD CONSTRAINT chk_bail_mobilite_no_deposit
CHECK (
  type_bail != 'bail_mobilite' OR depot_de_garantie IS NULL OR depot_de_garantie = 0
);

-- Commentaire explicatif sur la contrainte
COMMENT ON CONSTRAINT chk_bail_mobilite_no_deposit ON leases IS
'Article 25-13 Loi ELAN: Le bail mobilité ne peut pas comporter de dépôt de garantie';

-- Mettre à jour les baux mobilité existants qui auraient un dépôt (correction des données)
UPDATE leases
SET depot_de_garantie = 0
WHERE type_bail = 'bail_mobilite' AND depot_de_garantie > 0;


-- ========== 20260127000002_gap002_furniture_inventory.sql ==========
-- ============================================
-- GAP-002: Inventaire meublé pour EDL
-- Décret n°2015-981 du 31/07/2015
-- ============================================
--
-- Cette migration crée la table pour stocker l'inventaire du mobilier
-- lors des états des lieux pour les baux meublés et mobilité.
--
-- Référence légale:
-- "L'état des lieux doit être accompagné d'un inventaire détaillé du mobilier"
-- - Décret n°2015-981 du 31 juillet 2015

-- Type enum pour les catégories de mobilier
CREATE TYPE furniture_category AS ENUM (
  'literie',
  'occultation',
  'cuisine',
  'rangement',
  'luminaire',
  'vaisselle',
  'entretien'
);

-- Type enum pour l'état du mobilier
CREATE TYPE furniture_condition AS ENUM (
  'neuf',
  'tres_bon',
  'bon',
  'usage',
  'mauvais',
  'absent'
);

-- Table principale des inventaires de mobilier
CREATE TABLE IF NOT EXISTS furniture_inventories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_id UUID NOT NULL REFERENCES etats_des_lieux(id) ON DELETE CASCADE,
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('entree', 'sortie')),
  is_complete BOOLEAN DEFAULT FALSE,
  total_items INTEGER DEFAULT 0,
  items_present INTEGER DEFAULT 0,
  items_missing INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(edl_id) -- Un seul inventaire par EDL
);

-- Table des items de mobilier
CREATE TABLE IF NOT EXISTS furniture_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  inventory_id UUID NOT NULL REFERENCES furniture_inventories(id) ON DELETE CASCADE,
  category furniture_category NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  legal_requirement TEXT, -- Référence légale (ex: "Décret 2015-981 Art.2 - 1°")
  is_mandatory BOOLEAN DEFAULT FALSE,
  quantity INTEGER DEFAULT 1,
  condition furniture_condition NOT NULL DEFAULT 'bon',
  notes TEXT,
  photos TEXT[], -- URLs des photos
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index pour les requêtes fréquentes
CREATE INDEX idx_furniture_inventories_edl_id ON furniture_inventories(edl_id);
CREATE INDEX idx_furniture_inventories_lease_id ON furniture_inventories(lease_id);
CREATE INDEX idx_furniture_items_inventory_id ON furniture_items(inventory_id);
CREATE INDEX idx_furniture_items_category ON furniture_items(category);
CREATE INDEX idx_furniture_items_condition ON furniture_items(condition);

-- Trigger pour mettre à jour updated_at
CREATE OR REPLACE FUNCTION update_furniture_inventory_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_furniture_inventories_updated_at
  BEFORE UPDATE ON furniture_inventories
  FOR EACH ROW
  EXECUTE FUNCTION update_furniture_inventory_updated_at();

CREATE TRIGGER trigger_furniture_items_updated_at
  BEFORE UPDATE ON furniture_items
  FOR EACH ROW
  EXECUTE FUNCTION update_furniture_inventory_updated_at();

-- Trigger pour calculer automatiquement les compteurs de l'inventaire
CREATE OR REPLACE FUNCTION update_inventory_counts()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE furniture_inventories
  SET
    total_items = (
      SELECT COUNT(*) FROM furniture_items WHERE inventory_id = COALESCE(NEW.inventory_id, OLD.inventory_id)
    ),
    items_present = (
      SELECT COUNT(*) FROM furniture_items
      WHERE inventory_id = COALESCE(NEW.inventory_id, OLD.inventory_id)
      AND condition != 'absent'
    ),
    items_missing = (
      SELECT COUNT(*) FROM furniture_items
      WHERE inventory_id = COALESCE(NEW.inventory_id, OLD.inventory_id)
      AND condition = 'absent'
      AND is_mandatory = TRUE
    ),
    is_complete = (
      SELECT NOT EXISTS (
        SELECT 1 FROM furniture_items
        WHERE inventory_id = COALESCE(NEW.inventory_id, OLD.inventory_id)
        AND condition = 'absent'
        AND is_mandatory = TRUE
      )
    )
  WHERE id = COALESCE(NEW.inventory_id, OLD.inventory_id);

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_inventory_counts_insert
  AFTER INSERT ON furniture_items
  FOR EACH ROW
  EXECUTE FUNCTION update_inventory_counts();

CREATE TRIGGER trigger_update_inventory_counts_update
  AFTER UPDATE ON furniture_items
  FOR EACH ROW
  EXECUTE FUNCTION update_inventory_counts();

CREATE TRIGGER trigger_update_inventory_counts_delete
  AFTER DELETE ON furniture_items
  FOR EACH ROW
  EXECUTE FUNCTION update_inventory_counts();

-- RLS Policies
ALTER TABLE furniture_inventories ENABLE ROW LEVEL SECURITY;
ALTER TABLE furniture_items ENABLE ROW LEVEL SECURITY;

-- Policy: Les propriétaires peuvent gérer les inventaires de leurs baux
CREATE POLICY furniture_inventories_owner_policy ON furniture_inventories
  FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = furniture_inventories.lease_id
      AND p.owner_id = auth.uid()
    )
  );

-- Policy: Les locataires peuvent voir les inventaires de leurs baux
CREATE POLICY furniture_inventories_tenant_policy ON furniture_inventories
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM leases l
      WHERE l.id = furniture_inventories.lease_id
      AND l.tenant_id = auth.uid()
    )
  );

-- Policy: Les propriétaires peuvent gérer les items de leurs inventaires
CREATE POLICY furniture_items_owner_policy ON furniture_items
  FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM furniture_inventories fi
      JOIN leases l ON fi.lease_id = l.id
      JOIN properties p ON l.property_id = p.id
      WHERE fi.id = furniture_items.inventory_id
      AND p.owner_id = auth.uid()
    )
  );

-- Policy: Les locataires peuvent voir les items de leurs inventaires
CREATE POLICY furniture_items_tenant_policy ON furniture_items
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM furniture_inventories fi
      JOIN leases l ON fi.lease_id = l.id
      WHERE fi.id = furniture_items.inventory_id
      AND l.tenant_id = auth.uid()
    )
  );

-- Commentaires
COMMENT ON TABLE furniture_inventories IS 'Inventaires de mobilier pour EDL (Décret 2015-981)';
COMMENT ON TABLE furniture_items IS 'Items de mobilier dans les inventaires';
COMMENT ON COLUMN furniture_items.legal_requirement IS 'Référence légale de l''obligation (ex: Décret 2015-981 Art.2)';
COMMENT ON COLUMN furniture_items.is_mandatory IS 'Si true, l''item est obligatoire selon le décret';


-- ========== 20260127000002_vetusty_grid_tables.sql ==========
-- ============================================================================
-- MIGRATION: Tables pour la grille de vétusté (GAP-002)
-- Date: 2026-01-27
-- Description: Implémentation de la grille de vétusté pour le calcul des
--              retenues sur dépôt de garantie conformément aux accords collectifs
-- ============================================================================

-- 1. Table des rapports de vétusté
-- Un rapport par fin de bail, liant EDL entrée et sortie
CREATE TABLE IF NOT EXISTS vetusty_reports (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
  edl_entry_id UUID REFERENCES edl(id) ON DELETE SET NULL,
  edl_exit_id UUID REFERENCES edl(id) ON DELETE SET NULL,
  settlement_id UUID REFERENCES dg_settlements(id) ON DELETE SET NULL,

  -- Dates de référence
  edl_entry_date DATE NOT NULL,
  edl_exit_date DATE NOT NULL,
  lease_duration_years DECIMAL(4, 1) NOT NULL,

  -- Résumé financier
  total_items INTEGER NOT NULL DEFAULT 0,
  total_repair_cost DECIMAL(10, 2) NOT NULL DEFAULT 0,
  total_owner_share DECIMAL(10, 2) NOT NULL DEFAULT 0,
  total_tenant_share DECIMAL(10, 2) NOT NULL DEFAULT 0,
  average_vetusty_rate DECIMAL(5, 2) NOT NULL DEFAULT 0,

  -- Métadonnées
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'validated', 'contested', 'final')),
  validated_at TIMESTAMPTZ,
  validated_by UUID REFERENCES profiles(id),
  contested_at TIMESTAMPTZ,
  contest_reason TEXT,
  notes TEXT,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by UUID REFERENCES profiles(id)
);

-- Index pour les performances
CREATE INDEX IF NOT EXISTS idx_vetusty_reports_lease_id ON vetusty_reports(lease_id);
CREATE INDEX IF NOT EXISTS idx_vetusty_reports_settlement_id ON vetusty_reports(settlement_id);
CREATE INDEX IF NOT EXISTS idx_vetusty_reports_status ON vetusty_reports(status);

-- 2. Table des éléments de vétusté calculés
-- Détail de chaque élément avec le calcul
CREATE TABLE IF NOT EXISTS vetusty_items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  report_id UUID NOT NULL REFERENCES vetusty_reports(id) ON DELETE CASCADE,

  -- Référence à l'élément de la grille
  vetusty_grid_item_id TEXT NOT NULL, -- ID de l'élément dans VETUSTY_GRID
  item_name TEXT NOT NULL,
  category TEXT NOT NULL,

  -- Données pour le calcul
  age_years DECIMAL(4, 1) NOT NULL,
  lifespan_years INTEGER NOT NULL,
  franchise_years INTEGER NOT NULL,

  -- Résultat du calcul
  vetusty_rate DECIMAL(5, 2) NOT NULL, -- Taux de vétusté (0-100)
  repair_cost DECIMAL(10, 2) NOT NULL,
  owner_share DECIMAL(10, 2) NOT NULL,
  tenant_share DECIMAL(10, 2) NOT NULL,

  -- Lien avec EDL si applicable
  edl_entry_item_id UUID, -- Référence à l'item EDL d'entrée
  edl_exit_item_id UUID,  -- Référence à l'item EDL de sortie
  room_name TEXT,

  -- Justificatifs
  is_degradation BOOLEAN NOT NULL DEFAULT true, -- Dégradation vs usure normale
  notes TEXT,
  photo_urls TEXT[], -- URLs des photos justificatives
  invoice_url TEXT, -- URL du devis/facture

  -- Contestation
  is_contested BOOLEAN NOT NULL DEFAULT false,
  contest_reason TEXT,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour les performances
CREATE INDEX IF NOT EXISTS idx_vetusty_items_report_id ON vetusty_items(report_id);
CREATE INDEX IF NOT EXISTS idx_vetusty_items_category ON vetusty_items(category);
CREATE INDEX IF NOT EXISTS idx_vetusty_items_is_contested ON vetusty_items(is_contested);

-- 3. Table historique des grilles de vétusté utilisées
-- Pour traçabilité en cas de mise à jour de la grille
CREATE TABLE IF NOT EXISTS vetusty_grid_versions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  version TEXT NOT NULL UNIQUE,
  effective_date DATE NOT NULL,
  description TEXT,
  grid_data JSONB NOT NULL, -- Snapshot de la grille
  is_current BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Insérer la version actuelle de la grille
INSERT INTO vetusty_grid_versions (version, effective_date, description, grid_data, is_current)
VALUES (
  '2026.1',
  '2026-01-27',
  'Grille de vétusté initiale basée sur les accords collectifs ANIL/FNAIM/UNPI',
  '{"source": "accords_collectifs", "items_count": 55}'::jsonb,
  true
) ON CONFLICT (version) DO NOTHING;

-- 4. Trigger pour mettre à jour updated_at
CREATE TRIGGER update_vetusty_reports_updated_at
  BEFORE UPDATE ON vetusty_reports
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_vetusty_items_updated_at
  BEFORE UPDATE ON vetusty_items
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- 5. Fonction pour calculer automatiquement les totaux du rapport
CREATE OR REPLACE FUNCTION update_vetusty_report_totals()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE vetusty_reports
  SET
    total_items = (SELECT COUNT(*) FROM vetusty_items WHERE report_id = COALESCE(NEW.report_id, OLD.report_id)),
    total_repair_cost = (SELECT COALESCE(SUM(repair_cost), 0) FROM vetusty_items WHERE report_id = COALESCE(NEW.report_id, OLD.report_id)),
    total_owner_share = (SELECT COALESCE(SUM(owner_share), 0) FROM vetusty_items WHERE report_id = COALESCE(NEW.report_id, OLD.report_id)),
    total_tenant_share = (SELECT COALESCE(SUM(tenant_share), 0) FROM vetusty_items WHERE report_id = COALESCE(NEW.report_id, OLD.report_id)),
    average_vetusty_rate = (
      SELECT CASE
        WHEN SUM(repair_cost) > 0
        THEN SUM(vetusty_rate * repair_cost) / SUM(repair_cost)
        ELSE 0
      END
      FROM vetusty_items
      WHERE report_id = COALESCE(NEW.report_id, OLD.report_id)
    ),
    updated_at = NOW()
  WHERE id = COALESCE(NEW.report_id, OLD.report_id);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_vetusty_report_totals_insert
  AFTER INSERT ON vetusty_items
  FOR EACH ROW EXECUTE FUNCTION update_vetusty_report_totals();

CREATE TRIGGER trigger_update_vetusty_report_totals_update
  AFTER UPDATE ON vetusty_items
  FOR EACH ROW EXECUTE FUNCTION update_vetusty_report_totals();

CREATE TRIGGER trigger_update_vetusty_report_totals_delete
  AFTER DELETE ON vetusty_items
  FOR EACH ROW EXECUTE FUNCTION update_vetusty_report_totals();

-- 6. RLS Policies
ALTER TABLE vetusty_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE vetusty_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE vetusty_grid_versions ENABLE ROW LEVEL SECURITY;

-- Lecture des rapports : propriétaire du bien ou locataire concerné
CREATE POLICY "vetusty_reports_select_policy" ON vetusty_reports
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = vetusty_reports.lease_id
      AND (
        p.owner_id = auth.uid()
        OR EXISTS (
          SELECT 1 FROM lease_signers ls
          WHERE ls.lease_id = l.id
          AND ls.profile_id = auth.uid()
        )
      )
    )
  );

-- Création/modification : propriétaire uniquement
CREATE POLICY "vetusty_reports_insert_policy" ON vetusty_reports
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = vetusty_reports.lease_id
      AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "vetusty_reports_update_policy" ON vetusty_reports
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = vetusty_reports.lease_id
      AND p.owner_id = auth.uid()
    )
  );

-- Items de vétusté : mêmes règles via le rapport
CREATE POLICY "vetusty_items_select_policy" ON vetusty_items
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM vetusty_reports vr
      JOIN leases l ON vr.lease_id = l.id
      JOIN properties p ON l.property_id = p.id
      WHERE vr.id = vetusty_items.report_id
      AND (
        p.owner_id = auth.uid()
        OR EXISTS (
          SELECT 1 FROM lease_signers ls
          WHERE ls.lease_id = l.id
          AND ls.profile_id = auth.uid()
        )
      )
    )
  );

CREATE POLICY "vetusty_items_insert_policy" ON vetusty_items
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM vetusty_reports vr
      JOIN leases l ON vr.lease_id = l.id
      JOIN properties p ON l.property_id = p.id
      WHERE vr.id = vetusty_items.report_id
      AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "vetusty_items_update_policy" ON vetusty_items
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM vetusty_reports vr
      JOIN leases l ON vr.lease_id = l.id
      JOIN properties p ON l.property_id = p.id
      WHERE vr.id = vetusty_items.report_id
      AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "vetusty_items_delete_policy" ON vetusty_items
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM vetusty_reports vr
      JOIN leases l ON vr.lease_id = l.id
      JOIN properties p ON l.property_id = p.id
      WHERE vr.id = vetusty_items.report_id
      AND p.owner_id = auth.uid()
      AND vr.status = 'draft'
    )
  );

-- Grille de vétusté : lecture publique
CREATE POLICY "vetusty_grid_versions_select_policy" ON vetusty_grid_versions
  FOR SELECT USING (true);

-- 7. Commentaires
COMMENT ON TABLE vetusty_reports IS 'Rapports de calcul de vétusté pour les fins de bail';
COMMENT ON TABLE vetusty_items IS 'Éléments individuels du calcul de vétusté';
COMMENT ON TABLE vetusty_grid_versions IS 'Historique des versions de la grille de vétusté';

COMMENT ON COLUMN vetusty_items.vetusty_rate IS 'Taux de vétusté calculé (0-100%), représente la part d''usure normale';
COMMENT ON COLUMN vetusty_items.owner_share IS 'Part du coût à charge du propriétaire (vétusté/usure normale)';
COMMENT ON COLUMN vetusty_items.tenant_share IS 'Part du coût à charge du locataire (dégradations anormales)';


-- ========== 20260127000003_commercial_lease_types.sql ==========
-- Migration: Ajout des types de baux commerciaux
-- GAP-003: Support des baux commerciaux (3/6/9 et dérogatoire)
-- Conforme au Code de commerce (Articles L145-1 à L145-60)

-- =============================================================================
-- 1. EXTENSION DU TYPE ENUM lease_type
-- =============================================================================

-- Ajouter les nouveaux types de bail si pas déjà présents
DO $$
BEGIN
  -- Bail commercial 3/6/9
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum
    WHERE enumlabel = 'commercial'
    AND enumtypid = (SELECT oid FROM pg_type WHERE typname = 'lease_type')
  ) THEN
    ALTER TYPE lease_type ADD VALUE IF NOT EXISTS 'commercial';
  END IF;

  -- Bail dérogatoire (précaire)
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum
    WHERE enumlabel = 'commercial_derogatoire'
    AND enumtypid = (SELECT oid FROM pg_type WHERE typname = 'lease_type')
  ) THEN
    ALTER TYPE lease_type ADD VALUE IF NOT EXISTS 'commercial_derogatoire';
  END IF;

  -- Bail professionnel (pour les professions libérales)
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum
    WHERE enumlabel = 'professionnel'
    AND enumtypid = (SELECT oid FROM pg_type WHERE typname = 'lease_type')
  ) THEN
    ALTER TYPE lease_type ADD VALUE IF NOT EXISTS 'professionnel';
  END IF;
END$$;

-- =============================================================================
-- 2. TABLE: commercial_lease_details
-- Détails spécifiques aux baux commerciaux
-- =============================================================================

CREATE TABLE IF NOT EXISTS commercial_lease_details (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,

  -- Destination des locaux (Article L145-47)
  destination_clause TEXT NOT NULL,
  activite_principale TEXT NOT NULL,
  activites_connexes TEXT,
  clause_tous_commerces BOOLEAN DEFAULT FALSE,
  despecialisation_partielle_autorisee BOOLEAN DEFAULT TRUE,
  code_ape VARCHAR(10),

  -- Durée et périodes triennales
  duree_ferme_mois INTEGER, -- Pour bail dérogatoire: durée ferme
  renonciation_triennale BOOLEAN DEFAULT FALSE,
  renonciation_motif TEXT,

  -- Loyer et indexation
  loyer_annuel_ht DECIMAL(12,2) NOT NULL,
  tva_applicable BOOLEAN DEFAULT TRUE,
  tva_taux DECIMAL(5,2) DEFAULT 20.00,
  indice_type VARCHAR(10) DEFAULT 'ILC', -- ILC, ILAT, ICC
  indice_base DECIMAL(10,2),
  indice_trimestre_base VARCHAR(20),
  plafonnement_revision BOOLEAN DEFAULT TRUE,

  -- Pas-de-porte / Droit d'entrée
  pas_de_porte_montant DECIMAL(12,2),
  pas_de_porte_nature VARCHAR(50), -- 'supplement_loyer', 'indemnite'
  pas_de_porte_tva DECIMAL(12,2),

  -- Droit au bail
  droit_au_bail_valeur DECIMAL(12,2),

  -- Garanties spécifiques
  garantie_bancaire_type VARCHAR(50),
  garantie_bancaire_montant DECIMAL(12,2),
  garantie_bancaire_banque VARCHAR(255),
  garantie_bancaire_duree_mois INTEGER,

  -- Caution solidaire
  caution_solidaire BOOLEAN DEFAULT FALSE,
  caution_nom VARCHAR(255),
  caution_siret VARCHAR(14),
  caution_adresse TEXT,
  caution_montant_engagement DECIMAL(12,2),
  caution_duree_mois INTEGER,

  -- Cession et sous-location
  cession_libre BOOLEAN DEFAULT FALSE,
  droit_preemption_bailleur BOOLEAN DEFAULT FALSE,
  sous_location_autorisee BOOLEAN DEFAULT FALSE,
  garantie_solidaire_cedant BOOLEAN DEFAULT TRUE,
  garantie_cedant_duree_mois INTEGER DEFAULT 36,

  -- Charges (répartition Loi Pinel)
  taxe_fonciere_preneur BOOLEAN DEFAULT FALSE,
  taxe_bureaux_preneur BOOLEAN DEFAULT FALSE,
  charges_copro_fonct_preneur BOOLEAN DEFAULT TRUE,

  -- Travaux
  accession_ameliorations BOOLEAN DEFAULT TRUE,
  travaux_bailleur_liste TEXT,

  -- Clause résolutoire
  clause_resolutoire_delai_jours INTEGER DEFAULT 30,

  -- Métadonnées
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(lease_id)
);

-- Index pour performance
CREATE INDEX IF NOT EXISTS idx_commercial_lease_details_lease_id
  ON commercial_lease_details(lease_id);

-- =============================================================================
-- 3. TABLE: commercial_lease_triennial_periods
-- Historique des périodes triennales
-- =============================================================================

CREATE TABLE IF NOT EXISTS commercial_lease_triennial_periods (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,

  period_number INTEGER NOT NULL, -- 1, 2, 3
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  resignation_deadline DATE NOT NULL, -- Date limite pour donner congé

  -- Statut de la période
  resignation_given BOOLEAN DEFAULT FALSE,
  resignation_date DATE,
  resignation_by VARCHAR(20), -- 'preneur', 'bailleur'

  -- Loyer applicable pendant cette période
  loyer_annuel_ht DECIMAL(12,2),
  indice_revision DECIMAL(10,2),

  created_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(lease_id, period_number)
);

CREATE INDEX IF NOT EXISTS idx_commercial_triennial_lease_id
  ON commercial_lease_triennial_periods(lease_id);

-- =============================================================================
-- 4. TABLE: derogatoire_lease_history
-- Historique des baux dérogatoires successifs (contrôle des 3 ans max)
-- =============================================================================

CREATE TABLE IF NOT EXISTS derogatoire_lease_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,

  -- Preneur (peut être différent pour chaque bail)
  preneur_type VARCHAR(20) NOT NULL, -- 'personne_physique', 'personne_morale'
  preneur_nom VARCHAR(255) NOT NULL,
  preneur_siret VARCHAR(14),

  -- Période du bail
  lease_id UUID REFERENCES leases(id) ON DELETE SET NULL,
  date_debut DATE NOT NULL,
  date_fin DATE NOT NULL,
  duree_mois INTEGER NOT NULL,

  -- Pour vérification de la limite des 3 ans
  duree_cumulee_avant_mois INTEGER DEFAULT 0,
  duree_cumulee_apres_mois INTEGER NOT NULL,

  -- Alerte si proche de la limite
  alerte_limite_3_ans BOOLEAN DEFAULT FALSE,

  created_at TIMESTAMPTZ DEFAULT NOW(),

  CONSTRAINT check_duree_max CHECK (duree_cumulee_apres_mois <= 36)
);

CREATE INDEX IF NOT EXISTS idx_derogatoire_history_property
  ON derogatoire_lease_history(property_id);

-- =============================================================================
-- 5. FONCTION: Calcul automatique des périodes triennales
-- =============================================================================

CREATE OR REPLACE FUNCTION generate_triennial_periods()
RETURNS TRIGGER AS $$
DECLARE
  v_start_date DATE;
  v_period_start DATE;
  v_period_end DATE;
  v_resignation_deadline DATE;
  v_loyer DECIMAL(12,2);
BEGIN
  -- Seulement pour les baux commerciaux 3/6/9
  IF NEW.type != 'commercial' THEN
    RETURN NEW;
  END IF;

  -- Récupérer la date de début et le loyer
  v_start_date := NEW.start_date;

  SELECT loyer_annuel_ht INTO v_loyer
  FROM commercial_lease_details
  WHERE lease_id = NEW.id;

  -- Générer les 3 périodes triennales
  FOR i IN 1..3 LOOP
    v_period_start := v_start_date + ((i-1) * INTERVAL '3 years');
    v_period_end := v_start_date + (i * INTERVAL '3 years') - INTERVAL '1 day';
    v_resignation_deadline := v_period_end - INTERVAL '6 months';

    INSERT INTO commercial_lease_triennial_periods (
      lease_id,
      period_number,
      start_date,
      end_date,
      resignation_deadline,
      loyer_annuel_ht
    ) VALUES (
      NEW.id,
      i,
      v_period_start,
      v_period_end,
      v_resignation_deadline,
      v_loyer
    )
    ON CONFLICT (lease_id, period_number)
    DO UPDATE SET
      start_date = EXCLUDED.start_date,
      end_date = EXCLUDED.end_date,
      resignation_deadline = EXCLUDED.resignation_deadline;
  END LOOP;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger pour générer les périodes triennales
DROP TRIGGER IF EXISTS trigger_generate_triennial_periods ON leases;
CREATE TRIGGER trigger_generate_triennial_periods
  AFTER INSERT OR UPDATE OF start_date, type ON leases
  FOR EACH ROW
  WHEN (NEW.type = 'commercial')
  EXECUTE FUNCTION generate_triennial_periods();

-- =============================================================================
-- 6. FONCTION: Vérification durée cumulative bail dérogatoire
-- =============================================================================

CREATE OR REPLACE FUNCTION check_derogatoire_duration()
RETURNS TRIGGER AS $$
DECLARE
  v_cumul_mois INTEGER;
  v_new_total INTEGER;
BEGIN
  -- Calculer la durée cumulée des baux dérogatoires sur ce bien
  SELECT COALESCE(SUM(duree_mois), 0) INTO v_cumul_mois
  FROM derogatoire_lease_history
  WHERE property_id = NEW.property_id
    AND id != NEW.id;

  v_new_total := v_cumul_mois + NEW.duree_mois;

  -- Mettre à jour les valeurs
  NEW.duree_cumulee_avant_mois := v_cumul_mois;
  NEW.duree_cumulee_apres_mois := v_new_total;

  -- Alerte si on approche de la limite
  IF v_new_total > 30 THEN
    NEW.alerte_limite_3_ans := TRUE;
  END IF;

  -- Erreur si dépassement
  IF v_new_total > 36 THEN
    RAISE EXCEPTION 'La durée cumulée des baux dérogatoires ne peut excéder 36 mois (3 ans). Durée actuelle: % mois', v_new_total;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_check_derogatoire_duration ON derogatoire_lease_history;
CREATE TRIGGER trigger_check_derogatoire_duration
  BEFORE INSERT OR UPDATE ON derogatoire_lease_history
  FOR EACH ROW
  EXECUTE FUNCTION check_derogatoire_duration();

-- =============================================================================
-- 7. FONCTION: RPC pour obtenir l'historique dérogatoire d'un bien
-- =============================================================================

CREATE OR REPLACE FUNCTION get_derogatoire_history(p_property_id UUID)
RETURNS TABLE (
  id UUID,
  preneur_nom VARCHAR,
  date_debut DATE,
  date_fin DATE,
  duree_mois INTEGER,
  duree_cumulee_apres_mois INTEGER,
  mois_restants INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    h.id,
    h.preneur_nom,
    h.date_debut,
    h.date_fin,
    h.duree_mois,
    h.duree_cumulee_apres_mois,
    (36 - h.duree_cumulee_apres_mois) as mois_restants
  FROM derogatoire_lease_history h
  WHERE h.property_id = p_property_id
  ORDER BY h.date_debut;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- 8. FONCTION: RPC pour calculer la révision de loyer ILC/ILAT
-- =============================================================================

CREATE OR REPLACE FUNCTION calculate_commercial_rent_revision(
  p_lease_id UUID,
  p_new_indice DECIMAL
)
RETURNS TABLE (
  ancien_loyer DECIMAL,
  nouveau_loyer DECIMAL,
  variation_pct DECIMAL,
  indice_base DECIMAL,
  nouvel_indice DECIMAL
) AS $$
DECLARE
  v_loyer DECIMAL;
  v_indice_base DECIMAL;
  v_nouveau_loyer DECIMAL;
  v_variation DECIMAL;
BEGIN
  -- Récupérer les données du bail
  SELECT
    cld.loyer_annuel_ht,
    cld.indice_base
  INTO v_loyer, v_indice_base
  FROM commercial_lease_details cld
  WHERE cld.lease_id = p_lease_id;

  IF v_loyer IS NULL OR v_indice_base IS NULL THEN
    RAISE EXCEPTION 'Bail commercial non trouvé ou indice de base manquant';
  END IF;

  -- Calcul du nouveau loyer
  v_nouveau_loyer := v_loyer * (p_new_indice / v_indice_base);
  v_variation := ((p_new_indice - v_indice_base) / v_indice_base) * 100;

  RETURN QUERY
  SELECT
    v_loyer as ancien_loyer,
    ROUND(v_nouveau_loyer, 2) as nouveau_loyer,
    ROUND(v_variation, 2) as variation_pct,
    v_indice_base as indice_base,
    p_new_indice as nouvel_indice;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- 9. RLS POLICIES
-- =============================================================================

-- Activer RLS
ALTER TABLE commercial_lease_details ENABLE ROW LEVEL SECURITY;
ALTER TABLE commercial_lease_triennial_periods ENABLE ROW LEVEL SECURITY;
ALTER TABLE derogatoire_lease_history ENABLE ROW LEVEL SECURITY;

-- Policies pour commercial_lease_details
CREATE POLICY "commercial_lease_details_select_policy" ON commercial_lease_details
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = commercial_lease_details.lease_id
        AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "commercial_lease_details_insert_policy" ON commercial_lease_details
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = commercial_lease_details.lease_id
        AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "commercial_lease_details_update_policy" ON commercial_lease_details
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = commercial_lease_details.lease_id
        AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "commercial_lease_details_delete_policy" ON commercial_lease_details
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = commercial_lease_details.lease_id
        AND p.owner_id = auth.uid()
    )
  );

-- Policies pour commercial_lease_triennial_periods
CREATE POLICY "triennial_periods_select_policy" ON commercial_lease_triennial_periods
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = commercial_lease_triennial_periods.lease_id
        AND p.owner_id = auth.uid()
    )
  );

-- Policies pour derogatoire_lease_history
CREATE POLICY "derogatoire_history_select_policy" ON derogatoire_lease_history
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = derogatoire_lease_history.property_id
        AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "derogatoire_history_insert_policy" ON derogatoire_lease_history
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = derogatoire_lease_history.property_id
        AND p.owner_id = auth.uid()
    )
  );

-- =============================================================================
-- 10. TRIGGER: Mise à jour automatique updated_at
-- =============================================================================

CREATE OR REPLACE FUNCTION update_commercial_lease_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_update_commercial_lease_timestamp ON commercial_lease_details;
CREATE TRIGGER trigger_update_commercial_lease_timestamp
  BEFORE UPDATE ON commercial_lease_details
  FOR EACH ROW
  EXECUTE FUNCTION update_commercial_lease_timestamp();

-- =============================================================================
-- 11. COMMENTAIRES
-- =============================================================================

COMMENT ON TABLE commercial_lease_details IS
  'Détails spécifiques aux baux commerciaux (3/6/9 et dérogatoire) - Code de commerce L145';

COMMENT ON TABLE commercial_lease_triennial_periods IS
  'Périodes triennales pour les baux commerciaux 3/6/9 avec dates de résiliation';

COMMENT ON TABLE derogatoire_lease_history IS
  'Historique des baux dérogatoires par bien pour contrôle de la limite de 3 ans (L145-5)';

COMMENT ON COLUMN commercial_lease_details.indice_type IS
  'Type d''indice: ILC (commerces), ILAT (bureaux/activités tertiaires), ICC (obsolète)';

COMMENT ON COLUMN commercial_lease_details.pas_de_porte_nature IS
  'supplement_loyer = pris en compte pour renouvellement, indemnite = non pris en compte';


-- ========== 20260127000004_professional_lease_types.sql ==========
-- Migration: Ajout du bail professionnel
-- GAP-004: Support des baux professionnels (professions libérales)
-- Conforme à l'article 57 A de la loi n°86-1290 du 23 décembre 1986

-- =============================================================================
-- 1. EXTENSION DU TYPE ENUM lease_type (si pas déjà fait)
-- =============================================================================

-- Le type 'professionnel' a déjà été ajouté dans la migration précédente
-- Cette section est conservée pour idempotence
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum
    WHERE enumlabel = 'professionnel'
    AND enumtypid = (SELECT oid FROM pg_type WHERE typname = 'lease_type')
  ) THEN
    ALTER TYPE lease_type ADD VALUE IF NOT EXISTS 'professionnel';
  END IF;
END$$;

-- =============================================================================
-- 2. TABLE: professional_lease_details
-- Détails spécifiques aux baux professionnels
-- =============================================================================

CREATE TABLE IF NOT EXISTS professional_lease_details (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,

  -- Preneur - Profession
  profession_category VARCHAR(50) NOT NULL, -- sante, juridique, technique, comptable, conseil, artistique, autre
  profession_type VARCHAR(50) NOT NULL,     -- medecin_generaliste, avocat, architecte, etc.
  profession_libelle VARCHAR(255) NOT NULL, -- Libellé exact de la profession
  forme_juridique VARCHAR(50) NOT NULL,     -- exercice_individuel, scp, scm, sel, selarl, etc.

  -- Inscription ordinale
  ordre_professionnel VARCHAR(255),
  numero_ordinal VARCHAR(50),
  departement_inscription VARCHAR(3),

  -- Identification fiscale
  regime_fiscal VARCHAR(20) DEFAULT 'bnc', -- bnc, is, micro_bnc
  numero_tva_intra VARCHAR(20),

  -- Assurance RCP
  assurance_rcp BOOLEAN DEFAULT TRUE,
  assurance_rcp_compagnie VARCHAR(255),
  assurance_rcp_numero VARCHAR(100),

  -- Locaux
  surface_totale_m2 DECIMAL(10,2) NOT NULL,
  nb_bureaux INTEGER DEFAULT 1,
  nb_salles_attente INTEGER DEFAULT 1,
  nb_salles_examen INTEGER DEFAULT 0,
  accessibilite_pmr BOOLEAN DEFAULT FALSE,
  usage_exclusif_professionnel BOOLEAN DEFAULT TRUE,
  reception_clientele BOOLEAN DEFAULT TRUE,

  -- Financier
  loyer_annuel_hc DECIMAL(12,2) NOT NULL,
  tva_applicable BOOLEAN DEFAULT FALSE, -- Généralement pas de TVA
  tva_taux DECIMAL(5,2),
  charges_type VARCHAR(20) DEFAULT 'provisions', -- forfait, provisions, reel
  charges_montant_mensuel DECIMAL(10,2),

  -- Indexation (ILAT par défaut)
  indice_reference VARCHAR(10) DEFAULT 'ILAT',
  indice_base DECIMAL(10,2),
  indice_base_trimestre VARCHAR(20),
  date_revision_annuelle VARCHAR(5) DEFAULT '01-01', -- Format MM-DD

  -- Résiliation
  preavis_locataire_mois INTEGER DEFAULT 6,
  preavis_bailleur_mois INTEGER DEFAULT 6,

  -- Options
  sous_location_autorisee BOOLEAN DEFAULT FALSE,
  cession_autorisee BOOLEAN DEFAULT TRUE,
  cession_agrement_bailleur BOOLEAN DEFAULT TRUE,

  -- Clause résolutoire
  clause_resolutoire_active BOOLEAN DEFAULT TRUE,
  clause_resolutoire_delai_jours INTEGER DEFAULT 30,

  -- Métadonnées
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(lease_id)
);

-- Index pour performance
CREATE INDEX IF NOT EXISTS idx_professional_lease_details_lease_id
  ON professional_lease_details(lease_id);

CREATE INDEX IF NOT EXISTS idx_professional_lease_profession_type
  ON professional_lease_details(profession_type);

CREATE INDEX IF NOT EXISTS idx_professional_lease_profession_category
  ON professional_lease_details(profession_category);

-- =============================================================================
-- 3. TABLE: professional_orders
-- Référentiel des ordres professionnels
-- =============================================================================

CREATE TABLE IF NOT EXISTS professional_orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code VARCHAR(50) UNIQUE NOT NULL,
  name VARCHAR(255) NOT NULL,
  website VARCHAR(255),
  professions VARCHAR(255)[], -- Liste des professions concernées

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insertion des ordres professionnels
INSERT INTO professional_orders (code, name, website, professions) VALUES
  ('medecins', 'Ordre national des médecins', 'https://www.conseil-national.medecin.fr', ARRAY['medecin_generaliste', 'medecin_specialiste']),
  ('pharmaciens', 'Ordre national des pharmaciens', 'https://www.ordre.pharmacien.fr', ARRAY['pharmacien']),
  ('dentistes', 'Ordre national des chirurgiens-dentistes', 'https://www.ordre-chirurgiens-dentistes.fr', ARRAY['chirurgien_dentiste']),
  ('sages_femmes', 'Ordre national des sages-femmes', 'https://www.ordre-sages-femmes.fr', ARRAY['sage_femme']),
  ('infirmiers', 'Ordre national des infirmiers', 'https://www.ordre-infirmiers.fr', ARRAY['infirmier']),
  ('kinesitherapeutes', 'Ordre des masseurs-kinésithérapeutes', 'https://www.ordremk.fr', ARRAY['kinesitherapeute']),
  ('avocats', 'Conseil national des barreaux', 'https://www.cnb.avocat.fr', ARRAY['avocat']),
  ('notaires', 'Conseil supérieur du notariat', 'https://www.notaires.fr', ARRAY['notaire']),
  ('huissiers', 'Chambre nationale des commissaires de justice', 'https://www.cnhj.fr', ARRAY['huissier']),
  ('architectes', 'Ordre des architectes', 'https://www.architectes.org', ARRAY['architecte']),
  ('geometres_experts', 'Ordre des géomètres-experts', 'https://www.geometre-expert.fr', ARRAY['geometre_expert']),
  ('experts_comptables', 'Ordre des experts-comptables', 'https://www.experts-comptables.fr', ARRAY['expert_comptable', 'commissaire_aux_comptes']),
  ('veterinaires', 'Ordre national des vétérinaires', 'https://www.veterinaire.fr', ARRAY['veterinaire'])
ON CONFLICT (code) DO NOTHING;

-- =============================================================================
-- 4. FONCTION: Validation de la durée minimale bail professionnel
-- =============================================================================

CREATE OR REPLACE FUNCTION check_professional_lease_duration()
RETURNS TRIGGER AS $$
DECLARE
  v_lease_type TEXT;
  v_start_date DATE;
  v_end_date DATE;
  v_duration_months INTEGER;
BEGIN
  -- Récupérer le type de bail
  SELECT type, start_date, end_date
  INTO v_lease_type, v_start_date, v_end_date
  FROM leases
  WHERE id = NEW.lease_id;

  -- Vérifier seulement pour les baux professionnels
  IF v_lease_type = 'professionnel' AND v_end_date IS NOT NULL THEN
    -- Calculer la durée en mois
    v_duration_months := (
      EXTRACT(YEAR FROM v_end_date) - EXTRACT(YEAR FROM v_start_date)
    ) * 12 + (
      EXTRACT(MONTH FROM v_end_date) - EXTRACT(MONTH FROM v_start_date)
    );

    -- Durée minimale : 6 ans = 72 mois
    IF v_duration_months < 72 THEN
      RAISE EXCEPTION 'La durée minimale d''un bail professionnel est de 6 ans (72 mois). Durée actuelle: % mois', v_duration_months;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger pour vérifier la durée
DROP TRIGGER IF EXISTS trigger_check_professional_lease_duration ON professional_lease_details;
CREATE TRIGGER trigger_check_professional_lease_duration
  BEFORE INSERT OR UPDATE ON professional_lease_details
  FOR EACH ROW
  EXECUTE FUNCTION check_professional_lease_duration();

-- =============================================================================
-- 5. FONCTION: RPC pour obtenir les détails d'un bail professionnel
-- =============================================================================

CREATE OR REPLACE FUNCTION get_professional_lease_details(p_lease_id UUID)
RETURNS TABLE (
  lease_id UUID,
  profession_category VARCHAR,
  profession_type VARCHAR,
  profession_libelle VARCHAR,
  forme_juridique VARCHAR,
  ordre_professionnel VARCHAR,
  numero_ordinal VARCHAR,
  assurance_rcp BOOLEAN,
  surface_totale_m2 DECIMAL,
  loyer_annuel_hc DECIMAL,
  indice_reference VARCHAR,
  preavis_locataire_mois INTEGER,
  preavis_bailleur_mois INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    pld.lease_id,
    pld.profession_category,
    pld.profession_type,
    pld.profession_libelle,
    pld.forme_juridique,
    pld.ordre_professionnel,
    pld.numero_ordinal,
    pld.assurance_rcp,
    pld.surface_totale_m2,
    pld.loyer_annuel_hc,
    pld.indice_reference,
    pld.preavis_locataire_mois,
    pld.preavis_bailleur_mois
  FROM professional_lease_details pld
  WHERE pld.lease_id = p_lease_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- 6. FONCTION: Calcul de la révision ILAT
-- =============================================================================

CREATE OR REPLACE FUNCTION calculate_ilat_revision(
  p_current_rent DECIMAL,
  p_base_index DECIMAL,
  p_new_index DECIMAL
)
RETURNS TABLE (
  ancien_loyer DECIMAL,
  nouveau_loyer DECIMAL,
  variation_pct DECIMAL
) AS $$
DECLARE
  v_new_rent DECIMAL;
  v_variation DECIMAL;
BEGIN
  -- Calcul du nouveau loyer
  v_new_rent := p_current_rent * (p_new_index / p_base_index);
  v_variation := ((p_new_index - p_base_index) / p_base_index) * 100;

  RETURN QUERY
  SELECT
    p_current_rent as ancien_loyer,
    ROUND(v_new_rent, 2) as nouveau_loyer,
    ROUND(v_variation, 2) as variation_pct;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- 7. RLS POLICIES
-- =============================================================================

-- Activer RLS
ALTER TABLE professional_lease_details ENABLE ROW LEVEL SECURITY;
ALTER TABLE professional_orders ENABLE ROW LEVEL SECURITY;

-- Policies pour professional_lease_details
CREATE POLICY "professional_lease_details_select_policy" ON professional_lease_details
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = professional_lease_details.lease_id
        AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "professional_lease_details_insert_policy" ON professional_lease_details
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = professional_lease_details.lease_id
        AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "professional_lease_details_update_policy" ON professional_lease_details
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = professional_lease_details.lease_id
        AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "professional_lease_details_delete_policy" ON professional_lease_details
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON l.property_id = p.id
      WHERE l.id = professional_lease_details.lease_id
        AND p.owner_id = auth.uid()
    )
  );

-- Policies pour professional_orders (lecture seule pour tous)
CREATE POLICY "professional_orders_select_policy" ON professional_orders
  FOR SELECT USING (TRUE);

-- =============================================================================
-- 8. TRIGGER: Mise à jour automatique updated_at
-- =============================================================================

CREATE OR REPLACE FUNCTION update_professional_lease_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_update_professional_lease_timestamp ON professional_lease_details;
CREATE TRIGGER trigger_update_professional_lease_timestamp
  BEFORE UPDATE ON professional_lease_details
  FOR EACH ROW
  EXECUTE FUNCTION update_professional_lease_timestamp();

-- =============================================================================
-- 9. COMMENTAIRES
-- =============================================================================

COMMENT ON TABLE professional_lease_details IS
  'Détails spécifiques aux baux professionnels (article 57 A loi 86-1290) - Professions libérales';

COMMENT ON TABLE professional_orders IS
  'Référentiel des ordres professionnels français';

COMMENT ON COLUMN professional_lease_details.indice_reference IS
  'Indice de révision du loyer - ILAT recommandé pour les baux professionnels';

COMMENT ON COLUMN professional_lease_details.assurance_rcp IS
  'Assurance Responsabilité Civile Professionnelle - Obligatoire pour la plupart des professions réglementées';


-- ========== 20260127000005_edl_commercial.sql ==========
-- Migration: État des lieux commercial et professionnel
-- GAP-007: EDL spécifique pour les locaux commerciaux et professionnels
-- Date: 2026-01-27

-- =============================================================================
-- 1. TABLE: edl_commercial
-- État des lieux principal pour locaux commerciaux/professionnels
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
  property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,

  -- Type d'EDL
  type_edl VARCHAR(10) NOT NULL CHECK (type_edl IN ('entree', 'sortie')),
  type_local VARCHAR(50) NOT NULL,
  type_bail VARCHAR(50) NOT NULL CHECK (type_bail IN ('commercial', 'commercial_derogatoire', 'professionnel')),

  -- Dates et heures
  date_edl DATE NOT NULL,
  heure_debut TIME NOT NULL,
  heure_fin TIME,

  -- Surfaces
  surface_totale_m2 DECIMAL(10,2) NOT NULL,
  surface_vente_m2 DECIMAL(10,2),
  surface_reserve_m2 DECIMAL(10,2),
  surface_bureaux_m2 DECIMAL(10,2),
  surface_annexes_m2 DECIMAL(10,2),

  -- Représentant bailleur
  bailleur_nom VARCHAR(100) NOT NULL,
  bailleur_prenom VARCHAR(100) NOT NULL,
  bailleur_qualite VARCHAR(100) NOT NULL,
  bailleur_signature TEXT,
  bailleur_signature_date TIMESTAMPTZ,

  -- Représentant preneur
  preneur_nom VARCHAR(100) NOT NULL,
  preneur_prenom VARCHAR(100) NOT NULL,
  preneur_qualite VARCHAR(100) NOT NULL,
  preneur_raison_sociale VARCHAR(255),
  preneur_signature TEXT,
  preneur_signature_date TIMESTAMPTZ,

  -- Observations
  observations_generales TEXT,
  reserves_preneur TEXT,
  reserves_bailleur TEXT,

  -- État global
  etat_general VARCHAR(20) DEFAULT 'bon',
  conformite_globale VARCHAR(20) DEFAULT 'conforme',

  -- Référence EDL entrée (pour sortie)
  edl_entree_id UUID REFERENCES edl_commercial(id) ON DELETE SET NULL,

  -- Statut et validation
  status VARCHAR(20) DEFAULT 'brouillon' CHECK (status IN ('brouillon', 'en_cours', 'a_valider', 'valide', 'conteste')),

  -- Génération PDF
  pdf_generated BOOLEAN DEFAULT FALSE,
  pdf_path VARCHAR(500),

  -- Métadonnées
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,

  UNIQUE(lease_id, type_edl)
);

-- Index pour performance
CREATE INDEX IF NOT EXISTS idx_edl_commercial_lease_id ON edl_commercial(lease_id);
CREATE INDEX IF NOT EXISTS idx_edl_commercial_property_id ON edl_commercial(property_id);
CREATE INDEX IF NOT EXISTS idx_edl_commercial_type_bail ON edl_commercial(type_bail);
CREATE INDEX IF NOT EXISTS idx_edl_commercial_status ON edl_commercial(status);

-- =============================================================================
-- 2. TABLE: edl_commercial_securite_incendie
-- Conformité ERP et sécurité incendie
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_securite_incendie (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,

  -- Classification ERP
  erp_categorie VARCHAR(10), -- 1, 2, 3, 4, 5, non_erp
  erp_type VARCHAR(10), -- M, N, O, W, J, U
  erp_capacite_max INTEGER,

  -- Extincteurs
  extincteurs_presents BOOLEAN DEFAULT FALSE,
  extincteurs_nombre INTEGER DEFAULT 0,
  extincteurs_types TEXT[], -- eau, co2, poudre, mousse
  extincteurs_date_verification DATE,
  extincteurs_conformes BOOLEAN,

  -- Alarme incendie
  alarme_incendie_presente BOOLEAN DEFAULT FALSE,
  alarme_incendie_type VARCHAR(20), -- type_1, type_2a, type_2b, type_3, type_4
  alarme_incendie_centrale BOOLEAN DEFAULT FALSE,
  alarme_incendie_nb_detecteurs INTEGER DEFAULT 0,
  alarme_incendie_date_verification DATE,

  -- Issues de secours
  issues_secours_nombre INTEGER DEFAULT 0,
  issues_secours_conformes BOOLEAN DEFAULT FALSE,
  issues_secours_eclairage_securite BOOLEAN DEFAULT FALSE,
  issues_secours_balisage BOOLEAN DEFAULT FALSE,

  -- Désenfumage
  desenfumage_present BOOLEAN DEFAULT FALSE,
  desenfumage_type VARCHAR(20), -- naturel, mecanique
  desenfumage_conforme BOOLEAN,

  -- Documents et contrôles
  registre_securite_present BOOLEAN DEFAULT FALSE,
  registre_securite_a_jour BOOLEAN DEFAULT FALSE,
  dernier_controle_commission DATE,
  avis_commission VARCHAR(20), -- favorable, defavorable, sursis

  observations TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(edl_commercial_id)
);

-- =============================================================================
-- 3. TABLE: edl_commercial_accessibilite_pmr
-- Conformité accessibilité PMR
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_accessibilite_pmr (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,

  -- Attestation/Ad'AP
  ad_ap_presente BOOLEAN DEFAULT FALSE,
  ad_ap_date DATE,
  ad_ap_reference VARCHAR(100),

  -- Accès extérieur
  acces_plain_pied BOOLEAN DEFAULT FALSE,
  rampe_acces_presente BOOLEAN,
  rampe_acces_conforme BOOLEAN,
  rampe_pente_pct DECIMAL(5,2),
  largeur_porte_entree_cm INTEGER,

  -- Circulation intérieure
  circulation_largeur_min_cm INTEGER,
  circulation_libre BOOLEAN DEFAULT FALSE,
  escalier_present BOOLEAN DEFAULT FALSE,
  ascenseur_present BOOLEAN,
  ascenseur_conforme_pmr BOOLEAN,

  -- Sanitaires PMR
  sanitaire_pmr_present BOOLEAN DEFAULT FALSE,
  sanitaire_pmr_conforme BOOLEAN,
  sanitaire_pmr_dimensions VARCHAR(50),

  -- Stationnement
  place_pmr_presente BOOLEAN DEFAULT FALSE,
  place_pmr_signalee BOOLEAN,

  -- Signalétique
  signaletique_pmr_presente BOOLEAN DEFAULT FALSE,
  bande_guidage_presente BOOLEAN,

  conformite_globale VARCHAR(20) DEFAULT 'a_verifier', -- conforme, non_conforme, a_verifier, derogation
  observations TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(edl_commercial_id)
);

-- =============================================================================
-- 4. TABLE: edl_commercial_facade_vitrine
-- Inspection façade et vitrine (commerces)
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_facade_vitrine (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,

  -- Vitrine
  vitrine_etat VARCHAR(20) DEFAULT 'bon',
  vitrine_type VARCHAR(20), -- simple, double, securit, autre
  vitrine_surface_m2 DECIMAL(10,2),
  vitrine_film_adhesif BOOLEAN DEFAULT FALSE,
  vitrine_observations TEXT,

  -- Façade
  facade_etat VARCHAR(20) DEFAULT 'bon',
  facade_materiau VARCHAR(100),
  facade_peinture_date DATE,
  facade_observations TEXT,

  -- Store/Banne
  store_present BOOLEAN DEFAULT FALSE,
  store_type VARCHAR(20), -- banne, venitien, roulant, autre
  store_motorise BOOLEAN,
  store_etat VARCHAR(20),
  store_observations TEXT,

  -- Porte d'entrée
  porte_entree_etat VARCHAR(20) DEFAULT 'bon',
  porte_entree_type VARCHAR(20), -- vitree, pleine, rideau_metallique, autre
  porte_entree_serrure_type VARCHAR(50),
  porte_entree_nb_cles INTEGER DEFAULT 0,

  -- Rideau métallique
  rideau_metallique_present BOOLEAN DEFAULT FALSE,
  rideau_metallique_etat VARCHAR(20),
  rideau_metallique_motorise BOOLEAN,
  rideau_metallique_observations TEXT,

  photos JSONB DEFAULT '[]'::jsonb,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(edl_commercial_id)
);

-- =============================================================================
-- 5. TABLE: edl_commercial_enseigne
-- Inspection enseigne et signalétique
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_enseigne (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,

  -- Enseigne principale
  enseigne_presente BOOLEAN DEFAULT FALSE,
  enseigne_type VARCHAR(30), -- bandeau, caisson, lettres_decoupees, drapeau, autre
  enseigne_eclairee BOOLEAN,
  enseigne_etat VARCHAR(20),
  enseigne_dimensions VARCHAR(50),
  enseigne_autorisation_mairie BOOLEAN,
  enseigne_observations TEXT,

  -- Signalétique intérieure
  signaletique_interieure BOOLEAN DEFAULT FALSE,
  signaletique_sortie_secours BOOLEAN DEFAULT FALSE,
  signaletique_sanitaires BOOLEAN DEFAULT FALSE,
  signaletique_accessibilite BOOLEAN DEFAULT FALSE,
  signaletique_observations TEXT,

  photos JSONB DEFAULT '[]'::jsonb,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(edl_commercial_id)
);

-- =============================================================================
-- 6. TABLE: edl_commercial_installations_techniques
-- Installations techniques (clim, chauffage, électricité, etc.)
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_installations_techniques (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,

  -- Climatisation
  climatisation_presente BOOLEAN DEFAULT FALSE,
  climatisation_type VARCHAR(30), -- split, centralisee, vmc_double_flux, autre
  climatisation_marque VARCHAR(100),
  climatisation_puissance_kw DECIMAL(10,2),
  climatisation_date_entretien DATE,
  climatisation_etat VARCHAR(20),
  climatisation_observations TEXT,

  -- Chauffage
  chauffage_type VARCHAR(30), -- electrique, gaz, fioul, pompe_chaleur, autre
  chauffage_equipements TEXT[],
  chauffage_etat VARCHAR(20),
  chauffage_date_entretien DATE,
  chauffage_observations TEXT,

  -- Ventilation
  ventilation_type VARCHAR(30), -- naturelle, vmc_simple, vmc_double, extraction
  ventilation_etat VARCHAR(20),
  ventilation_observations TEXT,

  -- Électricité
  electricite_puissance_kva DECIMAL(10,2),
  electricite_tableau_conforme BOOLEAN DEFAULT FALSE,
  electricite_differentiel_present BOOLEAN DEFAULT FALSE,
  electricite_nb_prises INTEGER,
  electricite_nb_circuits INTEGER,
  electricite_date_diagnostic DATE,
  electricite_observations TEXT,

  -- Plomberie
  plomberie_arrivee_eau BOOLEAN DEFAULT TRUE,
  plomberie_evacuation BOOLEAN DEFAULT TRUE,
  plomberie_chauffe_eau_type VARCHAR(50),
  plomberie_chauffe_eau_capacite_l INTEGER,
  plomberie_etat VARCHAR(20),
  plomberie_observations TEXT,

  -- Télécom/IT
  telecom_lignes_telephoniques INTEGER DEFAULT 0,
  telecom_fibre_optique BOOLEAN DEFAULT FALSE,
  telecom_prises_rj45 INTEGER DEFAULT 0,
  telecom_baie_brassage BOOLEAN DEFAULT FALSE,
  telecom_observations TEXT,

  photos JSONB DEFAULT '[]'::jsonb,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(edl_commercial_id)
);

-- =============================================================================
-- 7. TABLE: edl_commercial_compteurs
-- Relevés des compteurs
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_compteurs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,

  -- Compteur électrique
  compteur_elec_numero VARCHAR(50),
  compteur_elec_index DECIMAL(15,2),
  compteur_elec_type VARCHAR(30), -- linky, electronique, mecanique
  compteur_elec_puissance_kva DECIMAL(10,2),
  compteur_elec_photo TEXT,

  -- Compteur gaz
  compteur_gaz_present BOOLEAN DEFAULT FALSE,
  compteur_gaz_numero VARCHAR(50),
  compteur_gaz_index_m3 DECIMAL(15,2),
  compteur_gaz_photo TEXT,

  -- Compteur eau
  compteur_eau_numero VARCHAR(50),
  compteur_eau_index_m3 DECIMAL(15,2),
  compteur_eau_divisionnaire BOOLEAN DEFAULT FALSE,
  compteur_eau_photo TEXT,

  -- Télécom
  ligne_telephonique_numero VARCHAR(50),
  acces_internet_type VARCHAR(20), -- adsl, fibre, cable, autre
  debit_internet_mbps INTEGER,

  observations TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(edl_commercial_id)
);

-- =============================================================================
-- 8. TABLE: edl_commercial_zones
-- Zones/Pièces du local
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_zones (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,

  -- Identification
  categorie VARCHAR(50) NOT NULL, -- facade_vitrine, zone_accueil, zone_vente, etc.
  nom VARCHAR(100) NOT NULL,
  surface_m2 DECIMAL(10,2),

  -- État
  etat_general VARCHAR(20) DEFAULT 'bon',
  conformite VARCHAR(20) DEFAULT 'conforme',

  -- Détails
  observations TEXT,

  -- Ordre d'affichage
  ordre INTEGER DEFAULT 0,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_edl_commercial_zones_edl_id ON edl_commercial_zones(edl_commercial_id);

-- =============================================================================
-- 9. TABLE: edl_commercial_items
-- Éléments d'inspection détaillés
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,
  zone_id UUID REFERENCES edl_commercial_zones(id) ON DELETE CASCADE,

  -- Identification
  categorie VARCHAR(50) NOT NULL,
  sous_categorie VARCHAR(50),
  nom VARCHAR(255) NOT NULL,
  description TEXT,

  -- État
  etat VARCHAR(20) DEFAULT 'bon',
  conformite VARCHAR(20),
  quantite INTEGER DEFAULT 1,

  -- Dimensions (optionnel)
  longueur_m DECIMAL(10,2),
  largeur_m DECIMAL(10,2),
  hauteur_m DECIMAL(10,2),
  surface_m2 DECIMAL(10,2),

  -- Observations
  observations TEXT,
  defauts TEXT[],
  action_requise TEXT,
  estimation_reparation DECIMAL(12,2),

  -- Photos
  photos JSONB DEFAULT '[]'::jsonb,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_edl_commercial_items_edl_id ON edl_commercial_items(edl_commercial_id);
CREATE INDEX IF NOT EXISTS idx_edl_commercial_items_zone_id ON edl_commercial_items(zone_id);
CREATE INDEX IF NOT EXISTS idx_edl_commercial_items_categorie ON edl_commercial_items(categorie);

-- =============================================================================
-- 10. TABLE: edl_commercial_equipements
-- Équipements fournis par le bailleur
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_equipements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,

  categorie VARCHAR(100) NOT NULL,
  designation VARCHAR(255) NOT NULL,
  marque VARCHAR(100),
  modele VARCHAR(100),
  numero_serie VARCHAR(100),
  date_installation DATE,
  etat VARCHAR(20) DEFAULT 'bon',
  valeur_estimee DECIMAL(12,2),
  photo TEXT,
  observations TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_edl_commercial_equipements_edl_id ON edl_commercial_equipements(edl_commercial_id);

-- =============================================================================
-- 11. TABLE: edl_commercial_cles
-- Clés et badges remis
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_cles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,

  type_cle VARCHAR(50) NOT NULL, -- porte_principale, porte_service, rideau_metallique, etc.
  description VARCHAR(255),
  quantite INTEGER DEFAULT 1,
  numero_badge VARCHAR(50),
  photo TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_edl_commercial_cles_edl_id ON edl_commercial_cles(edl_commercial_id);

-- =============================================================================
-- 12. TABLE: edl_commercial_documents
-- Documents annexés
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,

  type_document VARCHAR(50) NOT NULL, -- diagnostic, attestation, photo, plan, facture, autre
  nom VARCHAR(255) NOT NULL,
  description TEXT,
  chemin_fichier VARCHAR(500) NOT NULL,
  date_document DATE,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_edl_commercial_documents_edl_id ON edl_commercial_documents(edl_commercial_id);

-- =============================================================================
-- 13. TABLE: edl_commercial_differences
-- Différences constatées (EDL sortie)
-- =============================================================================

CREATE TABLE IF NOT EXISTS edl_commercial_differences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  edl_commercial_id UUID NOT NULL REFERENCES edl_commercial(id) ON DELETE CASCADE,

  categorie VARCHAR(50) NOT NULL,
  element VARCHAR(255) NOT NULL,
  etat_entree VARCHAR(20),
  etat_sortie VARCHAR(20),
  description_degradation TEXT,
  photos_entree JSONB DEFAULT '[]'::jsonb,
  photos_sortie JSONB DEFAULT '[]'::jsonb,
  imputable_preneur BOOLEAN DEFAULT FALSE,
  estimation_reparation DECIMAL(12,2),
  observations TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_edl_commercial_differences_edl_id ON edl_commercial_differences(edl_commercial_id);

-- =============================================================================
-- 14. TRIGGERS: Mise à jour automatique updated_at
-- =============================================================================

-- Fonction générique
CREATE OR REPLACE FUNCTION update_edl_commercial_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers pour toutes les tables
DO $$
DECLARE
  tables TEXT[] := ARRAY[
    'edl_commercial',
    'edl_commercial_securite_incendie',
    'edl_commercial_accessibilite_pmr',
    'edl_commercial_facade_vitrine',
    'edl_commercial_enseigne',
    'edl_commercial_installations_techniques',
    'edl_commercial_compteurs',
    'edl_commercial_zones',
    'edl_commercial_items',
    'edl_commercial_equipements',
    'edl_commercial_differences'
  ];
  t TEXT;
BEGIN
  FOREACH t IN ARRAY tables LOOP
    EXECUTE format('DROP TRIGGER IF EXISTS trigger_update_%s_timestamp ON %I', t, t);
    EXECUTE format('CREATE TRIGGER trigger_update_%s_timestamp
      BEFORE UPDATE ON %I
      FOR EACH ROW
      EXECUTE FUNCTION update_edl_commercial_timestamp()', t, t);
  END LOOP;
END $$;

-- =============================================================================
-- 15. RLS POLICIES
-- =============================================================================

-- Activer RLS sur toutes les tables
ALTER TABLE edl_commercial ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_securite_incendie ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_accessibilite_pmr ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_facade_vitrine ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_enseigne ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_installations_techniques ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_compteurs ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_zones ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_equipements ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_cles ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE edl_commercial_differences ENABLE ROW LEVEL SECURITY;

-- Policies pour edl_commercial (table principale)
CREATE POLICY "edl_commercial_select_policy" ON edl_commercial
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = edl_commercial.property_id
        AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "edl_commercial_insert_policy" ON edl_commercial
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = edl_commercial.property_id
        AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "edl_commercial_update_policy" ON edl_commercial
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = edl_commercial.property_id
        AND p.owner_id = auth.uid()
    )
  );

CREATE POLICY "edl_commercial_delete_policy" ON edl_commercial
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = edl_commercial.property_id
        AND p.owner_id = auth.uid()
    )
    AND status = 'brouillon' -- Seuls les brouillons peuvent être supprimés
  );

-- Macro pour créer les policies des tables liées
DO $$
DECLARE
  child_tables TEXT[] := ARRAY[
    'edl_commercial_securite_incendie',
    'edl_commercial_accessibilite_pmr',
    'edl_commercial_facade_vitrine',
    'edl_commercial_enseigne',
    'edl_commercial_installations_techniques',
    'edl_commercial_compteurs',
    'edl_commercial_zones',
    'edl_commercial_items',
    'edl_commercial_equipements',
    'edl_commercial_cles',
    'edl_commercial_documents',
    'edl_commercial_differences'
  ];
  t TEXT;
BEGIN
  FOREACH t IN ARRAY child_tables LOOP
    -- Policy SELECT
    EXECUTE format('CREATE POLICY "%s_select_policy" ON %I
      FOR SELECT USING (
        EXISTS (
          SELECT 1 FROM edl_commercial ec
          JOIN properties p ON ec.property_id = p.id
          WHERE ec.id = %I.edl_commercial_id
            AND p.owner_id = auth.uid()
        )
      )', t, t, t);

    -- Policy INSERT
    EXECUTE format('CREATE POLICY "%s_insert_policy" ON %I
      FOR INSERT WITH CHECK (
        EXISTS (
          SELECT 1 FROM edl_commercial ec
          JOIN properties p ON ec.property_id = p.id
          WHERE ec.id = %I.edl_commercial_id
            AND p.owner_id = auth.uid()
        )
      )', t, t, t);

    -- Policy UPDATE
    EXECUTE format('CREATE POLICY "%s_update_policy" ON %I
      FOR UPDATE USING (
        EXISTS (
          SELECT 1 FROM edl_commercial ec
          JOIN properties p ON ec.property_id = p.id
          WHERE ec.id = %I.edl_commercial_id
            AND p.owner_id = auth.uid()
        )
      )', t, t, t);

    -- Policy DELETE
    EXECUTE format('CREATE POLICY "%s_delete_policy" ON %I
      FOR DELETE USING (
        EXISTS (
          SELECT 1 FROM edl_commercial ec
          JOIN properties p ON ec.property_id = p.id
          WHERE ec.id = %I.edl_commercial_id
            AND p.owner_id = auth.uid()
            AND ec.status = ''brouillon''
        )
      )', t, t, t);
  END LOOP;
END $$;

-- =============================================================================
-- 16. FONCTION RPC: Obtenir un EDL commercial complet
-- =============================================================================

CREATE OR REPLACE FUNCTION get_edl_commercial_complet(p_edl_id UUID)
RETURNS JSONB AS $$
DECLARE
  v_result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'edl', row_to_json(ec.*),
    'securite_incendie', (SELECT row_to_json(s.*) FROM edl_commercial_securite_incendie s WHERE s.edl_commercial_id = ec.id),
    'accessibilite_pmr', (SELECT row_to_json(a.*) FROM edl_commercial_accessibilite_pmr a WHERE a.edl_commercial_id = ec.id),
    'facade_vitrine', (SELECT row_to_json(f.*) FROM edl_commercial_facade_vitrine f WHERE f.edl_commercial_id = ec.id),
    'enseigne', (SELECT row_to_json(e.*) FROM edl_commercial_enseigne e WHERE e.edl_commercial_id = ec.id),
    'installations_techniques', (SELECT row_to_json(i.*) FROM edl_commercial_installations_techniques i WHERE i.edl_commercial_id = ec.id),
    'compteurs', (SELECT row_to_json(c.*) FROM edl_commercial_compteurs c WHERE c.edl_commercial_id = ec.id),
    'zones', (SELECT COALESCE(jsonb_agg(row_to_json(z.*) ORDER BY z.ordre), '[]'::jsonb) FROM edl_commercial_zones z WHERE z.edl_commercial_id = ec.id),
    'items', (SELECT COALESCE(jsonb_agg(row_to_json(it.*)), '[]'::jsonb) FROM edl_commercial_items it WHERE it.edl_commercial_id = ec.id),
    'equipements', (SELECT COALESCE(jsonb_agg(row_to_json(eq.*)), '[]'::jsonb) FROM edl_commercial_equipements eq WHERE eq.edl_commercial_id = ec.id),
    'cles', (SELECT COALESCE(jsonb_agg(row_to_json(cl.*)), '[]'::jsonb) FROM edl_commercial_cles cl WHERE cl.edl_commercial_id = ec.id),
    'documents', (SELECT COALESCE(jsonb_agg(row_to_json(d.*)), '[]'::jsonb) FROM edl_commercial_documents d WHERE d.edl_commercial_id = ec.id),
    'differences', (SELECT COALESCE(jsonb_agg(row_to_json(df.*)), '[]'::jsonb) FROM edl_commercial_differences df WHERE df.edl_commercial_id = ec.id)
  ) INTO v_result
  FROM edl_commercial ec
  WHERE ec.id = p_edl_id;

  RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- 17. FONCTION RPC: Comparer EDL entrée/sortie
-- =============================================================================

CREATE OR REPLACE FUNCTION compare_edl_commercial(p_edl_sortie_id UUID)
RETURNS TABLE (
  categorie VARCHAR,
  element VARCHAR,
  etat_entree VARCHAR,
  etat_sortie VARCHAR,
  changement BOOLEAN
) AS $$
BEGIN
  RETURN QUERY
  WITH edl_sortie AS (
    SELECT ec.id, ec.edl_entree_id
    FROM edl_commercial ec
    WHERE ec.id = p_edl_sortie_id AND ec.type_edl = 'sortie'
  ),
  items_entree AS (
    SELECT categorie, nom, etat
    FROM edl_commercial_items
    WHERE edl_commercial_id = (SELECT edl_entree_id FROM edl_sortie)
  ),
  items_sortie AS (
    SELECT categorie, nom, etat
    FROM edl_commercial_items
    WHERE edl_commercial_id = p_edl_sortie_id
  )
  SELECT
    COALESCE(ie.categorie, is_.categorie)::VARCHAR AS categorie,
    COALESCE(ie.nom, is_.nom)::VARCHAR AS element,
    ie.etat::VARCHAR AS etat_entree,
    is_.etat::VARCHAR AS etat_sortie,
    (ie.etat IS DISTINCT FROM is_.etat) AS changement
  FROM items_entree ie
  FULL OUTER JOIN items_sortie is_ ON ie.categorie = is_.categorie AND ie.nom = is_.nom
  WHERE ie.etat IS DISTINCT FROM is_.etat;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- 18. VUE: EDL commerciaux en cours
-- =============================================================================

CREATE OR REPLACE VIEW v_edl_commercial_en_cours AS
SELECT
  ec.id,
  ec.lease_id,
  ec.property_id,
  ec.type_edl,
  ec.type_local,
  ec.type_bail,
  ec.date_edl,
  ec.status,
  ec.surface_totale_m2,
  ec.preneur_raison_sociale,
  p.adresse_complete,
  p.ville,
  l.date_debut AS bail_date_debut,
  ec.created_at,
  ec.updated_at
FROM edl_commercial ec
JOIN properties p ON ec.property_id = p.id
JOIN leases l ON ec.lease_id = l.id
WHERE ec.status IN ('brouillon', 'en_cours', 'a_valider')
ORDER BY ec.date_edl DESC;

-- =============================================================================
-- 19. COMMENTAIRES
-- =============================================================================

COMMENT ON TABLE edl_commercial IS 'État des lieux pour locaux commerciaux et professionnels - GAP-007';
COMMENT ON TABLE edl_commercial_securite_incendie IS 'Conformité ERP et sécurité incendie';
COMMENT ON TABLE edl_commercial_accessibilite_pmr IS 'Conformité accessibilité PMR';
COMMENT ON TABLE edl_commercial_facade_vitrine IS 'Inspection façade et vitrine (commerces)';
COMMENT ON TABLE edl_commercial_enseigne IS 'Inspection enseigne et signalétique';
COMMENT ON TABLE edl_commercial_installations_techniques IS 'Installations techniques (clim, chauffage, électricité, etc.)';
COMMENT ON TABLE edl_commercial_compteurs IS 'Relevés des compteurs';
COMMENT ON TABLE edl_commercial_zones IS 'Zones/Pièces du local';
COMMENT ON TABLE edl_commercial_items IS 'Éléments d''inspection détaillés';
COMMENT ON TABLE edl_commercial_equipements IS 'Équipements fournis par le bailleur';
COMMENT ON TABLE edl_commercial_cles IS 'Clés et badges remis';
COMMENT ON TABLE edl_commercial_documents IS 'Documents annexés à l''EDL';
COMMENT ON TABLE edl_commercial_differences IS 'Différences constatées entre EDL entrée et sortie';


-- ========== 20260127000006_location_gerance.sql ==========
-- Migration: Location-Gérance (Gérance Libre de Fonds de Commerce)
-- GAP-005: Support des contrats de location-gérance
-- Cadre légal: Articles L144-1 à L144-13 du Code de commerce
-- Date: 2026-01-27

-- =============================================================================
-- 1. EXTENSION DU TYPE ENUM lease_type
-- =============================================================================

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum
    WHERE enumlabel = 'location_gerance'
    AND enumtypid = (SELECT oid FROM pg_type WHERE typname = 'lease_type')
  ) THEN
    ALTER TYPE lease_type ADD VALUE IF NOT EXISTS 'location_gerance';
  END IF;
END$$;

-- =============================================================================
-- 2. TABLE: fonds_commerce
-- Référentiel des fonds de commerce
-- =============================================================================

CREATE TABLE IF NOT EXISTS fonds_commerce (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Identification
  nom_commercial VARCHAR(255) NOT NULL,
  enseigne VARCHAR(255),
  type_fonds VARCHAR(50) NOT NULL, -- commerce_detail, restaurant, hotel, etc.
  activite_principale VARCHAR(255) NOT NULL,
  activites_secondaires TEXT[],
  code_ape VARCHAR(10),

  -- Localisation
  adresse_exploitation VARCHAR(500) NOT NULL,
  code_postal VARCHAR(10) NOT NULL,
  ville VARCHAR(100) NOT NULL,
  local_surface_m2 DECIMAL(10,2),

  -- Bail commercial sous-jacent
  bail_commercial_id UUID REFERENCES leases(id) ON DELETE SET NULL,
  bail_commercial_reference VARCHAR(100),
  bail_date_fin DATE,
  bailleur_local_nom VARCHAR(255),

  -- Éléments incorporels
  clientele BOOLEAN DEFAULT TRUE,
  achalandage BOOLEAN DEFAULT TRUE,
  nom_commercial_inclus BOOLEAN DEFAULT TRUE,
  enseigne_incluse BOOLEAN DEFAULT TRUE,
  droit_au_bail BOOLEAN DEFAULT TRUE,
  brevets TEXT[],
  marques TEXT[],
  contrats_exclusivite TEXT[],

  -- Valeur
  valeur_estimee DECIMAL(15,2),
  date_evaluation DATE,
  methode_evaluation VARCHAR(100),

  -- Historique
  date_creation_fonds DATE,
  origine_fonds VARCHAR(50), -- creation, acquisition, heritage, autre
  chiffre_affaires_dernier_exercice DECIMAL(15,2),
  resultat_dernier_exercice DECIMAL(15,2),

  -- Statut
  en_location_gerance BOOLEAN DEFAULT FALSE,
  location_gerance_id UUID, -- Référence au contrat actif

  -- Métadonnées
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_fonds_commerce_owner_id ON fonds_commerce(owner_id);
CREATE INDEX IF NOT EXISTS idx_fonds_commerce_type_fonds ON fonds_commerce(type_fonds);
CREATE INDEX IF NOT EXISTS idx_fonds_commerce_ville ON fonds_commerce(ville);

-- =============================================================================
-- 3. TABLE: fonds_commerce_licences
-- Licences et autorisations du fonds
-- =============================================================================

CREATE TABLE IF NOT EXISTS fonds_commerce_licences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  fonds_id UUID NOT NULL REFERENCES fonds_commerce(id) ON DELETE CASCADE,

  type_licence VARCHAR(50) NOT NULL, -- licence_4, licence_3, debit_tabac, pharmacie, etc.
  numero VARCHAR(100),
  date_obtention DATE,
  date_expiration DATE,
  transferable BOOLEAN DEFAULT TRUE,
  observations TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_fonds_licences_fonds_id ON fonds_commerce_licences(fonds_id);

-- =============================================================================
-- 4. TABLE: fonds_commerce_equipements
-- Matériel et équipements du fonds
-- =============================================================================

CREATE TABLE IF NOT EXISTS fonds_commerce_equipements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  fonds_id UUID NOT NULL REFERENCES fonds_commerce(id) ON DELETE CASCADE,

  designation VARCHAR(255) NOT NULL,
  marque VARCHAR(100),
  modele VARCHAR(100),
  numero_serie VARCHAR(100),
  annee_acquisition INTEGER,
  valeur_acquisition DECIMAL(12,2),
  valeur_actuelle DECIMAL(12,2),
  etat VARCHAR(20) DEFAULT 'bon', -- neuf, bon, usage, a_remplacer
  inclus_dans_gerance BOOLEAN DEFAULT TRUE,
  observations TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_fonds_equipements_fonds_id ON fonds_commerce_equipements(fonds_id);

-- =============================================================================
-- 5. TABLE: location_gerance_contracts
-- Contrats de location-gérance
-- =============================================================================

CREATE TABLE IF NOT EXISTS location_gerance_contracts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  reference VARCHAR(50) UNIQUE NOT NULL,
  version INTEGER DEFAULT 1,

  -- Fonds de commerce
  fonds_id UUID NOT NULL REFERENCES fonds_commerce(id) ON DELETE RESTRICT,

  -- Loueur (propriétaire du fonds)
  loueur_type VARCHAR(20) NOT NULL, -- personne_physique, personne_morale
  loueur_civilite VARCHAR(20),
  loueur_nom VARCHAR(100),
  loueur_prenom VARCHAR(100),
  loueur_date_naissance DATE,
  loueur_lieu_naissance VARCHAR(100),
  loueur_nationalite VARCHAR(50),
  loueur_raison_sociale VARCHAR(255),
  loueur_forme_juridique VARCHAR(50),
  loueur_capital DECIMAL(15,2),
  loueur_siret VARCHAR(20),
  loueur_rcs VARCHAR(100),
  loueur_representant_nom VARCHAR(100),
  loueur_representant_qualite VARCHAR(100),
  loueur_adresse VARCHAR(500) NOT NULL,
  loueur_code_postal VARCHAR(10) NOT NULL,
  loueur_ville VARCHAR(100) NOT NULL,
  loueur_telephone VARCHAR(20),
  loueur_email VARCHAR(255),
  loueur_regime_fiscal VARCHAR(10),
  loueur_tva_assujetti BOOLEAN DEFAULT FALSE,
  loueur_numero_tva VARCHAR(20),

  -- Gérant (locataire-gérant)
  gerant_type VARCHAR(20) NOT NULL,
  gerant_civilite VARCHAR(20),
  gerant_nom VARCHAR(100),
  gerant_prenom VARCHAR(100),
  gerant_date_naissance DATE,
  gerant_lieu_naissance VARCHAR(100),
  gerant_nationalite VARCHAR(50),
  gerant_raison_sociale VARCHAR(255),
  gerant_forme_juridique VARCHAR(50),
  gerant_capital DECIMAL(15,2),
  gerant_siret VARCHAR(20),
  gerant_rcs VARCHAR(100),
  gerant_rcs_date DATE,
  gerant_rm_numero VARCHAR(100),
  gerant_rm_ville VARCHAR(100),
  gerant_representant_nom VARCHAR(100),
  gerant_representant_qualite VARCHAR(100),
  gerant_adresse VARCHAR(500) NOT NULL,
  gerant_code_postal VARCHAR(10) NOT NULL,
  gerant_ville VARCHAR(100) NOT NULL,
  gerant_telephone VARCHAR(20),
  gerant_email VARCHAR(255),
  gerant_assurance_rc BOOLEAN DEFAULT TRUE,
  gerant_assurance_rc_compagnie VARCHAR(255),
  gerant_assurance_rc_numero VARCHAR(100),
  gerant_assurance_multirisque BOOLEAN DEFAULT FALSE,
  gerant_assurance_multirisque_compagnie VARCHAR(255),

  -- Durée
  duree_type VARCHAR(20) NOT NULL, -- determinee, indeterminee
  duree_mois INTEGER,
  date_debut DATE NOT NULL,
  date_fin DATE,
  tacite_reconduction BOOLEAN DEFAULT TRUE,
  preavis_non_reconduction_mois INTEGER DEFAULT 6,

  -- Redevance
  redevance_type VARCHAR(20) NOT NULL, -- fixe, pourcentage_ca, mixte, progressive
  redevance_montant_fixe_mensuel DECIMAL(12,2),
  redevance_pourcentage_ca DECIMAL(5,2),
  redevance_minimum_garanti DECIMAL(12,2),
  redevance_paliers JSONB, -- Pour type progressive
  redevance_indexation BOOLEAN DEFAULT TRUE,
  redevance_indice VARCHAR(10) DEFAULT 'ILC',
  redevance_indice_base DECIMAL(10,2),
  redevance_indice_trimestre VARCHAR(20),
  redevance_date_revision VARCHAR(5) DEFAULT '01-01',
  redevance_tva_applicable BOOLEAN DEFAULT TRUE,
  redevance_tva_taux DECIMAL(5,2) DEFAULT 20,
  redevance_echeance_jour INTEGER DEFAULT 1,
  redevance_mode_paiement VARCHAR(20) DEFAULT 'virement',

  -- Cautionnement
  cautionnement_type VARCHAR(30), -- depot_especes, garantie_bancaire, caution_solidaire
  cautionnement_montant DECIMAL(12,2),
  cautionnement_banque_nom VARCHAR(255),
  cautionnement_numero VARCHAR(100),
  cautionnement_date_emission DATE,
  cautionnement_caution_nom VARCHAR(255),
  cautionnement_caution_adresse VARCHAR(500),

  -- Stock
  reprise_stock BOOLEAN DEFAULT FALSE,
  stock_valeur_entree DECIMAL(12,2),
  stock_mode_evaluation VARCHAR(50),
  stock_taux_minoration DECIMAL(5,2),
  stock_inventaire_date DATE,

  -- Charges
  charges_locatives_gerant BOOLEAN DEFAULT TRUE,
  taxe_fonciere_gerant BOOLEAN DEFAULT FALSE,
  cfe_gerant BOOLEAN DEFAULT TRUE,
  assurances_gerant TEXT[],

  -- Obligations
  obligation_exploitation_personnelle BOOLEAN DEFAULT TRUE,
  obligation_continuation_activite BOOLEAN DEFAULT TRUE,
  interdiction_sous_location BOOLEAN DEFAULT TRUE,
  interdiction_cession BOOLEAN DEFAULT TRUE,
  obligation_non_concurrence_loueur BOOLEAN DEFAULT TRUE,

  -- Clause non-concurrence gérant
  non_concurrence_active BOOLEAN DEFAULT FALSE,
  non_concurrence_duree_mois INTEGER,
  non_concurrence_perimetre_km INTEGER,
  non_concurrence_activites TEXT[],

  -- Fin de contrat
  clause_resiliation_anticipee BOOLEAN DEFAULT TRUE,
  preavis_resiliation_mois INTEGER DEFAULT 3,
  indemnite_resiliation DECIMAL(12,2),
  conditions_restitution TEXT,

  -- Solidarité (Art. L144-7)
  solidarite_duree_mois INTEGER DEFAULT 6,

  -- Publication JAL
  publication_journal_nom VARCHAR(255),
  publication_date DATE,
  publication_reference VARCHAR(100),

  -- Statut
  status VARCHAR(30) DEFAULT 'draft', -- draft, pending_publication, published, active, suspended, terminated, expired

  -- Signatures
  signed_at TIMESTAMPTZ,
  loueur_signature TEXT,
  loueur_signature_date TIMESTAMPTZ,
  gerant_signature TEXT,
  gerant_signature_date TIMESTAMPTZ,

  -- PDF
  pdf_generated BOOLEAN DEFAULT FALSE,
  pdf_path VARCHAR(500),

  -- Métadonnées
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_location_gerance_fonds_id ON location_gerance_contracts(fonds_id);
CREATE INDEX IF NOT EXISTS idx_location_gerance_status ON location_gerance_contracts(status);
CREATE INDEX IF NOT EXISTS idx_location_gerance_date_debut ON location_gerance_contracts(date_debut);
CREATE INDEX IF NOT EXISTS idx_location_gerance_date_fin ON location_gerance_contracts(date_fin);

-- =============================================================================
-- 6. TABLE: location_gerance_redevances
-- Historique des paiements de redevance
-- =============================================================================

CREATE TABLE IF NOT EXISTS location_gerance_redevances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_id UUID NOT NULL REFERENCES location_gerance_contracts(id) ON DELETE CASCADE,

  periode VARCHAR(7) NOT NULL, -- Format YYYY-MM
  date_echeance DATE NOT NULL,
  montant_base_ht DECIMAL(12,2) NOT NULL,
  montant_tva DECIMAL(12,2) DEFAULT 0,
  montant_ttc DECIMAL(12,2) NOT NULL,

  -- Si pourcentage CA
  chiffre_affaires_mois DECIMAL(15,2),
  montant_variable DECIMAL(12,2),

  -- Indexation
  indice_applique DECIMAL(10,2),
  coefficient_revision DECIMAL(8,4),

  -- Paiement
  date_paiement DATE,
  mode_paiement VARCHAR(20),
  reference_paiement VARCHAR(100),
  statut VARCHAR(20) DEFAULT 'pending', -- pending, paid, late, partial

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_lg_redevances_contract ON location_gerance_redevances(contract_id);
CREATE INDEX IF NOT EXISTS idx_lg_redevances_periode ON location_gerance_redevances(periode);
CREATE INDEX IF NOT EXISTS idx_lg_redevances_statut ON location_gerance_redevances(statut);

-- =============================================================================
-- 7. TABLE: location_gerance_publications
-- Historique des publications JAL
-- =============================================================================

CREATE TABLE IF NOT EXISTS location_gerance_publications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_id UUID NOT NULL REFERENCES location_gerance_contracts(id) ON DELETE CASCADE,

  type_publication VARCHAR(20) NOT NULL, -- debut, modification, fin
  journal_nom VARCHAR(255) NOT NULL,
  date_publication DATE NOT NULL,
  reference VARCHAR(100),
  texte_publication TEXT,
  document_path VARCHAR(500),
  cout DECIMAL(10,2),

  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_lg_publications_contract ON location_gerance_publications(contract_id);

-- =============================================================================
-- 8. TABLE: location_gerance_documents
-- Documents du contrat
-- =============================================================================

CREATE TABLE IF NOT EXISTS location_gerance_documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_id UUID NOT NULL REFERENCES location_gerance_contracts(id) ON DELETE CASCADE,

  type_document VARCHAR(50) NOT NULL, -- contrat_signe, publication_jal, kbis_gerant, inventaire, etc.
  nom VARCHAR(255) NOT NULL,
  description TEXT,
  chemin_fichier VARCHAR(500) NOT NULL,
  obligatoire BOOLEAN DEFAULT FALSE,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_lg_documents_contract ON location_gerance_documents(contract_id);

-- =============================================================================
-- 9. TRIGGERS
-- =============================================================================

-- Trigger mise à jour updated_at
CREATE OR REPLACE FUNCTION update_location_gerance_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Appliquer aux tables
DROP TRIGGER IF EXISTS trigger_update_fonds_commerce_timestamp ON fonds_commerce;
CREATE TRIGGER trigger_update_fonds_commerce_timestamp
  BEFORE UPDATE ON fonds_commerce
  FOR EACH ROW
  EXECUTE FUNCTION update_location_gerance_timestamp();

DROP TRIGGER IF EXISTS trigger_update_lg_contracts_timestamp ON location_gerance_contracts;
CREATE TRIGGER trigger_update_lg_contracts_timestamp
  BEFORE UPDATE ON location_gerance_contracts
  FOR EACH ROW
  EXECUTE FUNCTION update_location_gerance_timestamp();

DROP TRIGGER IF EXISTS trigger_update_lg_redevances_timestamp ON location_gerance_redevances;
CREATE TRIGGER trigger_update_lg_redevances_timestamp
  BEFORE UPDATE ON location_gerance_redevances
  FOR EACH ROW
  EXECUTE FUNCTION update_location_gerance_timestamp();

-- Trigger: Mettre à jour le statut du fonds quand un contrat devient actif
CREATE OR REPLACE FUNCTION update_fonds_location_gerance_status()
RETURNS TRIGGER AS $$
BEGIN
  -- Si le contrat passe à "active"
  IF NEW.status = 'active' AND (OLD.status IS NULL OR OLD.status != 'active') THEN
    UPDATE fonds_commerce
    SET en_location_gerance = TRUE, location_gerance_id = NEW.id
    WHERE id = NEW.fonds_id;
  END IF;

  -- Si le contrat n'est plus actif
  IF NEW.status IN ('terminated', 'expired') AND OLD.status = 'active' THEN
    UPDATE fonds_commerce
    SET en_location_gerance = FALSE, location_gerance_id = NULL
    WHERE id = NEW.fonds_id AND location_gerance_id = NEW.id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_update_fonds_lg_status ON location_gerance_contracts;
CREATE TRIGGER trigger_update_fonds_lg_status
  AFTER UPDATE ON location_gerance_contracts
  FOR EACH ROW
  EXECUTE FUNCTION update_fonds_location_gerance_status();

-- =============================================================================
-- 10. RLS POLICIES
-- =============================================================================

-- Activer RLS
ALTER TABLE fonds_commerce ENABLE ROW LEVEL SECURITY;
ALTER TABLE fonds_commerce_licences ENABLE ROW LEVEL SECURITY;
ALTER TABLE fonds_commerce_equipements ENABLE ROW LEVEL SECURITY;
ALTER TABLE location_gerance_contracts ENABLE ROW LEVEL SECURITY;
ALTER TABLE location_gerance_redevances ENABLE ROW LEVEL SECURITY;
ALTER TABLE location_gerance_publications ENABLE ROW LEVEL SECURITY;
ALTER TABLE location_gerance_documents ENABLE ROW LEVEL SECURITY;

-- Policies pour fonds_commerce
CREATE POLICY "fonds_commerce_select_policy" ON fonds_commerce
  FOR SELECT USING (owner_id = auth.uid());

CREATE POLICY "fonds_commerce_insert_policy" ON fonds_commerce
  FOR INSERT WITH CHECK (owner_id = auth.uid());

CREATE POLICY "fonds_commerce_update_policy" ON fonds_commerce
  FOR UPDATE USING (owner_id = auth.uid());

CREATE POLICY "fonds_commerce_delete_policy" ON fonds_commerce
  FOR DELETE USING (owner_id = auth.uid() AND NOT en_location_gerance);

-- Policies pour location_gerance_contracts (accès via fonds)
CREATE POLICY "lg_contracts_select_policy" ON location_gerance_contracts
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM fonds_commerce f
      WHERE f.id = location_gerance_contracts.fonds_id
        AND f.owner_id = auth.uid()
    )
  );

CREATE POLICY "lg_contracts_insert_policy" ON location_gerance_contracts
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM fonds_commerce f
      WHERE f.id = location_gerance_contracts.fonds_id
        AND f.owner_id = auth.uid()
    )
  );

CREATE POLICY "lg_contracts_update_policy" ON location_gerance_contracts
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM fonds_commerce f
      WHERE f.id = location_gerance_contracts.fonds_id
        AND f.owner_id = auth.uid()
    )
  );

CREATE POLICY "lg_contracts_delete_policy" ON location_gerance_contracts
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM fonds_commerce f
      WHERE f.id = location_gerance_contracts.fonds_id
        AND f.owner_id = auth.uid()
    )
    AND status = 'draft'
  );

-- Policies pour tables liées (via contrat)
CREATE POLICY "fonds_licences_policy" ON fonds_commerce_licences
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM fonds_commerce f
      WHERE f.id = fonds_commerce_licences.fonds_id
        AND f.owner_id = auth.uid()
    )
  );

CREATE POLICY "fonds_equipements_policy" ON fonds_commerce_equipements
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM fonds_commerce f
      WHERE f.id = fonds_commerce_equipements.fonds_id
        AND f.owner_id = auth.uid()
    )
  );

CREATE POLICY "lg_redevances_policy" ON location_gerance_redevances
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM location_gerance_contracts c
      JOIN fonds_commerce f ON c.fonds_id = f.id
      WHERE c.id = location_gerance_redevances.contract_id
        AND f.owner_id = auth.uid()
    )
  );

CREATE POLICY "lg_publications_policy" ON location_gerance_publications
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM location_gerance_contracts c
      JOIN fonds_commerce f ON c.fonds_id = f.id
      WHERE c.id = location_gerance_publications.contract_id
        AND f.owner_id = auth.uid()
    )
  );

CREATE POLICY "lg_documents_policy" ON location_gerance_documents
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM location_gerance_contracts c
      JOIN fonds_commerce f ON c.fonds_id = f.id
      WHERE c.id = location_gerance_documents.contract_id
        AND f.owner_id = auth.uid()
    )
  );

-- =============================================================================
-- 11. FONCTIONS RPC
-- =============================================================================

-- Générer référence contrat
CREATE OR REPLACE FUNCTION generate_location_gerance_reference()
RETURNS TEXT AS $$
DECLARE
  v_year TEXT;
  v_count INTEGER;
  v_ref TEXT;
BEGIN
  v_year := TO_CHAR(NOW(), 'YYYY');

  SELECT COUNT(*) + 1 INTO v_count
  FROM location_gerance_contracts
  WHERE reference LIKE 'LG-' || v_year || '-%';

  v_ref := 'LG-' || v_year || '-' || LPAD(v_count::TEXT, 4, '0');

  RETURN v_ref;
END;
$$ LANGUAGE plpgsql;

-- Calcul de la redevance avec indexation
CREATE OR REPLACE FUNCTION calculate_location_gerance_redevance(
  p_contract_id UUID,
  p_periode VARCHAR(7),
  p_chiffre_affaires DECIMAL DEFAULT NULL
)
RETURNS TABLE (
  montant_base_ht DECIMAL,
  montant_variable DECIMAL,
  montant_total_ht DECIMAL,
  montant_tva DECIMAL,
  montant_ttc DECIMAL,
  indice_applique DECIMAL,
  coefficient_revision DECIMAL
) AS $$
DECLARE
  v_contract location_gerance_contracts%ROWTYPE;
  v_base DECIMAL;
  v_variable DECIMAL := 0;
  v_total_ht DECIMAL;
  v_tva DECIMAL;
  v_coef DECIMAL := 1;
BEGIN
  -- Récupérer le contrat
  SELECT * INTO v_contract
  FROM location_gerance_contracts
  WHERE id = p_contract_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Contrat non trouvé';
  END IF;

  -- Calcul du montant de base selon le type
  CASE v_contract.redevance_type
    WHEN 'fixe' THEN
      v_base := v_contract.redevance_montant_fixe_mensuel;

    WHEN 'pourcentage_ca' THEN
      IF p_chiffre_affaires IS NULL THEN
        RAISE EXCEPTION 'Chiffre d''affaires requis pour ce type de redevance';
      END IF;
      v_base := 0;
      v_variable := p_chiffre_affaires * (v_contract.redevance_pourcentage_ca / 100);

    WHEN 'mixte' THEN
      v_base := COALESCE(v_contract.redevance_minimum_garanti, 0);
      IF p_chiffre_affaires IS NOT NULL THEN
        v_variable := GREATEST(0, p_chiffre_affaires * (v_contract.redevance_pourcentage_ca / 100) - v_base);
      END IF;

    ELSE
      v_base := v_contract.redevance_montant_fixe_mensuel;
  END CASE;

  -- TODO: Appliquer l'indexation si activée
  -- (Nécessite une table des indices INSEE)

  v_total_ht := v_base + v_variable;

  -- Calcul TVA
  IF v_contract.redevance_tva_applicable THEN
    v_tva := v_total_ht * (v_contract.redevance_tva_taux / 100);
  ELSE
    v_tva := 0;
  END IF;

  RETURN QUERY SELECT
    v_base AS montant_base_ht,
    v_variable AS montant_variable,
    v_total_ht AS montant_total_ht,
    v_tva AS montant_tva,
    (v_total_ht + v_tva) AS montant_ttc,
    v_contract.redevance_indice_base AS indice_applique,
    v_coef AS coefficient_revision;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Obtenir contrat complet avec fonds
CREATE OR REPLACE FUNCTION get_location_gerance_complet(p_contract_id UUID)
RETURNS JSONB AS $$
DECLARE
  v_result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'contrat', row_to_json(c.*),
    'fonds', row_to_json(f.*),
    'licences', (
      SELECT COALESCE(jsonb_agg(row_to_json(l.*)), '[]'::jsonb)
      FROM fonds_commerce_licences l WHERE l.fonds_id = c.fonds_id
    ),
    'equipements', (
      SELECT COALESCE(jsonb_agg(row_to_json(e.*)), '[]'::jsonb)
      FROM fonds_commerce_equipements e WHERE e.fonds_id = c.fonds_id
    ),
    'redevances', (
      SELECT COALESCE(jsonb_agg(row_to_json(r.*) ORDER BY r.periode DESC), '[]'::jsonb)
      FROM location_gerance_redevances r WHERE r.contract_id = c.id
    ),
    'publications', (
      SELECT COALESCE(jsonb_agg(row_to_json(p.*) ORDER BY p.date_publication), '[]'::jsonb)
      FROM location_gerance_publications p WHERE p.contract_id = c.id
    ),
    'documents', (
      SELECT COALESCE(jsonb_agg(row_to_json(d.*)), '[]'::jsonb)
      FROM location_gerance_documents d WHERE d.contract_id = c.id
    )
  ) INTO v_result
  FROM location_gerance_contracts c
  JOIN fonds_commerce f ON c.fonds_id = f.id
  WHERE c.id = p_contract_id;

  RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- 12. VUES
-- =============================================================================

-- Vue des contrats de location-gérance actifs
CREATE OR REPLACE VIEW v_location_gerance_actifs AS
SELECT
  c.id,
  c.reference,
  c.status,
  c.date_debut,
  c.date_fin,
  c.duree_type,
  c.redevance_type,
  c.redevance_montant_fixe_mensuel,
  c.redevance_pourcentage_ca,
  f.nom_commercial,
  f.enseigne,
  f.type_fonds,
  f.activite_principale,
  f.adresse_exploitation,
  f.ville,
  CASE c.gerant_type
    WHEN 'personne_physique' THEN c.gerant_nom || ' ' || c.gerant_prenom
    ELSE c.gerant_raison_sociale
  END AS gerant_nom_complet,
  c.gerant_email,
  c.created_at,
  c.updated_at
FROM location_gerance_contracts c
JOIN fonds_commerce f ON c.fonds_id = f.id
WHERE c.status IN ('published', 'active')
ORDER BY c.date_debut DESC;

-- Vue des redevances en retard
CREATE OR REPLACE VIEW v_location_gerance_redevances_retard AS
SELECT
  r.*,
  c.reference AS contrat_reference,
  f.nom_commercial,
  CASE c.gerant_type
    WHEN 'personne_physique' THEN c.gerant_nom || ' ' || c.gerant_prenom
    ELSE c.gerant_raison_sociale
  END AS gerant_nom,
  c.gerant_email,
  CURRENT_DATE - r.date_echeance AS jours_retard
FROM location_gerance_redevances r
JOIN location_gerance_contracts c ON r.contract_id = c.id
JOIN fonds_commerce f ON c.fonds_id = f.id
WHERE r.statut IN ('pending', 'late')
  AND r.date_echeance < CURRENT_DATE
ORDER BY r.date_echeance;

-- =============================================================================
-- 13. COMMENTAIRES
-- =============================================================================

COMMENT ON TABLE fonds_commerce IS
  'Fonds de commerce - Articles L141-1 et suivants du Code de commerce';

COMMENT ON TABLE location_gerance_contracts IS
  'Contrats de location-gérance - Articles L144-1 à L144-13 du Code de commerce';

COMMENT ON COLUMN location_gerance_contracts.solidarite_duree_mois IS
  'Durée de solidarité fiscale et sociale du loueur (Art. L144-7) - 6 mois par défaut après publication';

COMMENT ON TABLE location_gerance_publications IS
  'Publications JAL obligatoires - Art. L144-6 du Code de commerce';


-- ========== 20260127000007_taxe_sejour.sql ==========
-- ============================================
-- Migration: Taxe de Séjour - GAP-006 SOTA 2026
-- ============================================
-- Conformité:
-- - Article L2333-26 à L2333-47 du CGCT
-- - Décret n°2019-1062 (taux plafonds)
-- - Loi de finances 2024 (taxe additionnelle)
-- ============================================

-- ============================================
-- ENUMS
-- ============================================

-- Types d'hébergement touristique
CREATE TYPE hebergement_touristique_type AS ENUM (
  'palace',
  'hotel_5_etoiles',
  'hotel_4_etoiles',
  'hotel_3_etoiles',
  'hotel_2_etoiles',
  'hotel_1_etoile',
  'hotel_non_classe',
  'residence_tourisme_5',
  'residence_tourisme_4',
  'residence_tourisme_3',
  'residence_tourisme_2',
  'residence_tourisme_1',
  'residence_tourisme_nc',
  'meuble_tourisme_5',
  'meuble_tourisme_4',
  'meuble_tourisme_3',
  'meuble_tourisme_2',
  'meuble_tourisme_1',
  'meuble_tourisme_nc',
  'chambre_hotes',
  'camping_5_etoiles',
  'camping_4_etoiles',
  'camping_3_etoiles',
  'camping_2_etoiles',
  'camping_1_etoile',
  'camping_non_classe',
  'village_vacances_4_5',
  'village_vacances_1_2_3',
  'auberge_jeunesse',
  'port_plaisance',
  'aire_camping_car',
  'autre_hebergement'
);

-- Mode de perception
CREATE TYPE mode_perception_taxe AS ENUM (
  'au_reel',
  'au_forfait'
);

-- Statut de déclaration
CREATE TYPE declaration_taxe_status AS ENUM (
  'brouillon',
  'a_declarer',
  'declaree',
  'validee',
  'payee',
  'annulee'
);

-- Motifs d'exonération
CREATE TYPE motif_exoneration_taxe AS ENUM (
  'mineur',
  'intermediaire_agence',
  'travailleur_saisonnier',
  'logement_urgence',
  'resident_secondaire_taxe'
);

-- ============================================
-- TABLE: taxe_sejour_communes
-- Configuration par commune
-- ============================================
CREATE TABLE taxe_sejour_communes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Identification commune
  code_insee VARCHAR(5) NOT NULL UNIQUE,
  nom_commune VARCHAR(255) NOT NULL,
  code_postal VARCHAR(5) NOT NULL,
  departement VARCHAR(3) NOT NULL,

  -- Configuration taxe
  taxe_active BOOLEAN NOT NULL DEFAULT true,
  mode_perception mode_perception_taxe NOT NULL DEFAULT 'au_reel',

  -- Tarifs par type (€/personne/nuit) - NULL = tarif plafond par défaut
  tarifs JSONB NOT NULL DEFAULT '{}',

  -- Taxe additionnelle départementale (max 10%)
  taxe_additionnelle_departementale NUMERIC(5,2) NOT NULL DEFAULT 10.00
    CHECK (taxe_additionnelle_departementale >= 0 AND taxe_additionnelle_departementale <= 10),

  -- Déclaration
  portail_declaration_url TEXT,
  periodicite_declaration VARCHAR(20) NOT NULL DEFAULT 'trimestrielle'
    CHECK (periodicite_declaration IN ('mensuelle', 'trimestrielle', 'annuelle')),
  jour_limite_declaration INTEGER NOT NULL DEFAULT 15
    CHECK (jour_limite_declaration >= 1 AND jour_limite_declaration <= 28),

  -- Métadonnées
  observations TEXT,
  date_debut_validite DATE NOT NULL DEFAULT CURRENT_DATE,
  date_fin_validite DATE,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index pour recherche par code postal / département
CREATE INDEX idx_taxe_sejour_communes_code_postal ON taxe_sejour_communes(code_postal);
CREATE INDEX idx_taxe_sejour_communes_departement ON taxe_sejour_communes(departement);

-- ============================================
-- TABLE: sejours_touristiques
-- Séjours soumis à taxe de séjour
-- ============================================
CREATE TABLE sejours_touristiques (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Liens
  lease_id UUID NOT NULL REFERENCES leases(id) ON DELETE CASCADE,
  property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  commune_config_id UUID REFERENCES taxe_sejour_communes(id),

  -- Classification hébergement
  type_hebergement hebergement_touristique_type NOT NULL DEFAULT 'meuble_tourisme_nc',
  numero_enregistrement VARCHAR(50), -- Obligatoire dans certaines villes

  -- Dates du séjour
  date_arrivee DATE NOT NULL,
  date_depart DATE NOT NULL,
  nombre_nuitees INTEGER NOT NULL GENERATED ALWAYS AS (date_depart - date_arrivee) STORED,

  -- Occupants (JSONB array)
  occupants JSONB NOT NULL DEFAULT '[]',
  nombre_occupants_total INTEGER NOT NULL DEFAULT 0,
  nombre_occupants_assujettis INTEGER NOT NULL DEFAULT 0,

  -- Calcul de la taxe
  taux_applique NUMERIC(10,2) NOT NULL DEFAULT 0,
  taux_additionnel_departemental NUMERIC(5,2) NOT NULL DEFAULT 0,
  montant_taxe_collectee NUMERIC(10,2) NOT NULL DEFAULT 0,
  montant_taxe_additionnelle NUMERIC(10,2) NOT NULL DEFAULT 0,
  montant_total NUMERIC(10,2) NOT NULL DEFAULT 0,

  -- Collecte
  taxe_collectee BOOLEAN NOT NULL DEFAULT false,
  date_collecte DATE,
  moyen_paiement_taxe VARCHAR(20)
    CHECK (moyen_paiement_taxe IN ('especes', 'cb', 'virement', 'inclus_loyer')),

  -- Lien vers déclaration
  declaration_id UUID REFERENCES declarations_taxe_sejour(id),

  -- Métadonnées
  observations TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Contraintes
  CONSTRAINT dates_sejour_valides CHECK (date_depart > date_arrivee),
  CONSTRAINT nuitees_max CHECK (nombre_nuitees <= 90) -- Max location saisonnière
);

-- Index pour requêtes fréquentes
CREATE INDEX idx_sejours_touristiques_lease ON sejours_touristiques(lease_id);
CREATE INDEX idx_sejours_touristiques_property ON sejours_touristiques(property_id);
CREATE INDEX idx_sejours_touristiques_owner ON sejours_touristiques(owner_id);
CREATE INDEX idx_sejours_touristiques_dates ON sejours_touristiques(date_arrivee, date_depart);
CREATE INDEX idx_sejours_touristiques_non_collectes ON sejours_touristiques(owner_id)
  WHERE NOT taxe_collectee;
CREATE INDEX idx_sejours_touristiques_non_declares ON sejours_touristiques(owner_id)
  WHERE declaration_id IS NULL AND taxe_collectee;

-- ============================================
-- TABLE: declarations_taxe_sejour
-- Déclarations périodiques à la commune
-- ============================================
CREATE TABLE declarations_taxe_sejour (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Liens
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  commune_config_id UUID NOT NULL REFERENCES taxe_sejour_communes(id),

  -- Période
  periode_debut DATE NOT NULL,
  periode_fin DATE NOT NULL,
  annee_fiscale INTEGER NOT NULL,
  periode_reference VARCHAR(10) NOT NULL, -- "2026-Q1" ou "2026-01"

  -- Statut
  statut declaration_taxe_status NOT NULL DEFAULT 'brouillon',

  -- Totaux calculés
  total_nuitees INTEGER NOT NULL DEFAULT 0,
  total_personnes_assujetties INTEGER NOT NULL DEFAULT 0,
  montant_taxe_totale NUMERIC(10,2) NOT NULL DEFAULT 0,
  montant_taxe_additionnelle NUMERIC(10,2) NOT NULL DEFAULT 0,
  montant_total_a_reverser NUMERIC(10,2) NOT NULL DEFAULT 0,

  -- Échéances
  date_limite DATE NOT NULL,
  date_declaration DATE,
  reference_declaration VARCHAR(100),

  -- Paiement
  date_paiement DATE,
  reference_paiement VARCHAR(100),
  moyen_paiement VARCHAR(20)
    CHECK (moyen_paiement IN ('virement', 'prelevement', 'cheque', 'telepaiement')),

  -- Documents
  justificatif_id UUID REFERENCES documents(id),

  -- Métadonnées
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Contraintes
  CONSTRAINT periode_declaration_valide CHECK (periode_fin >= periode_debut)
);

-- Ajouter la foreign key maintenant que la table existe
ALTER TABLE sejours_touristiques
  ADD CONSTRAINT fk_sejours_declaration
  FOREIGN KEY (declaration_id) REFERENCES declarations_taxe_sejour(id) ON DELETE SET NULL;

-- Index
CREATE INDEX idx_declarations_taxe_owner ON declarations_taxe_sejour(owner_id);
CREATE INDEX idx_declarations_taxe_commune ON declarations_taxe_sejour(commune_config_id);
CREATE INDEX idx_declarations_taxe_periode ON declarations_taxe_sejour(annee_fiscale, periode_reference);
CREATE INDEX idx_declarations_taxe_statut ON declarations_taxe_sejour(statut);
CREATE INDEX idx_declarations_taxe_en_retard ON declarations_taxe_sejour(owner_id, date_limite)
  WHERE statut IN ('brouillon', 'a_declarer');

-- ============================================
-- TABLE: tarifs_plafonds_taxe_sejour
-- Référentiel des tarifs plafonds légaux
-- ============================================
CREATE TABLE tarifs_plafonds_taxe_sejour (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  type_hebergement hebergement_touristique_type NOT NULL UNIQUE,
  tarif_plafond NUMERIC(10,2) NOT NULL,
  annee_reference INTEGER NOT NULL DEFAULT 2024,

  -- Source légale
  reference_legale TEXT NOT NULL DEFAULT 'Article L2333-30 CGCT',

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Insérer les tarifs plafonds 2024
INSERT INTO tarifs_plafonds_taxe_sejour (type_hebergement, tarif_plafond, annee_reference) VALUES
  ('palace', 15.00, 2024),
  ('hotel_5_etoiles', 5.00, 2024),
  ('hotel_4_etoiles', 2.88, 2024),
  ('hotel_3_etoiles', 1.70, 2024),
  ('hotel_2_etoiles', 1.00, 2024),
  ('hotel_1_etoile', 0.90, 2024),
  ('hotel_non_classe', 0.90, 2024),
  ('residence_tourisme_5', 5.00, 2024),
  ('residence_tourisme_4', 2.88, 2024),
  ('residence_tourisme_3', 1.70, 2024),
  ('residence_tourisme_2', 1.00, 2024),
  ('residence_tourisme_1', 0.90, 2024),
  ('residence_tourisme_nc', 0.90, 2024),
  ('meuble_tourisme_5', 5.00, 2024),
  ('meuble_tourisme_4', 2.88, 2024),
  ('meuble_tourisme_3', 1.70, 2024),
  ('meuble_tourisme_2', 1.00, 2024),
  ('meuble_tourisme_1', 0.90, 2024),
  ('meuble_tourisme_nc', 0.90, 2024),
  ('chambre_hotes', 0.90, 2024),
  ('camping_5_etoiles', 0.70, 2024),
  ('camping_4_etoiles', 0.60, 2024),
  ('camping_3_etoiles', 0.55, 2024),
  ('camping_2_etoiles', 0.33, 2024),
  ('camping_1_etoile', 0.25, 2024),
  ('camping_non_classe', 0.25, 2024),
  ('village_vacances_4_5', 1.00, 2024),
  ('village_vacances_1_2_3', 0.90, 2024),
  ('auberge_jeunesse', 0.25, 2024),
  ('port_plaisance', 0.25, 2024),
  ('aire_camping_car', 0.25, 2024),
  ('autre_hebergement', 0.90, 2024);

-- ============================================
-- RLS POLICIES
-- ============================================

ALTER TABLE taxe_sejour_communes ENABLE ROW LEVEL SECURITY;
ALTER TABLE sejours_touristiques ENABLE ROW LEVEL SECURITY;
ALTER TABLE declarations_taxe_sejour ENABLE ROW LEVEL SECURITY;
ALTER TABLE tarifs_plafonds_taxe_sejour ENABLE ROW LEVEL SECURITY;

-- Communes: lecture publique (référentiel)
CREATE POLICY "Communes lisibles par tous" ON taxe_sejour_communes
  FOR SELECT USING (true);

-- Tarifs plafonds: lecture publique
CREATE POLICY "Tarifs plafonds lisibles par tous" ON tarifs_plafonds_taxe_sejour
  FOR SELECT USING (true);

-- Séjours: accès propriétaire uniquement
CREATE POLICY "Séjours visibles par propriétaire" ON sejours_touristiques
  FOR SELECT USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Séjours créables par propriétaire" ON sejours_touristiques
  FOR INSERT WITH CHECK (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Séjours modifiables par propriétaire" ON sejours_touristiques
  FOR UPDATE USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Séjours supprimables par propriétaire" ON sejours_touristiques
  FOR DELETE USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    AND declaration_id IS NULL -- Ne pas supprimer si déjà déclaré
  );

-- Déclarations: accès propriétaire uniquement
CREATE POLICY "Déclarations visibles par propriétaire" ON declarations_taxe_sejour
  FOR SELECT USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Déclarations créables par propriétaire" ON declarations_taxe_sejour
  FOR INSERT WITH CHECK (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Déclarations modifiables par propriétaire" ON declarations_taxe_sejour
  FOR UPDATE USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    AND statut NOT IN ('payee', 'validee') -- Pas de modification après paiement
  );

-- ============================================
-- TRIGGERS
-- ============================================

-- Trigger updated_at
CREATE TRIGGER set_updated_at_taxe_sejour_communes
  BEFORE UPDATE ON taxe_sejour_communes
  FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER set_updated_at_sejours_touristiques
  BEFORE UPDATE ON sejours_touristiques
  FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER set_updated_at_declarations_taxe_sejour
  BEFORE UPDATE ON declarations_taxe_sejour
  FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- ============================================
-- FONCTIONS RPC
-- ============================================

-- Calculer la taxe pour un séjour
CREATE OR REPLACE FUNCTION calculate_taxe_sejour(
  p_nuitees INTEGER,
  p_occupants JSONB,
  p_type_hebergement hebergement_touristique_type,
  p_code_insee VARCHAR(5) DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_taux_unitaire NUMERIC(10,2);
  v_taux_additionnel NUMERIC(5,2) := 10.00;
  v_occupants_assujettis INTEGER := 0;
  v_occupants_exoneres INTEGER := 0;
  v_taxe_base NUMERIC(10,2);
  v_taxe_additionnelle NUMERIC(10,2);
  v_total NUMERIC(10,2);
  v_occupant JSONB;
BEGIN
  -- Récupérer le taux plafond par défaut
  SELECT tarif_plafond INTO v_taux_unitaire
  FROM tarifs_plafonds_taxe_sejour
  WHERE type_hebergement = p_type_hebergement;

  -- Si commune spécifiée, utiliser son taux
  IF p_code_insee IS NOT NULL THEN
    SELECT
      COALESCE((tarifs->>p_type_hebergement::text)::numeric, v_taux_unitaire),
      taxe_additionnelle_departementale
    INTO v_taux_unitaire, v_taux_additionnel
    FROM taxe_sejour_communes
    WHERE code_insee = p_code_insee
      AND taxe_active = true;
  END IF;

  -- Compter les occupants assujettis
  FOR v_occupant IN SELECT * FROM jsonb_array_elements(p_occupants)
  LOOP
    IF (v_occupant->>'est_mineur')::boolean = true
       OR v_occupant->>'exoneration' IS NOT NULL THEN
      v_occupants_exoneres := v_occupants_exoneres + 1;
    ELSE
      v_occupants_assujettis := v_occupants_assujettis + 1;
    END IF;
  END LOOP;

  -- Calcul
  v_taxe_base := p_nuitees * v_occupants_assujettis * v_taux_unitaire;
  v_taxe_additionnelle := v_taxe_base * (v_taux_additionnel / 100);
  v_total := v_taxe_base + v_taxe_additionnelle;

  RETURN jsonb_build_object(
    'nuitees', p_nuitees,
    'occupants_assujettis', v_occupants_assujettis,
    'occupants_exoneres', v_occupants_exoneres,
    'taux_unitaire', v_taux_unitaire,
    'taxe_base', ROUND(v_taxe_base, 2),
    'taux_additionnel_pct', v_taux_additionnel,
    'taxe_additionnelle', ROUND(v_taxe_additionnelle, 2),
    'total', ROUND(v_total, 2),
    'formule', p_nuitees || ' nuits × ' || v_occupants_assujettis || ' pers. × ' ||
               v_taux_unitaire || '€ = ' || ROUND(v_taxe_base, 2) || '€'
  );
END;
$$;

-- Récupérer les statistiques de taxe de séjour pour un propriétaire
CREATE OR REPLACE FUNCTION get_taxe_sejour_stats(
  p_owner_id UUID,
  p_annee INTEGER DEFAULT EXTRACT(YEAR FROM CURRENT_DATE)::integer
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result JSONB;
BEGIN
  WITH stats AS (
    SELECT
      COUNT(*) as nombre_sejours,
      COALESCE(SUM(nombre_nuitees), 0) as total_nuitees,
      COALESCE(SUM(nombre_occupants_assujettis), 0) as total_personnes,
      COALESCE(SUM(CASE WHEN taxe_collectee THEN montant_total ELSE 0 END), 0) as total_collecte,
      COALESCE(SUM(montant_total), 0) as total_a_reverser,
      COALESCE(SUM(CASE WHEN NOT taxe_collectee THEN montant_total ELSE 0 END), 0) as en_attente
    FROM sejours_touristiques
    WHERE owner_id = p_owner_id
      AND EXTRACT(YEAR FROM date_arrivee) = p_annee
  ),
  declarations AS (
    SELECT
      COUNT(*) FILTER (WHERE statut IN ('brouillon', 'a_declarer')) as en_cours,
      COUNT(*) FILTER (WHERE statut IN ('brouillon', 'a_declarer') AND date_limite < CURRENT_DATE) as en_retard
    FROM declarations_taxe_sejour
    WHERE owner_id = p_owner_id
      AND annee_fiscale = p_annee
  ),
  par_type AS (
    SELECT
      type_hebergement,
      SUM(nombre_nuitees) as nuitees,
      SUM(montant_total) as montant
    FROM sejours_touristiques
    WHERE owner_id = p_owner_id
      AND EXTRACT(YEAR FROM date_arrivee) = p_annee
    GROUP BY type_hebergement
  )
  SELECT jsonb_build_object(
    'periode', jsonb_build_object(
      'debut', p_annee || '-01-01',
      'fin', p_annee || '-12-31'
    ),
    'nombre_sejours', s.nombre_sejours,
    'total_nuitees', s.total_nuitees,
    'total_personnes', s.total_personnes,
    'total_taxe_collectee', s.total_collecte,
    'total_taxe_a_reverser', s.total_a_reverser,
    'taxe_en_attente', s.en_attente,
    'declarations_en_cours', d.en_cours,
    'declarations_en_retard', d.en_retard,
    'par_type_hebergement', COALESCE(
      (SELECT jsonb_agg(jsonb_build_object(
        'type', type_hebergement,
        'nuitees', nuitees,
        'montant', montant
      )) FROM par_type),
      '[]'::jsonb
    )
  )
  INTO v_result
  FROM stats s, declarations d;

  RETURN v_result;
END;
$$;

-- Créer une déclaration avec les séjours de la période
CREATE OR REPLACE FUNCTION create_declaration_taxe_sejour(
  p_owner_id UUID,
  p_commune_config_id UUID,
  p_periode_debut DATE,
  p_periode_fin DATE
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_declaration_id UUID;
  v_annee INTEGER;
  v_periode_ref VARCHAR(10);
  v_totaux RECORD;
  v_date_limite DATE;
  v_periodicite VARCHAR(20);
  v_jour_limite INTEGER;
BEGIN
  -- Récupérer la config commune
  SELECT periodicite_declaration, jour_limite_declaration
  INTO v_periodicite, v_jour_limite
  FROM taxe_sejour_communes
  WHERE id = p_commune_config_id;

  -- Calculer période de référence et date limite
  v_annee := EXTRACT(YEAR FROM p_periode_debut);

  IF v_periodicite = 'mensuelle' THEN
    v_periode_ref := TO_CHAR(p_periode_debut, 'YYYY-MM');
    v_date_limite := (DATE_TRUNC('month', p_periode_fin) + INTERVAL '1 month' + (v_jour_limite - 1) * INTERVAL '1 day')::date;
  ELSIF v_periodicite = 'trimestrielle' THEN
    v_periode_ref := v_annee || '-Q' || CEIL(EXTRACT(MONTH FROM p_periode_debut) / 3.0)::integer;
    v_date_limite := (DATE_TRUNC('quarter', p_periode_fin) + INTERVAL '3 months' + (v_jour_limite - 1) * INTERVAL '1 day')::date;
  ELSE -- annuelle
    v_periode_ref := v_annee::text;
    v_date_limite := MAKE_DATE(v_annee + 1, 1, v_jour_limite);
  END IF;

  -- Calculer les totaux des séjours de la période
  SELECT
    COALESCE(SUM(nombre_nuitees), 0),
    COALESCE(SUM(nombre_occupants_assujettis), 0),
    COALESCE(SUM(montant_taxe_collectee), 0),
    COALESCE(SUM(montant_taxe_additionnelle), 0),
    COALESCE(SUM(montant_total), 0)
  INTO v_totaux
  FROM sejours_touristiques
  WHERE owner_id = p_owner_id
    AND commune_config_id = p_commune_config_id
    AND date_arrivee >= p_periode_debut
    AND date_depart <= p_periode_fin
    AND declaration_id IS NULL
    AND taxe_collectee = true;

  -- Créer la déclaration
  INSERT INTO declarations_taxe_sejour (
    owner_id,
    commune_config_id,
    periode_debut,
    periode_fin,
    annee_fiscale,
    periode_reference,
    date_limite,
    total_nuitees,
    total_personnes_assujetties,
    montant_taxe_totale,
    montant_taxe_additionnelle,
    montant_total_a_reverser
  ) VALUES (
    p_owner_id,
    p_commune_config_id,
    p_periode_debut,
    p_periode_fin,
    v_annee,
    v_periode_ref,
    v_date_limite,
    v_totaux.sum,
    v_totaux.sum,
    v_totaux.sum,
    v_totaux.sum,
    v_totaux.sum
  )
  RETURNING id INTO v_declaration_id;

  -- Associer les séjours à cette déclaration
  UPDATE sejours_touristiques
  SET declaration_id = v_declaration_id
  WHERE owner_id = p_owner_id
    AND commune_config_id = p_commune_config_id
    AND date_arrivee >= p_periode_debut
    AND date_depart <= p_periode_fin
    AND declaration_id IS NULL
    AND taxe_collectee = true;

  RETURN v_declaration_id;
END;
$$;

-- ============================================
-- VUES
-- ============================================

-- Vue des séjours avec calculs
CREATE OR REPLACE VIEW v_sejours_touristiques_complets AS
SELECT
  s.*,
  l.type_bail,
  l.date_debut as bail_date_debut,
  l.date_fin as bail_date_fin,
  p.adresse_complete,
  p.code_postal as property_code_postal,
  p.ville,
  c.nom_commune,
  c.code_insee,
  c.taxe_additionnelle_departementale,
  CASE
    WHEN s.taxe_collectee THEN 'Collectée'
    WHEN s.date_depart < CURRENT_DATE THEN 'À collecter'
    ELSE 'En cours'
  END as statut_collecte,
  CASE
    WHEN s.declaration_id IS NOT NULL THEN 'Déclaré'
    WHEN s.taxe_collectee AND s.declaration_id IS NULL THEN 'À déclarer'
    ELSE 'En attente'
  END as statut_declaration
FROM sejours_touristiques s
JOIN leases l ON s.lease_id = l.id
JOIN properties p ON s.property_id = p.id
LEFT JOIN taxe_sejour_communes c ON s.commune_config_id = c.id;

-- Vue des déclarations en retard
CREATE OR REPLACE VIEW v_declarations_taxe_en_retard AS
SELECT
  d.*,
  c.nom_commune,
  c.code_insee,
  CURRENT_DATE - d.date_limite as jours_retard
FROM declarations_taxe_sejour d
JOIN taxe_sejour_communes c ON d.commune_config_id = c.id
WHERE d.statut IN ('brouillon', 'a_declarer')
  AND d.date_limite < CURRENT_DATE;

-- ============================================
-- DONNÉES INITIALES - Quelques communes exemple
-- ============================================

INSERT INTO taxe_sejour_communes (code_insee, nom_commune, code_postal, departement, tarifs, observations) VALUES
  ('75056', 'Paris', '75001', '75',
   '{"palace": 15.00, "hotel_5_etoiles": 5.00, "hotel_4_etoiles": 2.88, "hotel_3_etoiles": 1.70, "hotel_2_etoiles": 1.00, "meuble_tourisme_nc": 0.90}'::jsonb,
   'Déclaration via paris.fr - Numéro enregistrement obligatoire'),
  ('13055', 'Marseille', '13001', '13',
   '{"meuble_tourisme_nc": 0.83, "meuble_tourisme_1": 0.83, "meuble_tourisme_2": 0.94, "meuble_tourisme_3": 1.50}'::jsonb,
   'Déclaration via taxesejour-marseille.fr'),
  ('69123', 'Lyon', '69001', '69',
   '{"meuble_tourisme_nc": 0.88, "meuble_tourisme_3": 1.65, "meuble_tourisme_4": 2.50}'::jsonb,
   'Déclaration via lyon.fr'),
  ('06088', 'Nice', '06000', '06',
   '{"meuble_tourisme_nc": 0.90, "meuble_tourisme_3": 1.70, "meuble_tourisme_4": 2.88}'::jsonb,
   'Déclaration via nice.fr');

-- ============================================
-- COMMENTAIRES
-- ============================================

COMMENT ON TABLE taxe_sejour_communes IS 'Configuration de la taxe de séjour par commune - Article L2333-26 CGCT';
COMMENT ON TABLE sejours_touristiques IS 'Séjours touristiques soumis à taxe de séjour';
COMMENT ON TABLE declarations_taxe_sejour IS 'Déclarations périodiques de taxe de séjour à reverser aux communes';
COMMENT ON TABLE tarifs_plafonds_taxe_sejour IS 'Référentiel des tarifs plafonds légaux par type d''hébergement';

COMMENT ON FUNCTION calculate_taxe_sejour IS 'Calcule le montant de taxe de séjour pour un séjour donné';
COMMENT ON FUNCTION get_taxe_sejour_stats IS 'Récupère les statistiques de taxe de séjour pour un propriétaire';
COMMENT ON FUNCTION create_declaration_taxe_sejour IS 'Crée une déclaration de taxe de séjour avec les séjours de la période';


-- ========== 20260127000008_diagnostics_dom_tom.sql ==========
-- ============================================
-- Migration: Diagnostics DOM-TOM - GAP-009/010/011 SOTA 2026
-- ============================================
-- Spécificités réglementaires des départements d'outre-mer:
-- - 971: Guadeloupe, 972: Martinique, 973: Guyane
-- - 974: La Réunion, 976: Mayotte
--
-- Conformité:
-- - Loi n°99-471 du 8 juin 1999 (termites)
-- - Code de l'environnement (risques naturels DOM)
-- ============================================

-- ============================================
-- ENUMS
-- ============================================

-- États d'infestation termites
CREATE TYPE etat_termites AS ENUM (
  'absence',
  'indices_anciens',
  'presence_active',
  'non_visible'
);

-- Types de termites tropicaux
CREATE TYPE type_termite AS ENUM (
  'reticulitermes',
  'cryptotermes',
  'coptotermes',
  'nasutitermes',
  'heterotermes'
);

-- Zones d'inspection termites
CREATE TYPE zone_diagnostic_termites AS ENUM (
  'interieur',
  'exterieur',
  'parties_communes',
  'dependances'
);

-- Risques naturels spécifiques DOM
CREATE TYPE risque_naturel_dom AS ENUM (
  'cyclone',
  'seisme',
  'volcan',
  'tsunami',
  'inondation',
  'mouvement_terrain',
  'submersion_marine',
  'erosion_cotiere',
  'recul_trait_cote',
  'radon',
  'feu_foret'
);

-- Zones volcaniques
CREATE TYPE zone_volcanique AS ENUM (
  'zone_interdite',
  'zone_danger_immediat',
  'zone_proximite',
  'zone_eloignee'
);

-- ============================================
-- TABLE: diagnostics_termites
-- Diagnostic termites obligatoire en DOM
-- ============================================
CREATE TABLE diagnostics_termites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Bien concerné
  property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,

  -- Diagnostiqueur
  diagnostiqueur_nom VARCHAR(255) NOT NULL,
  diagnostiqueur_certification VARCHAR(100) NOT NULL,
  numero_certification VARCHAR(50) NOT NULL,
  assurance_rc VARCHAR(100) NOT NULL,
  date_validite_certification DATE NOT NULL,

  -- Dates
  date_diagnostic DATE NOT NULL,
  date_validite DATE NOT NULL, -- 6 mois après diagnostic

  -- Localisation
  departement VARCHAR(3) NOT NULL,
  commune VARCHAR(255) NOT NULL,
  zone_arrete_prefectoral BOOLEAN NOT NULL DEFAULT true, -- Tout DOM est en zone arrêté
  reference_arrete VARCHAR(100),

  -- Résultat global
  conclusion etat_termites NOT NULL,
  presence_active BOOLEAN NOT NULL DEFAULT false,

  -- Types identifiés
  types_termites_identifies type_termite[] DEFAULT '{}',

  -- Traitement existant
  traitement_preventif_existant BOOLEAN NOT NULL DEFAULT false,
  date_dernier_traitement DATE,

  -- Recommandations
  recommandations TEXT[] DEFAULT '{}',

  -- Document
  document_id UUID REFERENCES documents(id),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Contrainte de validité (6 mois)
  CONSTRAINT validite_6_mois CHECK (date_validite = date_diagnostic + INTERVAL '6 months')
);

-- Index
CREATE INDEX idx_diagnostics_termites_property ON diagnostics_termites(property_id);
CREATE INDEX idx_diagnostics_termites_owner ON diagnostics_termites(owner_id);
CREATE INDEX idx_diagnostics_termites_departement ON diagnostics_termites(departement);
CREATE INDEX idx_diagnostics_termites_validite ON diagnostics_termites(date_validite);
CREATE INDEX idx_diagnostics_termites_actifs ON diagnostics_termites(property_id)
  WHERE presence_active = true;

-- ============================================
-- TABLE: diagnostics_termites_zones
-- Détail par zone inspectée
-- ============================================
CREATE TABLE diagnostics_termites_zones (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  diagnostic_id UUID NOT NULL REFERENCES diagnostics_termites(id) ON DELETE CASCADE,

  zone zone_diagnostic_termites NOT NULL,
  localisation VARCHAR(255) NOT NULL,
  etat etat_termites NOT NULL,
  elements_infestes TEXT[] DEFAULT '{}',
  observations TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_termites_zones_diagnostic ON diagnostics_termites_zones(diagnostic_id);

-- ============================================
-- TABLE: erp_dom_tom
-- État des Risques et Pollutions spécifique DOM
-- ============================================
CREATE TABLE erp_dom_tom (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Bien concerné
  property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
  owner_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,

  -- Localisation
  departement VARCHAR(3) NOT NULL CHECK (departement IN ('971', '972', '973', '974', '976')),
  commune VARCHAR(255) NOT NULL,

  -- Dates
  date_erp DATE NOT NULL,
  date_validite DATE NOT NULL, -- 6 mois

  -- Zone sismique (tous les DOM sont >= 2)
  zone_sismique INTEGER NOT NULL CHECK (zone_sismique BETWEEN 1 AND 5),

  -- Zone cyclonique
  zone_cyclonique BOOLEAN NOT NULL DEFAULT false,
  normes_paracycloniques BOOLEAN NOT NULL DEFAULT false,

  -- Zone volcanique
  zone_volcanique zone_volcanique,
  distance_volcan_km NUMERIC(10,2),
  volcan_reference VARCHAR(100),

  -- Tsunami
  risque_tsunami BOOLEAN NOT NULL DEFAULT false,

  -- Submersion marine
  zone_submersion_marine BOOLEAN NOT NULL DEFAULT false,

  -- Inondation
  zone_inondable BOOLEAN NOT NULL DEFAULT false,

  -- PPRN
  pprn_existe BOOLEAN NOT NULL DEFAULT false,
  pprn_reference VARCHAR(100),
  pprn_date_approbation DATE,
  pprn_prescriptions TEXT[] DEFAULT '{}',

  -- Mouvement de terrain
  mouvement_terrain BOOLEAN NOT NULL DEFAULT false,

  -- Érosion côtière
  erosion_cotiere BOOLEAN NOT NULL DEFAULT false,

  -- Recul du trait de côte (loi Climat et Résilience)
  recul_trait_cote_concerne BOOLEAN NOT NULL DEFAULT false,
  recul_trait_cote_30_ans BOOLEAN NOT NULL DEFAULT false,
  recul_trait_cote_100_ans BOOLEAN NOT NULL DEFAULT false,

  -- Risques technologiques
  seveso_proximite BOOLEAN NOT NULL DEFAULT false,
  distance_seveso_m NUMERIC(10,2),

  -- Pollution
  sis BOOLEAN NOT NULL DEFAULT false, -- Secteur d'information sur les sols

  -- Radon (zones volcaniques)
  zone_radon INTEGER CHECK (zone_radon BETWEEN 1 AND 3),

  -- IAL
  ial_annexe BOOLEAN NOT NULL DEFAULT true,

  -- Document
  document_id UUID REFERENCES documents(id),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index
CREATE INDEX idx_erp_dom_tom_property ON erp_dom_tom(property_id);
CREATE INDEX idx_erp_dom_tom_departement ON erp_dom_tom(departement);
CREATE INDEX idx_erp_dom_tom_validite ON erp_dom_tom(date_validite);

-- ============================================
-- TABLE: dom_referentiel
-- Référentiel des DOM et leurs caractéristiques
-- ============================================
CREATE TABLE dom_referentiel (
  departement VARCHAR(3) PRIMARY KEY CHECK (departement IN ('971', '972', '973', '974', '976')),

  nom VARCHAR(100) NOT NULL,
  region VARCHAR(100) NOT NULL,
  chef_lieu VARCHAR(100) NOT NULL,
  fuseau_horaire VARCHAR(50) NOT NULL,

  -- Risques
  risques_specifiques risque_naturel_dom[] NOT NULL,
  zone_sismique INTEGER NOT NULL CHECK (zone_sismique BETWEEN 1 AND 5),
  zone_cyclonique BOOLEAN NOT NULL DEFAULT false,
  zone_volcanique BOOLEAN NOT NULL DEFAULT false,
  volcan_actif VARCHAR(100),

  -- Obligations
  termites_obligatoire BOOLEAN NOT NULL DEFAULT true,
  normes_paracycloniques BOOLEAN NOT NULL DEFAULT false,
  normes_parasismiques BOOLEAN NOT NULL DEFAULT false,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Données de référence DOM
INSERT INTO dom_referentiel (departement, nom, region, chef_lieu, fuseau_horaire, risques_specifiques, zone_sismique, zone_cyclonique, zone_volcanique, volcan_actif, normes_paracycloniques, normes_parasismiques) VALUES
  ('971', 'Guadeloupe', 'Guadeloupe', 'Basse-Terre', 'America/Guadeloupe',
   ARRAY['cyclone', 'seisme', 'volcan', 'tsunami', 'inondation', 'mouvement_terrain']::risque_naturel_dom[],
   5, true, true, 'La Soufrière', true, true),
  ('972', 'Martinique', 'Martinique', 'Fort-de-France', 'America/Martinique',
   ARRAY['cyclone', 'seisme', 'volcan', 'tsunami', 'inondation', 'mouvement_terrain']::risque_naturel_dom[],
   5, true, true, 'Montagne Pelée', true, true),
  ('973', 'Guyane', 'Guyane', 'Cayenne', 'America/Cayenne',
   ARRAY['inondation', 'mouvement_terrain', 'feu_foret']::risque_naturel_dom[],
   2, false, false, NULL, false, false),
  ('974', 'La Réunion', 'La Réunion', 'Saint-Denis', 'Indian/Reunion',
   ARRAY['cyclone', 'seisme', 'volcan', 'tsunami', 'inondation', 'mouvement_terrain', 'erosion_cotiere']::risque_naturel_dom[],
   4, true, true, 'Piton de la Fournaise', true, true),
  ('976', 'Mayotte', 'Mayotte', 'Mamoudzou', 'Indian/Mayotte',
   ARRAY['cyclone', 'seisme', 'tsunami', 'inondation', 'mouvement_terrain', 'volcan']::risque_naturel_dom[],
   4, true, true, 'Volcan sous-marin Fani Maoré', true, true);

-- ============================================
-- RLS POLICIES
-- ============================================

ALTER TABLE diagnostics_termites ENABLE ROW LEVEL SECURITY;
ALTER TABLE diagnostics_termites_zones ENABLE ROW LEVEL SECURITY;
ALTER TABLE erp_dom_tom ENABLE ROW LEVEL SECURITY;
ALTER TABLE dom_referentiel ENABLE ROW LEVEL SECURITY;

-- Référentiel DOM: lecture publique
CREATE POLICY "Référentiel DOM lisible par tous" ON dom_referentiel
  FOR SELECT USING (true);

-- Diagnostics termites: accès propriétaire
CREATE POLICY "Diagnostics termites visibles par propriétaire" ON diagnostics_termites
  FOR SELECT USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Diagnostics termites créables par propriétaire" ON diagnostics_termites
  FOR INSERT WITH CHECK (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Diagnostics termites modifiables par propriétaire" ON diagnostics_termites
  FOR UPDATE USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- Zones termites: accès via diagnostic parent
CREATE POLICY "Zones termites visibles si diagnostic visible" ON diagnostics_termites_zones
  FOR SELECT USING (
    diagnostic_id IN (
      SELECT id FROM diagnostics_termites
      WHERE owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

CREATE POLICY "Zones termites créables si diagnostic propriétaire" ON diagnostics_termites_zones
  FOR INSERT WITH CHECK (
    diagnostic_id IN (
      SELECT id FROM diagnostics_termites
      WHERE owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
    )
  );

-- ERP DOM: accès propriétaire
CREATE POLICY "ERP DOM visibles par propriétaire" ON erp_dom_tom
  FOR SELECT USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "ERP DOM créables par propriétaire" ON erp_dom_tom
  FOR INSERT WITH CHECK (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "ERP DOM modifiables par propriétaire" ON erp_dom_tom
  FOR UPDATE USING (
    owner_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
  );

-- ============================================
-- TRIGGERS
-- ============================================

-- Updated_at triggers
CREATE TRIGGER set_updated_at_diagnostics_termites
  BEFORE UPDATE ON diagnostics_termites
  FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER set_updated_at_erp_dom_tom
  BEFORE UPDATE ON erp_dom_tom
  FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- ============================================
-- FONCTIONS RPC
-- ============================================

-- Vérifie si un diagnostic termites est requis pour un bien
CREATE OR REPLACE FUNCTION is_termites_required(p_property_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_departement VARCHAR(3);
BEGIN
  SELECT departement INTO v_departement
  FROM properties
  WHERE id = p_property_id;

  -- Tous les DOM nécessitent un diagnostic termites
  IF v_departement IN ('971', '972', '973', '974', '976') THEN
    RETURN true;
  END IF;

  -- En métropole, vérifier si zone à arrêté préfectoral
  -- (non implémenté - retourne false par défaut)
  RETURN false;
END;
$$;

-- Vérifie si un diagnostic termites est valide pour un bien
CREATE OR REPLACE FUNCTION is_termites_valid(p_property_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_diagnostic diagnostics_termites%ROWTYPE;
  v_valid BOOLEAN;
  v_message TEXT;
BEGIN
  -- Récupérer le diagnostic le plus récent
  SELECT * INTO v_diagnostic
  FROM diagnostics_termites
  WHERE property_id = p_property_id
  ORDER BY date_diagnostic DESC
  LIMIT 1;

  IF v_diagnostic IS NULL THEN
    RETURN jsonb_build_object(
      'valid', false,
      'exists', false,
      'message', 'Aucun diagnostic termites trouvé'
    );
  END IF;

  v_valid := v_diagnostic.date_validite >= CURRENT_DATE;

  IF v_valid THEN
    v_message := 'Diagnostic valide jusqu''au ' || v_diagnostic.date_validite::text;
  ELSE
    v_message := 'Diagnostic expiré depuis le ' || v_diagnostic.date_validite::text;
  END IF;

  RETURN jsonb_build_object(
    'valid', v_valid,
    'exists', true,
    'diagnostic_id', v_diagnostic.id,
    'date_diagnostic', v_diagnostic.date_diagnostic,
    'date_validite', v_diagnostic.date_validite,
    'conclusion', v_diagnostic.conclusion,
    'presence_active', v_diagnostic.presence_active,
    'message', v_message
  );
END;
$$;

-- Récupère les diagnostics obligatoires pour un bien DOM
CREATE OR REPLACE FUNCTION get_diagnostics_obligatoires_dom(
  p_property_id UUID,
  p_is_vente BOOLEAN DEFAULT false
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_departement VARCHAR(3);
  v_dom_info dom_referentiel%ROWTYPE;
  v_diagnostics JSONB := '[]'::jsonb;
BEGIN
  -- Récupérer le département du bien
  SELECT departement INTO v_departement
  FROM properties
  WHERE id = p_property_id;

  IF v_departement NOT IN ('971', '972', '973', '974', '976') THEN
    RETURN jsonb_build_object(
      'is_dom', false,
      'diagnostics', '[]'::jsonb
    );
  END IF;

  -- Récupérer les infos du DOM
  SELECT * INTO v_dom_info
  FROM dom_referentiel
  WHERE departement = v_departement;

  -- Construire la liste des diagnostics
  v_diagnostics := v_diagnostics || jsonb_build_object(
    'type', 'termites',
    'nom', 'Diagnostic termites (état parasitaire)',
    'obligatoire', true,
    'validite_mois', 6,
    'specificite', 'Espèces tropicales agressives'
  );

  v_diagnostics := v_diagnostics || jsonb_build_object(
    'type', 'erp',
    'nom', 'État des Risques et Pollutions DOM',
    'obligatoire', true,
    'validite_mois', 6,
    'risques', v_dom_info.risques_specifiques
  );

  IF v_dom_info.normes_paracycloniques THEN
    v_diagnostics := v_diagnostics || jsonb_build_object(
      'type', 'paracyclonique',
      'nom', 'Attestation normes paracycloniques',
      'obligatoire', true,
      'validite_mois', NULL
    );
  END IF;

  IF v_dom_info.normes_parasismiques THEN
    v_diagnostics := v_diagnostics || jsonb_build_object(
      'type', 'parasismique',
      'nom', 'Attestation normes parasismiques',
      'obligatoire', true,
      'zone_sismique', v_dom_info.zone_sismique
    );
  END IF;

  RETURN jsonb_build_object(
    'is_dom', true,
    'departement', v_departement,
    'nom', v_dom_info.nom,
    'zone_sismique', v_dom_info.zone_sismique,
    'zone_cyclonique', v_dom_info.zone_cyclonique,
    'zone_volcanique', v_dom_info.zone_volcanique,
    'volcan_actif', v_dom_info.volcan_actif,
    'diagnostics', v_diagnostics
  );
END;
$$;

-- ============================================
-- VUES
-- ============================================

-- Diagnostics termites expirés ou à renouveler
CREATE OR REPLACE VIEW v_diagnostics_termites_a_renouveler AS
SELECT
  dt.*,
  p.adresse_complete,
  p.code_postal,
  p.ville,
  p.departement,
  CASE
    WHEN dt.date_validite < CURRENT_DATE THEN 'expiré'
    WHEN dt.date_validite < CURRENT_DATE + INTERVAL '30 days' THEN 'expire_bientot'
    ELSE 'valide'
  END as statut_validite,
  dt.date_validite - CURRENT_DATE as jours_restants
FROM diagnostics_termites dt
JOIN properties p ON dt.property_id = p.id
WHERE dt.date_validite < CURRENT_DATE + INTERVAL '60 days';

-- Biens DOM sans diagnostic termites valide
CREATE OR REPLACE VIEW v_biens_dom_sans_termites AS
SELECT
  p.id as property_id,
  p.owner_id,
  p.adresse_complete,
  p.code_postal,
  p.ville,
  p.departement,
  dr.nom as nom_dom,
  dr.zone_sismique,
  dr.zone_cyclonique,
  dr.zone_volcanique,
  dr.volcan_actif
FROM properties p
JOIN dom_referentiel dr ON p.departement = dr.departement
LEFT JOIN diagnostics_termites dt ON p.id = dt.property_id AND dt.date_validite >= CURRENT_DATE
WHERE dt.id IS NULL;

-- ============================================
-- COMMENTAIRES
-- ============================================

COMMENT ON TABLE diagnostics_termites IS 'Diagnostics termites obligatoires en DOM - Loi du 8 juin 1999';
COMMENT ON TABLE erp_dom_tom IS 'État des Risques et Pollutions spécifique aux DOM';
COMMENT ON TABLE dom_referentiel IS 'Référentiel des caractéristiques et obligations par DOM';

COMMENT ON FUNCTION is_termites_required IS 'Vérifie si un diagnostic termites est requis pour un bien';
COMMENT ON FUNCTION is_termites_valid IS 'Vérifie la validité du diagnostic termites d''un bien';
COMMENT ON FUNCTION get_diagnostics_obligatoires_dom IS 'Liste les diagnostics obligatoires pour un bien DOM';


-- ========== 20260128000000_surface_carrez_rent_control.sql ==========
-- Migration : Surface Carrez et encadrement des loyers SOTA 2026
-- Ajoute les colonnes pour la conformite loi ALUR et decret decence
BEGIN;

-- ============================================
-- SURFACE CARREZ (Loi du 18 decembre 1996)
-- ============================================
-- Surface privative certifiee, obligatoire en copropriete
-- Doit etre <= surface_habitable_m2

ALTER TABLE properties
  ADD COLUMN IF NOT EXISTS surface_carrez NUMERIC(8,2),
  ADD COLUMN IF NOT EXISTS surface_carrez_certifiee BOOLEAN DEFAULT false;

-- Commentaire pour documentation
COMMENT ON COLUMN properties.surface_carrez IS 'Surface privative loi Carrez (m2), obligatoire en copropriete';
COMMENT ON COLUMN properties.surface_carrez_certifiee IS 'Surface Carrez certifiee par un diagnostiqueur agree';

-- ============================================
-- ENCADREMENT DES LOYERS (Loi ALUR / ELAN)
-- ============================================
-- Pour les zones tendues avec encadrement (Paris, Lille, Lyon, etc.)

ALTER TABLE properties
  ADD COLUMN IF NOT EXISTS zone_encadrement TEXT,
  ADD COLUMN IF NOT EXISTS loyer_reference NUMERIC(12,2),
  ADD COLUMN IF NOT EXISTS loyer_reference_majore NUMERIC(12,2),
  ADD COLUMN IF NOT EXISTS complement_loyer NUMERIC(12,2),
  ADD COLUMN IF NOT EXISTS complement_loyer_justification TEXT;

-- Contrainte sur zone_encadrement
ALTER TABLE properties
  DROP CONSTRAINT IF EXISTS properties_zone_encadrement_check;

ALTER TABLE properties
  ADD CONSTRAINT properties_zone_encadrement_check
    CHECK (zone_encadrement IS NULL OR zone_encadrement IN (
      'paris',
      'paris_agglo',
      'lille',
      'lyon',
      'villeurbanne',
      'montpellier',
      'bordeaux',
      'aucune'
    ));

COMMENT ON COLUMN properties.zone_encadrement IS 'Zone d encadrement des loyers (Paris, Lille, Lyon, etc.)';
COMMENT ON COLUMN properties.loyer_reference IS 'Loyer de reference median pour la zone (EUR/m2)';
COMMENT ON COLUMN properties.loyer_reference_majore IS 'Loyer de reference majore (loyer_reference * 1.2)';
COMMENT ON COLUMN properties.complement_loyer IS 'Complement de loyer exceptionnel (EUR/mois)';
COMMENT ON COLUMN properties.complement_loyer_justification IS 'Justification du complement de loyer (caracteristiques exceptionnelles)';

-- ============================================
-- DPE COMPLET (Loi Climat et Resilience 2021)
-- ============================================
-- Champs DPE detailles pour conformite

ALTER TABLE properties
  ADD COLUMN IF NOT EXISTS dpe_classe_energie TEXT,
  ADD COLUMN IF NOT EXISTS dpe_classe_climat TEXT,
  ADD COLUMN IF NOT EXISTS dpe_consommation NUMERIC(8,2),
  ADD COLUMN IF NOT EXISTS dpe_emissions NUMERIC(8,2),
  ADD COLUMN IF NOT EXISTS dpe_date_realisation DATE,
  ADD COLUMN IF NOT EXISTS dpe_numero TEXT;

-- Contraintes DPE
ALTER TABLE properties
  DROP CONSTRAINT IF EXISTS properties_dpe_classe_energie_check,
  DROP CONSTRAINT IF EXISTS properties_dpe_classe_climat_check;

ALTER TABLE properties
  ADD CONSTRAINT properties_dpe_classe_energie_check
    CHECK (dpe_classe_energie IS NULL OR dpe_classe_energie IN ('A','B','C','D','E','F','G','NC')),
  ADD CONSTRAINT properties_dpe_classe_climat_check
    CHECK (dpe_classe_climat IS NULL OR dpe_classe_climat IN ('A','B','C','D','E','F','G','NC'));

COMMENT ON COLUMN properties.dpe_classe_energie IS 'Classe energie DPE (A-G ou NC)';
COMMENT ON COLUMN properties.dpe_classe_climat IS 'Classe emissions GES (A-G ou NC)';
COMMENT ON COLUMN properties.dpe_consommation IS 'Consommation energetique (kWh/m2/an)';
COMMENT ON COLUMN properties.dpe_emissions IS 'Emissions GES (kg CO2/m2/an)';

-- ============================================
-- INDEX POUR PERFORMANCE
-- ============================================

CREATE INDEX IF NOT EXISTS idx_properties_dpe_classe ON properties(dpe_classe_energie);
CREATE INDEX IF NOT EXISTS idx_properties_zone_encadrement ON properties(zone_encadrement);
CREATE INDEX IF NOT EXISTS idx_properties_surface_carrez ON properties(surface_carrez);

COMMIT;


-- ========== 20260128000001_fix_edl_schema_500.sql ==========
-- ============================================================================
-- MIGRATION: Fix EDL table schema - Resolve 500 error on EDL creation
-- Date: 2026-01-28
-- Fixes:
--   1. Add property_id FK column (used by POST /api/properties/[id]/inspections)
--   2. Add scheduled_at TIMESTAMPTZ column (used by wizard creation flow)
--   3. Extend status CHECK constraint to include 'scheduled' and 'closed'
--   4. Backfill property_id from leases.property_id for existing records
-- ============================================================================

-- 1. Add property_id column to edl table
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'edl' AND column_name = 'property_id'
    ) THEN
        ALTER TABLE edl ADD COLUMN property_id UUID REFERENCES properties(id) ON DELETE SET NULL;
        RAISE NOTICE 'Added property_id column to edl table';
    END IF;
END $$;

-- 2. Add scheduled_at TIMESTAMPTZ column (more precise than scheduled_date DATE)
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'edl' AND column_name = 'scheduled_at'
    ) THEN
        ALTER TABLE edl ADD COLUMN scheduled_at TIMESTAMPTZ;
        RAISE NOTICE 'Added scheduled_at column to edl table';
    END IF;
END $$;

-- 3. Extend status CHECK constraint to include 'scheduled' and 'closed'
-- Drop existing constraint and recreate with all valid statuses
DO $$
BEGIN
    -- Drop existing constraint (may have different names depending on migration order)
    ALTER TABLE edl DROP CONSTRAINT IF EXISTS edl_status_check;

    -- Recreate with all statuses used in the codebase
    ALTER TABLE edl ADD CONSTRAINT edl_status_check
        CHECK (status IN (
            'draft',           -- Brouillon initial
            'scheduled',       -- Planifie (cree via le wizard)
            'in_progress',     -- En cours de saisie
            'completed',       -- Complete, en attente de signatures
            'signed',          -- Signe par toutes les parties
            'disputed',        -- Conteste
            'closed'           -- Cloture (archive)
        ));

    RAISE NOTICE 'Updated status CHECK constraint on edl table';
EXCEPTION
    WHEN others THEN
        RAISE NOTICE 'Could not update status constraint: %', SQLERRM;
END $$;

-- 4. Backfill property_id from leases.property_id for existing records
UPDATE edl e
SET property_id = l.property_id
FROM leases l
WHERE e.lease_id = l.id
AND e.property_id IS NULL
AND l.property_id IS NOT NULL;

-- 5. Backfill scheduled_at from scheduled_date for existing records
UPDATE edl
SET scheduled_at = scheduled_date::timestamptz
WHERE scheduled_at IS NULL
AND scheduled_date IS NOT NULL;

-- 6. Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_edl_property_id ON edl(property_id);
CREATE INDEX IF NOT EXISTS idx_edl_scheduled_at ON edl(scheduled_at);
CREATE INDEX IF NOT EXISTS idx_edl_status ON edl(status);

-- 7. Comments
COMMENT ON COLUMN edl.property_id IS 'FK directe vers le bien immobilier (denormalise depuis leases.property_id pour faciliter les requetes)';
COMMENT ON COLUMN edl.scheduled_at IS 'Date et heure planifiees pour la realisation de l''EDL';

-- 8. RLS Policy for property_id direct access
-- Permet l'accès direct via property_id en plus de la relation lease_id
DROP POLICY IF EXISTS "owner_access_via_property_id" ON edl;
CREATE POLICY "owner_access_via_property_id" ON edl
  FOR ALL
  USING (
    -- Via property_id direct (nouvelle colonne)
    EXISTS (
      SELECT 1 FROM properties p
      JOIN profiles pr ON pr.id = p.owner_id
      WHERE p.id = edl.property_id
      AND pr.user_id = auth.uid()
    )
    OR
    -- Via lease_id (relation existante - fallback)
    EXISTS (
      SELECT 1 FROM leases l
      JOIN properties p ON p.id = l.property_id
      JOIN profiles pr ON pr.id = p.owner_id
      WHERE l.id = edl.lease_id
      AND pr.user_id = auth.uid()
    )
    OR
    -- Créateur de l'EDL
    edl.created_by = auth.uid()
    OR
    -- Signataire invité
    EXISTS (
      SELECT 1 FROM edl_signatures es
      JOIN profiles pr ON pr.id = es.signer_profile_id
      WHERE es.edl_id = edl.id
      AND pr.user_id = auth.uid()
    )
  );

SELECT 'Migration fix_edl_schema_500 applied successfully' AS status;


-- ========== 20260128000001_webhook_queue.sql ==========
-- Migration: Create webhook_queue table for retry service
-- Sprint 2: INTEG-001 - Webhook retry service

-- Table de queue pour les webhooks sortants avec retry
CREATE TABLE IF NOT EXISTS public.webhook_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Identifiant de l'événement
    event_type TEXT NOT NULL,

    -- Payload JSON à envoyer
    payload JSONB NOT NULL DEFAULT '{}',

    -- URL cible
    target_url TEXT NOT NULL,

    -- Headers HTTP supplémentaires (optionnel)
    headers JSONB DEFAULT NULL,

    -- Compteur de retries
    retry_count INTEGER NOT NULL DEFAULT 0,
    max_retries INTEGER NOT NULL DEFAULT 5,

    -- Date du prochain retry
    next_retry_at TIMESTAMPTZ DEFAULT NOW(),

    -- Statut du webhook
    status TEXT NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'processing', 'success', 'failed', 'dead_letter')),

    -- Métadonnées de suivi
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_attempt_at TIMESTAMPTZ DEFAULT NULL,
    last_error TEXT DEFAULT NULL,

    -- Index pour les requêtes fréquentes
    CONSTRAINT webhook_queue_max_retries_check CHECK (max_retries > 0 AND max_retries <= 10)
);

-- Index pour récupérer les webhooks à traiter
CREATE INDEX IF NOT EXISTS idx_webhook_queue_pending
    ON public.webhook_queue (next_retry_at)
    WHERE status = 'pending';

-- Index pour les dead letters
CREATE INDEX IF NOT EXISTS idx_webhook_queue_dead_letter
    ON public.webhook_queue (created_at DESC)
    WHERE status = 'dead_letter';

-- Index pour le nettoyage
CREATE INDEX IF NOT EXISTS idx_webhook_queue_cleanup
    ON public.webhook_queue (created_at)
    WHERE status = 'success';

-- Index sur event_type pour monitoring
CREATE INDEX IF NOT EXISTS idx_webhook_queue_event_type
    ON public.webhook_queue (event_type, status);

-- Commentaires
COMMENT ON TABLE public.webhook_queue IS 'Queue pour les webhooks sortants avec système de retry';
COMMENT ON COLUMN public.webhook_queue.event_type IS 'Type d''événement (ex: Payment.Succeeded, Lease.Created)';
COMMENT ON COLUMN public.webhook_queue.payload IS 'Contenu JSON du webhook';
COMMENT ON COLUMN public.webhook_queue.target_url IS 'URL de destination du webhook';
COMMENT ON COLUMN public.webhook_queue.headers IS 'Headers HTTP supplémentaires (auth, etc.)';
COMMENT ON COLUMN public.webhook_queue.retry_count IS 'Nombre de tentatives effectuées';
COMMENT ON COLUMN public.webhook_queue.max_retries IS 'Nombre maximum de tentatives (défaut: 5)';
COMMENT ON COLUMN public.webhook_queue.next_retry_at IS 'Date/heure du prochain essai';
COMMENT ON COLUMN public.webhook_queue.status IS 'Statut: pending, processing, success, failed, dead_letter';
COMMENT ON COLUMN public.webhook_queue.last_error IS 'Dernière erreur rencontrée';

-- RLS: Seul le service role peut accéder à cette table
ALTER TABLE public.webhook_queue ENABLE ROW LEVEL SECURITY;

-- Pas de policy pour les utilisateurs normaux
-- La table n'est accessible que via le service role

-- Fonction de nettoyage automatique (optionnel, via pg_cron)
CREATE OR REPLACE FUNCTION cleanup_old_webhooks()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM public.webhook_queue
    WHERE status = 'success'
    AND created_at < NOW() - INTERVAL '30 days';

    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION cleanup_old_webhooks() IS 'Supprime les webhooks réussis de plus de 30 jours';


-- ========== 20260201000000_ged_system.sql ==========
-- Migration: Système GED (Gestion Électronique des Documents)
-- SOTA 2026 - Extension du système documents existant
-- Ajoute: document_types référentiel, alertes d'expiration, partages, audit log GED
-- RÉTROCOMPATIBLE: ne modifie aucune colonne existante

BEGIN;

-- ============================================
-- TABLE: ged_document_types (Référentiel types)
-- ============================================
-- Référentiel centralisé des types de documents avec métadonnées GED
-- Complète l'enum DocumentType existant avec des infos de validité et rattachement

CREATE TABLE IF NOT EXISTS ged_document_types (
  id TEXT PRIMARY KEY,
  label TEXT NOT NULL,
  label_short TEXT,
  icon TEXT,
  category TEXT NOT NULL CHECK (category IN (
    'legal', 'diagnostic', 'insurance', 'financial',
    'administrative', 'identity', 'edl', 'maintenance', 'other'
  )),
  is_expirable BOOLEAN NOT NULL DEFAULT FALSE,
  default_validity_days INTEGER,
  can_attach_to_entity BOOLEAN NOT NULL DEFAULT FALSE,
  can_attach_to_property BOOLEAN NOT NULL DEFAULT FALSE,
  can_attach_to_lease BOOLEAN NOT NULL DEFAULT FALSE,
  is_auto_generated BOOLEAN NOT NULL DEFAULT FALSE,
  is_mandatory_for_lease BOOLEAN NOT NULL DEFAULT FALSE,
  retention_days INTEGER,  -- Durée légale de conservation en jours
  display_order INTEGER NOT NULL DEFAULT 100,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Seed data: tous les types de documents
INSERT INTO ged_document_types (id, label, label_short, icon, category, is_expirable, default_validity_days, can_attach_to_entity, can_attach_to_property, can_attach_to_lease, is_auto_generated, is_mandatory_for_lease, retention_days, display_order) VALUES
  -- Légaux (bail)
  ('bail', 'Bail de location', 'Bail', 'FileText', 'legal', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, TRUE, 1825, 10),
  ('avenant', 'Avenant au bail', 'Avenant', 'FilePlus', 'legal', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 11),
  ('engagement_garant', 'Acte de cautionnement', 'Caution', 'Shield', 'legal', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 12),
  ('bail_signe_locataire', 'Bail signé locataire', 'Bail signé', 'FileCheck', 'legal', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 13),
  ('bail_signe_proprietaire', 'Bail signé propriétaire', 'Bail signé', 'FileCheck', 'legal', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 14),
  ('consentement', 'Consentement RGPD', 'RGPD', 'ShieldCheck', 'legal', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1095, 15),

  -- Diagnostics (bien) - EXPIRABLES
  ('dpe', 'DPE (Diagnostic Performance Énergétique)', 'DPE', 'Thermometer', 'diagnostic', TRUE, 3650, FALSE, TRUE, FALSE, FALSE, TRUE, 3650, 20),
  ('diagnostic_gaz', 'Diagnostic Gaz', 'Gaz', 'Flame', 'diagnostic', TRUE, 2190, FALSE, TRUE, FALSE, FALSE, TRUE, 2190, 21),
  ('diagnostic_electricite', 'Diagnostic Électricité', 'Électricité', 'Zap', 'diagnostic', TRUE, 2190, FALSE, TRUE, FALSE, FALSE, TRUE, 2190, 22),
  ('diagnostic_plomb', 'Diagnostic Plomb (CREP)', 'Plomb', 'AlertTriangle', 'diagnostic', TRUE, 365, FALSE, TRUE, FALSE, FALSE, TRUE, NULL, 23),
  ('diagnostic_amiante', 'Diagnostic Amiante', 'Amiante', 'AlertTriangle', 'diagnostic', TRUE, NULL, FALSE, TRUE, FALSE, FALSE, FALSE, NULL, 24),
  ('diagnostic_termites', 'Diagnostic Termites', 'Termites', 'Bug', 'diagnostic', TRUE, 180, FALSE, TRUE, FALSE, FALSE, FALSE, 180, 25),
  ('erp', 'État des Risques et Pollutions', 'ERP', 'MapPin', 'diagnostic', TRUE, 180, FALSE, TRUE, FALSE, FALSE, TRUE, 180, 26),
  ('diagnostic', 'Dossier Diagnostic Technique (DDT)', 'DDT', 'FileSearch', 'diagnostic', FALSE, NULL, FALSE, TRUE, FALSE, FALSE, FALSE, NULL, 27),
  ('diagnostic_tertiaire', 'Diagnostic tertiaire', 'Tertiaire', 'Building', 'diagnostic', TRUE, 3650, FALSE, TRUE, FALSE, FALSE, FALSE, 3650, 28),
  ('diagnostic_performance', 'Diagnostic performance', 'Performance', 'BarChart', 'diagnostic', TRUE, 3650, FALSE, TRUE, FALSE, FALSE, FALSE, 3650, 29),

  -- Assurances - EXPIRABLES
  ('attestation_assurance', 'Attestation d''assurance habitation', 'Assurance hab.', 'ShieldCheck', 'insurance', TRUE, 365, FALSE, FALSE, TRUE, FALSE, TRUE, 1095, 30),
  ('assurance_pno', 'Assurance PNO', 'PNO', 'Shield', 'insurance', TRUE, 365, FALSE, TRUE, FALSE, FALSE, FALSE, 1095, 31),

  -- Financiers
  ('quittance', 'Quittance de loyer', 'Quittance', 'Receipt', 'financial', FALSE, NULL, FALSE, FALSE, TRUE, TRUE, 1095, 40),
  ('facture', 'Facture', 'Facture', 'Receipt', 'financial', FALSE, NULL, TRUE, TRUE, TRUE, FALSE, FALSE, 3650, 41),
  ('rib', 'RIB / Coordonnées bancaires', 'RIB', 'CreditCard', 'financial', FALSE, NULL, TRUE, FALSE, FALSE, FALSE, FALSE, NULL, 42),
  ('avis_imposition', 'Avis d''imposition', 'Impôts', 'FileText', 'financial', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1095, 43),
  ('bulletin_paie', 'Bulletin de paie', 'Paie', 'FileText', 'financial', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1095, 44),
  ('attestation_loyer', 'Attestation de loyer', 'Att. loyer', 'FileText', 'financial', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1095, 45),
  ('justificatif_revenus', 'Justificatif de revenus', 'Revenus', 'FileText', 'financial', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1095, 46),
  ('taxe_fonciere', 'Taxe foncière', 'Taxe fonc.', 'FileText', 'financial', FALSE, NULL, FALSE, TRUE, FALSE, FALSE, FALSE, 1825, 47),
  ('taxe_sejour', 'Taxe de séjour', 'Taxe séjour', 'FileText', 'financial', FALSE, NULL, FALSE, TRUE, FALSE, FALSE, FALSE, 1825, 48),

  -- Identité
  ('piece_identite', 'Pièce d''identité', 'ID', 'User', 'identity', TRUE, 3650, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 50),
  ('cni_recto', 'Carte d''identité (recto)', 'CNI recto', 'CreditCard', 'identity', TRUE, 3650, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 51),
  ('cni_verso', 'Carte d''identité (verso)', 'CNI verso', 'CreditCard', 'identity', TRUE, 3650, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 52),
  ('passeport', 'Passeport', 'Passeport', 'BookOpen', 'identity', TRUE, 3650, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 53),
  ('titre_sejour', 'Titre de séjour', 'Titre séjour', 'FileText', 'identity', TRUE, 365, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 54),

  -- États des lieux
  ('EDL_entree', 'État des lieux d''entrée', 'EDL entrée', 'ClipboardCheck', 'edl', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, TRUE, 1825, 60),
  ('EDL_sortie', 'État des lieux de sortie', 'EDL sortie', 'ClipboardCheck', 'edl', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 61),
  ('inventaire', 'Inventaire mobilier', 'Inventaire', 'List', 'edl', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 62),

  -- Candidature locataire
  ('candidature_identite', 'Candidature - Identité', 'ID candidat', 'UserCheck', 'identity', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 365, 70),
  ('candidature_revenus', 'Candidature - Revenus', 'Revenus candidat', 'DollarSign', 'financial', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 365, 71),
  ('candidature_domicile', 'Candidature - Domicile', 'Domicile candidat', 'Home', 'identity', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 365, 72),
  ('candidature_garantie', 'Candidature - Garantie', 'Garantie candidat', 'Shield', 'financial', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 365, 73),

  -- Garant
  ('garant_identite', 'Garant - Identité', 'ID garant', 'UserCheck', 'identity', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 80),
  ('garant_revenus', 'Garant - Revenus', 'Revenus garant', 'DollarSign', 'financial', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 81),
  ('garant_domicile', 'Garant - Domicile', 'Domicile garant', 'Home', 'identity', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 82),
  ('garant_engagement', 'Garant - Engagement', 'Engagement garant', 'FileSignature', 'legal', FALSE, NULL, FALSE, FALSE, TRUE, FALSE, FALSE, 1825, 83),

  -- Prestataire / Maintenance
  ('devis', 'Devis', 'Devis', 'Calculator', 'maintenance', FALSE, NULL, FALSE, TRUE, FALSE, FALSE, FALSE, 1825, 90),
  ('ordre_mission', 'Ordre de mission', 'Ordre mission', 'ClipboardList', 'maintenance', FALSE, NULL, FALSE, TRUE, FALSE, FALSE, FALSE, 1825, 91),
  ('rapport_intervention', 'Rapport d''intervention', 'Rapport', 'FileText', 'maintenance', FALSE, NULL, FALSE, TRUE, FALSE, FALSE, FALSE, 1825, 92),

  -- Copropriété
  ('copropriete', 'Règlement de copropriété', 'Règl. copro', 'Building', 'administrative', FALSE, NULL, FALSE, TRUE, FALSE, FALSE, FALSE, NULL, 100),
  ('proces_verbal', 'Procès-verbal d''AG', 'PV AG', 'FileText', 'administrative', FALSE, NULL, TRUE, TRUE, FALSE, FALSE, FALSE, 1825, 101),
  ('appel_fonds', 'Appel de fonds', 'Appel fonds', 'Receipt', 'financial', FALSE, NULL, FALSE, TRUE, FALSE, FALSE, FALSE, 1825, 102),

  -- Administratifs (entité)
  ('annexe_pinel', 'Annexe Pinel', 'Pinel', 'FileText', 'administrative', FALSE, NULL, TRUE, TRUE, FALSE, FALSE, FALSE, 3650, 110),
  ('etat_travaux', 'État des travaux', 'Travaux', 'Wrench', 'administrative', FALSE, NULL, FALSE, TRUE, FALSE, FALSE, FALSE, 1825, 111),
  ('publication_jal', 'Publication JAL', 'JAL', 'Newspaper', 'administrative', FALSE, NULL, TRUE, FALSE, FALSE, FALSE, FALSE, 1825, 112),

  -- Divers
  ('courrier', 'Courrier', 'Courrier', 'Mail', 'other', FALSE, NULL, TRUE, TRUE, TRUE, FALSE, FALSE, 1095, 120),
  ('photo', 'Photo / Justificatif visuel', 'Photo', 'Camera', 'other', FALSE, NULL, FALSE, TRUE, TRUE, FALSE, FALSE, NULL, 121),
  ('autre', 'Autre document', 'Autre', 'File', 'other', FALSE, NULL, TRUE, TRUE, TRUE, FALSE, FALSE, NULL, 200)
ON CONFLICT (id) DO NOTHING;


-- ============================================
-- EXTENSION: Colonnes GED sur documents existant
-- ============================================
-- Ajoute les colonnes GED sans toucher aux colonnes existantes

-- Rattachement entité juridique
ALTER TABLE documents ADD COLUMN IF NOT EXISTS entity_id UUID REFERENCES legal_entities(id) ON DELETE SET NULL;

-- Validité / Expiration
ALTER TABLE documents ADD COLUMN IF NOT EXISTS valid_from DATE;
ALTER TABLE documents ADD COLUMN IF NOT EXISTS valid_until DATE;

-- Versioning
ALTER TABLE documents ADD COLUMN IF NOT EXISTS version INTEGER NOT NULL DEFAULT 1;
ALTER TABLE documents ADD COLUMN IF NOT EXISTS parent_document_id UUID REFERENCES documents(id) ON DELETE SET NULL;
ALTER TABLE documents ADD COLUMN IF NOT EXISTS is_current_version BOOLEAN NOT NULL DEFAULT TRUE;

-- Statut GED (complète le verification_status existant)
ALTER TABLE documents ADD COLUMN IF NOT EXISTS ged_status TEXT DEFAULT 'active' CHECK (ged_status IN (
  'draft', 'active', 'pending_signature', 'signed', 'archived', 'expired'
));

-- Signature
ALTER TABLE documents ADD COLUMN IF NOT EXISTS signed_at TIMESTAMPTZ;
ALTER TABLE documents ADD COLUMN IF NOT EXISTS signature_data JSONB;

-- Tags pour recherche
ALTER TABLE documents ADD COLUMN IF NOT EXISTS tags TEXT[] DEFAULT '{}';

-- Données extraites par IA GED
ALTER TABLE documents ADD COLUMN IF NOT EXISTS ged_ai_data JSONB;
ALTER TABLE documents ADD COLUMN IF NOT EXISTS ged_ai_processed_at TIMESTAMPTZ;

-- Index GED
CREATE INDEX IF NOT EXISTS idx_documents_entity_id ON documents(entity_id);
CREATE INDEX IF NOT EXISTS idx_documents_valid_until ON documents(valid_until) WHERE valid_until IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_documents_ged_status ON documents(ged_status);
CREATE INDEX IF NOT EXISTS idx_documents_version ON documents(parent_document_id, version);
CREATE INDEX IF NOT EXISTS idx_documents_tags ON documents USING gin(tags);


-- ============================================
-- TABLE: document_alerts (Alertes d'expiration)
-- ============================================

CREATE TABLE IF NOT EXISTS document_alerts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,

  -- Type d'alerte
  alert_type TEXT NOT NULL CHECK (alert_type IN (
    'expiring_soon',     -- Document arrive à expiration
    'expired',           -- Document expiré
    'missing',           -- Document manquant (obligatoire pour bail)
    'action_required'    -- Action requise (upload, signature, etc.)
  )),

  -- Configuration
  days_before_expiry INTEGER,   -- Pour expiring_soon: combien de jours avant
  message TEXT,                 -- Message personnalisé

  -- Statut
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
    'pending', 'sent', 'dismissed', 'resolved'
  )),

  -- Notification
  notified_at TIMESTAMPTZ,
  notification_channel TEXT,   -- 'in_app', 'email', 'sms'

  -- Résolution
  resolved_at TIMESTAMPTZ,
  resolved_by UUID REFERENCES auth.users(id),

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Contrainte: pas de doublon
  UNIQUE(document_id, alert_type, days_before_expiry)
);

CREATE INDEX IF NOT EXISTS idx_document_alerts_status ON document_alerts(status) WHERE status IN ('pending', 'sent');
CREATE INDEX IF NOT EXISTS idx_document_alerts_document ON document_alerts(document_id);


-- ============================================
-- TABLE: document_shares (Partages sécurisés)
-- ============================================

CREATE TABLE IF NOT EXISTS document_shares (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,

  -- Type de partage
  share_type TEXT NOT NULL CHECK (share_type IN ('link', 'email')),

  -- Destinataire
  recipient_email TEXT,
  recipient_name TEXT,

  -- Token et URL
  share_token TEXT UNIQUE NOT NULL DEFAULT encode(gen_random_bytes(32), 'hex'),

  -- Sécurité
  password_hash TEXT,          -- Optionnel: mot de passe pour accéder
  expires_at TIMESTAMPTZ NOT NULL,
  max_downloads INTEGER,
  download_count INTEGER NOT NULL DEFAULT 0,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by UUID NOT NULL REFERENCES auth.users(id),
  last_accessed_at TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_document_shares_token ON document_shares(share_token);
CREATE INDEX IF NOT EXISTS idx_document_shares_document ON document_shares(document_id);
CREATE INDEX IF NOT EXISTS idx_document_shares_expires ON document_shares(expires_at) WHERE expires_at > NOW();


-- ============================================
-- TABLE: document_ged_audit_log (Journal GED)
-- ============================================
-- Séparé de l'audit_log existant pour ne pas interférer

CREATE TABLE IF NOT EXISTS document_ged_audit_log (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,

  -- Action
  action TEXT NOT NULL CHECK (action IN (
    'created', 'viewed', 'downloaded', 'updated', 'signed',
    'shared', 'archived', 'deleted', 'restored', 'version_created',
    'alert_created', 'alert_dismissed', 'ai_analyzed'
  )),

  -- Détails
  details JSONB,

  -- Contexte
  performed_by UUID REFERENCES auth.users(id),
  ip_address INET,
  user_agent TEXT,

  -- Timestamp
  performed_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_ged_audit_document ON document_ged_audit_log(document_id);
CREATE INDEX IF NOT EXISTS idx_ged_audit_action ON document_ged_audit_log(action);
CREATE INDEX IF NOT EXISTS idx_ged_audit_performed_at ON document_ged_audit_log(performed_at);


-- ============================================
-- VUE: v_documents_ged (Vue enrichie GED)
-- ============================================
-- Vue qui combine documents + ged_document_types pour faciliter les requêtes

CREATE OR REPLACE VIEW v_documents_ged AS
SELECT
  d.id,
  d.type,
  d.title,
  d.storage_path,
  d.file_size,
  d.mime_type,
  d.owner_id,
  d.tenant_id,
  d.property_id,
  d.lease_id,
  d.entity_id,
  d.valid_from,
  d.valid_until,
  d.version,
  d.parent_document_id,
  d.is_current_version,
  d.ged_status,
  d.signed_at,
  d.tags,
  d.ged_ai_data,
  d.created_at,
  d.updated_at,
  d.created_by,
  -- Infos du type de document
  gdt.label AS type_label,
  gdt.label_short AS type_label_short,
  gdt.icon AS type_icon,
  gdt.category AS type_category,
  gdt.is_expirable,
  gdt.default_validity_days,
  gdt.is_mandatory_for_lease,
  gdt.retention_days,
  -- Calculs d'expiration
  CASE
    WHEN d.valid_until IS NOT NULL AND d.valid_until < CURRENT_DATE THEN 'expired'
    WHEN d.valid_until IS NOT NULL AND d.valid_until < CURRENT_DATE + INTERVAL '30 days' THEN 'expiring_soon'
    WHEN d.valid_until IS NOT NULL AND d.valid_until < CURRENT_DATE + INTERVAL '90 days' THEN 'expiring_notice'
    WHEN d.valid_until IS NOT NULL THEN 'valid'
    ELSE NULL
  END AS expiry_status,
  CASE
    WHEN d.valid_until IS NOT NULL THEN d.valid_until - CURRENT_DATE
    ELSE NULL
  END AS days_until_expiry
FROM documents d
LEFT JOIN ged_document_types gdt ON gdt.id = d.type
WHERE d.is_archived IS NOT TRUE
  AND d.is_current_version IS TRUE;


-- ============================================
-- VUE: v_document_alerts_summary (Résumé alertes)
-- ============================================
-- Pour le panneau d'alertes de la page GED

CREATE OR REPLACE VIEW v_document_alerts_summary AS
SELECT
  d.owner_id,
  d.property_id,
  d.lease_id,
  d.entity_id,
  COUNT(*) FILTER (WHERE vg.expiry_status = 'expired') AS expired_count,
  COUNT(*) FILTER (WHERE vg.expiry_status = 'expiring_soon') AS expiring_soon_count,
  COUNT(*) FILTER (WHERE vg.expiry_status = 'expiring_notice') AS expiring_notice_count,
  json_agg(
    json_build_object(
      'id', d.id,
      'type', d.type,
      'title', d.title,
      'valid_until', d.valid_until,
      'expiry_status', vg.expiry_status,
      'days_until_expiry', vg.days_until_expiry,
      'property_id', d.property_id,
      'lease_id', d.lease_id
    ) ORDER BY d.valid_until ASC
  ) FILTER (WHERE vg.expiry_status IN ('expired', 'expiring_soon', 'expiring_notice')) AS alert_documents
FROM documents d
JOIN v_documents_ged vg ON vg.id = d.id
WHERE d.is_archived IS NOT TRUE
  AND d.valid_until IS NOT NULL
  AND vg.expiry_status IS NOT NULL
GROUP BY d.owner_id, d.property_id, d.lease_id, d.entity_id;


-- ============================================
-- RLS: Policies pour les nouvelles tables
-- ============================================

-- document_alerts
ALTER TABLE document_alerts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view alerts for their documents"
  ON document_alerts FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM documents d
      LEFT JOIN properties p ON d.property_id = p.id
      LEFT JOIN profiles pr ON pr.user_id = auth.uid()
      WHERE d.id = document_alerts.document_id
        AND (d.owner_id = pr.id OR d.tenant_id = pr.id)
    )
  );

CREATE POLICY "Users can update alerts for their documents"
  ON document_alerts FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM documents d
      LEFT JOIN profiles pr ON pr.user_id = auth.uid()
      WHERE d.id = document_alerts.document_id
        AND (d.owner_id = pr.id)
    )
  );

-- document_shares
ALTER TABLE document_shares ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their shares"
  ON document_shares FOR SELECT
  USING (created_by = auth.uid());

CREATE POLICY "Users can create shares"
  ON document_shares FOR INSERT
  WITH CHECK (created_by = auth.uid());

CREATE POLICY "Users can delete their shares"
  ON document_shares FOR DELETE
  USING (created_by = auth.uid());

-- document_ged_audit_log
ALTER TABLE document_ged_audit_log ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view audit logs for their documents"
  ON document_ged_audit_log FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM documents d
      LEFT JOIN profiles pr ON pr.user_id = auth.uid()
      WHERE d.id = document_ged_audit_log.document_id
        AND (d.owner_id = pr.id)
    )
  );

CREATE POLICY "System can insert audit logs"
  ON document_ged_audit_log FOR INSERT
  WITH CHECK (TRUE);

-- ged_document_types (lecture publique)
ALTER TABLE ged_document_types ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can read document types"
  ON ged_document_types FOR SELECT
  USING (TRUE);


-- ============================================
-- FONCTION: Mise à jour automatique des alertes
-- ============================================

CREATE OR REPLACE FUNCTION update_document_ged_status()
RETURNS TRIGGER AS $$
BEGIN
  -- Si valid_until est défini et passé, marquer comme expiré
  IF NEW.valid_until IS NOT NULL AND NEW.valid_until < CURRENT_DATE AND NEW.ged_status = 'active' THEN
    NEW.ged_status := 'expired';
  END IF;

  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger sur mise à jour de documents
DROP TRIGGER IF EXISTS trigger_update_document_ged_status ON documents;
CREATE TRIGGER trigger_update_document_ged_status
  BEFORE UPDATE ON documents
  FOR EACH ROW
  WHEN (OLD.valid_until IS DISTINCT FROM NEW.valid_until OR OLD.ged_status IS DISTINCT FROM NEW.ged_status)
  EXECUTE FUNCTION update_document_ged_status();

COMMIT;


-- ========== 20260207000000_apply_legal_entities_consolidated.sql ==========
-- Migration consolidée: Legal Entities - Application et cohérence
-- SOTA 2026 - S'assure que l'architecture multi-entités est complète et cohérente
-- IDEMPOTENT: Peut être exécuté plusieurs fois sans erreur

BEGIN;

-- ============================================
-- 1. Vérification / Création des tables de base
-- ============================================
-- (Les tables sont créées par 20260115000000_multi_entity_architecture.sql)
-- Cette migration ne fait que s'assurer de la cohérence et des compléments

-- Colonne entity_id sur documents (référence GED → legal_entities)
ALTER TABLE documents ADD COLUMN IF NOT EXISTS entity_id UUID REFERENCES legal_entities(id) ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_documents_entity_id ON documents(entity_id) WHERE entity_id IS NOT NULL;

-- ============================================
-- 2. Index supplémentaires pour performance
-- ============================================

-- Index composite pour requêtes filtrées (owner + actif)
CREATE INDEX IF NOT EXISTS idx_legal_entities_owner_active
  ON legal_entities(owner_profile_id) WHERE is_active = true;

-- ============================================
-- 3. Contraintes de cohérence
-- ============================================
-- S'assure que les propriétés ont soit legal_entity_id soit restent sur owner_id legacy

DO $$
BEGIN
  -- Vérifier que detention_mode est bien défini pour les propriétés avec legal_entity_id
  UPDATE properties
  SET detention_mode = COALESCE(detention_mode, 'societe')
  WHERE legal_entity_id IS NOT NULL
    AND (detention_mode IS NULL OR detention_mode = 'direct');

  -- Pour les propriétés sans legal_entity_id, garder 'direct'
  UPDATE properties
  SET detention_mode = COALESCE(detention_mode, 'direct')
  WHERE legal_entity_id IS NULL
    AND detention_mode IS NULL;
END $$;

-- ============================================
-- 4. Backfill: entités par défaut manquantes
-- ============================================

INSERT INTO legal_entities (
  owner_profile_id,
  entity_type,
  nom,
  regime_fiscal,
  is_active,
  siret,
  adresse_siege,
  iban
)
SELECT
  op.profile_id,
  CASE
    WHEN op.type = 'societe' THEN 'sci_ir'
    ELSE 'particulier'
  END,
  COALESCE(
    op.raison_sociale,
    (SELECT CONCAT(p.prenom, ' ', p.nom) FROM profiles p WHERE p.id = op.profile_id),
    'Patrimoine personnel'
  ),
  'ir',
  true,
  op.siret,
  op.adresse_facturation,
  op.iban
FROM owner_profiles op
WHERE NOT EXISTS (
  SELECT 1 FROM legal_entities le
  WHERE le.owner_profile_id = op.profile_id
);

-- Lier les propriétés orphelines à l'entité par défaut du propriétaire
UPDATE properties p
SET legal_entity_id = (
  SELECT le.id
  FROM legal_entities le
  WHERE le.owner_profile_id = p.owner_id
  ORDER BY le.created_at ASC
  LIMIT 1
),
detention_mode = COALESCE(p.detention_mode, 'direct')
WHERE p.legal_entity_id IS NULL
  AND EXISTS (
    SELECT 1 FROM legal_entities le
    WHERE le.owner_profile_id = p.owner_id
  );

-- Créer property_ownership manquants pour les propriétés liées à une entité
INSERT INTO property_ownership (
  property_id,
  legal_entity_id,
  profile_id,
  quote_part_numerateur,
  quote_part_denominateur,
  detention_type,
  date_acquisition,
  mode_acquisition,
  is_current
)
SELECT
  p.id,
  p.legal_entity_id,
  NULL,
  1,
  1,
  'pleine_propriete',
  p.created_at::DATE,
  'achat',
  true
FROM properties p
WHERE p.legal_entity_id IS NOT NULL
  AND NOT EXISTS (
    SELECT 1 FROM property_ownership po
    WHERE po.property_id = p.id
  );

COMMIT;

-- ========== 20260205000001_fix_edl_signatures_insert_rls.sql ==========
-- Migration: Fix edl_signatures INSERT RLS policy
-- Date: 2026-02-05

BEGIN;

DROP POLICY IF EXISTS "EDL signatures signer create" ON edl_signatures;

CREATE POLICY "EDL signatures insert"
  ON edl_signatures FOR INSERT
  WITH CHECK (
    signer_user = auth.uid()
    OR
    edl_id IN (
      SELECT id FROM edl WHERE created_by = auth.uid()
    )
    OR
    edl_id IN (
      SELECT e.id FROM edl e
      JOIN properties p ON p.id = e.property_id
      JOIN profiles pr ON pr.id = p.owner_id
      WHERE pr.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "EDL signatures creator update" ON edl_signatures;
CREATE POLICY "EDL signatures creator update"
  ON edl_signatures FOR UPDATE
  USING (
    signer_user = auth.uid()
    OR
    edl_id IN (
      SELECT id FROM edl WHERE created_by = auth.uid()
    )
  )
  WITH CHECK (
    signer_user = auth.uid()
    OR
    edl_id IN (
      SELECT id FROM edl WHERE created_by = auth.uid()
    )
  );

COMMIT;

-- ========== 20260206000000_migrate_owner_profiles_to_legal_entities.sql ==========
-- Migration: owner_profiles societe data -> legal_entities
-- Date: 2026-02-06

BEGIN;

INSERT INTO legal_entities (
  id, owner_profile_id, entity_type, nom, siret, forme_juridique,
  adresse_siege, numero_tva, is_active, created_at, updated_at
)
SELECT
  gen_random_uuid(),
  op.profile_id,
  CASE
    WHEN op.forme_juridique = 'SCI'  THEN 'sci_ir'
    WHEN op.forme_juridique = 'SARL' THEN 'sarl'
    WHEN op.forme_juridique = 'SAS'  THEN 'sas'
    WHEN op.forme_juridique = 'SASU' THEN 'sasu'
    WHEN op.forme_juridique = 'EURL' THEN 'eurl'
    WHEN op.forme_juridique = 'EI'   THEN 'eurl'
    WHEN op.forme_juridique = 'SA'   THEN 'sa'
    WHEN op.forme_juridique = 'SCPI' THEN 'sci_ir'
    ELSE 'sarl'
  END,
  op.raison_sociale, op.siret, op.forme_juridique,
  op.adresse_siege, op.tva, true, NOW(), NOW()
FROM owner_profiles op
WHERE op.type = 'societe'
  AND op.raison_sociale IS NOT NULL
  AND op.raison_sociale != ''
  AND NOT EXISTS (
    SELECT 1 FROM legal_entities le
    WHERE le.owner_profile_id = op.profile_id AND le.is_active = true
  );

UPDATE properties p
SET legal_entity_id = le.id
FROM owner_profiles op
JOIN legal_entities le ON le.owner_profile_id = op.profile_id AND le.is_active = true
WHERE p.owner_id = op.profile_id
  AND p.legal_entity_id IS NULL
  AND op.type = 'societe'
  AND op.raison_sociale IS NOT NULL;

UPDATE leases l
SET signatory_entity_id = p.legal_entity_id
FROM properties p
WHERE l.property_id = p.id
  AND l.signatory_entity_id IS NULL
  AND p.legal_entity_id IS NOT NULL
  AND l.statut IN ('active', 'pending_signature', 'draft');

COMMIT;

-- ========== 20260207100000_fix_audit_critical_issues.sql ==========
-- MIGRATION: Fix critical issues found during EDL/Bail system audit (2026-02-07)

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'edl' AND column_name = 'entity_id'
  ) THEN
    ALTER TABLE public.edl ADD COLUMN entity_id UUID REFERENCES public.legal_entities(id) ON DELETE SET NULL;
    CREATE INDEX IF NOT EXISTS idx_edl_entity_id ON public.edl(entity_id);
    UPDATE public.edl e SET entity_id = l.signatory_entity_id
    FROM public.leases l WHERE e.lease_id = l.id AND l.signatory_entity_id IS NOT NULL AND e.entity_id IS NULL;
    UPDATE public.edl e SET entity_id = p.legal_entity_id
    FROM public.properties p WHERE e.property_id = p.id AND p.legal_entity_id IS NOT NULL AND e.entity_id IS NULL;
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'documents' AND column_name = 'edl_id'
  ) THEN
    ALTER TABLE public.documents ADD COLUMN edl_id UUID REFERENCES public.edl(id) ON DELETE SET NULL;
    CREATE INDEX IF NOT EXISTS idx_documents_edl_id ON public.documents(edl_id);
  END IF;
END $$;

DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'furniture_inventories') THEN
    IF EXISTS (
      SELECT 1 FROM information_schema.table_constraints
      WHERE table_name = 'furniture_inventories' AND constraint_type = 'FOREIGN KEY' AND constraint_name LIKE '%edl_id%'
    ) THEN
      DECLARE fk_name TEXT;
      BEGIN
        SELECT constraint_name INTO fk_name FROM information_schema.table_constraints
        WHERE table_name = 'furniture_inventories' AND constraint_type = 'FOREIGN KEY' AND constraint_name LIKE '%edl_id%' LIMIT 1;
        IF fk_name IS NOT NULL THEN
          EXECUTE format('ALTER TABLE public.furniture_inventories DROP CONSTRAINT %I', fk_name);
        END IF;
      END;
    END IF;
    BEGIN
      ALTER TABLE public.furniture_inventories ADD CONSTRAINT furniture_inventories_edl_id_fkey
        FOREIGN KEY (edl_id) REFERENCES public.edl(id) ON DELETE CASCADE;
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;
  END IF;
END $$;

DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'vetusty_reports') THEN
    DECLARE fk_name TEXT;
    BEGIN
      SELECT constraint_name INTO fk_name
      FROM information_schema.table_constraints tc
      JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
      WHERE tc.table_name = 'vetusty_reports' AND tc.constraint_type = 'FOREIGN KEY' AND kcu.column_name = 'settlement_id' LIMIT 1;
      IF fk_name IS NOT NULL THEN
        EXECUTE format('ALTER TABLE public.vetusty_reports DROP CONSTRAINT %I', fk_name);
      END IF;
    END;
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'deposit_movements') THEN
      BEGIN
        ALTER TABLE public.vetusty_reports ADD CONSTRAINT vetusty_reports_settlement_id_fkey
          FOREIGN KEY (settlement_id) REFERENCES public.deposit_movements(id) ON DELETE SET NULL;
      EXCEPTION WHEN duplicate_object THEN NULL; WHEN undefined_table THEN NULL;
      END;
    END IF;
    CREATE INDEX IF NOT EXISTS idx_vetusty_reports_edl_entry ON public.vetusty_reports(edl_entry_id);
    CREATE INDEX IF NOT EXISTS idx_vetusty_reports_edl_exit ON public.vetusty_reports(edl_exit_id);
    CREATE INDEX IF NOT EXISTS idx_vetusty_reports_validated_by ON public.vetusty_reports(validated_by);
    CREATE INDEX IF NOT EXISTS idx_vetusty_reports_created_by ON public.vetusty_reports(created_by);
  END IF;
END $$;

DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'vetusty_reports') THEN
    DROP POLICY IF EXISTS "vetusty_reports_owner_select" ON public.vetusty_reports;
    DROP POLICY IF EXISTS "vetusty_reports_owner_insert" ON public.vetusty_reports;
    DROP POLICY IF EXISTS "vetusty_reports_owner_update" ON public.vetusty_reports;
    DROP POLICY IF EXISTS "vetusty_reports_owner_delete" ON public.vetusty_reports;
    DROP POLICY IF EXISTS "vetusty_reports_tenant_select" ON public.vetusty_reports;
    DROP POLICY IF EXISTS "vetusty_reports_admin_all" ON public.vetusty_reports;
    CREATE POLICY "vetusty_reports_owner_select" ON public.vetusty_reports FOR SELECT USING (EXISTS (SELECT 1 FROM public.leases l JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE l.id = vetusty_reports.lease_id AND pr.user_id = auth.uid()));
    CREATE POLICY "vetusty_reports_owner_insert" ON public.vetusty_reports FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.leases l JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE l.id = vetusty_reports.lease_id AND pr.user_id = auth.uid()));
    CREATE POLICY "vetusty_reports_owner_update" ON public.vetusty_reports FOR UPDATE USING (EXISTS (SELECT 1 FROM public.leases l JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE l.id = vetusty_reports.lease_id AND pr.user_id = auth.uid()));
    CREATE POLICY "vetusty_reports_owner_delete" ON public.vetusty_reports FOR DELETE USING (EXISTS (SELECT 1 FROM public.leases l JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE l.id = vetusty_reports.lease_id AND pr.user_id = auth.uid()));
    CREATE POLICY "vetusty_reports_tenant_select" ON public.vetusty_reports FOR SELECT USING (EXISTS (SELECT 1 FROM public.leases l JOIN public.profiles pr ON pr.id = l.tenant_id WHERE l.id = vetusty_reports.lease_id AND pr.user_id = auth.uid()));
    CREATE POLICY "vetusty_reports_admin_all" ON public.vetusty_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE user_id = auth.uid() AND role = 'admin'));
  END IF;
END $$;

DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'vetusty_items') THEN
    DROP POLICY IF EXISTS "vetusty_items_owner_select" ON public.vetusty_items;
    DROP POLICY IF EXISTS "vetusty_items_owner_insert" ON public.vetusty_items;
    DROP POLICY IF EXISTS "vetusty_items_owner_update" ON public.vetusty_items;
    DROP POLICY IF EXISTS "vetusty_items_owner_delete" ON public.vetusty_items;
    DROP POLICY IF EXISTS "vetusty_items_tenant_select" ON public.vetusty_items;
    DROP POLICY IF EXISTS "vetusty_items_admin_all" ON public.vetusty_items;
    CREATE POLICY "vetusty_items_owner_select" ON public.vetusty_items FOR SELECT USING (EXISTS (SELECT 1 FROM public.vetusty_reports vr JOIN public.leases l ON l.id = vr.lease_id JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE vr.id = vetusty_items.report_id AND pr.user_id = auth.uid()));
    CREATE POLICY "vetusty_items_owner_insert" ON public.vetusty_items FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.vetusty_reports vr JOIN public.leases l ON l.id = vr.lease_id JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE vr.id = vetusty_items.report_id AND pr.user_id = auth.uid()));
    CREATE POLICY "vetusty_items_owner_update" ON public.vetusty_items FOR UPDATE USING (EXISTS (SELECT 1 FROM public.vetusty_reports vr JOIN public.leases l ON l.id = vr.lease_id JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE vr.id = vetusty_items.report_id AND pr.user_id = auth.uid()));
    CREATE POLICY "vetusty_items_owner_delete" ON public.vetusty_items FOR DELETE USING (EXISTS (SELECT 1 FROM public.vetusty_reports vr JOIN public.leases l ON l.id = vr.lease_id JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE vr.id = vetusty_items.report_id AND pr.user_id = auth.uid()));
    CREATE POLICY "vetusty_items_tenant_select" ON public.vetusty_items FOR SELECT USING (EXISTS (SELECT 1 FROM public.vetusty_reports vr JOIN public.leases l ON l.id = vr.lease_id JOIN public.profiles pr ON pr.id = l.tenant_id WHERE vr.id = vetusty_items.report_id AND pr.user_id = auth.uid()));
    CREATE POLICY "vetusty_items_admin_all" ON public.vetusty_items FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE user_id = auth.uid() AND role = 'admin'));
    BEGIN ALTER TABLE public.vetusty_items ADD CONSTRAINT vetusty_items_edl_entry_item_fkey FOREIGN KEY (edl_entry_item_id) REFERENCES public.edl_items(id) ON DELETE SET NULL; EXCEPTION WHEN duplicate_object THEN NULL; WHEN undefined_column THEN NULL; END;
    BEGIN ALTER TABLE public.vetusty_items ADD CONSTRAINT vetusty_items_edl_exit_item_fkey FOREIGN KEY (edl_exit_item_id) REFERENCES public.edl_items(id) ON DELETE SET NULL; EXCEPTION WHEN duplicate_object THEN NULL; WHEN undefined_column THEN NULL; END;
  END IF;
END $$;

DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'furniture_inventories') THEN
    DROP POLICY IF EXISTS "furniture_inventories_owner_select" ON public.furniture_inventories;
    DROP POLICY IF EXISTS "furniture_inventories_owner_insert" ON public.furniture_inventories;
    DROP POLICY IF EXISTS "furniture_inventories_owner_update" ON public.furniture_inventories;
    DROP POLICY IF EXISTS "furniture_inventories_owner_delete" ON public.furniture_inventories;
    DROP POLICY IF EXISTS "furniture_inventories_tenant_select" ON public.furniture_inventories;
    DROP POLICY IF EXISTS "furniture_inventories_admin_all" ON public.furniture_inventories;
    CREATE POLICY "furniture_inventories_owner_select" ON public.furniture_inventories FOR SELECT USING (EXISTS (SELECT 1 FROM public.leases l JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE l.id = furniture_inventories.lease_id AND pr.user_id = auth.uid()));
    CREATE POLICY "furniture_inventories_owner_insert" ON public.furniture_inventories FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.leases l JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE l.id = furniture_inventories.lease_id AND pr.user_id = auth.uid()));
    CREATE POLICY "furniture_inventories_owner_update" ON public.furniture_inventories FOR UPDATE USING (EXISTS (SELECT 1 FROM public.leases l JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE l.id = furniture_inventories.lease_id AND pr.user_id = auth.uid()));
    CREATE POLICY "furniture_inventories_tenant_select" ON public.furniture_inventories FOR SELECT USING (EXISTS (SELECT 1 FROM public.leases l JOIN public.profiles pr ON pr.id = l.tenant_id WHERE l.id = furniture_inventories.lease_id AND pr.user_id = auth.uid()));
    CREATE POLICY "furniture_inventories_admin_all" ON public.furniture_inventories FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE user_id = auth.uid() AND role = 'admin'));
  END IF;
END $$;

DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'furniture_items') THEN
    DROP POLICY IF EXISTS "furniture_items_owner_select" ON public.furniture_items;
    DROP POLICY IF EXISTS "furniture_items_owner_insert" ON public.furniture_items;
    DROP POLICY IF EXISTS "furniture_items_owner_update" ON public.furniture_items;
    DROP POLICY IF EXISTS "furniture_items_owner_delete" ON public.furniture_items;
    DROP POLICY IF EXISTS "furniture_items_tenant_select" ON public.furniture_items;
    DROP POLICY IF EXISTS "furniture_items_admin_all" ON public.furniture_items;
    CREATE POLICY "furniture_items_owner_select" ON public.furniture_items FOR SELECT USING (EXISTS (SELECT 1 FROM public.furniture_inventories fi JOIN public.leases l ON l.id = fi.lease_id JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE fi.id = furniture_items.inventory_id AND pr.user_id = auth.uid()));
    CREATE POLICY "furniture_items_owner_insert" ON public.furniture_items FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.furniture_inventories fi JOIN public.leases l ON l.id = fi.lease_id JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE fi.id = furniture_items.inventory_id AND pr.user_id = auth.uid()));
    CREATE POLICY "furniture_items_owner_update" ON public.furniture_items FOR UPDATE USING (EXISTS (SELECT 1 FROM public.furniture_inventories fi JOIN public.leases l ON l.id = fi.lease_id JOIN public.properties p ON p.id = l.property_id JOIN public.profiles pr ON pr.id = p.owner_id WHERE fi.id = furniture_items.inventory_id AND pr.user_id = auth.uid()));
    CREATE POLICY "furniture_items_tenant_select" ON public.furniture_items FOR SELECT USING (EXISTS (SELECT 1 FROM public.furniture_inventories fi JOIN public.leases l ON l.id = fi.lease_id JOIN public.profiles pr ON pr.id = l.tenant_id WHERE fi.id = furniture_items.inventory_id AND pr.user_id = auth.uid()));
    CREATE POLICY "furniture_items_admin_all" ON public.furniture_items FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE user_id = auth.uid() AND role = 'admin'));
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_edl_signatures_signer_profile ON public.edl_signatures(signer_profile_id);

CREATE OR REPLACE FUNCTION public.set_edl_entity_id()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.entity_id IS NULL AND NEW.lease_id IS NOT NULL THEN
    SELECT signatory_entity_id INTO NEW.entity_id FROM public.leases WHERE id = NEW.lease_id;
  END IF;
  IF NEW.entity_id IS NULL AND NEW.property_id IS NOT NULL THEN
    SELECT legal_entity_id INTO NEW.entity_id FROM public.properties WHERE id = NEW.property_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_set_edl_entity_id ON public.edl;
CREATE TRIGGER trigger_set_edl_entity_id
  BEFORE INSERT ON public.edl FOR EACH ROW EXECUTE FUNCTION public.set_edl_entity_id();

-- ========== 20260207200000_audit_improvements_phase2.sql ==========
-- MIGRATION: Improvements from EDL/Bail audit - Phase 2

DROP TRIGGER IF EXISTS trigger_activate_lease_on_edl_signed ON public.edl;
DROP FUNCTION IF EXISTS public.activate_lease_on_edl_signed();

DO $$ BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE table_name = 'edl' AND constraint_name LIKE '%type%' AND constraint_type = 'CHECK'
  ) THEN
    DECLARE cname TEXT;
    BEGIN
      SELECT constraint_name INTO cname FROM information_schema.table_constraints
      WHERE table_name = 'edl' AND constraint_name LIKE '%type%' AND constraint_type = 'CHECK' LIMIT 1;
      IF cname IS NOT NULL THEN EXECUTE format('ALTER TABLE public.edl DROP CONSTRAINT %I', cname); END IF;
    END;
  END IF;
  ALTER TABLE public.edl ADD CONSTRAINT edl_type_check CHECK (type IN ('entree', 'sortie', 'intermediaire'));
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    WHERE tc.table_name = 'leases' AND kcu.column_name = 'tenant_id' AND tc.constraint_type = 'FOREIGN KEY'
  ) THEN
    DECLARE fk_name TEXT;
    BEGIN
      SELECT tc.constraint_name INTO fk_name FROM information_schema.table_constraints tc
      JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
      WHERE tc.table_name = 'leases' AND kcu.column_name = 'tenant_id' AND tc.constraint_type = 'FOREIGN KEY' LIMIT 1;
      IF fk_name IS NOT NULL THEN
        EXECUTE format('ALTER TABLE public.leases DROP CONSTRAINT %I', fk_name);
        ALTER TABLE public.leases ADD CONSTRAINT leases_tenant_id_fkey FOREIGN KEY (tenant_id) REFERENCES public.profiles(id) ON DELETE SET NULL;
      END IF;
    END;
  END IF;
END $$;

DO $$ BEGIN
  BEGIN
    ALTER TABLE public.documents DROP CONSTRAINT IF EXISTS documents_replaced_by_fkey;
    ALTER TABLE public.documents ADD CONSTRAINT documents_replaced_by_fkey FOREIGN KEY (replaced_by) REFERENCES public.documents(id) ON DELETE SET NULL;
  EXCEPTION WHEN undefined_column THEN NULL;
  END;
END $$;

DO $$ BEGIN
  BEGIN
    ALTER TABLE public.documents DROP CONSTRAINT IF EXISTS documents_verified_by_fkey;
    ALTER TABLE public.documents ADD CONSTRAINT documents_verified_by_fkey FOREIGN KEY (verified_by) REFERENCES public.profiles(id) ON DELETE SET NULL;
  EXCEPTION WHEN undefined_column THEN NULL;
  END;
END $$;

DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'furniture_inventories') THEN
    COMMENT ON TABLE public.furniture_inventories IS 'DEPRECATED: Use edl_furniture_inventory instead.';
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'furniture_items') THEN
    COMMENT ON TABLE public.furniture_items IS 'DEPRECATED: Use edl_mandatory_furniture / edl_additional_furniture instead.';
  END IF;
END $$;

DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'entity_associates' AND column_name = 'piece_identite_document_id') THEN
    BEGIN
      ALTER TABLE public.entity_associates ADD CONSTRAINT entity_associates_piece_identite_fkey FOREIGN KEY (piece_identite_document_id) REFERENCES public.documents(id) ON DELETE SET NULL;
      CREATE INDEX IF NOT EXISTS idx_entity_associates_piece_identite ON public.entity_associates(piece_identite_document_id);
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'entity_associates' AND column_name = 'justificatif_domicile_document_id') THEN
    BEGIN
      ALTER TABLE public.entity_associates ADD CONSTRAINT entity_associates_justificatif_domicile_fkey FOREIGN KEY (justificatif_domicile_document_id) REFERENCES public.documents(id) ON DELETE SET NULL;
      CREATE INDEX IF NOT EXISTS idx_entity_associates_justificatif_domicile ON public.entity_associates(justificatif_domicile_document_id);
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;
  END IF;
END $$;

-- ========== 20260208100000_fix_data_storage_audit.sql ==========
-- Migration: Fix data storage issues found during route audit (2026-02-08)

ALTER TABLE roommates ALTER COLUMN user_id DROP NOT NULL;
ALTER TABLE roommates ALTER COLUMN profile_id DROP NOT NULL;
ALTER TABLE roommates ALTER COLUMN first_name DROP NOT NULL;
ALTER TABLE roommates ALTER COLUMN last_name DROP NOT NULL;
ALTER TABLE roommates ALTER COLUMN first_name SET DEFAULT '';
ALTER TABLE roommates ALTER COLUMN last_name SET DEFAULT '';

ALTER TABLE roommates ADD COLUMN IF NOT EXISTS room_label TEXT;
ALTER TABLE roommates ADD COLUMN IF NOT EXISTS has_guarantor BOOLEAN DEFAULT false;
ALTER TABLE roommates ADD COLUMN IF NOT EXISTS guarantor_email TEXT;
ALTER TABLE roommates ADD COLUMN IF NOT EXISTS guarantor_name TEXT;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'leases' AND column_name = 'clauses_particulieres'
  ) THEN
    ALTER TABLE leases ADD COLUMN clauses_particulieres TEXT;
  END IF;
END $$;

ALTER TABLE roommates DROP CONSTRAINT IF EXISTS roommates_lease_id_user_id_key;
CREATE UNIQUE INDEX IF NOT EXISTS roommates_lease_user_unique ON roommates (lease_id, user_id) WHERE user_id IS NOT NULL;
CREATE UNIQUE INDEX IF NOT EXISTS roommates_lease_email_unique ON roommates (lease_id, invited_email) WHERE invited_email IS NOT NULL;

-- ========== 20260209100000_create_sms_messages_table.sql ==========
-- Migration: Create sms_messages table for Twilio SMS tracking (2026-02-09)

CREATE TABLE IF NOT EXISTS sms_messages (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id    UUID REFERENCES profiles(id) ON DELETE SET NULL,
  from_number   TEXT NOT NULL,
  to_number     TEXT NOT NULL,
  message       TEXT NOT NULL,
  segments      INT DEFAULT 1,
  twilio_sid    TEXT,
  twilio_status TEXT,
  status        TEXT NOT NULL DEFAULT 'queued'
                CHECK (status IN ('queued', 'sent', 'delivered', 'undelivered', 'failed')),
  error_code    TEXT,
  error_message TEXT,
  sent_at       TIMESTAMPTZ,
  delivered_at  TIMESTAMPTZ,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_sms_messages_twilio_sid ON sms_messages (twilio_sid) WHERE twilio_sid IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_sms_messages_profile_id ON sms_messages (profile_id) WHERE profile_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_sms_messages_created_at ON sms_messages (created_at DESC);

CREATE OR REPLACE FUNCTION update_sms_messages_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sms_messages_updated_at ON sms_messages;
CREATE TRIGGER trg_sms_messages_updated_at
  BEFORE UPDATE ON sms_messages FOR EACH ROW EXECUTE FUNCTION update_sms_messages_updated_at();

ALTER TABLE sms_messages ENABLE ROW LEVEL SECURITY;

CREATE POLICY sms_messages_admin_all ON sms_messages FOR ALL USING (EXISTS (SELECT 1 FROM profiles p WHERE p.user_id = auth.uid() AND p.role = 'admin'));
CREATE POLICY sms_messages_owner_select ON sms_messages FOR SELECT USING (EXISTS (SELECT 1 FROM profiles p WHERE p.user_id = auth.uid() AND p.role = 'owner' AND p.id = sms_messages.profile_id));
CREATE POLICY sms_messages_service_insert ON sms_messages FOR INSERT WITH CHECK (true);


-- ========== 20260211000000_p2_unique_constraint_and_gdpr_rpc.sql ==========
-- =====================================================
-- Migration P2: Contrainte UNIQUE partielle + RPC GDPR transactionnelle
-- Date: 2026-02-11
-- =====================================================

BEGIN;

-- ============================================
-- 1. CONTRAINTE UNIQUE PARTIELLE SUR DOCUMENTS
-- ============================================
-- Empêche la création de doublons pour les documents générés
-- (même type + même bail + même hash de contenu)
-- Ne s'applique qu'aux documents avec un content_hash (documents générés).

CREATE UNIQUE INDEX IF NOT EXISTS idx_documents_unique_type_lease_hash
  ON documents (type, lease_id, content_hash)
  WHERE content_hash IS NOT NULL
    AND lease_id IS NOT NULL;

COMMENT ON INDEX idx_documents_unique_type_lease_hash IS
  'Empêche les doublons de documents générés pour un même bail (P2 audit duplicate-detection)';

-- ============================================
-- 2. RPC TRANSACTIONNELLE POUR ANONYMISATION GDPR
-- ============================================
-- Toutes les opérations d'anonymisation sont wrappées dans une
-- transaction Postgres unique pour garantir l'atomicité.
-- Si une étape échoue, TOUT est annulé (rollback automatique).

CREATE OR REPLACE FUNCTION anonymize_user_cascade(
  p_user_id UUID,
  p_admin_user_id UUID,
  p_reason TEXT,
  p_keep_financial_records BOOLEAN DEFAULT TRUE
)
RETURNS JSONB AS $$
DECLARE
  v_profile_id UUID;
  v_profile_role TEXT;
  v_result JSONB := '{"tables_processed": [], "documents_deleted": 0, "total_rows_affected": 0}'::JSONB;
  v_tables JSONB := '[]'::JSONB;
  v_count INTEGER;
  v_total INTEGER := 0;
  v_doc RECORD;
  v_docs_deleted INTEGER := 0;
BEGIN
  -- Récupérer le profil cible
  SELECT id, role INTO v_profile_id, v_profile_role
  FROM profiles
  WHERE user_id = p_user_id;

  IF v_profile_id IS NULL THEN
    RAISE EXCEPTION 'Utilisateur non trouvé: %', p_user_id;
  END IF;

  IF v_profile_role = 'admin' THEN
    RAISE EXCEPTION 'Impossible d''anonymiser un administrateur';
  END IF;

  -- ========== 1. Profil principal ==========
  UPDATE profiles SET
    prenom = 'UTILISATEUR',
    nom = 'ANONYME',
    email = 'anonyme_' || EXTRACT(EPOCH FROM NOW())::BIGINT || '@deleted.local',
    telephone = NULL,
    avatar_url = NULL,
    date_naissance = NULL,
    updated_at = NOW()
  WHERE user_id = p_user_id;
  GET DIAGNOSTICS v_count = ROW_COUNT;
  v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'profiles', 'rows_affected', v_count));
  v_total := v_total + v_count;

  -- ========== 2. Owner profile ==========
  UPDATE owner_profiles SET
    siret = NULL, tva = NULL, iban = NULL, adresse_facturation = NULL
  WHERE profile_id = v_profile_id;
  GET DIAGNOSTICS v_count = ROW_COUNT;
  IF v_count > 0 THEN
    v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'owner_profiles', 'rows_affected', v_count));
    v_total := v_total + v_count;
  END IF;

  -- ========== 3. Tenant profile ==========
  UPDATE tenant_profiles SET
    situation_pro = NULL, revenus_mensuels = NULL,
    employeur = NULL, employeur_adresse = NULL, employeur_telephone = NULL
  WHERE profile_id = v_profile_id;
  GET DIAGNOSTICS v_count = ROW_COUNT;
  IF v_count > 0 THEN
    v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'tenant_profiles', 'rows_affected', v_count));
    v_total := v_total + v_count;
  END IF;

  -- ========== 4. Provider profile ==========
  UPDATE provider_profiles SET
    siret = NULL, certifications = NULL, zones_intervention = NULL
  WHERE profile_id = v_profile_id;
  GET DIAGNOSTICS v_count = ROW_COUNT;
  IF v_count > 0 THEN
    v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'provider_profiles', 'rows_affected', v_count));
    v_total := v_total + v_count;
  END IF;

  -- ========== 5. Consentements ==========
  DELETE FROM user_consents WHERE user_id = p_user_id;
  GET DIAGNOSTICS v_count = ROW_COUNT;
  IF v_count > 0 THEN
    v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'user_consents', 'rows_affected', v_count));
    v_total := v_total + v_count;
  END IF;

  -- ========== 6. Tickets ==========
  UPDATE tickets SET description = '[Contenu supprimé - RGPD]'
  WHERE created_by_profile_id = v_profile_id;
  GET DIAGNOSTICS v_count = ROW_COUNT;
  IF v_count > 0 THEN
    v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'tickets', 'rows_affected', v_count));
    v_total := v_total + v_count;
  END IF;

  -- Messages des tickets
  UPDATE ticket_messages SET content = '[Message supprimé - RGPD]'
  WHERE ticket_id IN (
    SELECT id FROM tickets WHERE created_by_profile_id = v_profile_id
  );
  GET DIAGNOSTICS v_count = ROW_COUNT;
  IF v_count > 0 THEN
    v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'ticket_messages', 'rows_affected', v_count));
    v_total := v_total + v_count;
  END IF;

  -- ========== 7. Notifications ==========
  DELETE FROM notifications WHERE profile_id = v_profile_id;
  GET DIAGNOSTICS v_count = ROW_COUNT;
  IF v_count > 0 THEN
    v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'notifications', 'rows_affected', v_count));
    v_total := v_total + v_count;
  END IF;

  -- ========== 8. Documents (métadonnées) ==========
  -- Note: la suppression des fichiers Storage doit être faite côté API
  -- car les fonctions SQL n'ont pas accès au Storage.
  -- On collecte les storage_path des docs non-financiers pour le caller.
  UPDATE documents SET
    metadata = jsonb_build_object('anonymized', true, 'anonymized_at', NOW())
  WHERE owner_id = v_profile_id OR tenant_id = v_profile_id;
  GET DIAGNOSTICS v_count = ROW_COUNT;
  IF v_count > 0 THEN
    v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'documents', 'rows_affected', v_count));
    v_total := v_total + v_count;
  END IF;

  -- ========== 9. Factures (si autorisé) ==========
  IF NOT p_keep_financial_records THEN
    UPDATE invoices SET metadata = jsonb_build_object('anonymized', true)
    WHERE owner_id = v_profile_id OR tenant_id = v_profile_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
    IF v_count > 0 THEN
      v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'invoices', 'rows_affected', v_count));
      v_total := v_total + v_count;
    END IF;
  END IF;

  -- ========== 10. Logs de connexion ==========
  UPDATE audit_log SET
    metadata = jsonb_build_object('anonymized', true),
    ip_address = NULL
  WHERE user_id = p_user_id;
  GET DIAGNOSTICS v_count = ROW_COUNT;
  IF v_count > 0 THEN
    v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'audit_log', 'rows_affected', v_count));
    v_total := v_total + v_count;
  END IF;

  -- ========== 11. Documents d'identité (métadonnées DB) ==========
  -- Les fichiers Storage seront supprimés côté API
  DELETE FROM tenant_identity_documents WHERE tenant_id = v_profile_id;
  GET DIAGNOSTICS v_count = ROW_COUNT;
  IF v_count > 0 THEN
    v_tables := v_tables || jsonb_build_array(jsonb_build_object('table', 'tenant_identity_documents', 'rows_affected', v_count));
    v_total := v_total + v_count;
  END IF;

  -- ========== 12. Log de l'opération ==========
  INSERT INTO audit_log (user_id, action, entity_type, entity_id, metadata)
  VALUES (
    p_admin_user_id,
    'data_anonymized_cascade',
    'user',
    p_user_id::TEXT,
    jsonb_build_object(
      'reason', p_reason,
      'tables_processed', v_tables,
      'total_rows_affected', v_total,
      'keep_financial_records', p_keep_financial_records,
      'timestamp', NOW()
    )
  );

  -- Construire le résultat
  v_result := jsonb_build_object(
    'success', true,
    'profile_id', v_profile_id,
    'tables_processed', v_tables,
    'total_rows_affected', v_total
  );

  RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION anonymize_user_cascade IS
  'Anonymise toutes les données d''un utilisateur en une seule transaction atomique (RGPD Art. 17)';

-- ============================================
-- 3. RPC POUR NETTOYAGE ORPHELINS (utilisée par le cron)
-- ============================================

CREATE OR REPLACE FUNCTION cleanup_orphan_documents()
RETURNS JSONB AS $$
DECLARE
  v_orphan_lease_count INTEGER := 0;
  v_orphan_property_count INTEGER := 0;
  v_old_notif_count INTEGER := 0;
  v_expired_otp_count INTEGER := 0;
  v_expired_preview_count INTEGER := 0;
  v_storage_paths TEXT[] := '{}';
BEGIN
  -- 1. Documents dont le bail a été supprimé
  -- Collecter les storage_path pour suppression côté Storage
  SELECT ARRAY_AGG(storage_path) INTO v_storage_paths
  FROM documents
  WHERE lease_id IS NOT NULL
    AND lease_id NOT IN (SELECT id FROM leases);

  DELETE FROM documents
  WHERE lease_id IS NOT NULL
    AND lease_id NOT IN (SELECT id FROM leases);
  GET DIAGNOSTICS v_orphan_lease_count = ROW_COUNT;

  -- 2. Documents dont la propriété a été hard-delete
  DELETE FROM documents
  WHERE property_id IS NOT NULL
    AND property_id NOT IN (SELECT id FROM properties);
  GET DIAGNOSTICS v_orphan_property_count = ROW_COUNT;

  -- 3. Notifications lues > 90 jours
  DELETE FROM notifications
  WHERE is_read = TRUE
    AND created_at < NOW() - INTERVAL '90 days';
  GET DIAGNOSTICS v_old_notif_count = ROW_COUNT;

  -- 4. OTP codes expirés > 24h
  DELETE FROM otp_codes
  WHERE expires_at < NOW() - INTERVAL '24 hours';
  GET DIAGNOSTICS v_expired_otp_count = ROW_COUNT;

  -- 5. Preview cache expirés
  DELETE FROM preview_cache
  WHERE expires_at < NOW();
  GET DIAGNOSTICS v_expired_preview_count = ROW_COUNT;

  RETURN jsonb_build_object(
    'orphan_documents_lease', v_orphan_lease_count,
    'orphan_documents_property', v_orphan_property_count,
    'old_notifications', v_old_notif_count,
    'expired_otp', v_expired_otp_count,
    'expired_previews', v_expired_preview_count,
    'storage_paths_to_delete', v_storage_paths,
    'executed_at', NOW()
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION cleanup_orphan_documents IS
  'Nettoie les enregistrements orphelins en une transaction. Retourne les storage_path à supprimer côté Storage.';

COMMIT;

-- ========== 20260211100000_bic_compliance_tax_regime.sql ==========
-- ============================================
-- BIC Compliance: Régime fiscal + Inventaire mobilier
-- Corrige les lacunes identifiées dans l'audit BIC
-- ============================================

-- 1. Enum pour le régime fiscal BIC
DO $$ BEGIN
  CREATE TYPE tax_regime_type AS ENUM (
    'micro_foncier',    -- Revenus fonciers < 15k€ (location nue)
    'reel_foncier',     -- Revenus fonciers réel (location nue)
    'micro_bic',        -- BIC micro < 77 700€ (location meublée)
    'reel_bic'          -- BIC réel (location meublée)
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- 2. Enum pour le statut LMNP/LMP
DO $$ BEGIN
  CREATE TYPE lmnp_status_type AS ENUM (
    'lmnp',  -- Loueur Meublé Non Professionnel
    'lmp'    -- Loueur Meublé Professionnel
  );
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- 3. Ajouter colonnes au tableau leases
ALTER TABLE leases
  ADD COLUMN IF NOT EXISTS tax_regime text DEFAULT NULL,
  ADD COLUMN IF NOT EXISTS lmnp_status text DEFAULT NULL,
  ADD COLUMN IF NOT EXISTS furniture_inventory jsonb DEFAULT NULL;

-- 4. Ajouter indicateur meublé au tableau properties
ALTER TABLE properties
  ADD COLUMN IF NOT EXISTS is_furnished boolean DEFAULT false,
  ADD COLUMN IF NOT EXISTS default_tax_regime text DEFAULT NULL;

-- 5. Contrainte: si bail meublé, tax_regime doit être BIC
-- (informative, pas bloquante pour permettre migration progressive)
COMMENT ON COLUMN leases.tax_regime IS
  'Régime fiscal: micro_foncier, reel_foncier (bail nu), micro_bic, reel_bic (bail meublé)';

COMMENT ON COLUMN leases.lmnp_status IS
  'Statut fiscal meublé: lmnp (non professionnel) ou lmp (professionnel)';

COMMENT ON COLUMN leases.furniture_inventory IS
  'Inventaire mobilier JSON (Décret 2015-981) — 11 éléments obligatoires + supplémentaires';

COMMENT ON COLUMN properties.is_furnished IS
  'Indique si le bien est meublé (conditionne le type de bail et le régime fiscal BIC)';

COMMENT ON COLUMN properties.default_tax_regime IS
  'Régime fiscal par défaut pour les nouveaux baux sur ce bien';

-- 6. Auto-update is_furnished quand un bail meublé est créé
CREATE OR REPLACE FUNCTION update_property_furnished_status()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.type_bail IN ('meuble', 'bail_mobilite', 'etudiant') THEN
    UPDATE properties
    SET is_furnished = true
    WHERE id = NEW.property_id
      AND is_furnished = false;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_update_property_furnished ON leases;
CREATE TRIGGER trg_update_property_furnished
  AFTER INSERT ON leases
  FOR EACH ROW
  EXECUTE FUNCTION update_property_furnished_status();

-- 7. Vue pour le monitoring LMNP/LMP
CREATE OR REPLACE VIEW v_owner_rental_income AS
SELECT
  p.owner_id,
  EXTRACT(YEAR FROM i.periode::date) AS year,
  SUM(CASE
    WHEN l.type_bail IN ('meuble', 'bail_mobilite', 'etudiant', 'saisonnier')
    THEN i.montant_total
    ELSE 0
  END) AS furnished_income,
  SUM(CASE
    WHEN l.type_bail IN ('nu', 'bail_mixte')
    THEN i.montant_total
    ELSE 0
  END) AS unfurnished_income,
  SUM(i.montant_total) AS total_income
FROM invoices i
  JOIN leases l ON l.id = i.lease_id
  JOIN properties p ON p.id = l.property_id
WHERE i.statut = 'paid'
GROUP BY p.owner_id, EXTRACT(YEAR FROM i.periode::date);

-- 8. Index pour performances
CREATE INDEX IF NOT EXISTS idx_leases_tax_regime ON leases(tax_regime) WHERE tax_regime IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_properties_is_furnished ON properties(is_furnished) WHERE is_furnished = true;

-- ========== 20260212000000_audit_database_integrity.sql ==========
-- ============================================================================
-- AUDIT D'INTÉGRITÉ DE LA BASE DE DONNÉES TALOK
-- Date: 2026-02-12
-- Auteur: Audit automatisé
-- ============================================================================
-- Ce script est un audit SAFE (lecture seule + fonctions de diagnostic).
-- Il ne supprime AUCUNE donnée. Il crée :
--   1. Des fonctions RPC de diagnostic pour détecter les orphelins
--   2. Des fonctions RPC de diagnostic pour détecter les doublons
--   3. Une vue matérialisée consolidée de l'état d'intégrité
--   4. Des fonctions de nettoyage SAFE (soft-delete / archivage)
-- ============================================================================

-- ============================================================================
-- PHASE 1: FONCTIONS DE DÉTECTION DES ORPHELINS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 1.1 Audit global : retourne toutes les relations orphelines en un seul appel
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION audit_orphan_records()
RETURNS TABLE(
  source_table TEXT,
  fk_column TEXT,
  target_table TEXT,
  orphan_count BIGINT,
  severity TEXT,
  description TEXT
) AS $$
BEGIN

  -- ── PROFILES ──────────────────────────────────────────────────────
  -- profiles → auth.users (user_id)
  RETURN QUERY
  SELECT 'profiles'::TEXT, 'user_id'::TEXT, 'auth.users'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Profiles sans compte auth.users associé'::TEXT
  FROM profiles p
  WHERE NOT EXISTS (SELECT 1 FROM auth.users u WHERE u.id = p.user_id);

  -- ── PROPERTIES ────────────────────────────────────────────────────
  -- properties → profiles (owner_id)
  RETURN QUERY
  SELECT 'properties'::TEXT, 'owner_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Propriétés dont le propriétaire (profile) n''existe plus'::TEXT
  FROM properties p
  WHERE p.owner_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM profiles pr WHERE pr.id = p.owner_id);

  -- properties → buildings (building_id)
  RETURN QUERY
  SELECT 'properties'::TEXT, 'building_id'::TEXT, 'buildings'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Propriétés avec building_id pointant vers un immeuble inexistant'::TEXT
  FROM properties p
  WHERE p.building_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM buildings b WHERE b.id = p.building_id);

  -- properties → legal_entities (legal_entity_id)
  RETURN QUERY
  SELECT 'properties'::TEXT, 'legal_entity_id'::TEXT, 'legal_entities'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Propriétés avec legal_entity_id pointant vers une entité inexistante'::TEXT
  FROM properties p
  WHERE p.legal_entity_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM legal_entities le WHERE le.id = p.legal_entity_id);

  -- ── UNITS ─────────────────────────────────────────────────────────
  -- units → properties (property_id)
  RETURN QUERY
  SELECT 'units'::TEXT, 'property_id'::TEXT, 'properties'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Unités de colocation dont la propriété n''existe plus'::TEXT
  FROM units u
  WHERE NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = u.property_id);

  -- ── LEASES ────────────────────────────────────────────────────────
  -- leases → properties (property_id)
  RETURN QUERY
  SELECT 'leases'::TEXT, 'property_id'::TEXT, 'properties'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Baux dont la propriété n''existe plus'::TEXT
  FROM leases l
  WHERE l.property_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = l.property_id);

  -- leases → units (unit_id)
  RETURN QUERY
  SELECT 'leases'::TEXT, 'unit_id'::TEXT, 'units'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Baux dont l''unité n''existe plus'::TEXT
  FROM leases l
  WHERE l.unit_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM units u WHERE u.id = l.unit_id);

  -- leases → profiles (tenant_id) — FK implicite ajoutée plus tard
  RETURN QUERY
  SELECT 'leases'::TEXT, 'tenant_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Baux dont le locataire (tenant_id) n''existe plus dans profiles'::TEXT
  FROM leases l
  WHERE l.tenant_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM profiles pr WHERE pr.id = l.tenant_id);

  -- leases → profiles (owner_id) — FK implicite
  RETURN QUERY
  SELECT 'leases'::TEXT, 'owner_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Baux dont le propriétaire (owner_id) n''existe plus dans profiles'::TEXT
  FROM leases l
  WHERE l.owner_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM profiles pr WHERE pr.id = l.owner_id);

  -- Baux actifs sans aucun signataire
  RETURN QUERY
  SELECT 'leases'::TEXT, '(no_signers)'::TEXT, 'lease_signers'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Baux actifs/pending sans aucun signataire'::TEXT
  FROM leases l
  WHERE l.statut NOT IN ('draft', 'cancelled', 'archived', 'terminated')
    AND NOT EXISTS (SELECT 1 FROM lease_signers ls WHERE ls.lease_id = l.id);

  -- ── LEASE_SIGNERS ─────────────────────────────────────────────────
  -- lease_signers → leases (lease_id)
  RETURN QUERY
  SELECT 'lease_signers'::TEXT, 'lease_id'::TEXT, 'leases'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Signataires dont le bail n''existe plus'::TEXT
  FROM lease_signers ls
  WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = ls.lease_id);

  -- lease_signers → profiles (profile_id)
  RETURN QUERY
  SELECT 'lease_signers'::TEXT, 'profile_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Signataires dont le profil n''existe plus'::TEXT
  FROM lease_signers ls
  WHERE ls.profile_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = ls.profile_id);

  -- ── INVOICES ──────────────────────────────────────────────────────
  -- invoices → leases (lease_id)
  RETURN QUERY
  SELECT 'invoices'::TEXT, 'lease_id'::TEXT, 'leases'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Factures dont le bail n''existe plus'::TEXT
  FROM invoices i
  WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = i.lease_id);

  -- invoices → profiles (owner_id)
  RETURN QUERY
  SELECT 'invoices'::TEXT, 'owner_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Factures dont le profil propriétaire n''existe plus'::TEXT
  FROM invoices i
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = i.owner_id);

  -- invoices → profiles (tenant_id)
  RETURN QUERY
  SELECT 'invoices'::TEXT, 'tenant_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Factures dont le profil locataire n''existe plus'::TEXT
  FROM invoices i
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = i.tenant_id);

  -- ── PAYMENTS ──────────────────────────────────────────────────────
  -- payments → invoices (invoice_id)
  RETURN QUERY
  SELECT 'payments'::TEXT, 'invoice_id'::TEXT, 'invoices'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Paiements dont la facture n''existe plus'::TEXT
  FROM payments py
  WHERE NOT EXISTS (SELECT 1 FROM invoices i WHERE i.id = py.invoice_id);

  -- ── DOCUMENTS ─────────────────────────────────────────────────────
  -- documents → leases (lease_id)
  RETURN QUERY
  SELECT 'documents'::TEXT, 'lease_id'::TEXT, 'leases'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Documents dont le bail n''existe plus'::TEXT
  FROM documents d
  WHERE d.lease_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = d.lease_id);

  -- documents → properties (property_id)
  RETURN QUERY
  SELECT 'documents'::TEXT, 'property_id'::TEXT, 'properties'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Documents dont la propriété n''existe plus'::TEXT
  FROM documents d
  WHERE d.property_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = d.property_id);

  -- documents → profiles (owner_id)
  RETURN QUERY
  SELECT 'documents'::TEXT, 'owner_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Documents dont le profil owner n''existe plus'::TEXT
  FROM documents d
  WHERE d.owner_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = d.owner_id);

  -- documents → profiles (tenant_id)
  RETURN QUERY
  SELECT 'documents'::TEXT, 'tenant_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Documents dont le profil tenant n''existe plus'::TEXT
  FROM documents d
  WHERE d.tenant_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = d.tenant_id);

  -- documents → profiles (profile_id)
  RETURN QUERY
  SELECT 'documents'::TEXT, 'profile_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Documents dont le profile_id n''existe plus'::TEXT
  FROM documents d
  WHERE d.profile_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = d.profile_id);

  -- Documents totalement flottants (aucune FK remplie)
  RETURN QUERY
  SELECT 'documents'::TEXT, '(no_parent)'::TEXT, '(none)'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Documents sans aucun rattachement (owner_id, tenant_id, property_id, lease_id tous NULL)'::TEXT
  FROM documents d
  WHERE d.owner_id IS NULL
    AND d.tenant_id IS NULL
    AND d.property_id IS NULL
    AND d.lease_id IS NULL
    AND d.profile_id IS NULL;

  -- ── TICKETS ───────────────────────────────────────────────────────
  -- tickets → properties (property_id)
  RETURN QUERY
  SELECT 'tickets'::TEXT, 'property_id'::TEXT, 'properties'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Tickets dont la propriété n''existe plus'::TEXT
  FROM tickets t
  WHERE NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = t.property_id);

  -- tickets → profiles (created_by_profile_id)
  RETURN QUERY
  SELECT 'tickets'::TEXT, 'created_by_profile_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Tickets dont le créateur n''existe plus'::TEXT
  FROM tickets t
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = t.created_by_profile_id);

  -- tickets → leases (lease_id)
  RETURN QUERY
  SELECT 'tickets'::TEXT, 'lease_id'::TEXT, 'leases'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Tickets avec lease_id pointant vers un bail inexistant'::TEXT
  FROM tickets t
  WHERE t.lease_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = t.lease_id);

  -- ── WORK_ORDERS ───────────────────────────────────────────────────
  -- work_orders → tickets (ticket_id)
  RETURN QUERY
  SELECT 'work_orders'::TEXT, 'ticket_id'::TEXT, 'tickets'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Ordres de travail dont le ticket n''existe plus'::TEXT
  FROM work_orders wo
  WHERE NOT EXISTS (SELECT 1 FROM tickets t WHERE t.id = wo.ticket_id);

  -- work_orders → profiles (provider_id)
  RETURN QUERY
  SELECT 'work_orders'::TEXT, 'provider_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Ordres de travail dont le prestataire n''existe plus'::TEXT
  FROM work_orders wo
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = wo.provider_id);

  -- ── CHARGES ───────────────────────────────────────────────────────
  -- charges → properties (property_id)
  RETURN QUERY
  SELECT 'charges'::TEXT, 'property_id'::TEXT, 'properties'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Charges dont la propriété n''existe plus'::TEXT
  FROM charges c
  WHERE NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = c.property_id);

  -- ── EDL ───────────────────────────────────────────────────────────
  -- edl → leases (lease_id)
  RETURN QUERY
  SELECT 'edl'::TEXT, 'lease_id'::TEXT, 'leases'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'États des lieux dont le bail n''existe plus'::TEXT
  FROM edl e
  WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = e.lease_id);

  -- edl_items → edl (edl_id)
  RETURN QUERY
  SELECT 'edl_items'::TEXT, 'edl_id'::TEXT, 'edl'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Items d''EDL dont l''EDL parent n''existe plus'::TEXT
  FROM edl_items ei
  WHERE NOT EXISTS (SELECT 1 FROM edl e WHERE e.id = ei.edl_id);

  -- edl_media → edl (edl_id)
  RETURN QUERY
  SELECT 'edl_media'::TEXT, 'edl_id'::TEXT, 'edl'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Médias d''EDL dont l''EDL parent n''existe plus'::TEXT
  FROM edl_media em
  WHERE NOT EXISTS (SELECT 1 FROM edl e WHERE e.id = em.edl_id);

  -- edl_signatures → edl (edl_id)
  RETURN QUERY
  SELECT 'edl_signatures'::TEXT, 'edl_id'::TEXT, 'edl'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Signatures d''EDL dont l''EDL parent n''existe plus'::TEXT
  FROM edl_signatures es
  WHERE NOT EXISTS (SELECT 1 FROM edl e WHERE e.id = es.edl_id);

  -- edl_meter_readings → edl (edl_id)
  RETURN QUERY
  SELECT 'edl_meter_readings'::TEXT, 'edl_id'::TEXT, 'edl'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Relevés compteurs EDL dont l''EDL n''existe plus'::TEXT
  FROM edl_meter_readings emr
  WHERE NOT EXISTS (SELECT 1 FROM edl e WHERE e.id = emr.edl_id);

  -- ── METERS ────────────────────────────────────────────────────────
  -- meters → leases (lease_id)
  RETURN QUERY
  SELECT 'meters'::TEXT, 'lease_id'::TEXT, 'leases'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Compteurs dont le bail n''existe plus'::TEXT
  FROM meters m
  WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = m.lease_id);

  -- meter_readings → meters (meter_id)
  RETURN QUERY
  SELECT 'meter_readings'::TEXT, 'meter_id'::TEXT, 'meters'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Relevés de compteur dont le compteur n''existe plus'::TEXT
  FROM meter_readings mr
  WHERE NOT EXISTS (SELECT 1 FROM meters m WHERE m.id = mr.meter_id);

  -- ── ROOMMATES ─────────────────────────────────────────────────────
  -- roommates → leases (lease_id)
  RETURN QUERY
  SELECT 'roommates'::TEXT, 'lease_id'::TEXT, 'leases'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Colocataires dont le bail n''existe plus'::TEXT
  FROM roommates r
  WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = r.lease_id);

  -- roommates → profiles (profile_id)
  RETURN QUERY
  SELECT 'roommates'::TEXT, 'profile_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Colocataires dont le profil n''existe plus'::TEXT
  FROM roommates r
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = r.profile_id);

  -- ── PAYMENT_SHARES ────────────────────────────────────────────────
  -- payment_shares → roommates (roommate_id)
  RETURN QUERY
  SELECT 'payment_shares'::TEXT, 'roommate_id'::TEXT, 'roommates'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Parts de paiement dont le colocataire n''existe plus'::TEXT
  FROM payment_shares ps
  WHERE NOT EXISTS (SELECT 1 FROM roommates r WHERE r.id = ps.roommate_id);

  -- payment_shares → invoices (invoice_id)
  RETURN QUERY
  SELECT 'payment_shares'::TEXT, 'invoice_id'::TEXT, 'invoices'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Parts de paiement dont la facture n''existe plus'::TEXT
  FROM payment_shares ps
  WHERE ps.invoice_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM invoices i WHERE i.id = ps.invoice_id);

  -- ── DEPOSIT_SHARES ────────────────────────────────────────────────
  -- deposit_shares → roommates (roommate_id)
  RETURN QUERY
  SELECT 'deposit_shares'::TEXT, 'roommate_id'::TEXT, 'roommates'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Parts de dépôt dont le colocataire n''existe plus'::TEXT
  FROM deposit_shares ds
  WHERE NOT EXISTS (SELECT 1 FROM roommates r WHERE r.id = ds.roommate_id);

  -- ── DEPOSIT_MOVEMENTS ─────────────────────────────────────────────
  -- deposit_movements → leases (lease_id)
  RETURN QUERY
  SELECT 'deposit_movements'::TEXT, 'lease_id'::TEXT, 'leases'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Mouvements de dépôt dont le bail n''existe plus'::TEXT
  FROM deposit_movements dm
  WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = dm.lease_id);

  -- ── NOTIFICATIONS ─────────────────────────────────────────────────
  -- notifications → auth.users (user_id)
  RETURN QUERY
  SELECT 'notifications'::TEXT, 'user_id'::TEXT, 'auth.users'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Notifications dont l''utilisateur n''existe plus'::TEXT
  FROM notifications n
  WHERE NOT EXISTS (SELECT 1 FROM auth.users u WHERE u.id = n.user_id);

  -- ── SUBSCRIPTIONS ─────────────────────────────────────────────────
  -- subscriptions → profiles (user_id / owner_id)
  RETURN QUERY
  SELECT 'subscriptions'::TEXT, 'user_id'::TEXT, 'auth.users'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Abonnements dont l''utilisateur n''existe plus'::TEXT
  FROM subscriptions s
  WHERE NOT EXISTS (SELECT 1 FROM auth.users u WHERE u.id = s.user_id);

  -- ── OWNER_PROFILES ────────────────────────────────────────────────
  -- owner_profiles → profiles (profile_id)
  RETURN QUERY
  SELECT 'owner_profiles'::TEXT, 'profile_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Profils propriétaire dont le profil de base n''existe plus'::TEXT
  FROM owner_profiles op
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = op.profile_id);

  -- ── TENANT_PROFILES ───────────────────────────────────────────────
  -- tenant_profiles → profiles (profile_id)
  RETURN QUERY
  SELECT 'tenant_profiles'::TEXT, 'profile_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Profils locataire dont le profil de base n''existe plus'::TEXT
  FROM tenant_profiles tp
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = tp.profile_id);

  -- ── PROVIDER_PROFILES ─────────────────────────────────────────────
  -- provider_profiles → profiles (profile_id)
  RETURN QUERY
  SELECT 'provider_profiles'::TEXT, 'profile_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Profils prestataire dont le profil de base n''existe plus'::TEXT
  FROM provider_profiles pp
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = pp.profile_id);

  -- ── CONVERSATIONS ─────────────────────────────────────────────────
  -- conversations → profiles (owner_id)
  RETURN QUERY
  SELECT 'conversations'::TEXT, 'owner_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Conversations dont le profil owner n''existe plus'::TEXT
  FROM conversations c
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = c.owner_id);

  -- messages → conversations (conversation_id)
  RETURN QUERY
  SELECT 'messages'::TEXT, 'conversation_id'::TEXT, 'conversations'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Messages dont la conversation n''existe plus'::TEXT
  FROM messages m
  WHERE NOT EXISTS (SELECT 1 FROM conversations c WHERE c.id = m.conversation_id);

  -- ── UNIFIED CONVERSATIONS ─────────────────────────────────────────
  -- unified_messages → unified_conversations (conversation_id)
  RETURN QUERY
  SELECT 'unified_messages'::TEXT, 'conversation_id'::TEXT, 'unified_conversations'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Messages unifiés dont la conversation n''existe plus'::TEXT
  FROM unified_messages um
  WHERE NOT EXISTS (SELECT 1 FROM unified_conversations uc WHERE uc.id = um.conversation_id);

  -- ── SIGNATURE_SESSIONS ────────────────────────────────────────────
  -- signature_participants → signature_sessions (session_id)
  RETURN QUERY
  SELECT 'signature_participants'::TEXT, 'session_id'::TEXT, 'signature_sessions'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Participants de signature dont la session n''existe plus'::TEXT
  FROM signature_participants sp
  WHERE NOT EXISTS (SELECT 1 FROM signature_sessions ss WHERE ss.id = sp.session_id);

  -- signature_proofs → signature_participants (participant_id)
  RETURN QUERY
  SELECT 'signature_proofs'::TEXT, 'participant_id'::TEXT, 'signature_participants'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Preuves de signature dont le participant n''existe plus'::TEXT
  FROM signature_proofs sp
  WHERE NOT EXISTS (SELECT 1 FROM signature_participants pa WHERE pa.id = sp.participant_id);

  -- signature_audit_log → signature_sessions (session_id)
  RETURN QUERY
  SELECT 'signature_audit_log'::TEXT, 'session_id'::TEXT, 'signature_sessions'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Logs d''audit de signature dont la session n''existe plus'::TEXT
  FROM signature_audit_log sal
  WHERE NOT EXISTS (SELECT 1 FROM signature_sessions ss WHERE ss.id = sal.session_id);

  -- ── LEGAL_ENTITIES ────────────────────────────────────────────────
  -- legal_entities → profiles (owner_profile_id)
  RETURN QUERY
  SELECT 'legal_entities'::TEXT, 'owner_profile_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Entités légales dont le profil propriétaire n''existe plus'::TEXT
  FROM legal_entities le
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = le.owner_profile_id);

  -- entity_associates → legal_entities (legal_entity_id)
  RETURN QUERY
  SELECT 'entity_associates'::TEXT, 'legal_entity_id'::TEXT, 'legal_entities'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Associés dont l''entité légale n''existe plus'::TEXT
  FROM entity_associates ea
  WHERE NOT EXISTS (SELECT 1 FROM legal_entities le WHERE le.id = ea.legal_entity_id);

  -- ── PROPERTY_OWNERSHIP ────────────────────────────────────────────
  -- property_ownership → properties (property_id)
  RETURN QUERY
  SELECT 'property_ownership'::TEXT, 'property_id'::TEXT, 'properties'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Détentions de propriété dont le bien n''existe plus'::TEXT
  FROM property_ownership po
  WHERE NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = po.property_id);

  -- ── BUILDINGS ─────────────────────────────────────────────────────
  -- buildings → profiles (owner_id) — si la colonne existe
  RETURN QUERY
  SELECT 'buildings'::TEXT, 'owner_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Immeubles dont le propriétaire n''existe plus'::TEXT
  FROM buildings b
  WHERE b.owner_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = b.owner_id);

  -- building_units → buildings (building_id)
  RETURN QUERY
  SELECT 'building_units'::TEXT, 'building_id'::TEXT, 'buildings'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Lots d''immeuble dont l''immeuble n''existe plus'::TEXT
  FROM building_units bu
  WHERE NOT EXISTS (SELECT 1 FROM buildings b WHERE b.id = bu.building_id);

  -- ── LEASE_END_PROCESSES ───────────────────────────────────────────
  -- lease_end_processes → leases (lease_id)
  RETURN QUERY
  SELECT 'lease_end_processes'::TEXT, 'lease_id'::TEXT, 'leases'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Processus de fin de bail dont le bail n''existe plus'::TEXT
  FROM lease_end_processes lep
  WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = lep.lease_id);

  -- edl_inspection_items → lease_end_processes (lease_end_process_id)
  RETURN QUERY
  SELECT 'edl_inspection_items'::TEXT, 'lease_end_process_id'::TEXT, 'lease_end_processes'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Items d''inspection dont le processus de fin n''existe plus'::TEXT
  FROM edl_inspection_items eii
  WHERE NOT EXISTS (SELECT 1 FROM lease_end_processes lep WHERE lep.id = eii.lease_end_process_id);

  -- renovation_items → lease_end_processes (lease_end_process_id)
  RETURN QUERY
  SELECT 'renovation_items'::TEXT, 'lease_end_process_id'::TEXT, 'lease_end_processes'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Items de rénovation dont le processus de fin n''existe plus'::TEXT
  FROM renovation_items ri
  WHERE NOT EXISTS (SELECT 1 FROM lease_end_processes lep WHERE lep.id = ri.lease_end_process_id);

  -- renovation_quotes → renovation_items (renovation_item_id)
  RETURN QUERY
  SELECT 'renovation_quotes'::TEXT, 'renovation_item_id'::TEXT, 'renovation_items'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Devis de rénovation dont l''item de rénovation n''existe plus'::TEXT
  FROM renovation_quotes rq
  WHERE NOT EXISTS (SELECT 1 FROM renovation_items ri WHERE ri.id = rq.renovation_item_id);

  -- ── PHOTOS ────────────────────────────────────────────────────────
  -- photos → properties (property_id)
  RETURN QUERY
  SELECT 'photos'::TEXT, 'property_id'::TEXT, 'properties'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Photos dont la propriété n''existe plus'::TEXT
  FROM photos ph
  WHERE NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = ph.property_id);

  -- ── VISIT SCHEDULING ──────────────────────────────────────────────
  -- visit_slots → properties (property_id)
  RETURN QUERY
  SELECT 'visit_slots'::TEXT, 'property_id'::TEXT, 'properties'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Créneaux de visite dont la propriété n''existe plus'::TEXT
  FROM visit_slots vs
  WHERE NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = vs.property_id);

  -- visit_bookings → visit_slots (slot_id)
  RETURN QUERY
  SELECT 'visit_bookings'::TEXT, 'slot_id'::TEXT, 'visit_slots'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Réservations de visite dont le créneau n''existe plus'::TEXT
  FROM visit_bookings vb
  WHERE NOT EXISTS (SELECT 1 FROM visit_slots vs WHERE vs.id = vb.slot_id);

  -- ── QUOTES ────────────────────────────────────────────────────────
  -- quotes → tickets (ticket_id)
  RETURN QUERY
  SELECT 'quotes'::TEXT, 'ticket_id'::TEXT, 'tickets'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Devis dont le ticket n''existe plus'::TEXT
  FROM quotes q
  WHERE q.ticket_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM tickets t WHERE t.id = q.ticket_id);

  -- quotes → profiles (provider_id)
  RETURN QUERY
  SELECT 'quotes'::TEXT, 'provider_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Devis dont le prestataire n''existe plus'::TEXT
  FROM quotes q
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = q.provider_id);

  -- ── CONVERSATION_PARTICIPANTS ─────────────────────────────────────
  -- conversation_participants → unified_conversations (conversation_id)
  RETURN QUERY
  SELECT 'conversation_participants'::TEXT, 'conversation_id'::TEXT, 'unified_conversations'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Participants de conversation dont la conversation unifiée n''existe plus'::TEXT
  FROM conversation_participants cp
  WHERE NOT EXISTS (SELECT 1 FROM unified_conversations uc WHERE uc.id = cp.conversation_id);

  -- ── ORGANIZATION_BRANDING ─────────────────────────────────────────
  -- organization_branding → organizations (organization_id)
  RETURN QUERY
  SELECT 'organization_branding'::TEXT, 'organization_id'::TEXT, 'organizations'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Branding d''organisation dont l''organisation n''existe plus'::TEXT
  FROM organization_branding ob
  WHERE NOT EXISTS (SELECT 1 FROM organizations o WHERE o.id = ob.organization_id);

  -- ── PROVIDER_INVOICES ─────────────────────────────────────────────
  -- provider_invoices → profiles (provider_id)
  RETURN QUERY
  SELECT 'provider_invoices'::TEXT, 'provider_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Factures prestataire dont le profil prestataire n''existe plus'::TEXT
  FROM provider_invoices pi
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = pi.provider_id);

  -- ── PROVIDER_QUOTES ───────────────────────────────────────────────
  -- provider_quotes → profiles (provider_id)
  RETURN QUERY
  SELECT 'provider_quotes'::TEXT, 'provider_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Devis prestataire dont le profil prestataire n''existe plus'::TEXT
  FROM provider_quotes pq
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = pq.provider_id);

  -- ── SIGNATURES (legacy) ───────────────────────────────────────────
  -- signatures → leases (lease_id)
  RETURN QUERY
  SELECT 'signatures'::TEXT, 'lease_id'::TEXT, 'leases'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Signatures legacy dont le bail n''existe plus'::TEXT
  FROM signatures s
  WHERE s.lease_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = s.lease_id);

  -- signatures → profiles (signer_profile_id)
  RETURN QUERY
  SELECT 'signatures'::TEXT, 'signer_profile_id'::TEXT, 'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Signatures legacy dont le profil signataire n''existe plus'::TEXT
  FROM signatures s
  WHERE NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = s.signer_profile_id);

  -- Filter: only return rows where orphan_count > 0
  -- (handled by caller, but the function returns all checks for completeness)

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION audit_orphan_records() IS
  'Audit complet des enregistrements orphelins. Retourne toutes les relations cassées avec leur sévérité.';


-- ============================================================================
-- PHASE 2: FONCTIONS DE DÉTECTION DES DOUBLONS
-- ============================================================================

CREATE OR REPLACE FUNCTION audit_duplicate_records()
RETURNS TABLE(
  table_name TEXT,
  duplicate_key TEXT,
  duplicate_count BIGINT,
  severity TEXT,
  description TEXT,
  sample_ids TEXT
) AS $$
BEGIN

  -- ── PROFILES : même user_id (devrait être UNIQUE) ────────────────
  RETURN QUERY
  SELECT 'profiles'::TEXT,
    'user_id'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Comptes avec plusieurs profils pour le même auth.users'::TEXT,
    string_agg(p.id::TEXT, ', ' ORDER BY p.created_at)::TEXT
  FROM profiles p
  GROUP BY p.user_id
  HAVING COUNT(*) > 1;

  -- ── PROFILES : même email (doublons fonctionnels) ─────────────────
  RETURN QUERY
  SELECT 'profiles'::TEXT,
    'email=' || COALESCE(p.email, '(null)'),
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Profils avec le même email'::TEXT,
    string_agg(p.id::TEXT, ', ' ORDER BY p.created_at)::TEXT
  FROM profiles p
  WHERE p.email IS NOT NULL AND p.email != ''
  GROUP BY p.email
  HAVING COUNT(*) > 1;

  -- ── PROPERTIES : même adresse + même propriétaire ─────────────────
  RETURN QUERY
  SELECT 'properties'::TEXT,
    'owner_id+adresse=' || p.owner_id || '+' || LOWER(TRIM(p.adresse_complete)),
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Propriétés dupliquées (même propriétaire + même adresse)'::TEXT,
    string_agg(p.id::TEXT, ', ' ORDER BY p.created_at)::TEXT
  FROM properties p
  WHERE p.deleted_at IS NULL
  GROUP BY p.owner_id, LOWER(TRIM(p.adresse_complete))
  HAVING COUNT(*) > 1;

  -- ── PROPERTIES : même unique_code (devrait être impossible) ───────
  RETURN QUERY
  SELECT 'properties'::TEXT,
    'unique_code=' || p.unique_code,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Propriétés avec le même code unique (violation unicité)'::TEXT,
    string_agg(p.id::TEXT, ', ' ORDER BY p.created_at)::TEXT
  FROM properties p
  GROUP BY p.unique_code
  HAVING COUNT(*) > 1;

  -- ── LEASES : même property_id + dates qui se chevauchent ──────────
  RETURN QUERY
  SELECT 'leases'::TEXT,
    'property_id=' || l1.property_id || ' overlap_with=' || l2.id,
    2::BIGINT,
    'HIGH'::TEXT,
    'Baux actifs qui se chevauchent sur la même propriété'::TEXT,
    (l1.id::TEXT || ', ' || l2.id::TEXT)::TEXT
  FROM leases l1
  JOIN leases l2 ON l1.property_id = l2.property_id
    AND l1.id < l2.id
    AND l1.statut IN ('active', 'pending_signature', 'fully_signed')
    AND l2.statut IN ('active', 'pending_signature', 'fully_signed')
    AND l1.property_id IS NOT NULL
    AND l1.date_debut <= COALESCE(l2.date_fin, '9999-12-31'::DATE)
    AND l2.date_debut <= COALESCE(l1.date_fin, '9999-12-31'::DATE);

  -- ── INVOICES : même bail + même période ───────────────────────────
  RETURN QUERY
  SELECT 'invoices'::TEXT,
    'lease_id+periode=' || i.lease_id || '+' || i.periode,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Factures dupliquées pour le même bail et la même période'::TEXT,
    string_agg(i.id::TEXT, ', ' ORDER BY i.created_at)::TEXT
  FROM invoices i
  GROUP BY i.lease_id, i.periode
  HAVING COUNT(*) > 1;

  -- ── LEASE_SIGNERS : même bail + même profil ───────────────────────
  RETURN QUERY
  SELECT 'lease_signers'::TEXT,
    'lease_id+profile_id=' || ls.lease_id || '+' || ls.profile_id,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Signataires dupliqués sur le même bail'::TEXT,
    string_agg(ls.id::TEXT, ', ' ORDER BY ls.created_at)::TEXT
  FROM lease_signers ls
  WHERE ls.profile_id IS NOT NULL
  GROUP BY ls.lease_id, ls.profile_id
  HAVING COUNT(*) > 1;

  -- ── LEASE_SIGNERS : même bail + même invited_email ────────────────
  RETURN QUERY
  SELECT 'lease_signers'::TEXT,
    'lease_id+invited_email=' || ls.lease_id || '+' || ls.invited_email,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Signataires invités en double sur le même bail (même email)'::TEXT,
    string_agg(ls.id::TEXT, ', ' ORDER BY ls.created_at)::TEXT
  FROM lease_signers ls
  WHERE ls.invited_email IS NOT NULL AND ls.invited_email != ''
  GROUP BY ls.lease_id, ls.invited_email
  HAVING COUNT(*) > 1;

  -- ── DOCUMENTS : même storage_path ─────────────────────────────────
  RETURN QUERY
  SELECT 'documents'::TEXT,
    'storage_path=' || COALESCE(d.storage_path, d.url),
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Documents pointant vers le même fichier storage'::TEXT,
    string_agg(d.id::TEXT, ', ' ORDER BY d.created_at)::TEXT
  FROM documents d
  WHERE COALESCE(d.storage_path, d.url) IS NOT NULL
  GROUP BY COALESCE(d.storage_path, d.url)
  HAVING COUNT(*) > 1;

  -- ── OWNER_PROFILES : même profile_id (PK, mais vérifions) ────────
  RETURN QUERY
  SELECT 'owner_profiles'::TEXT,
    'profile_id=' || op.profile_id,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Profils propriétaire dupliqués pour le même profil'::TEXT,
    string_agg(op.profile_id::TEXT, ', ')::TEXT
  FROM owner_profiles op
  GROUP BY op.profile_id
  HAVING COUNT(*) > 1;

  -- ── SUBSCRIPTIONS : abonnements actifs multiples ──────────────────
  RETURN QUERY
  SELECT 'subscriptions'::TEXT,
    'user_id=' || s.user_id || ' (active)',
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Utilisateurs avec plusieurs abonnements actifs'::TEXT,
    string_agg(s.id::TEXT, ', ' ORDER BY s.created_at)::TEXT
  FROM subscriptions s
  WHERE s.status IN ('active', 'trialing')
  GROUP BY s.user_id
  HAVING COUNT(*) > 1;

  -- ── NOTIFICATIONS : doublons exacts ───────────────────────────────
  RETURN QUERY
  SELECT 'notifications'::TEXT,
    'user+type+title=' || n.user_id || '+' || n.type || '+' || n.title,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Notifications dupliquées (même user, type, titre, même minute)'::TEXT,
    string_agg(n.id::TEXT, ', ' ORDER BY n.created_at LIMIT 5)::TEXT
  FROM notifications n
  GROUP BY n.user_id, n.type, n.title, date_trunc('minute', n.created_at)
  HAVING COUNT(*) > 1;

  -- ── ROOMMATES : même bail + même profil ───────────────────────────
  RETURN QUERY
  SELECT 'roommates'::TEXT,
    'lease_id+profile_id=' || r.lease_id || '+' || r.profile_id,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Colocataires dupliqués sur le même bail'::TEXT,
    string_agg(r.id::TEXT, ', ' ORDER BY r.created_at)::TEXT
  FROM roommates r
  GROUP BY r.lease_id, r.profile_id
  HAVING COUNT(*) > 1;

  -- ── PHOTOS : même property + même storage_path ────────────────────
  RETURN QUERY
  SELECT 'photos'::TEXT,
    'property_id+storage_path=' || ph.property_id || '+' || COALESCE(ph.storage_path, ph.url),
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Photos dupliquées pour la même propriété'::TEXT,
    string_agg(ph.id::TEXT, ', ' ORDER BY ph.created_at)::TEXT
  FROM photos ph
  WHERE COALESCE(ph.storage_path, ph.url) IS NOT NULL
  GROUP BY ph.property_id, COALESCE(ph.storage_path, ph.url)
  HAVING COUNT(*) > 1;

  -- ── LEGAL_ENTITIES : même SIRET ───────────────────────────────────
  RETURN QUERY
  SELECT 'legal_entities'::TEXT,
    'siret=' || le.siret,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Entités légales avec le même SIRET'::TEXT,
    string_agg(le.id::TEXT, ', ' ORDER BY le.created_at)::TEXT
  FROM legal_entities le
  WHERE le.siret IS NOT NULL AND le.siret != ''
  GROUP BY le.siret
  HAVING COUNT(*) > 1;

  -- ── EDL : même bail + même type ───────────────────────────────────
  RETURN QUERY
  SELECT 'edl'::TEXT,
    'lease_id+type=' || e.lease_id || '+' || e.type,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'EDL dupliqués pour le même bail et le même type'::TEXT,
    string_agg(e.id::TEXT, ', ' ORDER BY e.created_at)::TEXT
  FROM edl e
  GROUP BY e.lease_id, e.type
  HAVING COUNT(*) > 1;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION audit_duplicate_records() IS
  'Audit complet des enregistrements dupliqués. Retourne tous les doublons détectés avec leur sévérité.';


-- ============================================================================
-- PHASE 3: DÉTECTION DES FK IMPLICITES (colonnes *_id sans contrainte)
-- ============================================================================

CREATE OR REPLACE FUNCTION audit_missing_fk_constraints()
RETURNS TABLE(
  table_name TEXT,
  column_name TEXT,
  expected_target TEXT,
  has_fk BOOLEAN,
  recommendation TEXT
) AS $$
BEGIN

  -- Lister toutes les colonnes finissant par _id dans le schéma public
  -- et vérifier si elles ont une contrainte FK
  RETURN QUERY
  WITH id_columns AS (
    SELECT
      c.table_name::TEXT AS tbl,
      c.column_name::TEXT AS col,
      CASE
        WHEN c.column_name LIKE '%profile_id%' THEN 'profiles'
        WHEN c.column_name LIKE '%owner_id%' THEN 'profiles'
        WHEN c.column_name LIKE '%tenant_id%' THEN 'profiles'
        WHEN c.column_name LIKE '%user_id%' THEN 'auth.users'
        WHEN c.column_name LIKE '%property_id%' THEN 'properties'
        WHEN c.column_name LIKE '%lease_id%' THEN 'leases'
        WHEN c.column_name LIKE '%unit_id%' THEN 'units'
        WHEN c.column_name LIKE '%invoice_id%' THEN 'invoices'
        WHEN c.column_name LIKE '%ticket_id%' THEN 'tickets'
        WHEN c.column_name LIKE '%building_id%' THEN 'buildings'
        WHEN c.column_name LIKE '%edl_id%' THEN 'edl'
        WHEN c.column_name LIKE '%meter_id%' THEN 'meters'
        WHEN c.column_name LIKE '%conversation_id%' THEN 'conversations/unified_conversations'
        WHEN c.column_name LIKE '%session_id%' THEN 'signature_sessions'
        WHEN c.column_name LIKE '%organization_id%' THEN 'organizations'
        WHEN c.column_name LIKE '%legal_entity_id%' THEN 'legal_entities'
        WHEN c.column_name LIKE '%roommate_id%' THEN 'roommates'
        WHEN c.column_name LIKE '%provider_id%' THEN 'profiles/provider_profiles'
        WHEN c.column_name LIKE '%document_id%' THEN 'documents'
        WHEN c.column_name LIKE '%quote_id%' THEN 'quotes'
        WHEN c.column_name LIKE '%work_order_id%' THEN 'work_orders'
        WHEN c.column_name LIKE '%application_id%' THEN 'tenant_applications'
        WHEN c.column_name LIKE '%participant_id%' THEN 'signature_participants'
        ELSE '(unknown)'
      END AS expected_target
    FROM information_schema.columns c
    WHERE c.table_schema = 'public'
      AND c.data_type IN ('uuid', 'text')
      AND (c.column_name LIKE '%_id' OR c.column_name LIKE '%_uuid')
      AND c.column_name != 'id'
      AND c.table_name NOT LIKE '_%' -- skip internal tables
  ),
  existing_fks AS (
    SELECT
      tc.table_name::TEXT AS tbl,
      kcu.column_name::TEXT AS col
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu
      ON tc.constraint_name = kcu.constraint_name
      AND tc.table_schema = kcu.table_schema
    WHERE tc.constraint_type = 'FOREIGN KEY'
      AND tc.table_schema = 'public'
  )
  SELECT
    ic.tbl,
    ic.col,
    ic.expected_target,
    EXISTS(SELECT 1 FROM existing_fks ef WHERE ef.tbl = ic.tbl AND ef.col = ic.col),
    CASE
      WHEN EXISTS(SELECT 1 FROM existing_fks ef WHERE ef.tbl = ic.tbl AND ef.col = ic.col)
        THEN 'FK existe — OK'
      ELSE 'MANQUANTE — Ajouter ALTER TABLE ' || ic.tbl || ' ADD CONSTRAINT fk_' || ic.tbl || '_' || ic.col || ' FOREIGN KEY (' || ic.col || ') REFERENCES ' || ic.expected_target || '(id)'
    END
  FROM id_columns ic
  WHERE ic.expected_target != '(unknown)'
  ORDER BY
    CASE WHEN EXISTS(SELECT 1 FROM existing_fks ef WHERE ef.tbl = ic.tbl AND ef.col = ic.col) THEN 1 ELSE 0 END,
    ic.tbl, ic.col;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION audit_missing_fk_constraints() IS
  'Détecte les colonnes *_id sans contrainte FK formelle (FK implicites).';


-- ============================================================================
-- PHASE 4: VUE CONSOLIDÉE DU TABLEAU DE BORD D'INTÉGRITÉ
-- ============================================================================

CREATE OR REPLACE VIEW audit_integrity_dashboard AS

-- Orphelins
SELECT
  'orphan' AS audit_type,
  source_table,
  fk_column AS detail_key,
  target_table AS detail_value,
  orphan_count AS count,
  severity,
  description
FROM audit_orphan_records()
WHERE orphan_count > 0

UNION ALL

-- Doublons
SELECT
  'duplicate' AS audit_type,
  table_name AS source_table,
  duplicate_key AS detail_key,
  sample_ids AS detail_value,
  duplicate_count AS count,
  severity,
  description
FROM audit_duplicate_records();

COMMENT ON VIEW audit_integrity_dashboard IS
  'Vue consolidée de tous les problèmes d''intégrité détectés (orphelins + doublons).';


-- ============================================================================
-- PHASE 5: FONCTIONS DE NETTOYAGE SAFE (avec backup préalable)
-- ============================================================================

-- 5.1 Table d'archivage pour les enregistrements nettoyés
CREATE TABLE IF NOT EXISTS _audit_cleanup_archive (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cleanup_batch_id UUID NOT NULL,
  source_table TEXT NOT NULL,
  source_id TEXT NOT NULL,
  fk_column TEXT,
  original_data JSONB NOT NULL,
  cleanup_reason TEXT NOT NULL,
  cleaned_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  cleaned_by TEXT DEFAULT current_user
);

CREATE INDEX IF NOT EXISTS idx_cleanup_archive_batch
  ON _audit_cleanup_archive(cleanup_batch_id);
CREATE INDEX IF NOT EXISTS idx_cleanup_archive_table
  ON _audit_cleanup_archive(source_table);
CREATE INDEX IF NOT EXISTS idx_cleanup_archive_date
  ON _audit_cleanup_archive(cleaned_at);

COMMENT ON TABLE _audit_cleanup_archive IS
  'Archive des enregistrements supprimés lors du nettoyage d''intégrité. Permet de restaurer si nécessaire.';

-- 5.2 Fonction de nettoyage SAFE avec archivage
CREATE OR REPLACE FUNCTION safe_cleanup_orphans(
  p_dry_run BOOLEAN DEFAULT TRUE,
  p_severity_filter TEXT DEFAULT 'ALL'
)
RETURNS TABLE(
  action TEXT,
  source_table TEXT,
  fk_column TEXT,
  records_affected BIGINT,
  detail TEXT
) AS $$
DECLARE
  v_batch_id UUID := gen_random_uuid();
  v_count BIGINT;
BEGIN

  -- Header
  action := 'INFO';
  source_table := '(batch)';
  fk_column := '';
  records_affected := 0;
  detail := 'Batch ID: ' || v_batch_id::TEXT || ' | Mode: ' || CASE WHEN p_dry_run THEN 'DRY RUN (aucune suppression)' ELSE 'EXECUTION RÉELLE' END;
  RETURN NEXT;

  -- ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  -- CRITICAL: lease_signers orphelins (bail supprimé)
  -- ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  IF p_severity_filter IN ('ALL', 'CRITICAL') THEN

    -- Archive + delete lease_signers sans bail
    IF NOT p_dry_run THEN
      INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
      SELECT v_batch_id, 'lease_signers', ls.id::TEXT, 'lease_id', to_jsonb(ls), 'Bail inexistant'
      FROM lease_signers ls
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = ls.lease_id);

      DELETE FROM lease_signers ls
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = ls.lease_id);
      GET DIAGNOSTICS v_count = ROW_COUNT;
    ELSE
      SELECT COUNT(*) INTO v_count
      FROM lease_signers ls
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = ls.lease_id);
    END IF;

    action := CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'DELETED' END;
    source_table := 'lease_signers';
    fk_column := 'lease_id → leases';
    records_affected := v_count;
    detail := 'Signataires dont le bail n''existe plus';
    RETURN NEXT;

    -- Archive + delete invoices sans bail
    IF NOT p_dry_run THEN
      INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
      SELECT v_batch_id, 'invoices', i.id::TEXT, 'lease_id', to_jsonb(i), 'Bail inexistant'
      FROM invoices i
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = i.lease_id);

      DELETE FROM invoices i
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = i.lease_id);
      GET DIAGNOSTICS v_count = ROW_COUNT;
    ELSE
      SELECT COUNT(*) INTO v_count
      FROM invoices i
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = i.lease_id);
    END IF;

    action := CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'DELETED' END;
    source_table := 'invoices';
    fk_column := 'lease_id → leases';
    records_affected := v_count;
    detail := 'Factures dont le bail n''existe plus';
    RETURN NEXT;

    -- Archive + delete payments sans invoice
    IF NOT p_dry_run THEN
      INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
      SELECT v_batch_id, 'payments', py.id::TEXT, 'invoice_id', to_jsonb(py), 'Facture inexistante'
      FROM payments py
      WHERE NOT EXISTS (SELECT 1 FROM invoices i WHERE i.id = py.invoice_id);

      DELETE FROM payments py
      WHERE NOT EXISTS (SELECT 1 FROM invoices i WHERE i.id = py.invoice_id);
      GET DIAGNOSTICS v_count = ROW_COUNT;
    ELSE
      SELECT COUNT(*) INTO v_count
      FROM payments py
      WHERE NOT EXISTS (SELECT 1 FROM invoices i WHERE i.id = py.invoice_id);
    END IF;

    action := CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'DELETED' END;
    source_table := 'payments';
    fk_column := 'invoice_id → invoices';
    records_affected := v_count;
    detail := 'Paiements dont la facture n''existe plus';
    RETURN NEXT;

  END IF;

  -- ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  -- HIGH: documents orphelins
  -- ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  IF p_severity_filter IN ('ALL', 'CRITICAL', 'HIGH') THEN

    -- Documents avec lease_id invalide → SET NULL (ne pas supprimer)
    IF NOT p_dry_run THEN
      INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
      SELECT v_batch_id, 'documents', d.id::TEXT, 'lease_id', jsonb_build_object('lease_id', d.lease_id), 'Bail inexistant — lease_id mis à NULL'
      FROM documents d
      WHERE d.lease_id IS NOT NULL
        AND NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = d.lease_id);

      UPDATE documents d
      SET lease_id = NULL
      WHERE d.lease_id IS NOT NULL
        AND NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = d.lease_id);
      GET DIAGNOSTICS v_count = ROW_COUNT;
    ELSE
      SELECT COUNT(*) INTO v_count
      FROM documents d
      WHERE d.lease_id IS NOT NULL
        AND NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = d.lease_id);
    END IF;

    action := CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'NULLIFIED' END;
    source_table := 'documents';
    fk_column := 'lease_id → leases';
    records_affected := v_count;
    detail := 'Documents: lease_id mis à NULL (bail inexistant)';
    RETURN NEXT;

    -- Documents avec property_id invalide → SET NULL
    IF NOT p_dry_run THEN
      INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
      SELECT v_batch_id, 'documents', d.id::TEXT, 'property_id', jsonb_build_object('property_id', d.property_id), 'Propriété inexistante — property_id mis à NULL'
      FROM documents d
      WHERE d.property_id IS NOT NULL
        AND NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = d.property_id);

      UPDATE documents d
      SET property_id = NULL
      WHERE d.property_id IS NOT NULL
        AND NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = d.property_id);
      GET DIAGNOSTICS v_count = ROW_COUNT;
    ELSE
      SELECT COUNT(*) INTO v_count
      FROM documents d
      WHERE d.property_id IS NOT NULL
        AND NOT EXISTS (SELECT 1 FROM properties p WHERE p.id = d.property_id);
    END IF;

    action := CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'NULLIFIED' END;
    source_table := 'documents';
    fk_column := 'property_id → properties';
    records_affected := v_count;
    detail := 'Documents: property_id mis à NULL (propriété inexistante)';
    RETURN NEXT;

    -- EDL orphelins (bail supprimé)
    IF NOT p_dry_run THEN
      -- D'abord archiver et supprimer les enfants des EDL orphelins
      WITH orphan_edls AS (
        SELECT e.id FROM edl e WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = e.lease_id)
      )
      INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
      SELECT v_batch_id, 'edl', e.id::TEXT, 'lease_id', to_jsonb(e), 'Bail inexistant'
      FROM edl e
      WHERE e.id IN (SELECT id FROM orphan_edls);

      DELETE FROM edl_items WHERE edl_id IN (SELECT e.id FROM edl e WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = e.lease_id));
      DELETE FROM edl_media WHERE edl_id IN (SELECT e.id FROM edl e WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = e.lease_id));
      DELETE FROM edl_signatures WHERE edl_id IN (SELECT e.id FROM edl e WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = e.lease_id));
      DELETE FROM edl_meter_readings WHERE edl_id IN (SELECT e.id FROM edl e WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = e.lease_id));
      DELETE FROM edl WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = edl.lease_id);
      GET DIAGNOSTICS v_count = ROW_COUNT;
    ELSE
      SELECT COUNT(*) INTO v_count
      FROM edl e WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = e.lease_id);
    END IF;

    action := CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'DELETED' END;
    source_table := 'edl (+ items, media, signatures)';
    fk_column := 'lease_id → leases';
    records_affected := v_count;
    detail := 'EDL orphelins supprimés en cascade';
    RETURN NEXT;

    -- Roommates orphelins (bail supprimé)
    IF NOT p_dry_run THEN
      INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
      SELECT v_batch_id, 'roommates', r.id::TEXT, 'lease_id', to_jsonb(r), 'Bail inexistant'
      FROM roommates r
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = r.lease_id);

      DELETE FROM roommates r
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = r.lease_id);
      GET DIAGNOSTICS v_count = ROW_COUNT;
    ELSE
      SELECT COUNT(*) INTO v_count
      FROM roommates r WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = r.lease_id);
    END IF;

    action := CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'DELETED' END;
    source_table := 'roommates';
    fk_column := 'lease_id → leases';
    records_affected := v_count;
    detail := 'Colocataires dont le bail n''existe plus';
    RETURN NEXT;

    -- Deposit_movements orphelins
    IF NOT p_dry_run THEN
      INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
      SELECT v_batch_id, 'deposit_movements', dm.id::TEXT, 'lease_id', to_jsonb(dm), 'Bail inexistant'
      FROM deposit_movements dm
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = dm.lease_id);

      DELETE FROM deposit_movements dm
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = dm.lease_id);
      GET DIAGNOSTICS v_count = ROW_COUNT;
    ELSE
      SELECT COUNT(*) INTO v_count
      FROM deposit_movements dm WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = dm.lease_id);
    END IF;

    action := CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'DELETED' END;
    source_table := 'deposit_movements';
    fk_column := 'lease_id → leases';
    records_affected := v_count;
    detail := 'Mouvements de dépôt dont le bail n''existe plus';
    RETURN NEXT;

    -- Meters orphelins
    IF NOT p_dry_run THEN
      INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
      SELECT v_batch_id, 'meters', m.id::TEXT, 'lease_id', to_jsonb(m), 'Bail inexistant'
      FROM meters m
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = m.lease_id);

      -- D'abord supprimer les readings des meters orphelins
      DELETE FROM meter_readings WHERE meter_id IN (
        SELECT m.id FROM meters m WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = m.lease_id)
      );
      DELETE FROM meters m
      WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = m.lease_id);
      GET DIAGNOSTICS v_count = ROW_COUNT;
    ELSE
      SELECT COUNT(*) INTO v_count
      FROM meters m WHERE NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = m.lease_id);
    END IF;

    action := CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'DELETED' END;
    source_table := 'meters (+ readings)';
    fk_column := 'lease_id → leases';
    records_affected := v_count;
    detail := 'Compteurs orphelins supprimés en cascade';
    RETURN NEXT;

    -- Tickets avec lease_id invalide → SET NULL (garder le ticket)
    IF NOT p_dry_run THEN
      UPDATE tickets t
      SET lease_id = NULL
      WHERE t.lease_id IS NOT NULL
        AND NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = t.lease_id);
      GET DIAGNOSTICS v_count = ROW_COUNT;
    ELSE
      SELECT COUNT(*) INTO v_count
      FROM tickets t
      WHERE t.lease_id IS NOT NULL
        AND NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = t.lease_id);
    END IF;

    action := CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'NULLIFIED' END;
    source_table := 'tickets';
    fk_column := 'lease_id → leases';
    records_affected := v_count;
    detail := 'Tickets: lease_id mis à NULL (bail inexistant)';
    RETURN NEXT;

  END IF;

  -- ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  -- LOW: Notifications obsolètes
  -- ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  IF p_severity_filter = 'ALL' THEN

    -- Notifications lues > 90 jours
    IF NOT p_dry_run THEN
      DELETE FROM notifications
      WHERE is_read = true
        AND created_at < NOW() - INTERVAL '90 days';
      GET DIAGNOSTICS v_count = ROW_COUNT;
    ELSE
      SELECT COUNT(*) INTO v_count
      FROM notifications
      WHERE is_read = true
        AND created_at < NOW() - INTERVAL '90 days';
    END IF;

    action := CASE WHEN p_dry_run THEN 'DRY_RUN' ELSE 'DELETED' END;
    source_table := 'notifications';
    fk_column := '(age > 90 days + read)';
    records_affected := v_count;
    detail := 'Notifications lues de plus de 90 jours';
    RETURN NEXT;

  END IF;

  -- Summary
  action := 'SUMMARY';
  source_table := '(all)';
  fk_column := '';
  records_affected := 0;
  detail := 'Nettoyage terminé. Batch: ' || v_batch_id::TEXT || ' — Consultez _audit_cleanup_archive pour restaurer.';
  RETURN NEXT;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION safe_cleanup_orphans(BOOLEAN, TEXT) IS
  'Nettoyage SAFE des orphelins avec archivage. Par défaut en DRY RUN. Usage: SELECT * FROM safe_cleanup_orphans(false) pour exécuter.';


-- ============================================================================
-- PHASE 6: FONCTION DE RESTAURATION (rollback d'un batch de nettoyage)
-- ============================================================================

CREATE OR REPLACE FUNCTION restore_cleanup_batch(p_batch_id UUID)
RETURNS TABLE(
  restored_table TEXT,
  restored_count BIGINT
) AS $$
DECLARE
  r RECORD;
  v_count BIGINT := 0;
BEGIN
  -- On ne peut restaurer que les lignes supprimées (pas les NULL-ifiées)
  -- Pour chaque table dans l'archive, on ré-insère les données
  FOR r IN
    SELECT DISTINCT a.source_table
    FROM _audit_cleanup_archive a
    WHERE a.cleanup_batch_id = p_batch_id
      AND a.cleanup_reason NOT LIKE '%mis à NULL%'
    ORDER BY a.source_table
  LOOP
    restored_table := r.source_table;

    -- Compter les enregistrements à restaurer
    SELECT COUNT(*) INTO v_count
    FROM _audit_cleanup_archive a
    WHERE a.cleanup_batch_id = p_batch_id
      AND a.source_table = r.source_table
      AND a.cleanup_reason NOT LIKE '%mis à NULL%';

    restored_count := v_count;
    RETURN NEXT;
  END LOOP;

  -- Note : la restauration réelle nécessite un INSERT dynamique
  -- qui doit être exécuté manuellement pour chaque table
  -- car la structure des colonnes diffère
  restored_table := '⚠️ IMPORTANT';
  restored_count := 0;
  RETURN NEXT;

  restored_table := 'Les données sont dans _audit_cleanup_archive.original_data (JSONB)';
  restored_count := 0;
  RETURN NEXT;

  restored_table := 'Utilisez: SELECT original_data FROM _audit_cleanup_archive WHERE cleanup_batch_id = ''' || p_batch_id::TEXT || '''';
  restored_count := 0;
  RETURN NEXT;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION restore_cleanup_batch(UUID) IS
  'Liste les enregistrements restaurables pour un batch de nettoyage donné.';


-- ============================================================================
-- LOGS DE MIGRATION
-- ============================================================================
DO $$
BEGIN
  RAISE NOTICE '══════════════════════════════════════════════════════════════';
  RAISE NOTICE '  AUDIT D''INTÉGRITÉ TALOK — Migration installée';
  RAISE NOTICE '══════════════════════════════════════════════════════════════';
  RAISE NOTICE '';
  RAISE NOTICE '  Fonctions disponibles :';
  RAISE NOTICE '    SELECT * FROM audit_orphan_records();';
  RAISE NOTICE '    SELECT * FROM audit_duplicate_records();';
  RAISE NOTICE '    SELECT * FROM audit_missing_fk_constraints();';
  RAISE NOTICE '    SELECT * FROM audit_integrity_dashboard;';
  RAISE NOTICE '';
  RAISE NOTICE '  Nettoyage (DRY RUN par défaut) :';
  RAISE NOTICE '    SELECT * FROM safe_cleanup_orphans(true);   -- prévisualiser';
  RAISE NOTICE '    SELECT * FROM safe_cleanup_orphans(false);  -- exécuter';
  RAISE NOTICE '';
  RAISE NOTICE '  Restauration :';
  RAISE NOTICE '    SELECT * FROM restore_cleanup_batch(''<batch_id>'');';
  RAISE NOTICE '══════════════════════════════════════════════════════════════';
END $$;

-- ========== 20260212000001_fix_guarantor_role_and_tables.sql ==========
-- ============================================
-- Migration: Ajouter le rôle guarantor + tables manquantes
-- Date: 2026-02-12
-- Description:
--   1. Ajouter 'guarantor' dans le CHECK constraint de profiles.role
--   2. Mettre à jour handle_new_user pour accepter 'guarantor'
--   3. Créer la table guarantor_profiles
--   4. Créer la table user_consents pour la conformité RGPD
--   5. Ajouter un CHECK constraint sur le champ telephone
-- ============================================

-- 1. Modifier le CHECK constraint de profiles.role pour inclure 'guarantor'
ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_role_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_role_check
  CHECK (role IN ('admin', 'owner', 'tenant', 'provider', 'guarantor'));

-- 2. Mettre à jour handle_new_user pour reconnaître 'guarantor'
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_role TEXT;
  v_prenom TEXT;
  v_nom TEXT;
  v_telephone TEXT;
BEGIN
  -- Lire le rôle depuis les metadata, avec fallback sur 'tenant'
  v_role := COALESCE(
    NEW.raw_user_meta_data->>'role',
    'tenant'
  );

  -- Valider le rôle (inclut désormais 'guarantor')
  IF v_role NOT IN ('admin', 'owner', 'tenant', 'provider', 'guarantor') THEN
    v_role := 'tenant';
  END IF;

  -- Lire les autres données depuis les metadata
  v_prenom := NEW.raw_user_meta_data->>'prenom';
  v_nom := NEW.raw_user_meta_data->>'nom';
  v_telephone := NEW.raw_user_meta_data->>'telephone';

  -- Insérer le profil avec toutes les données
  INSERT INTO public.profiles (user_id, role, prenom, nom, telephone)
  VALUES (NEW.id, v_role, v_prenom, v_nom, v_telephone)
  ON CONFLICT (user_id) DO UPDATE SET
    role = EXCLUDED.role,
    prenom = COALESCE(EXCLUDED.prenom, profiles.prenom),
    nom = COALESCE(EXCLUDED.nom, profiles.nom),
    telephone = COALESCE(EXCLUDED.telephone, profiles.telephone),
    updated_at = NOW();

  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.handle_new_user() IS
'Crée automatiquement un profil lors de la création d''un utilisateur.
Lit le rôle et les informations personnelles depuis les raw_user_meta_data.
Supporte les rôles: admin, owner, tenant, provider, guarantor.
Utilise ON CONFLICT pour gérer les cas où le profil existe déjà.';

-- 3. Créer la table guarantor_profiles
CREATE TABLE IF NOT EXISTS guarantor_profiles (
  profile_id UUID PRIMARY KEY REFERENCES profiles(id) ON DELETE CASCADE,
  type_garantie TEXT CHECK (type_garantie IN ('personnelle', 'visale', 'depot_bancaire')),
  revenus_mensuels DECIMAL(10, 2),
  date_naissance DATE,
  piece_identite_path TEXT,
  justificatif_revenus_path TEXT,
  visale_path TEXT,
  depot_bancaire_montant DECIMAL(10, 2),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS pour guarantor_profiles
ALTER TABLE guarantor_profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "guarantor_profiles_select_own" ON guarantor_profiles
  FOR SELECT USING (
    profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "guarantor_profiles_insert_own" ON guarantor_profiles
  FOR INSERT WITH CHECK (
    profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "guarantor_profiles_update_own" ON guarantor_profiles
  FOR UPDATE USING (
    profile_id IN (
      SELECT id FROM profiles WHERE user_id = auth.uid()
    )
  );

-- 4. Créer la table user_consents pour la conformité RGPD
CREATE TABLE IF NOT EXISTS user_consents (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  terms_accepted BOOLEAN NOT NULL DEFAULT false,
  terms_version TEXT NOT NULL,
  terms_accepted_at TIMESTAMPTZ,
  privacy_accepted BOOLEAN NOT NULL DEFAULT false,
  privacy_version TEXT NOT NULL,
  privacy_accepted_at TIMESTAMPTZ,
  cookies_necessary BOOLEAN NOT NULL DEFAULT true,
  cookies_analytics BOOLEAN NOT NULL DEFAULT false,
  cookies_ads BOOLEAN NOT NULL DEFAULT false,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_user_consents_user_id ON user_consents(user_id);

-- RLS pour user_consents
ALTER TABLE user_consents ENABLE ROW LEVEL SECURITY;

CREATE POLICY "user_consents_select_own" ON user_consents
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "user_consents_insert_own" ON user_consents
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY "user_consents_update_own" ON user_consents
  FOR UPDATE USING (user_id = auth.uid());

-- 5. Ajouter un CHECK constraint sur telephone (format E.164)
-- Le format E.164 commence par + suivi de 1 à 15 chiffres
ALTER TABLE profiles DROP CONSTRAINT IF EXISTS profiles_telephone_check;
ALTER TABLE profiles ADD CONSTRAINT profiles_telephone_check
  CHECK (telephone IS NULL OR telephone ~ '^\+[1-9]\d{1,14}$');

-- ========== 20260212100000_audit_v2_merge_and_prevention.sql ==========
-- ============================================================================
-- AUDIT D'INTÉGRITÉ V2 — FUSION, DRY RUN, ROLLBACK, PRÉVENTION
-- Date: 2026-02-12
-- Complète 20260212000000_audit_database_integrity.sql
-- ============================================================================
-- Ce script ajoute :
--   Phase 3 : Détection avancée des doublons (fuzzy, temporels)
--   Phase 4 : Fonctions de fusion SAFE (merge avec backup + rollback)
--   Phase 5 : Contraintes de prévention (FK, UNIQUE, triggers)
-- ============================================================================
-- PRÉREQUIS : 20260212000000_audit_database_integrity.sql déjà appliqué
-- ============================================================================


-- ============================================================================
-- INFRASTRUCTURE : Tables de support
-- ============================================================================

-- Table d'audit pour TOUTES les opérations de nettoyage
CREATE TABLE IF NOT EXISTS _audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  action TEXT NOT NULL,          -- MERGE, DELETE, NULLIFY, BACKUP, ROLLBACK
  table_name TEXT NOT NULL,
  old_id TEXT,
  new_id TEXT,
  details TEXT,
  affected_rows INTEGER DEFAULT 0,
  executed_by TEXT DEFAULT current_user,
  session_id TEXT DEFAULT current_setting('request.jwt.claim.sub', true),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_audit_log_table ON _audit_log(table_name);
CREATE INDEX IF NOT EXISTS idx_audit_log_action ON _audit_log(action);
CREATE INDEX IF NOT EXISTS idx_audit_log_date ON _audit_log(created_at);

COMMENT ON TABLE _audit_log IS 'Journal d''audit de toutes les opérations de nettoyage/fusion de données.';


-- ============================================================================
-- PHASE 3 : DÉTECTION AVANCÉE DES DOUBLONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 3.1 Doublons de propriétés (adresse normalisée + code_postal + ville)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION audit_duplicate_properties()
RETURNS TABLE(
  duplicate_key TEXT,
  nb_doublons BIGINT,
  ids UUID[],
  owner_ids UUID[],
  premier_cree TIMESTAMPTZ,
  dernier_cree TIMESTAMPTZ,
  match_type TEXT
) AS $$
BEGIN
  -- Doublons exacts : même adresse normalisée + CP + ville + même owner
  RETURN QUERY
  SELECT
    ('exact:' || p.owner_id || ':' || LOWER(TRIM(p.adresse_complete)) || ':' || p.code_postal)::TEXT,
    COUNT(*)::BIGINT,
    ARRAY_AGG(p.id ORDER BY p.created_at ASC),
    ARRAY_AGG(DISTINCT p.owner_id),
    MIN(p.created_at),
    MAX(p.created_at),
    'EXACT'::TEXT
  FROM properties p
  WHERE p.deleted_at IS NULL
  GROUP BY p.owner_id, LOWER(TRIM(p.adresse_complete)), p.code_postal
  HAVING COUNT(*) > 1;

  -- Doublons temporels : même owner, créés à < 5 min d'intervalle
  RETURN QUERY
  SELECT
    ('temporal:' || p1.owner_id || ':' || p1.id || ':' || p2.id)::TEXT,
    2::BIGINT,
    ARRAY[p1.id, p2.id],
    ARRAY[p1.owner_id],
    LEAST(p1.created_at, p2.created_at),
    GREATEST(p1.created_at, p2.created_at),
    'TEMPORAL (<5min)'::TEXT
  FROM properties p1
  JOIN properties p2 ON p1.owner_id = p2.owner_id
    AND p1.id < p2.id
    AND p1.deleted_at IS NULL AND p2.deleted_at IS NULL
    AND ABS(EXTRACT(EPOCH FROM (p1.created_at - p2.created_at))) < 300
    AND LOWER(TRIM(p1.ville)) = LOWER(TRIM(p2.ville))
    AND p1.code_postal = p2.code_postal;

  -- Doublons flous : même CP + ville, adresses très similaires (même owner)
  RETURN QUERY
  SELECT
    ('fuzzy:' || p1.owner_id || ':' || p1.id || ':' || p2.id)::TEXT,
    2::BIGINT,
    ARRAY[p1.id, p2.id],
    ARRAY[p1.owner_id],
    LEAST(p1.created_at, p2.created_at),
    GREATEST(p1.created_at, p2.created_at),
    'FUZZY (même CP+ville, type identique)'::TEXT
  FROM properties p1
  JOIN properties p2 ON p1.owner_id = p2.owner_id
    AND p1.id < p2.id
    AND p1.deleted_at IS NULL AND p2.deleted_at IS NULL
    AND p1.code_postal = p2.code_postal
    AND LOWER(TRIM(p1.ville)) = LOWER(TRIM(p2.ville))
    AND p1.type = p2.type
    AND p1.surface = p2.surface
    AND p1.nb_pieces = p2.nb_pieces
    -- Exclure les paires déjà capturées en exact
    AND LOWER(TRIM(p1.adresse_complete)) != LOWER(TRIM(p2.adresse_complete));
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ----------------------------------------------------------------------------
-- 3.2 Doublons de profils/contacts (email OU nom+prénom+date_naissance)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION audit_duplicate_profiles()
RETURNS TABLE(
  duplicate_key TEXT,
  nb_doublons BIGINT,
  ids UUID[],
  emails TEXT[],
  roles TEXT[],
  premier_cree TIMESTAMPTZ,
  dernier_cree TIMESTAMPTZ,
  match_type TEXT
) AS $$
BEGIN
  -- Doublons par email (même email dans profiles)
  RETURN QUERY
  SELECT
    ('email:' || LOWER(TRIM(p.email)))::TEXT,
    COUNT(*)::BIGINT,
    ARRAY_AGG(p.id ORDER BY p.created_at ASC),
    ARRAY_AGG(DISTINCT p.email),
    ARRAY_AGG(DISTINCT p.role),
    MIN(p.created_at),
    MAX(p.created_at),
    'EMAIL_EXACT'::TEXT
  FROM profiles p
  WHERE p.email IS NOT NULL AND TRIM(p.email) != ''
  GROUP BY LOWER(TRIM(p.email))
  HAVING COUNT(*) > 1;

  -- Doublons par nom+prénom+date_naissance
  RETURN QUERY
  SELECT
    ('identity:' || LOWER(TRIM(COALESCE(p.nom,''))) || ':' || LOWER(TRIM(COALESCE(p.prenom,''))) || ':' || COALESCE(p.date_naissance::TEXT,''))::TEXT,
    COUNT(*)::BIGINT,
    ARRAY_AGG(p.id ORDER BY p.created_at ASC),
    ARRAY_AGG(p.email),
    ARRAY_AGG(DISTINCT p.role),
    MIN(p.created_at),
    MAX(p.created_at),
    'IDENTITY (nom+prénom+naissance)'::TEXT
  FROM profiles p
  WHERE p.nom IS NOT NULL AND p.prenom IS NOT NULL AND p.date_naissance IS NOT NULL
    AND TRIM(p.nom) != '' AND TRIM(p.prenom) != ''
  GROUP BY LOWER(TRIM(p.nom)), LOWER(TRIM(p.prenom)), p.date_naissance
  HAVING COUNT(*) > 1;

  -- Doublons user_id (critique : même auth.users → 2+ profiles)
  RETURN QUERY
  SELECT
    ('user_id:' || p.user_id)::TEXT,
    COUNT(*)::BIGINT,
    ARRAY_AGG(p.id ORDER BY p.created_at ASC),
    ARRAY_AGG(p.email),
    ARRAY_AGG(DISTINCT p.role),
    MIN(p.created_at),
    MAX(p.created_at),
    'CRITICAL: même user_id'::TEXT
  FROM profiles p
  GROUP BY p.user_id
  HAVING COUNT(*) > 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ----------------------------------------------------------------------------
-- 3.3 Doublons de baux (property_id + tenant_id + date_debut ±7j)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION audit_duplicate_leases()
RETURNS TABLE(
  duplicate_key TEXT,
  nb_doublons BIGINT,
  ids UUID[],
  statuts TEXT[],
  premier_cree TIMESTAMPTZ,
  dernier_cree TIMESTAMPTZ,
  match_type TEXT
) AS $$
BEGIN
  -- Doublons exacts : même property + même période
  RETURN QUERY
  SELECT
    ('exact:' || l.property_id || ':' || l.date_debut)::TEXT,
    COUNT(*)::BIGINT,
    ARRAY_AGG(l.id ORDER BY l.created_at ASC),
    ARRAY_AGG(l.statut),
    MIN(l.created_at),
    MAX(l.created_at),
    'EXACT (même property+date_debut)'::TEXT
  FROM leases l
  WHERE l.property_id IS NOT NULL
    AND l.statut NOT IN ('cancelled', 'archived')
  GROUP BY l.property_id, l.date_debut
  HAVING COUNT(*) > 1;

  -- Doublons temporels : même property, dates proches (±7 jours), même type
  RETURN QUERY
  SELECT
    ('temporal:' || l1.id || ':' || l2.id)::TEXT,
    2::BIGINT,
    ARRAY[l1.id, l2.id],
    ARRAY[l1.statut, l2.statut],
    LEAST(l1.created_at, l2.created_at),
    GREATEST(l1.created_at, l2.created_at),
    'TEMPORAL (même property, date ±7j)'::TEXT
  FROM leases l1
  JOIN leases l2 ON l1.property_id = l2.property_id
    AND l1.id < l2.id
    AND l1.property_id IS NOT NULL
    AND l1.type_bail = l2.type_bail
    AND l1.statut NOT IN ('cancelled', 'archived')
    AND l2.statut NOT IN ('cancelled', 'archived')
    AND ABS(l1.date_debut - l2.date_debut) <= 7;

  -- Baux actifs chevauchants sur même propriété
  RETURN QUERY
  SELECT
    ('overlap:' || l1.property_id || ':' || l1.id || ':' || l2.id)::TEXT,
    2::BIGINT,
    ARRAY[l1.id, l2.id],
    ARRAY[l1.statut, l2.statut],
    LEAST(l1.created_at, l2.created_at),
    GREATEST(l1.created_at, l2.created_at),
    'OVERLAP (baux actifs chevauchants)'::TEXT
  FROM leases l1
  JOIN leases l2 ON l1.property_id = l2.property_id
    AND l1.id < l2.id
    AND l1.property_id IS NOT NULL
    AND l1.statut IN ('active', 'pending_signature', 'fully_signed')
    AND l2.statut IN ('active', 'pending_signature', 'fully_signed')
    AND l1.date_debut <= COALESCE(l2.date_fin, '9999-12-31'::DATE)
    AND l2.date_debut <= COALESCE(l1.date_fin, '9999-12-31'::DATE);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ----------------------------------------------------------------------------
-- 3.4 Doublons de documents (nom + entité + created_at ±1min)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION audit_duplicate_documents()
RETURNS TABLE(
  duplicate_key TEXT,
  nb_doublons BIGINT,
  ids UUID[],
  premier_cree TIMESTAMPTZ,
  dernier_cree TIMESTAMPTZ,
  match_type TEXT
) AS $$
BEGIN
  -- Doublons par storage_path (même fichier physique)
  RETURN QUERY
  SELECT
    ('storage:' || COALESCE(d.storage_path, d.url))::TEXT,
    COUNT(*)::BIGINT,
    ARRAY_AGG(d.id ORDER BY d.created_at ASC),
    MIN(d.created_at),
    MAX(d.created_at),
    'STORAGE_PATH identique'::TEXT
  FROM documents d
  WHERE COALESCE(d.storage_path, d.url) IS NOT NULL
  GROUP BY COALESCE(d.storage_path, d.url)
  HAVING COUNT(*) > 1;

  -- Doublons temporels par entité (même type + même parent + <1 min)
  RETURN QUERY
  SELECT
    ('temporal:' || d1.id || ':' || d2.id)::TEXT,
    2::BIGINT,
    ARRAY[d1.id, d2.id],
    LEAST(d1.created_at, d2.created_at),
    GREATEST(d1.created_at, d2.created_at),
    'TEMPORAL (<1min, même type+parent)'::TEXT
  FROM documents d1
  JOIN documents d2 ON d1.id < d2.id
    AND d1.type = d2.type
    AND COALESCE(d1.lease_id, '00000000-0000-0000-0000-000000000000'::UUID) = COALESCE(d2.lease_id, '00000000-0000-0000-0000-000000000000'::UUID)
    AND COALESCE(d1.property_id, '00000000-0000-0000-0000-000000000000'::UUID) = COALESCE(d2.property_id, '00000000-0000-0000-0000-000000000000'::UUID)
    AND ABS(EXTRACT(EPOCH FROM (d1.created_at - d2.created_at))) < 60;

  -- Doublons par nom de fichier + entité
  RETURN QUERY
  SELECT
    ('name:' || LOWER(TRIM(COALESCE(d.nom, d.nom_fichier, ''))) || ':' || COALESCE(d.lease_id::TEXT, d.property_id::TEXT, 'none'))::TEXT,
    COUNT(*)::BIGINT,
    ARRAY_AGG(d.id ORDER BY d.created_at ASC),
    MIN(d.created_at),
    MAX(d.created_at),
    'NOM_FICHIER identique (même entité)'::TEXT
  FROM documents d
  WHERE COALESCE(d.nom, d.nom_fichier) IS NOT NULL
    AND TRIM(COALESCE(d.nom, d.nom_fichier, '')) != ''
  GROUP BY LOWER(TRIM(COALESCE(d.nom, d.nom_fichier, ''))), COALESCE(d.lease_id::TEXT, d.property_id::TEXT, 'none')
  HAVING COUNT(*) > 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ----------------------------------------------------------------------------
-- 3.5 Doublons de paiements (montant + invoice_id + date ±1j)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION audit_duplicate_payments()
RETURNS TABLE(
  duplicate_key TEXT,
  nb_doublons BIGINT,
  ids UUID[],
  montants NUMERIC[],
  premier_cree TIMESTAMPTZ,
  dernier_cree TIMESTAMPTZ,
  match_type TEXT
) AS $$
BEGIN
  -- Doublons exacts : même invoice + même montant
  RETURN QUERY
  SELECT
    ('exact:' || py.invoice_id || ':' || py.montant)::TEXT,
    COUNT(*)::BIGINT,
    ARRAY_AGG(py.id ORDER BY py.created_at ASC),
    ARRAY_AGG(py.montant),
    MIN(py.created_at),
    MAX(py.created_at),
    'EXACT (même invoice+montant)'::TEXT
  FROM payments py
  GROUP BY py.invoice_id, py.montant
  HAVING COUNT(*) > 1;

  -- Doublons temporels : même invoice, même montant, < 1 jour
  RETURN QUERY
  SELECT
    ('temporal:' || p1.id || ':' || p2.id)::TEXT,
    2::BIGINT,
    ARRAY[p1.id, p2.id],
    ARRAY[p1.montant, p2.montant],
    LEAST(p1.created_at, p2.created_at),
    GREATEST(p1.created_at, p2.created_at),
    'TEMPORAL (<24h, même invoice+montant)'::TEXT
  FROM payments p1
  JOIN payments p2 ON p1.invoice_id = p2.invoice_id
    AND p1.id < p2.id
    AND p1.montant = p2.montant
    AND ABS(EXTRACT(EPOCH FROM (p1.created_at - p2.created_at))) < 86400;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ----------------------------------------------------------------------------
-- 3.6 Doublons d'EDL (lease_id + type + date ±1j)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION audit_duplicate_edl()
RETURNS TABLE(
  duplicate_key TEXT,
  nb_doublons BIGINT,
  ids UUID[],
  statuts TEXT[],
  premier_cree TIMESTAMPTZ,
  dernier_cree TIMESTAMPTZ,
  match_type TEXT
) AS $$
BEGIN
  -- Doublons exacts : même bail + même type
  RETURN QUERY
  SELECT
    ('exact:' || e.lease_id || ':' || e.type)::TEXT,
    COUNT(*)::BIGINT,
    ARRAY_AGG(e.id ORDER BY e.created_at ASC),
    ARRAY_AGG(e.status),
    MIN(e.created_at),
    MAX(e.created_at),
    'EXACT (même bail+type)'::TEXT
  FROM edl e
  GROUP BY e.lease_id, e.type
  HAVING COUNT(*) > 1;

  -- Doublons temporels
  RETURN QUERY
  SELECT
    ('temporal:' || e1.id || ':' || e2.id)::TEXT,
    2::BIGINT,
    ARRAY[e1.id, e2.id],
    ARRAY[e1.status, e2.status],
    LEAST(e1.created_at, e2.created_at),
    GREATEST(e1.created_at, e2.created_at),
    'TEMPORAL (<24h, même bail+type)'::TEXT
  FROM edl e1
  JOIN edl e2 ON e1.lease_id = e2.lease_id
    AND e1.type = e2.type
    AND e1.id < e2.id
    AND ABS(EXTRACT(EPOCH FROM (e1.created_at - e2.created_at))) < 86400;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ----------------------------------------------------------------------------
-- 3.7 Doublons de factures (lease_id + periode)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION audit_duplicate_invoices()
RETURNS TABLE(
  duplicate_key TEXT,
  nb_doublons BIGINT,
  ids UUID[],
  montants NUMERIC[],
  statuts TEXT[],
  premier_cree TIMESTAMPTZ,
  dernier_cree TIMESTAMPTZ,
  match_type TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    ('exact:' || i.lease_id || ':' || i.periode)::TEXT,
    COUNT(*)::BIGINT,
    ARRAY_AGG(i.id ORDER BY i.created_at ASC),
    ARRAY_AGG(i.montant_total),
    ARRAY_AGG(i.statut),
    MIN(i.created_at),
    MAX(i.created_at),
    'EXACT (même bail+période)'::TEXT
  FROM invoices i
  GROUP BY i.lease_id, i.periode
  HAVING COUNT(*) > 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ----------------------------------------------------------------------------
-- 3.8 Rapport consolidé de tous les doublons
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION audit_all_duplicates_summary()
RETURNS TABLE(
  entity TEXT,
  match_type TEXT,
  duplicate_groups BIGINT,
  total_excess_records BIGINT,
  severity TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 'properties'::TEXT, dp.match_type, COUNT(*)::BIGINT,
    SUM(dp.nb_doublons - 1)::BIGINT, 'HIGH'::TEXT
  FROM audit_duplicate_properties() dp
  GROUP BY dp.match_type;

  RETURN QUERY
  SELECT 'profiles'::TEXT, dp.match_type, COUNT(*)::BIGINT,
    SUM(dp.nb_doublons - 1)::BIGINT,
    CASE WHEN dp.match_type LIKE '%user_id%' THEN 'CRITICAL' ELSE 'HIGH' END::TEXT
  FROM audit_duplicate_profiles() dp
  GROUP BY dp.match_type;

  RETURN QUERY
  SELECT 'leases'::TEXT, dl.match_type, COUNT(*)::BIGINT,
    SUM(dl.nb_doublons - 1)::BIGINT,
    CASE WHEN dl.match_type LIKE '%OVERLAP%' THEN 'CRITICAL' ELSE 'HIGH' END::TEXT
  FROM audit_duplicate_leases() dl
  GROUP BY dl.match_type;

  RETURN QUERY
  SELECT 'documents'::TEXT, dd.match_type, COUNT(*)::BIGINT,
    SUM(dd.nb_doublons - 1)::BIGINT, 'MEDIUM'::TEXT
  FROM audit_duplicate_documents() dd
  GROUP BY dd.match_type;

  RETURN QUERY
  SELECT 'payments'::TEXT, dp.match_type, COUNT(*)::BIGINT,
    SUM(dp.nb_doublons - 1)::BIGINT, 'CRITICAL'::TEXT
  FROM audit_duplicate_payments() dp
  GROUP BY dp.match_type;

  RETURN QUERY
  SELECT 'edl'::TEXT, de.match_type, COUNT(*)::BIGINT,
    SUM(de.nb_doublons - 1)::BIGINT, 'MEDIUM'::TEXT
  FROM audit_duplicate_edl() de
  GROUP BY de.match_type;

  RETURN QUERY
  SELECT 'invoices'::TEXT, di.match_type, COUNT(*)::BIGINT,
    SUM(di.nb_doublons - 1)::BIGINT, 'CRITICAL'::TEXT
  FROM audit_duplicate_invoices() di
  GROUP BY di.match_type;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- ============================================================================
-- PHASE 4 : FONCTIONS DE FUSION SAFE (MERGE)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 4.1 Fusion générique : élit un master, transfère les enfants, supprime
-- ----------------------------------------------------------------------------

-- Helper : compter les champs non-null d'un enregistrement
CREATE OR REPLACE FUNCTION _count_non_null_fields(p_table TEXT, p_id UUID)
RETURNS INTEGER AS $$
DECLARE
  v_count INTEGER;
BEGIN
  EXECUTE format(
    'SELECT COUNT(*) FROM (
       SELECT unnest(ARRAY[%s]) AS val
     ) sub WHERE val IS NOT NULL',
    (SELECT string_agg(quote_ident(column_name) || '::TEXT', ', ')
     FROM information_schema.columns
     WHERE table_schema = 'public' AND table_name = p_table)
  ) USING p_id INTO v_count;
  RETURN v_count;
EXCEPTION WHEN OTHERS THEN
  RETURN 0;
END;
$$ LANGUAGE plpgsql;

-- 4.2 Merge de propriétés
CREATE OR REPLACE FUNCTION merge_duplicate_properties(
  p_master_id UUID,
  p_duplicate_id UUID,
  p_dry_run BOOLEAN DEFAULT TRUE
)
RETURNS TABLE(step TEXT, detail TEXT, affected_rows INTEGER) AS $$
DECLARE
  v_count INTEGER;
BEGIN
  -- Validation
  IF p_master_id = p_duplicate_id THEN
    step := 'ERROR'; detail := 'master_id et duplicate_id sont identiques'; affected_rows := 0;
    RETURN NEXT; RETURN;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM properties WHERE id = p_master_id) THEN
    step := 'ERROR'; detail := 'master_id introuvable'; affected_rows := 0;
    RETURN NEXT; RETURN;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM properties WHERE id = p_duplicate_id) THEN
    step := 'ERROR'; detail := 'duplicate_id introuvable'; affected_rows := 0;
    RETURN NEXT; RETURN;
  END IF;

  -- 1. Backup
  IF NOT p_dry_run THEN
    INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
    SELECT gen_random_uuid(), 'properties', p_duplicate_id::TEXT, 'MERGE', to_jsonb(p), 'Fusion vers ' || p_master_id
    FROM properties p WHERE id = p_duplicate_id;
  END IF;
  step := '1.BACKUP'; detail := 'Backup du doublon dans _audit_cleanup_archive'; affected_rows := 1;
  RETURN NEXT;

  -- 2. Transfert : leases
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM leases WHERE property_id = p_duplicate_id;
  ELSE
    UPDATE leases SET property_id = p_master_id WHERE property_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'leases.property_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 3. Transfert : units
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM units WHERE property_id = p_duplicate_id;
  ELSE
    UPDATE units SET property_id = p_master_id WHERE property_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'units.property_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 4. Transfert : charges
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM charges WHERE property_id = p_duplicate_id;
  ELSE
    UPDATE charges SET property_id = p_master_id WHERE property_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'charges.property_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 5. Transfert : documents
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM documents WHERE property_id = p_duplicate_id;
  ELSE
    UPDATE documents SET property_id = p_master_id WHERE property_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'documents.property_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 6. Transfert : tickets
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM tickets WHERE property_id = p_duplicate_id;
  ELSE
    UPDATE tickets SET property_id = p_master_id WHERE property_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'tickets.property_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 7. Transfert : photos
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM photos WHERE property_id = p_duplicate_id;
  ELSE
    UPDATE photos SET property_id = p_master_id WHERE property_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'photos.property_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 8. Transfert : visit_slots
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM visit_slots WHERE property_id = p_duplicate_id;
  ELSE
    UPDATE visit_slots SET property_id = p_master_id WHERE property_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'visit_slots.property_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 9. Transfert : property_ownership
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM property_ownership WHERE property_id = p_duplicate_id;
  ELSE
    UPDATE property_ownership SET property_id = p_master_id WHERE property_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'property_ownership.property_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 10. Transfert : conversations
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM conversations WHERE property_id = p_duplicate_id;
  ELSE
    UPDATE conversations SET property_id = p_master_id WHERE property_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'conversations.property_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 11. Enrichir le master avec les champs manquants du doublon
  IF NOT p_dry_run THEN
    UPDATE properties SET
      cover_url = COALESCE(properties.cover_url, dup.cover_url),
      loyer_reference = COALESCE(properties.loyer_reference, dup.loyer_reference),
      loyer_base = COALESCE(properties.loyer_base, dup.loyer_base),
      charges_mensuelles = COALESCE(properties.charges_mensuelles, dup.charges_mensuelles),
      depot_garantie = COALESCE(properties.depot_garantie, dup.depot_garantie),
      dpe_classe_energie = COALESCE(properties.dpe_classe_energie, dup.dpe_classe_energie),
      dpe_classe_climat = COALESCE(properties.dpe_classe_climat, dup.dpe_classe_climat),
      visite_virtuelle_url = COALESCE(properties.visite_virtuelle_url, dup.visite_virtuelle_url),
      latitude = COALESCE(properties.latitude, dup.latitude),
      longitude = COALESCE(properties.longitude, dup.longitude)
    FROM properties dup
    WHERE properties.id = p_master_id AND dup.id = p_duplicate_id;
  END IF;
  step := '3.ENRICH'; detail := 'Champs manquants copiés vers master'; affected_rows := 1;
  RETURN NEXT;

  -- 12. Suppression (soft-delete si colonne existe, sinon hard delete)
  IF NOT p_dry_run THEN
    UPDATE properties SET deleted_at = NOW() WHERE id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;

    INSERT INTO _audit_log (action, table_name, old_id, new_id, details)
    VALUES ('MERGE', 'properties', p_duplicate_id::TEXT, p_master_id::TEXT,
            'Fusion propriété doublon → master');
  ELSE
    v_count := 1;
  END IF;
  step := '4.DELETE'; detail := 'Soft-delete du doublon (deleted_at = NOW())'; affected_rows := v_count;
  RETURN NEXT;

  step := 'DONE';
  detail := CASE WHEN p_dry_run THEN '🔍 DRY RUN terminé — aucune modification' ELSE '✅ Fusion exécutée' END;
  affected_rows := 0;
  RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4.3 Merge de factures dupliquées
CREATE OR REPLACE FUNCTION merge_duplicate_invoices(
  p_master_id UUID,
  p_duplicate_id UUID,
  p_dry_run BOOLEAN DEFAULT TRUE
)
RETURNS TABLE(step TEXT, detail TEXT, affected_rows INTEGER) AS $$
DECLARE
  v_count INTEGER;
BEGIN
  IF p_master_id = p_duplicate_id THEN
    step := 'ERROR'; detail := 'IDs identiques'; affected_rows := 0;
    RETURN NEXT; RETURN;
  END IF;

  -- 1. Backup
  IF NOT p_dry_run THEN
    INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
    SELECT gen_random_uuid(), 'invoices', p_duplicate_id::TEXT, 'MERGE', to_jsonb(i), 'Fusion vers ' || p_master_id
    FROM invoices i WHERE id = p_duplicate_id;
  END IF;
  step := '1.BACKUP'; detail := 'Backup du doublon'; affected_rows := 1;
  RETURN NEXT;

  -- 2. Transfert des paiements
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM payments WHERE invoice_id = p_duplicate_id;
  ELSE
    UPDATE payments SET invoice_id = p_master_id WHERE invoice_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'payments.invoice_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 3. Transfert des payment_shares
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM payment_shares WHERE invoice_id = p_duplicate_id;
  ELSE
    UPDATE payment_shares SET invoice_id = p_master_id WHERE invoice_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'payment_shares.invoice_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 4. Suppression
  IF NOT p_dry_run THEN
    DELETE FROM invoices WHERE id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
    INSERT INTO _audit_log (action, table_name, old_id, new_id, details)
    VALUES ('MERGE', 'invoices', p_duplicate_id::TEXT, p_master_id::TEXT, 'Fusion facture doublon');
  ELSE
    v_count := 1;
  END IF;
  step := '3.DELETE'; detail := 'Suppression du doublon'; affected_rows := v_count;
  RETURN NEXT;

  step := 'DONE';
  detail := CASE WHEN p_dry_run THEN '🔍 DRY RUN' ELSE '✅ Fusion exécutée' END;
  affected_rows := 0;
  RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4.4 Merge de documents dupliqués
CREATE OR REPLACE FUNCTION merge_duplicate_documents(
  p_master_id UUID,
  p_duplicate_id UUID,
  p_dry_run BOOLEAN DEFAULT TRUE
)
RETURNS TABLE(step TEXT, detail TEXT, affected_rows INTEGER) AS $$
DECLARE
  v_count INTEGER;
BEGIN
  IF p_master_id = p_duplicate_id THEN
    step := 'ERROR'; detail := 'IDs identiques'; affected_rows := 0;
    RETURN NEXT; RETURN;
  END IF;

  -- 1. Backup
  IF NOT p_dry_run THEN
    INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
    SELECT gen_random_uuid(), 'documents', p_duplicate_id::TEXT, 'MERGE', to_jsonb(d), 'Fusion vers ' || p_master_id
    FROM documents d WHERE id = p_duplicate_id;
  END IF;
  step := '1.BACKUP'; detail := 'Backup du doublon'; affected_rows := 1;
  RETURN NEXT;

  -- 2. Transfert : documents.replaced_by
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM documents WHERE replaced_by = p_duplicate_id;
  ELSE
    UPDATE documents SET replaced_by = p_master_id WHERE replaced_by = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'documents.replaced_by'; affected_rows := v_count;
  RETURN NEXT;

  -- 3. Enrichir master
  IF NOT p_dry_run THEN
    UPDATE documents SET
      storage_path = COALESCE(documents.storage_path, dup.storage_path),
      url = COALESCE(documents.url, dup.url),
      mime_type = COALESCE(documents.mime_type, dup.mime_type),
      size = COALESCE(documents.size, dup.size),
      preview_url = COALESCE(documents.preview_url, dup.preview_url)
    FROM documents dup
    WHERE documents.id = p_master_id AND dup.id = p_duplicate_id;
  END IF;
  step := '3.ENRICH'; detail := 'Champs manquants copiés'; affected_rows := 1;
  RETURN NEXT;

  -- 4. Suppression
  IF NOT p_dry_run THEN
    DELETE FROM documents WHERE id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
    INSERT INTO _audit_log (action, table_name, old_id, new_id, details)
    VALUES ('MERGE', 'documents', p_duplicate_id::TEXT, p_master_id::TEXT, 'Fusion document doublon');
  ELSE
    v_count := 1;
  END IF;
  step := '4.DELETE'; detail := 'Suppression du doublon'; affected_rows := v_count;
  RETURN NEXT;

  step := 'DONE';
  detail := CASE WHEN p_dry_run THEN '🔍 DRY RUN' ELSE '✅ Fusion exécutée' END;
  affected_rows := 0;
  RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4.5 Merge d'EDL dupliqués
CREATE OR REPLACE FUNCTION merge_duplicate_edl(
  p_master_id UUID,
  p_duplicate_id UUID,
  p_dry_run BOOLEAN DEFAULT TRUE
)
RETURNS TABLE(step TEXT, detail TEXT, affected_rows INTEGER) AS $$
DECLARE
  v_count INTEGER;
BEGIN
  IF p_master_id = p_duplicate_id THEN
    step := 'ERROR'; detail := 'IDs identiques'; affected_rows := 0;
    RETURN NEXT; RETURN;
  END IF;

  -- 1. Backup
  IF NOT p_dry_run THEN
    INSERT INTO _audit_cleanup_archive (cleanup_batch_id, source_table, source_id, fk_column, original_data, cleanup_reason)
    SELECT gen_random_uuid(), 'edl', p_duplicate_id::TEXT, 'MERGE', to_jsonb(e), 'Fusion vers ' || p_master_id
    FROM edl e WHERE id = p_duplicate_id;
  END IF;
  step := '1.BACKUP'; detail := 'Backup du doublon'; affected_rows := 1;
  RETURN NEXT;

  -- 2. Transfert edl_items (ceux du doublon qui n'existent pas dans le master)
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM edl_items WHERE edl_id = p_duplicate_id;
  ELSE
    UPDATE edl_items SET edl_id = p_master_id WHERE edl_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'edl_items.edl_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 3. Transfert edl_media
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM edl_media WHERE edl_id = p_duplicate_id;
  ELSE
    UPDATE edl_media SET edl_id = p_master_id WHERE edl_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'edl_media.edl_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 4. Transfert edl_signatures
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM edl_signatures WHERE edl_id = p_duplicate_id;
  ELSE
    UPDATE edl_signatures SET edl_id = p_master_id WHERE edl_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'edl_signatures.edl_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 5. Transfert edl_meter_readings
  IF p_dry_run THEN
    SELECT COUNT(*) INTO v_count FROM edl_meter_readings WHERE edl_id = p_duplicate_id;
  ELSE
    UPDATE edl_meter_readings SET edl_id = p_master_id WHERE edl_id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
  END IF;
  step := '2.TRANSFER'; detail := 'edl_meter_readings.edl_id'; affected_rows := v_count;
  RETURN NEXT;

  -- 6. Suppression
  IF NOT p_dry_run THEN
    DELETE FROM edl WHERE id = p_duplicate_id;
    GET DIAGNOSTICS v_count = ROW_COUNT;
    INSERT INTO _audit_log (action, table_name, old_id, new_id, details)
    VALUES ('MERGE', 'edl', p_duplicate_id::TEXT, p_master_id::TEXT, 'Fusion EDL doublon');
  ELSE
    v_count := 1;
  END IF;
  step := '3.DELETE'; detail := 'Suppression du doublon'; affected_rows := v_count;
  RETURN NEXT;

  step := 'DONE';
  detail := CASE WHEN p_dry_run THEN '🔍 DRY RUN' ELSE '✅ Fusion exécutée' END;
  affected_rows := 0;
  RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- ============================================================================
-- PHASE 5 : PRÉVENTION — CONTRAINTES FK, UNIQUE, TRIGGERS
-- ============================================================================
-- ⚠️ Ces contraintes sont ajoutées avec NOT VALID + VALIDATE séparément
-- pour éviter de bloquer la table pendant la création.
-- Elles sont idempotentes (IF NOT EXISTS / DO $$ ... $$).
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 5.1 FK Formelles manquantes
-- ----------------------------------------------------------------------------

-- leases.tenant_id → profiles.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'fk_leases_tenant_id' AND table_name = 'leases'
  ) THEN
    -- D'abord nettoyer les valeurs invalides
    UPDATE leases SET tenant_id = NULL
    WHERE tenant_id IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM profiles WHERE id = leases.tenant_id);
    -- Puis ajouter la contrainte
    ALTER TABLE leases
      ADD CONSTRAINT fk_leases_tenant_id
      FOREIGN KEY (tenant_id) REFERENCES profiles(id) ON DELETE SET NULL;
  END IF;
END $$;

-- leases.owner_id → profiles.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'fk_leases_owner_id' AND table_name = 'leases'
  ) THEN
    UPDATE leases SET owner_id = NULL
    WHERE owner_id IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM profiles WHERE id = leases.owner_id);
    ALTER TABLE leases
      ADD CONSTRAINT fk_leases_owner_id
      FOREIGN KEY (owner_id) REFERENCES profiles(id) ON DELETE SET NULL;
  END IF;
END $$;

-- tickets.assigned_provider_id → profiles.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'fk_tickets_assigned_provider_id' AND table_name = 'tickets'
  ) THEN
    UPDATE tickets SET assigned_provider_id = NULL
    WHERE assigned_provider_id IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM profiles WHERE id = tickets.assigned_provider_id);
    ALTER TABLE tickets
      ADD CONSTRAINT fk_tickets_assigned_provider_id
      FOREIGN KEY (assigned_provider_id) REFERENCES profiles(id) ON DELETE SET NULL;
  END IF;
END $$;

-- tickets.owner_id → profiles.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'fk_tickets_owner_id' AND table_name = 'tickets'
  ) THEN
    UPDATE tickets SET owner_id = NULL
    WHERE owner_id IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM profiles WHERE id = tickets.owner_id);
    ALTER TABLE tickets
      ADD CONSTRAINT fk_tickets_owner_id
      FOREIGN KEY (owner_id) REFERENCES profiles(id) ON DELETE SET NULL;
  END IF;
END $$;

-- documents.profile_id → profiles.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'fk_documents_profile_id' AND table_name = 'documents'
  ) THEN
    UPDATE documents SET profile_id = NULL
    WHERE profile_id IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM profiles WHERE id = documents.profile_id);
    ALTER TABLE documents
      ADD CONSTRAINT fk_documents_profile_id
      FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE SET NULL;
  END IF;
END $$;

-- building_units.current_lease_id → leases.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'fk_building_units_current_lease_id' AND table_name = 'building_units'
  ) THEN
    UPDATE building_units SET current_lease_id = NULL
    WHERE current_lease_id IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM leases WHERE id = building_units.current_lease_id);
    ALTER TABLE building_units
      ADD CONSTRAINT fk_building_units_current_lease_id
      FOREIGN KEY (current_lease_id) REFERENCES leases(id) ON DELETE SET NULL;
  END IF;
END $$;

-- work_orders.quote_id → quotes.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'fk_work_orders_quote_id' AND table_name = 'work_orders'
  ) THEN
    UPDATE work_orders SET quote_id = NULL
    WHERE quote_id IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM quotes WHERE id = work_orders.quote_id);
    ALTER TABLE work_orders
      ADD CONSTRAINT fk_work_orders_quote_id
      FOREIGN KEY (quote_id) REFERENCES quotes(id) ON DELETE SET NULL;
  END IF;
END $$;

-- work_orders.property_id → properties.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'fk_work_orders_property_id' AND table_name = 'work_orders'
  ) THEN
    UPDATE work_orders SET property_id = NULL
    WHERE property_id IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM properties WHERE id = work_orders.property_id);
    ALTER TABLE work_orders
      ADD CONSTRAINT fk_work_orders_property_id
      FOREIGN KEY (property_id) REFERENCES properties(id) ON DELETE SET NULL;
  END IF;
END $$;

-- ----------------------------------------------------------------------------
-- 5.2 Contraintes UNIQUE pour empêcher les futurs doublons
-- ----------------------------------------------------------------------------

-- Empêcher 2 factures pour le même bail + même période
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'uq_invoices_lease_periode'
  ) THEN
    -- Supprimer les doublons avant d'ajouter la contrainte
    -- On garde la plus ancienne (ou la payée si elle existe)
    WITH ranked AS (
      SELECT id, ROW_NUMBER() OVER (
        PARTITION BY lease_id, periode
        ORDER BY
          CASE WHEN statut = 'paid' THEN 0 ELSE 1 END,
          created_at ASC
      ) AS rn
      FROM invoices
    )
    DELETE FROM invoices WHERE id IN (
      SELECT id FROM ranked WHERE rn > 1
    );

    ALTER TABLE invoices
      ADD CONSTRAINT uq_invoices_lease_periode
      UNIQUE (lease_id, periode);
  END IF;
END $$;

-- Empêcher 2 signataires identiques sur le même bail
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'uq_lease_signers_lease_profile'
  ) THEN
    -- Supprimer les doublons (garder le plus ancien)
    WITH ranked AS (
      SELECT id, ROW_NUMBER() OVER (
        PARTITION BY lease_id, profile_id
        ORDER BY
          CASE WHEN signature_status = 'signed' THEN 0 ELSE 1 END,
          created_at ASC
      ) AS rn
      FROM lease_signers
      WHERE profile_id IS NOT NULL
    )
    DELETE FROM lease_signers WHERE id IN (
      SELECT id FROM ranked WHERE rn > 1
    );

    -- Contrainte partielle (profile_id non null)
    CREATE UNIQUE INDEX IF NOT EXISTS uq_lease_signers_lease_profile
      ON lease_signers (lease_id, profile_id)
      WHERE profile_id IS NOT NULL;
  END IF;
END $$;

-- Empêcher 2 EDL de même type sur le même bail (hors annulés)
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE indexname = 'uq_edl_lease_type_active'
  ) THEN
    CREATE UNIQUE INDEX IF NOT EXISTS uq_edl_lease_type_active
      ON edl (lease_id, type)
      WHERE status NOT IN ('cancelled', 'disputed');
  END IF;
END $$;

-- Empêcher les doublons de roommates sur le même bail
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE indexname = 'uq_roommates_lease_profile'
  ) THEN
    WITH ranked AS (
      SELECT id, ROW_NUMBER() OVER (
        PARTITION BY lease_id, profile_id ORDER BY created_at ASC
      ) AS rn
      FROM roommates
    )
    DELETE FROM roommates WHERE id IN (
      SELECT id FROM ranked WHERE rn > 1
    );

    CREATE UNIQUE INDEX IF NOT EXISTS uq_roommates_lease_profile
      ON roommates (lease_id, profile_id);
  END IF;
END $$;

-- Empêcher les abonnements actifs multiples par user
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE indexname = 'uq_subscriptions_user_active'
  ) THEN
    CREATE UNIQUE INDEX IF NOT EXISTS uq_subscriptions_user_active
      ON subscriptions (user_id)
      WHERE status IN ('active', 'trialing');
  END IF;
END $$;

-- ----------------------------------------------------------------------------
-- 5.3 Trigger anti-doublon sur INSERT de propriétés
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION prevent_duplicate_property()
RETURNS TRIGGER AS $$
DECLARE
  v_existing_id UUID;
BEGIN
  -- Chercher un doublon exact (même owner + même adresse + même CP)
  SELECT id INTO v_existing_id
  FROM properties
  WHERE owner_id = NEW.owner_id
    AND LOWER(TRIM(adresse_complete)) = LOWER(TRIM(NEW.adresse_complete))
    AND code_postal = NEW.code_postal
    AND deleted_at IS NULL
    AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::UUID)
  LIMIT 1;

  IF v_existing_id IS NOT NULL THEN
    RAISE EXCEPTION 'Propriété en doublon détectée (id: %). Même adresse et code postal pour ce propriétaire.', v_existing_id
      USING HINT = 'Vérifiez si cette propriété existe déjà avant d''en créer une nouvelle.',
            ERRCODE = 'unique_violation';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_prevent_duplicate_property ON properties;
CREATE TRIGGER trg_prevent_duplicate_property
  BEFORE INSERT ON properties
  FOR EACH ROW
  EXECUTE FUNCTION prevent_duplicate_property();

-- ----------------------------------------------------------------------------
-- 5.4 Trigger anti-doublon sur INSERT de paiements (même invoice + même montant + <24h)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION prevent_duplicate_payment()
RETURNS TRIGGER AS $$
DECLARE
  v_existing_id UUID;
BEGIN
  SELECT id INTO v_existing_id
  FROM payments
  WHERE invoice_id = NEW.invoice_id
    AND montant = NEW.montant
    AND ABS(EXTRACT(EPOCH FROM (created_at - NOW()))) < 86400
    AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::UUID)
  LIMIT 1;

  IF v_existing_id IS NOT NULL THEN
    RAISE WARNING 'Paiement potentiellement en doublon (id existant: %). Même montant + même facture en < 24h.', v_existing_id;
    -- On ne bloque pas, on avertit seulement (pour ne pas casser les paiements légitimes)
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_prevent_duplicate_payment ON payments;
CREATE TRIGGER trg_prevent_duplicate_payment
  BEFORE INSERT ON payments
  FOR EACH ROW
  EXECUTE FUNCTION prevent_duplicate_payment();


-- ============================================================================
-- LOGS
-- ============================================================================
DO $$
BEGIN
  RAISE NOTICE '══════════════════════════════════════════════════════════════';
  RAISE NOTICE '  AUDIT V2 — Fusion, Prévention, Contraintes installés';
  RAISE NOTICE '══════════════════════════════════════════════════════════════';
  RAISE NOTICE '';
  RAISE NOTICE '  Phase 3 — Détection avancée doublons :';
  RAISE NOTICE '    SELECT * FROM audit_duplicate_properties();';
  RAISE NOTICE '    SELECT * FROM audit_duplicate_profiles();';
  RAISE NOTICE '    SELECT * FROM audit_duplicate_leases();';
  RAISE NOTICE '    SELECT * FROM audit_duplicate_documents();';
  RAISE NOTICE '    SELECT * FROM audit_duplicate_payments();';
  RAISE NOTICE '    SELECT * FROM audit_duplicate_edl();';
  RAISE NOTICE '    SELECT * FROM audit_duplicate_invoices();';
  RAISE NOTICE '    SELECT * FROM audit_all_duplicates_summary();';
  RAISE NOTICE '';
  RAISE NOTICE '  Phase 4 — Fusion SAFE (DRY RUN par défaut) :';
  RAISE NOTICE '    SELECT * FROM merge_duplicate_properties(master, dup, true);';
  RAISE NOTICE '    SELECT * FROM merge_duplicate_invoices(master, dup, true);';
  RAISE NOTICE '    SELECT * FROM merge_duplicate_documents(master, dup, true);';
  RAISE NOTICE '    SELECT * FROM merge_duplicate_edl(master, dup, true);';
  RAISE NOTICE '';
  RAISE NOTICE '  Phase 5 — Contraintes de prévention installées :';
  RAISE NOTICE '    - 8 FK formelles ajoutées';
  RAISE NOTICE '    - 5 contraintes UNIQUE ajoutées';
  RAISE NOTICE '    - 2 triggers anti-doublon activés';
  RAISE NOTICE '══════════════════════════════════════════════════════════════';
END $$;

-- ========== 20260212100000_email_template_system.sql ==========
-- ============================================================
-- Email Template System
-- Tables: email_templates, email_template_versions, email_logs
-- ============================================================

-- Table des templates email éditables
CREATE TABLE IF NOT EXISTS email_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  slug TEXT UNIQUE NOT NULL,
  category TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  subject TEXT NOT NULL,
  body_html TEXT NOT NULL,
  body_text TEXT NOT NULL,
  available_variables JSONB NOT NULL DEFAULT '[]'::jsonb,
  is_active BOOLEAN DEFAULT true,
  send_delay_minutes INT DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Index pour recherche rapide par slug et catégorie
CREATE INDEX IF NOT EXISTS idx_email_templates_slug ON email_templates(slug);
CREATE INDEX IF NOT EXISTS idx_email_templates_category ON email_templates(category);
CREATE INDEX IF NOT EXISTS idx_email_templates_is_active ON email_templates(is_active);

-- Historique des modifications (audit trail)
CREATE TABLE IF NOT EXISTS email_template_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_id UUID NOT NULL REFERENCES email_templates(id) ON DELETE CASCADE,
  subject TEXT NOT NULL,
  body_html TEXT NOT NULL,
  body_text TEXT NOT NULL,
  modified_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_email_template_versions_template ON email_template_versions(template_id);
CREATE INDEX IF NOT EXISTS idx_email_template_versions_created ON email_template_versions(created_at DESC);

-- Logs d'envoi
CREATE TABLE IF NOT EXISTS email_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_slug TEXT NOT NULL,
  recipient_email TEXT NOT NULL,
  variables_used JSONB,
  status TEXT NOT NULL CHECK (status IN ('sent', 'failed', 'bounced')),
  error_message TEXT,
  sent_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_email_logs_template ON email_logs(template_slug);
CREATE INDEX IF NOT EXISTS idx_email_logs_recipient ON email_logs(recipient_email);
CREATE INDEX IF NOT EXISTS idx_email_logs_status ON email_logs(status);
CREATE INDEX IF NOT EXISTS idx_email_logs_sent_at ON email_logs(sent_at DESC);

-- Trigger pour updated_at automatique
CREATE OR REPLACE FUNCTION update_email_template_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_email_templates_updated_at ON email_templates;
CREATE TRIGGER trg_email_templates_updated_at
  BEFORE UPDATE ON email_templates
  FOR EACH ROW
  EXECUTE FUNCTION update_email_template_updated_at();

-- Trigger pour versionner automatiquement les modifications
CREATE OR REPLACE FUNCTION version_email_template()
RETURNS TRIGGER AS $$
BEGIN
  -- Sauvegarder l'ancienne version si le contenu a changé
  IF OLD.subject IS DISTINCT FROM NEW.subject
     OR OLD.body_html IS DISTINCT FROM NEW.body_html
     OR OLD.body_text IS DISTINCT FROM NEW.body_text THEN
    INSERT INTO email_template_versions (template_id, subject, body_html, body_text, modified_by)
    VALUES (OLD.id, OLD.subject, OLD.body_html, OLD.body_text, auth.uid());
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trg_email_template_version ON email_templates;
CREATE TRIGGER trg_email_template_version
  BEFORE UPDATE ON email_templates
  FOR EACH ROW
  EXECUTE FUNCTION version_email_template();

-- ============================================================
-- RLS Policies
-- ============================================================

ALTER TABLE email_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_template_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_logs ENABLE ROW LEVEL SECURITY;

-- email_templates: lecture pour les admins, écriture pour les admins
CREATE POLICY "email_templates_admin_read" ON email_templates
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.user_id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

CREATE POLICY "email_templates_admin_write" ON email_templates
  FOR ALL TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.user_id = auth.uid()
      AND profiles.role = 'admin'
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.user_id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

-- email_templates: lecture pour le service role (envoi d'emails)
CREATE POLICY "email_templates_service_read" ON email_templates
  FOR SELECT TO service_role
  USING (true);

-- email_template_versions: lecture pour les admins
CREATE POLICY "email_template_versions_admin_read" ON email_template_versions
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.user_id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

-- email_logs: lecture pour les admins
CREATE POLICY "email_logs_admin_read" ON email_logs
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.user_id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

-- email_logs: insertion pour service role
CREATE POLICY "email_logs_service_insert" ON email_logs
  FOR INSERT TO service_role
  WITH CHECK (true);

-- ========== 20260212100001_email_templates_seed.sql ==========
-- ============================================================
-- Seed data: 31 email templates
-- ============================================================

-- ============================================
-- CATÉGORIE : AUTHENTIFICATION (auth)
-- ============================================

INSERT INTO email_templates (slug, category, name, description, subject, body_html, body_text, available_variables, send_delay_minutes) VALUES

-- 1. Confirmation d'inscription
('auth_confirmation', 'auth', 'Confirmation d''inscription', 'Email de confirmation envoyé après la création de compte', 'Confirmez votre inscription sur Talok, {{prenom}}',
'<h2>Bienvenue sur Talok, {{prenom}} !</h2>
<p>Vous venez de créer un compte en tant que <strong>{{role}}</strong>.</p>
<p>Pour activer votre compte et commencer à utiliser Talok, veuillez confirmer votre adresse email :</p>
<a href="{{confirmation_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Confirmer mon adresse email</a>
<p>Ce lien est valable 24 heures. Si vous n''avez pas créé de compte, ignorez cet email.</p>
<p>À très vite sur Talok,<br>L''équipe Talok</p>',
'Bienvenue sur Talok, {{prenom}} !

Vous venez de créer un compte en tant que {{role}}.

Pour activer votre compte, confirmez votre adresse email en cliquant sur le lien suivant :
{{confirmation_url}}

Ce lien est valable 24 heures. Si vous n''avez pas créé de compte, ignorez cet email.

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom de l''utilisateur", "example": "Thomas"}, {"key": "email", "label": "Adresse email", "example": "thomas@email.com"}, {"key": "confirmation_url", "label": "Lien de confirmation", "example": "https://talok.fr/auth/confirm?token=..."}, {"key": "role", "label": "Rôle (Propriétaire/Locataire/Prestataire)", "example": "Propriétaire"}]'::jsonb,
0),

-- 2. Réinitialisation de mot de passe
('auth_reset_password', 'auth', 'Réinitialisation de mot de passe', 'Email envoyé lors d''une demande de réinitialisation de mot de passe', 'Réinitialisation de votre mot de passe Talok',
'<h2>Réinitialisation de mot de passe</h2>
<p>Bonjour {{prenom}},</p>
<p>Vous avez demandé la réinitialisation de votre mot de passe. Cliquez sur le bouton ci-dessous pour en choisir un nouveau :</p>
<a href="{{reset_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Réinitialiser mon mot de passe</a>
<p>Ce lien expire dans {{expiration}}. Si vous n''êtes pas à l''origine de cette demande, ignorez cet email — votre mot de passe ne sera pas modifié.</p>',
'Bonjour {{prenom}},

Vous avez demandé la réinitialisation de votre mot de passe.
Cliquez sur le lien suivant pour en choisir un nouveau :
{{reset_url}}

Ce lien expire dans {{expiration}}.

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom", "example": "Thomas"}, {"key": "reset_url", "label": "Lien de réinitialisation", "example": "https://talok.fr/auth/reset?token=..."}, {"key": "expiration", "label": "Durée de validité", "example": "1 heure"}]'::jsonb,
0),

-- 3. Connexion par lien magique
('auth_magic_link', 'auth', 'Connexion par lien magique', 'Lien magique de connexion sans mot de passe', 'Votre lien de connexion Talok',
'<p>Bonjour {{prenom}},</p>
<p>Cliquez sur le bouton ci-dessous pour vous connecter à Talok :</p>
<a href="{{magic_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Se connecter</a>
<p>Ce lien expire dans {{expiration}} et ne peut être utilisé qu''une seule fois.</p>',
'Bonjour {{prenom}},

Connectez-vous à Talok via ce lien :
{{magic_url}}

Ce lien expire dans {{expiration}} et ne peut être utilisé qu''une seule fois.

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom", "example": "Thomas"}, {"key": "magic_url", "label": "Lien de connexion", "example": "https://talok.fr/auth/magic?token=..."}, {"key": "expiration", "label": "Durée de validité", "example": "15 minutes"}]'::jsonb,
0),

-- 4. Changement d'adresse email
('auth_email_change', 'auth', 'Changement d''adresse email', 'Confirmation lors d''un changement d''adresse email', 'Confirmez votre nouvelle adresse email',
'<p>Bonjour {{prenom}},</p>
<p>Vous avez demandé le changement de votre adresse email vers <strong>{{new_email}}</strong>.</p>
<a href="{{confirm_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Confirmer le changement</a>
<p>Si vous n''êtes pas à l''origine de cette demande, sécurisez votre compte immédiatement.</p>',
'Bonjour {{prenom}},

Vous avez demandé le changement de votre adresse email vers {{new_email}}.

Confirmez le changement via ce lien :
{{confirm_url}}

Si vous n''êtes pas à l''origine de cette demande, sécurisez votre compte immédiatement.

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom", "example": "Thomas"}, {"key": "new_email", "label": "Nouvelle adresse email", "example": "nouveau@email.com"}, {"key": "confirm_url", "label": "Lien de confirmation", "example": "https://talok.fr/auth/confirm-email?token=..."}]'::jsonb,
0),

-- ============================================
-- CATÉGORIE : INVITATIONS & ONBOARDING (invitation)
-- ============================================

-- 5. Invitation locataire
('invitation_tenant', 'invitation', 'Invitation locataire', 'Email d''invitation envoyé à un locataire par le propriétaire', '{{nom_proprietaire}} vous invite à rejoindre Talok',
'<h2>Vous êtes invité(e) sur Talok</h2>
<p>Bonjour {{prenom_locataire}},</p>
<p><strong>{{nom_proprietaire}}</strong> vous invite à rejoindre Talok pour gérer votre location au :</p>
<p style="background:#f1f5f9;padding:12px 16px;border-radius:8px;border-left:4px solid #2563eb;">📍 {{adresse_bien}}</p>
<p>Avec Talok, vous pourrez :</p>
<ul>
  <li>Consulter et télécharger vos quittances de loyer</li>
  <li>Signaler des incidents et suivre leur résolution</li>
  <li>Signer vos documents numériquement</li>
  <li>Communiquer facilement avec votre propriétaire</li>
</ul>
<a href="{{invitation_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Créer mon compte locataire</a>',
'Bonjour {{prenom_locataire}},

{{nom_proprietaire}} vous invite à rejoindre Talok pour gérer votre location au :
{{adresse_bien}}

Créez votre compte via ce lien :
{{invitation_url}}

L''équipe Talok',
'[{"key": "prenom_locataire", "label": "Prénom du locataire", "example": "Marie"}, {"key": "nom_proprietaire", "label": "Nom du propriétaire", "example": "M. Dupont"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas, Fort-de-France"}, {"key": "invitation_url", "label": "Lien d''invitation", "example": "https://talok.fr/invite?token=..."}]'::jsonb,
0),

-- 6. Invitation prestataire
('invitation_provider', 'invitation', 'Invitation prestataire', 'Email d''invitation envoyé à un prestataire par le propriétaire', '{{nom_proprietaire}} vous invite comme prestataire sur Talok',
'<p>Bonjour {{prenom_prestataire}},</p>
<p><strong>{{nom_proprietaire}}</strong> souhaite vous ajouter comme prestataire <strong>{{specialite}}</strong> sur Talok.</p>
<p>En rejoignant Talok, vous pourrez recevoir et gérer vos interventions directement depuis votre espace dédié.</p>
<a href="{{invitation_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Rejoindre Talok</a>',
'Bonjour {{prenom_prestataire}},

{{nom_proprietaire}} souhaite vous ajouter comme prestataire {{specialite}} sur Talok.

Rejoignez Talok via ce lien :
{{invitation_url}}

L''équipe Talok',
'[{"key": "prenom_prestataire", "label": "Prénom du prestataire", "example": "Jacques"}, {"key": "nom_proprietaire", "label": "Nom du propriétaire", "example": "M. Dupont"}, {"key": "specialite", "label": "Spécialité", "example": "plomberie"}, {"key": "invitation_url", "label": "Lien d''invitation", "example": "https://talok.fr/invite?token=..."}]'::jsonb,
0),

-- 7. Bienvenue propriétaire
('welcome_owner', 'invitation', 'Bienvenue propriétaire', 'Email de bienvenue envoyé après confirmation du compte propriétaire', 'Bienvenue sur Talok, {{prenom}} ! Voici comment démarrer',
'<h2>Votre compte est activé</h2>
<p>Bonjour {{prenom}},</p>
<p>Bienvenue sur Talok ! Voici les premières étapes pour bien démarrer :</p>
<ol>
  <li><strong>Ajoutez votre premier bien</strong> — renseignez l''adresse, le type et les caractéristiques</li>
  <li><strong>Créez un bail</strong> — associez un locataire et définissez les conditions</li>
  <li><strong>Invitez votre locataire</strong> — il recevra un email pour créer son espace</li>
</ol>
<a href="{{dashboard_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Accéder à mon tableau de bord</a>
<p>Besoin d''aide ? Notre équipe est disponible à support@talok.fr</p>',
'Bonjour {{prenom}},

Bienvenue sur Talok ! Voici les premières étapes :
1. Ajoutez votre premier bien
2. Créez un bail
3. Invitez votre locataire

Accédez à votre tableau de bord : {{dashboard_url}}

Besoin d''aide ? Contactez support@talok.fr

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom", "example": "Thomas"}, {"key": "dashboard_url", "label": "Lien vers le dashboard", "example": "https://talok.fr/owner/dashboard"}]'::jsonb,
0),

-- ============================================
-- CATÉGORIE : BAUX (lease)
-- ============================================

-- 8. Bail créé
('lease_created', 'lease', 'Bail créé', 'Notification au propriétaire lors de la création d''un bail', 'Bail créé — {{adresse_bien}}',
'<p>Bonjour {{prenom}},</p>
<p>Le bail pour le bien situé au <strong>{{adresse_bien}}</strong> a été créé avec succès.</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Locataire</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{nom_locataire}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Début du bail</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{date_debut}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Loyer mensuel</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{montant_loyer}} €</td></tr>
</table>
<a href="{{lease_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Voir le bail</a>',
'Bonjour {{prenom}},

Le bail pour le bien au {{adresse_bien}} a été créé.
Locataire : {{nom_locataire}}
Début : {{date_debut}}
Loyer : {{montant_loyer}} €

Voir le bail : {{lease_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du propriétaire", "example": "Thomas"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas, Fort-de-France"}, {"key": "nom_locataire", "label": "Nom du locataire", "example": "Marie Martin"}, {"key": "date_debut", "label": "Date de début du bail", "example": "1er mars 2026"}, {"key": "montant_loyer", "label": "Montant du loyer", "example": "850"}, {"key": "lease_url", "label": "Lien vers le bail", "example": "https://talok.fr/owner/leases/..."}]'::jsonb,
0),

-- 9. Bail expirant
('lease_expiring', 'lease', 'Bail arrivant à échéance', 'Alerte au propriétaire avant l''expiration d''un bail', 'Bail expirant dans {{jours_restants}} jours — {{adresse_bien}}',
'<p>Bonjour {{prenom}},</p>
<p>Le bail de <strong>{{nom_locataire}}</strong> au <strong>{{adresse_bien}}</strong> arrive à échéance le <strong>{{date_fin}}</strong> (dans {{jours_restants}} jours).</p>
<p>Pensez à :</p>
<ul>
  <li>Renouveler le bail si vous souhaitez continuer la location</li>
  <li>Planifier un état des lieux de sortie</li>
  <li>Prévenir votre locataire de vos intentions</li>
</ul>
<a href="{{lease_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Gérer ce bail</a>',
'Bonjour {{prenom}},

Le bail de {{nom_locataire}} au {{adresse_bien}} expire le {{date_fin}} (dans {{jours_restants}} jours).

Gérer ce bail : {{lease_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du propriétaire", "example": "Thomas"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "nom_locataire", "label": "Nom du locataire", "example": "Marie Martin"}, {"key": "date_fin", "label": "Date de fin du bail", "example": "31 mars 2026"}, {"key": "jours_restants", "label": "Nombre de jours restants", "example": "30"}, {"key": "lease_url", "label": "Lien vers le bail", "example": "https://talok.fr/owner/leases/..."}]'::jsonb,
0),

-- 10. Résiliation de bail
('lease_terminated', 'lease', 'Résiliation de bail', 'Notification de résiliation de bail', 'Résiliation de bail — {{adresse_bien}}',
'<p>Bonjour {{prenom}},</p>
<p>Le bail pour le bien situé au <strong>{{adresse_bien}}</strong> a été résilié.</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Date de fin effective</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{date_fin}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Motif</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{motif}}</td></tr>
</table>
<p>Un état des lieux de sortie devra être planifié avant cette date.</p>',
'Bonjour {{prenom}},

Le bail au {{adresse_bien}} a été résilié.
Date de fin : {{date_fin}}
Motif : {{motif}}

Un état des lieux de sortie devra être planifié.

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du destinataire", "example": "Thomas"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "date_fin", "label": "Date effective de fin", "example": "31 mars 2026"}, {"key": "motif", "label": "Motif de résiliation", "example": "Congé du locataire"}]'::jsonb,
0),

-- ============================================
-- CATÉGORIE : PAIEMENTS & LOYERS (payment)
-- ============================================

-- 11. Rappel de loyer
('rent_reminder', 'payment', 'Rappel de loyer', 'Rappel envoyé au locataire avant l''échéance du loyer', 'Rappel : loyer de {{montant}} € à régler avant le {{date_echeance}}',
'<p>Bonjour {{prenom}},</p>
<p>Votre loyer de <strong>{{montant}} €</strong> pour le bien situé au <strong>{{adresse_bien}}</strong> est à régler avant le <strong>{{date_echeance}}</strong>.</p>
<a href="{{payment_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Payer mon loyer</a>
<p>Si vous avez déjà effectué le paiement, veuillez ignorer cet email.</p>',
'Bonjour {{prenom}},

Votre loyer de {{montant}} € pour le bien au {{adresse_bien}} est à régler avant le {{date_echeance}}.

Payer : {{payment_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du locataire", "example": "Marie"}, {"key": "montant", "label": "Montant du loyer", "example": "850"}, {"key": "date_echeance", "label": "Date d''échéance", "example": "5 mars 2026"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "payment_url", "label": "Lien de paiement", "example": "https://talok.fr/tenant/payments/..."}]'::jsonb,
0),

-- 12. Loyer reçu (propriétaire)
('rent_received', 'payment', 'Loyer reçu', 'Notification au propriétaire après réception d''un loyer', 'Loyer reçu — {{montant}} € de {{nom_locataire}}',
'<p>Bonjour {{prenom}},</p>
<p>Le loyer du mois de <strong>{{mois}}</strong> a été reçu :</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Locataire</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{nom_locataire}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Bien</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{adresse_bien}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Montant</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{montant}} €</td></tr>
</table>
<p>La quittance sera automatiquement générée et envoyée au locataire.</p>',
'Bonjour {{prenom}},

Loyer de {{mois}} reçu :
Locataire : {{nom_locataire}}
Bien : {{adresse_bien}}
Montant : {{montant}} €

La quittance sera générée automatiquement.

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du propriétaire", "example": "Thomas"}, {"key": "nom_locataire", "label": "Nom du locataire", "example": "Marie Martin"}, {"key": "montant", "label": "Montant reçu", "example": "850"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "mois", "label": "Mois concerné", "example": "mars 2026"}, {"key": "dashboard_url", "label": "Lien dashboard", "example": "https://talok.fr/owner/dashboard"}]'::jsonb,
0),

-- 13. Loyer en retard (propriétaire)
('rent_late', 'payment', 'Loyer en retard', 'Alerte au propriétaire pour un loyer impayé', 'Loyer impayé — {{nom_locataire}} ({{jours_retard}} jours de retard)',
'<p>Bonjour {{prenom}},</p>
<p>Le loyer de <strong>{{nom_locataire}}</strong> pour le bien au <strong>{{adresse_bien}}</strong> est en retard de <strong>{{jours_retard}} jours</strong>.</p>
<p>Montant impayé : <strong>{{montant}} €</strong></p>
<a href="{{lease_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Voir le détail</a>',
'Bonjour {{prenom}},

Loyer impayé de {{nom_locataire}} au {{adresse_bien}}.
Retard : {{jours_retard}} jours
Montant : {{montant}} €

Voir le détail : {{lease_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du propriétaire", "example": "Thomas"}, {"key": "nom_locataire", "label": "Nom du locataire", "example": "Marie Martin"}, {"key": "montant", "label": "Montant dû", "example": "850"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "jours_retard", "label": "Jours de retard", "example": "5"}, {"key": "lease_url", "label": "Lien vers le bail", "example": "https://talok.fr/owner/leases/..."}]'::jsonb,
0),

-- 14. Relance loyer impayé (locataire)
('rent_late_tenant', 'payment', 'Relance loyer impayé', 'Relance envoyée au locataire pour un loyer en retard', 'Rappel important : loyer impayé de {{montant}} €',
'<p>Bonjour {{prenom}},</p>
<p>Nous vous informons que votre loyer pour le bien au <strong>{{adresse_bien}}</strong> est en retard de <strong>{{jours_retard}} jours</strong>.</p>
<p>Montant à régler : <strong>{{montant}} €</strong></p>
<a href="{{payment_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Régulariser maintenant</a>
<p>En cas de difficulté, nous vous encourageons à contacter votre propriétaire pour trouver une solution amiable.</p>',
'Bonjour {{prenom}},

Votre loyer au {{adresse_bien}} est en retard de {{jours_retard}} jours.
Montant : {{montant}} €

Régulariser : {{payment_url}}

En cas de difficulté, contactez votre propriétaire.

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du locataire", "example": "Marie"}, {"key": "montant", "label": "Montant dû", "example": "850"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "jours_retard", "label": "Jours de retard", "example": "5"}, {"key": "payment_url", "label": "Lien de paiement", "example": "https://talok.fr/tenant/payments/..."}]'::jsonb,
0),

-- ============================================
-- CATÉGORIE : DOCUMENTS & QUITTANCES (document)
-- ============================================

-- 15. Quittance disponible
('quittance_available', 'document', 'Quittance disponible', 'Notification au locataire quand une quittance est prête', 'Votre quittance de loyer — {{mois}} {{annee}}',
'<p>Bonjour {{prenom}},</p>
<p>Votre quittance de loyer pour <strong>{{mois}} {{annee}}</strong> est disponible.</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Bien</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{adresse_bien}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Montant</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{montant}} €</td></tr>
</table>
<a href="{{download_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Télécharger ma quittance</a>',
'Bonjour {{prenom}},

Votre quittance de loyer pour {{mois}} {{annee}} est disponible.
Bien : {{adresse_bien}}
Montant : {{montant}} €

Télécharger : {{download_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du locataire", "example": "Marie"}, {"key": "mois", "label": "Mois", "example": "mars"}, {"key": "annee", "label": "Année", "example": "2026"}, {"key": "montant", "label": "Montant", "example": "850"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "download_url", "label": "Lien de téléchargement", "example": "https://talok.fr/tenant/documents/..."}]'::jsonb,
0),

-- 16. Document à signer
('document_to_sign', 'document', 'Document à signer', 'Notification quand un document nécessite une signature', 'Document à signer : {{type_document}} — {{adresse_bien}}',
'<p>Bonjour {{prenom}},</p>
<p><strong>{{nom_expediteur}}</strong> vous invite à signer le document suivant :</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Document</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{type_document}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Bien concerné</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{adresse_bien}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">À signer avant</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{expiration}}</td></tr>
</table>
<a href="{{sign_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Signer le document</a>
<p>Ce lien expire le {{expiration}}.</p>',
'Bonjour {{prenom}},

{{nom_expediteur}} vous invite à signer : {{type_document}}
Bien : {{adresse_bien}}
À signer avant : {{expiration}}

Signer : {{sign_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du signataire", "example": "Marie"}, {"key": "type_document", "label": "Type de document", "example": "Bail d''habitation"}, {"key": "nom_expediteur", "label": "Nom de l''expéditeur", "example": "M. Dupont"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "sign_url", "label": "Lien de signature", "example": "https://talok.fr/signature/..."}, {"key": "expiration", "label": "Date d''expiration", "example": "15 mars 2026"}]'::jsonb,
0),

-- 17. Document signé
('document_signed', 'document', 'Document signé', 'Notification quand un document a été signé', 'Document signé par {{nom_signataire}} — {{type_document}}',
'<p>Bonjour {{prenom}},</p>
<p><strong>{{nom_signataire}}</strong> a signé le document <strong>{{type_document}}</strong> concernant le bien au <strong>{{adresse_bien}}</strong> le {{date_signature}}.</p>
<a href="{{document_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Voir le document signé</a>',
'Bonjour {{prenom}},

{{nom_signataire}} a signé le document {{type_document}} pour le bien au {{adresse_bien}} le {{date_signature}}.

Voir le document : {{document_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du destinataire", "example": "Thomas"}, {"key": "type_document", "label": "Type de document", "example": "Bail d''habitation"}, {"key": "nom_signataire", "label": "Nom du signataire", "example": "Marie Martin"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "date_signature", "label": "Date de signature", "example": "1er mars 2026"}, {"key": "document_url", "label": "Lien vers le document", "example": "https://talok.fr/documents/..."}]'::jsonb,
0),

-- ============================================
-- CATÉGORIE : ÉTATS DES LIEUX (edl)
-- ============================================

-- 18. EDL planifié
('edl_scheduled', 'edl', 'EDL planifié', 'Notification quand un état des lieux est programmé', 'État des lieux {{type_edl}} planifié — {{adresse_bien}}',
'<p>Bonjour {{prenom}},</p>
<p>Un état des lieux <strong>{{type_edl}}</strong> a été planifié :</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Bien</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{adresse_bien}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Date</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{date_edl}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Organisé par</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{nom_organisateur}}</td></tr>
</table>
<a href="{{edl_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Voir les détails</a>
<p>Veuillez vous présenter à l''adresse indiquée à la date et heure convenues.</p>',
'Bonjour {{prenom}},

État des lieux {{type_edl}} planifié :
Bien : {{adresse_bien}}
Date : {{date_edl}}
Organisé par : {{nom_organisateur}}

Détails : {{edl_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du destinataire", "example": "Marie"}, {"key": "type_edl", "label": "Type (Entrée/Sortie)", "example": "d''entrée"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "date_edl", "label": "Date et heure", "example": "15 mars 2026 à 10h00"}, {"key": "nom_organisateur", "label": "Organisateur", "example": "M. Dupont"}, {"key": "edl_url", "label": "Lien vers le détail", "example": "https://talok.fr/edl/..."}]'::jsonb,
0),

-- 19. EDL terminé
('edl_completed', 'edl', 'EDL terminé', 'Notification quand un état des lieux est finalisé', 'État des lieux {{type_edl}} terminé — {{adresse_bien}}',
'<p>Bonjour {{prenom}},</p>
<p>L''état des lieux <strong>{{type_edl}}</strong> du bien au <strong>{{adresse_bien}}</strong> réalisé le {{date_edl}} est maintenant finalisé.</p>
<a href="{{report_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Consulter le rapport</a>
<p>Le rapport est disponible dans votre espace documents.</p>',
'Bonjour {{prenom}},

L''état des lieux {{type_edl}} au {{adresse_bien}} réalisé le {{date_edl}} est finalisé.

Consulter le rapport : {{report_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom", "example": "Thomas"}, {"key": "type_edl", "label": "Type (Entrée/Sortie)", "example": "de sortie"}, {"key": "adresse_bien", "label": "Adresse", "example": "12 rue des Lilas"}, {"key": "date_edl", "label": "Date de réalisation", "example": "15 mars 2026"}, {"key": "report_url", "label": "Lien vers le rapport", "example": "https://talok.fr/edl/report/..."}]'::jsonb,
0),

-- ============================================
-- CATÉGORIE : INCIDENTS & INTERVENTIONS (incident)
-- ============================================

-- 20. Incident signalé (propriétaire)
('incident_reported', 'incident', 'Incident signalé', 'Notification au propriétaire quand un locataire signale un incident', 'Incident signalé — {{titre_incident}} ({{urgence}})',
'<p>Bonjour {{prenom}},</p>
<p><strong>{{nom_locataire}}</strong> a signalé un incident au <strong>{{adresse_bien}}</strong> :</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Incident</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{titre_incident}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Urgence</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{urgence}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Description</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{description_incident}}</td></tr>
</table>
<a href="{{incident_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Gérer l''incident</a>',
'Bonjour {{prenom}},

{{nom_locataire}} a signalé un incident au {{adresse_bien}} :
Incident : {{titre_incident}}
Urgence : {{urgence}}
Description : {{description_incident}}

Gérer : {{incident_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du propriétaire", "example": "Thomas"}, {"key": "nom_locataire", "label": "Locataire", "example": "Marie Martin"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "titre_incident", "label": "Titre de l''incident", "example": "Fuite robinet cuisine"}, {"key": "description_incident", "label": "Description", "example": "Le robinet fuit depuis ce matin"}, {"key": "urgence", "label": "Niveau d''urgence", "example": "urgent"}, {"key": "incident_url", "label": "Lien vers l''incident", "example": "https://talok.fr/owner/tickets/..."}]'::jsonb,
0),

-- 21. Mise à jour d'incident (locataire)
('incident_update', 'incident', 'Mise à jour d''incident', 'Notification au locataire lors de la mise à jour d''un incident', 'Mise à jour de votre incident — {{titre_incident}}',
'<p>Bonjour {{prenom}},</p>
<p>Votre incident <strong>{{titre_incident}}</strong> a été mis à jour :</p>
<p>Nouveau statut : <strong>{{nouveau_statut}}</strong></p>
<p>{{commentaire}}</p>
<a href="{{incident_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Voir le détail</a>',
'Bonjour {{prenom}},

Votre incident "{{titre_incident}}" a été mis à jour.
Nouveau statut : {{nouveau_statut}}
{{commentaire}}

Détail : {{incident_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du locataire", "example": "Marie"}, {"key": "titre_incident", "label": "Titre de l''incident", "example": "Fuite robinet cuisine"}, {"key": "nouveau_statut", "label": "Nouveau statut", "example": "En cours de traitement"}, {"key": "commentaire", "label": "Commentaire", "example": "Un technicien passera demain."}, {"key": "incident_url", "label": "Lien", "example": "https://talok.fr/tenant/tickets/..."}]'::jsonb,
0),

-- 22. Intervention assignée (prestataire)
('intervention_assigned', 'incident', 'Intervention assignée', 'Notification au prestataire quand une intervention lui est assignée', 'Nouvelle intervention — {{titre_intervention}}',
'<p>Bonjour {{prenom}},</p>
<p><strong>{{nom_proprietaire}}</strong> vous assigne une intervention :</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Intervention</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{titre_intervention}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Adresse</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{adresse_bien}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Date souhaitée</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{date_souhaitee}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Urgence</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{urgence}}</td></tr>
</table>
<a href="{{intervention_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Accepter / Planifier</a>',
'Bonjour {{prenom}},

{{nom_proprietaire}} vous assigne une intervention :
Intervention : {{titre_intervention}}
Adresse : {{adresse_bien}}
Date souhaitée : {{date_souhaitee}}
Urgence : {{urgence}}

Accepter/Planifier : {{intervention_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du prestataire", "example": "Jacques"}, {"key": "nom_proprietaire", "label": "Nom du propriétaire", "example": "M. Dupont"}, {"key": "adresse_bien", "label": "Adresse du bien", "example": "12 rue des Lilas"}, {"key": "titre_intervention", "label": "Description", "example": "Réparation fuite robinet"}, {"key": "date_souhaitee", "label": "Date souhaitée", "example": "18 mars 2026"}, {"key": "urgence", "label": "Niveau d''urgence", "example": "urgent"}, {"key": "intervention_url", "label": "Lien", "example": "https://talok.fr/provider/work-orders/..."}]'::jsonb,
0),

-- 23. Intervention planifiée (locataire)
('intervention_scheduled', 'incident', 'Intervention planifiée', 'Notification au locataire quand une intervention est programmée', 'Intervention planifiée — {{titre_intervention}}',
'<p>Bonjour {{prenom}},</p>
<p>Une intervention a été planifiée pour votre logement au <strong>{{adresse_bien}}</strong> :</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Intervention</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{titre_intervention}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Prestataire</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{nom_prestataire}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Date</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{date_intervention}}</td></tr>
</table>
<p>Merci de vous assurer que l''accès au logement sera possible à cette date.</p>',
'Bonjour {{prenom}},

Intervention planifiée au {{adresse_bien}} :
Intervention : {{titre_intervention}}
Prestataire : {{nom_prestataire}}
Date : {{date_intervention}}

Merci d''assurer l''accès au logement.

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du locataire", "example": "Marie"}, {"key": "titre_intervention", "label": "Description", "example": "Réparation fuite robinet"}, {"key": "nom_prestataire", "label": "Nom du prestataire", "example": "Jacques Martin"}, {"key": "date_intervention", "label": "Date et créneau", "example": "18 mars 2026, 9h-12h"}, {"key": "adresse_bien", "label": "Adresse", "example": "12 rue des Lilas"}]'::jsonb,
0),

-- 24. Intervention terminée (propriétaire)
('intervention_completed', 'incident', 'Intervention terminée', 'Notification au propriétaire quand une intervention est finalisée', 'Intervention terminée — {{titre_intervention}}',
'<p>Bonjour {{prenom}},</p>
<p>L''intervention <strong>{{titre_intervention}}</strong> au <strong>{{adresse_bien}}</strong> a été réalisée.</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Prestataire</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{nom_prestataire}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Date</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{date_realisation}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Coût</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{cout}} €</td></tr>
</table>
<a href="{{intervention_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Voir le compte-rendu</a>',
'Bonjour {{prenom}},

Intervention terminée : {{titre_intervention}} au {{adresse_bien}}
Prestataire : {{nom_prestataire}}
Date : {{date_realisation}}
Coût : {{cout}} €

Compte-rendu : {{intervention_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du propriétaire", "example": "Thomas"}, {"key": "titre_intervention", "label": "Description", "example": "Réparation fuite robinet"}, {"key": "nom_prestataire", "label": "Prestataire", "example": "Jacques Martin"}, {"key": "adresse_bien", "label": "Adresse", "example": "12 rue des Lilas"}, {"key": "date_realisation", "label": "Date de réalisation", "example": "18 mars 2026"}, {"key": "cout", "label": "Coût", "example": "150"}, {"key": "intervention_url", "label": "Lien", "example": "https://talok.fr/owner/work-orders/..."}]'::jsonb,
0),

-- ============================================
-- CATÉGORIE : ABONNEMENT & FACTURATION (subscription)
-- ============================================

-- 25. Bienvenue abonnement
('subscription_welcome', 'subscription', 'Bienvenue abonnement', 'Email de bienvenue après souscription à un plan', 'Votre abonnement Talok {{plan}} est activé !',
'<p>Bonjour {{prenom}},</p>
<p>Votre abonnement <strong>Talok {{plan}}</strong> est maintenant actif. Merci pour votre confiance !</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Plan</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{plan}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Montant</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{montant}} € / an</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Prochain renouvellement</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{date_renouvellement}}</td></tr>
</table>
<a href="{{dashboard_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Accéder à Talok</a>',
'Bonjour {{prenom}},

Votre abonnement Talok {{plan}} est actif.
Plan : {{plan}}
Montant : {{montant}} € / an
Prochain renouvellement : {{date_renouvellement}}

Accéder à Talok : {{dashboard_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom", "example": "Thomas"}, {"key": "plan", "label": "Nom du plan", "example": "Confort"}, {"key": "montant", "label": "Montant annuel", "example": "290"}, {"key": "date_renouvellement", "label": "Date de renouvellement", "example": "12 février 2027"}, {"key": "dashboard_url", "label": "Lien dashboard", "example": "https://talok.fr/owner/dashboard"}]'::jsonb,
0),

-- 26. Abonnement expirant
('subscription_expiring', 'subscription', 'Abonnement expirant', 'Alerte avant l''expiration d''un abonnement', 'Votre abonnement Talok expire dans {{jours_restants}} jours',
'<p>Bonjour {{prenom}},</p>
<p>Votre abonnement <strong>Talok {{plan}}</strong> expire le <strong>{{date_expiration}}</strong>.</p>
<p>Pour continuer à profiter de toutes les fonctionnalités, pensez à renouveler votre abonnement.</p>
<a href="{{renewal_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Renouveler mon abonnement</a>',
'Bonjour {{prenom}},

Votre abonnement Talok {{plan}} expire le {{date_expiration}}.

Renouveler : {{renewal_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom", "example": "Thomas"}, {"key": "plan", "label": "Plan actuel", "example": "Confort"}, {"key": "date_expiration", "label": "Date d''expiration", "example": "12 mars 2026"}, {"key": "jours_restants", "label": "Jours restants", "example": "15"}, {"key": "renewal_url", "label": "Lien de renouvellement", "example": "https://talok.fr/settings/billing"}]'::jsonb,
0),

-- 27. Abonnement renouvelé
('subscription_renewed', 'subscription', 'Abonnement renouvelé', 'Confirmation de renouvellement d''abonnement', 'Abonnement Talok renouvelé',
'<p>Bonjour {{prenom}},</p>
<p>Votre abonnement <strong>Talok {{plan}}</strong> a été renouvelé avec succès.</p>
<p>Montant : <strong>{{montant}} €</strong><br>
Prochain renouvellement : {{date_renouvellement}}</p>
<a href="{{invoice_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Télécharger ma facture</a>',
'Bonjour {{prenom}},

Votre abonnement Talok {{plan}} a été renouvelé.
Montant : {{montant}} €
Prochain renouvellement : {{date_renouvellement}}

Facture : {{invoice_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom", "example": "Thomas"}, {"key": "plan", "label": "Plan", "example": "Confort"}, {"key": "montant", "label": "Montant facturé", "example": "290"}, {"key": "date_renouvellement", "label": "Prochaine échéance", "example": "12 février 2027"}, {"key": "invoice_url", "label": "Lien vers la facture", "example": "https://talok.fr/settings/billing/invoices/..."}]'::jsonb,
0),

-- 28. Échec de paiement
('payment_failed', 'subscription', 'Échec de paiement', 'Alerte lors d''un échec de paiement d''abonnement', 'Échec du paiement Talok — Action requise',
'<p>Bonjour {{prenom}},</p>
<p>Le paiement de <strong>{{montant}} €</strong> pour votre abonnement Talok a échoué.</p>
<p>Raison : {{raison}}</p>
<p>Veuillez mettre à jour vos informations de paiement pour éviter toute interruption de service.</p>
<a href="{{billing_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Mettre à jour mon moyen de paiement</a>',
'Bonjour {{prenom}},

Le paiement de {{montant}} € pour votre abonnement Talok a échoué.
Raison : {{raison}}

Mettez à jour vos informations de paiement : {{billing_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom", "example": "Thomas"}, {"key": "montant", "label": "Montant", "example": "290"}, {"key": "raison", "label": "Raison de l''échec", "example": "Carte expirée"}, {"key": "billing_url", "label": "Lien paramètres de paiement", "example": "https://talok.fr/settings/billing"}]'::jsonb,
0),

-- 29. Facture disponible
('invoice_available', 'subscription', 'Facture disponible', 'Notification quand une facture Talok est prête', 'Facture Talok n°{{numero_facture}} disponible',
'<p>Bonjour {{prenom}},</p>
<p>Votre facture Talok est disponible :</p>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Facture n°</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{numero_facture}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Date</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{date_facture}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Montant</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{montant}} €</td></tr>
</table>
<a href="{{invoice_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Télécharger la facture</a>',
'Bonjour {{prenom}},

Facture Talok disponible :
N° : {{numero_facture}}
Date : {{date_facture}}
Montant : {{montant}} €

Télécharger : {{invoice_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom", "example": "Thomas"}, {"key": "numero_facture", "label": "Numéro de facture", "example": "TLK-2026-0042"}, {"key": "montant", "label": "Montant", "example": "290"}, {"key": "date_facture", "label": "Date", "example": "12 février 2026"}, {"key": "invoice_url", "label": "Lien de téléchargement", "example": "https://talok.fr/settings/billing/invoices/..."}]'::jsonb,
0),

-- ============================================
-- CATÉGORIE : MESSAGERIE (messaging)
-- ============================================

-- 30. Nouveau message
('new_message', 'messaging', 'Nouveau message', 'Notification quand un nouveau message est reçu', 'Nouveau message de {{nom_expediteur}}',
'<p>Bonjour {{prenom}},</p>
<p><strong>{{nom_expediteur}}</strong> vous a envoyé un message :</p>
<blockquote style="border-left:4px solid #2563eb;padding:8px 16px;margin:16px 0;background:#f8fafc;">{{apercu_message}}</blockquote>
<a href="{{message_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Répondre</a>',
'Bonjour {{prenom}},

{{nom_expediteur}} vous a envoyé un message :
"{{apercu_message}}"

Répondre : {{message_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom du destinataire", "example": "Thomas"}, {"key": "nom_expediteur", "label": "Nom de l''expéditeur", "example": "Marie Martin"}, {"key": "apercu_message", "label": "Aperçu du message", "example": "Bonjour, j''ai une question concernant..."}, {"key": "message_url", "label": "Lien vers la conversation", "example": "https://talok.fr/messages/..."}]'::jsonb,
0),

-- ============================================
-- CATÉGORIE : RAPPORTS (report)
-- ============================================

-- 31. Récapitulatif mensuel propriétaire
('monthly_summary_owner', 'report', 'Récapitulatif mensuel', 'Rapport mensuel envoyé aux propriétaires', 'Récapitulatif {{mois}} {{annee}} — {{loyers_recus}} € encaissés',
'<h2>Récapitulatif du mois de {{mois}} {{annee}}</h2>
<p>Bonjour {{prenom}}, voici le résumé de votre activité locative :</p>
<h3>Finances</h3>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Loyers encaissés</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{loyers_recus}} € / {{loyers_attendus}} €</td></tr>
</table>
<h3>Patrimoine</h3>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Biens gérés</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{nb_biens}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Taux d''occupation</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{taux_occupation}} %</td></tr>
</table>
<h3>Maintenance</h3>
<table style="width:100%;border-collapse:collapse;margin:16px 0;">
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Incidents ouverts</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{nb_incidents_ouverts}}</td></tr>
  <tr><td style="padding:8px;border-bottom:1px solid #e2e8f0;font-weight:600;">Interventions ce mois</td><td style="padding:8px;border-bottom:1px solid #e2e8f0;">{{nb_interventions}}</td></tr>
</table>
<a href="{{dashboard_url}}" style="display:inline-block;padding:12px 24px;background-color:#2563eb;color:#ffffff;text-decoration:none;border-radius:6px;font-weight:600;">Voir le détail</a>',
'Bonjour {{prenom}},

Récapitulatif {{mois}} {{annee}} :

FINANCES
Loyers encaissés : {{loyers_recus}} € / {{loyers_attendus}} €

PATRIMOINE
Biens gérés : {{nb_biens}}
Taux d''occupation : {{taux_occupation}} %

MAINTENANCE
Incidents ouverts : {{nb_incidents_ouverts}}
Interventions : {{nb_interventions}}

Détail : {{dashboard_url}}

L''équipe Talok',
'[{"key": "prenom", "label": "Prénom", "example": "Thomas"}, {"key": "mois", "label": "Mois", "example": "février"}, {"key": "annee", "label": "Année", "example": "2026"}, {"key": "nb_biens", "label": "Nombre de biens", "example": "3"}, {"key": "loyers_recus", "label": "Loyers encaissés", "example": "2550"}, {"key": "loyers_attendus", "label": "Loyers attendus", "example": "2550"}, {"key": "nb_incidents_ouverts", "label": "Incidents ouverts", "example": "1"}, {"key": "nb_interventions", "label": "Interventions du mois", "example": "2"}, {"key": "taux_occupation", "label": "Taux d''occupation", "example": "100"}, {"key": "dashboard_url", "label": "Lien dashboard", "example": "https://talok.fr/owner/dashboard"}]'::jsonb,
0);

-- ========== 20260212200000_audit_v3_comprehensive_integrity.sql ==========
-- ============================================================================
-- AUDIT D'INTÉGRITÉ V3 — VÉRIFICATIONS ÉTENDUES & QUALITÉ DES DONNÉES
-- Date: 2026-02-12
-- Complète 20260212000000 + 20260212100000
-- ============================================================================
-- Ce script ajoute :
--   Phase 6 : Intégrité signatures (sessions, participants, preuves)
--   Phase 7 : Intégrité organisations & white-label
--   Phase 8 : Intégrité commercial (fonds de commerce, location-gérance)
--   Phase 9 : Qualité des données (champs obligatoires, cohérence métier)
--   Phase 10 : Rapport d'audit unifié (score global)
-- ============================================================================
-- PRÉREQUIS : 20260212000000 + 20260212100000 déjà appliqués
-- ============================================================================


-- ============================================================================
-- PHASE 6 : INTÉGRITÉ DES SIGNATURES
-- ============================================================================

CREATE OR REPLACE FUNCTION audit_signature_integrity()
RETURNS TABLE(
  check_name TEXT,
  source_table TEXT,
  issue_count BIGINT,
  severity TEXT,
  description TEXT,
  sample_ids TEXT
) AS $$
BEGIN

  -- Sessions sans participants
  RETURN QUERY
  SELECT 'sessions_without_participants'::TEXT,
    'signature_sessions'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Sessions de signature actives sans aucun participant'::TEXT,
    string_agg(ss.id::TEXT, ', ' ORDER BY ss.created_at LIMIT 5)::TEXT
  FROM signature_sessions ss
  WHERE ss.status IN ('pending', 'ongoing')
    AND NOT EXISTS (SELECT 1 FROM signature_participants sp WHERE sp.session_id = ss.id);

  -- Participants orphelins (session supprimée)
  RETURN QUERY
  SELECT 'orphan_participants'::TEXT,
    'signature_participants'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Participants dont la session de signature n''existe plus'::TEXT,
    string_agg(sp.id::TEXT, ', ' ORDER BY sp.created_at LIMIT 5)::TEXT
  FROM signature_participants sp
  WHERE NOT EXISTS (SELECT 1 FROM signature_sessions ss WHERE ss.id = sp.session_id);

  -- Preuves orphelines (participant supprimé)
  RETURN QUERY
  SELECT 'orphan_proofs'::TEXT,
    'signature_proofs'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Preuves de signature dont le participant n''existe plus'::TEXT,
    string_agg(sp.id::TEXT, ', ' ORDER BY sp.created_at LIMIT 5)::TEXT
  FROM signature_proofs sp
  WHERE NOT EXISTS (SELECT 1 FROM signature_participants pa WHERE pa.id = sp.participant_id);

  -- Sessions "done" sans preuve pour tous les participants signés
  RETURN QUERY
  SELECT 'done_sessions_missing_proofs'::TEXT,
    'signature_sessions'::TEXT,
    COUNT(DISTINCT ss.id)::BIGINT,
    'HIGH'::TEXT,
    'Sessions terminées avec des participants signés sans preuve eIDAS'::TEXT,
    string_agg(DISTINCT ss.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM signature_sessions ss
  JOIN signature_participants sp ON sp.session_id = ss.id
  WHERE ss.status = 'done'
    AND sp.status = 'signed'
    AND NOT EXISTS (
      SELECT 1 FROM signature_proofs pr WHERE pr.participant_id = sp.id
    );

  -- Sessions expirées non marquées
  RETURN QUERY
  SELECT 'expired_sessions_not_marked'::TEXT,
    'signature_sessions'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Sessions avec deadline dépassée mais statut non-expiré'::TEXT,
    string_agg(ss.id::TEXT, ', ' ORDER BY ss.deadline LIMIT 5)::TEXT
  FROM signature_sessions ss
  WHERE ss.deadline < NOW()
    AND ss.status IN ('pending', 'ongoing');

  -- Audit log orphelin
  RETURN QUERY
  SELECT 'orphan_audit_log'::TEXT,
    'signature_audit_log'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Logs d''audit dont la session n''existe plus'::TEXT,
    NULL::TEXT
  FROM signature_audit_log sal
  WHERE NOT EXISTS (SELECT 1 FROM signature_sessions ss WHERE ss.id = sal.session_id);

  -- Participants avec profile_id invalide
  RETURN QUERY
  SELECT 'participant_invalid_profile'::TEXT,
    'signature_participants'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Participants avec un profile_id pointant vers un profil inexistant'::TEXT,
    string_agg(sp.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM signature_participants sp
  WHERE sp.profile_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM profiles p WHERE p.id = sp.profile_id);

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION audit_signature_integrity() IS
  'Vérifie l''intégrité du système de signatures (sessions, participants, preuves eIDAS).';


-- ============================================================================
-- PHASE 7 : INTÉGRITÉ ORGANISATIONS & WHITE-LABEL
-- ============================================================================

CREATE OR REPLACE FUNCTION audit_organization_integrity()
RETURNS TABLE(
  check_name TEXT,
  source_table TEXT,
  issue_count BIGINT,
  severity TEXT,
  description TEXT,
  sample_ids TEXT
) AS $$
BEGIN

  -- Organisations sans owner
  RETURN QUERY
  SELECT 'org_without_owner'::TEXT,
    'organizations'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Organisations dont le propriétaire (auth.users) n''existe plus'::TEXT,
    string_agg(o.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM organizations o
  WHERE NOT EXISTS (SELECT 1 FROM auth.users u WHERE u.id = o.owner_id);

  -- Membres orphelins (org supprimée)
  RETURN QUERY
  SELECT 'orphan_members'::TEXT,
    'organization_members'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Membres d''organisation dont l''organisation n''existe plus'::TEXT,
    string_agg(om.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM organization_members om
  WHERE NOT EXISTS (SELECT 1 FROM organizations o WHERE o.id = om.organization_id);

  -- Membres orphelins (user supprimé)
  RETURN QUERY
  SELECT 'member_invalid_user'::TEXT,
    'organization_members'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Membres d''organisation dont le user_id n''existe plus'::TEXT,
    string_agg(om.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM organization_members om
  WHERE NOT EXISTS (SELECT 1 FROM auth.users u WHERE u.id = om.user_id);

  -- Branding orphelin
  RETURN QUERY
  SELECT 'orphan_branding'::TEXT,
    'organization_branding'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Branding d''organisation dont l''organisation n''existe plus'::TEXT,
    string_agg(ob.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM organization_branding ob
  WHERE NOT EXISTS (SELECT 1 FROM organizations o WHERE o.id = ob.organization_id);

  -- Domaines personnalisés orphelins
  RETURN QUERY
  SELECT 'orphan_domains'::TEXT,
    'custom_domains'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Domaines personnalisés dont l''organisation n''existe plus'::TEXT,
    string_agg(cd.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM custom_domains cd
  WHERE NOT EXISTS (SELECT 1 FROM organizations o WHERE o.id = cd.organization_id);

  -- Orgs actives sans branding
  RETURN QUERY
  SELECT 'active_org_no_branding'::TEXT,
    'organizations'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Organisations actives en mode white-label sans branding configuré'::TEXT,
    string_agg(o.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM organizations o
  WHERE o.is_active = true
    AND o.white_label_level != 'none'
    AND NOT EXISTS (SELECT 1 FROM organization_branding ob WHERE ob.organization_id = o.id);

  -- Domaines actifs avec SSL expiré
  RETURN QUERY
  SELECT 'expired_ssl'::TEXT,
    'custom_domains'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Domaines actifs avec certificat SSL expiré'::TEXT,
    string_agg(cd.domain, ', ' LIMIT 5)::TEXT
  FROM custom_domains cd
  WHERE cd.is_active = true
    AND cd.verified = true
    AND cd.ssl_expires_at IS NOT NULL
    AND cd.ssl_expires_at < NOW();

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION audit_organization_integrity() IS
  'Vérifie l''intégrité du système multi-tenant et white-label.';


-- ============================================================================
-- PHASE 8 : INTÉGRITÉ COMMERCIAL (FONDS DE COMMERCE, LOCATION-GÉRANCE)
-- ============================================================================

CREATE OR REPLACE FUNCTION audit_commercial_integrity()
RETURNS TABLE(
  check_name TEXT,
  source_table TEXT,
  issue_count BIGINT,
  severity TEXT,
  description TEXT,
  sample_ids TEXT
) AS $$
BEGIN

  -- Fonds de commerce sans owner
  RETURN QUERY
  SELECT 'fonds_without_owner'::TEXT,
    'fonds_commerce'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Fonds de commerce dont le propriétaire n''existe plus'::TEXT,
    string_agg(fc.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM fonds_commerce fc
  WHERE NOT EXISTS (SELECT 1 FROM auth.users u WHERE u.id = fc.owner_id);

  -- Fonds avec bail_commercial_id invalide
  RETURN QUERY
  SELECT 'fonds_invalid_bail'::TEXT,
    'fonds_commerce'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Fonds avec bail_commercial_id pointant vers un bail inexistant'::TEXT,
    string_agg(fc.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM fonds_commerce fc
  WHERE fc.bail_commercial_id IS NOT NULL
    AND NOT EXISTS (SELECT 1 FROM leases l WHERE l.id = fc.bail_commercial_id);

  -- Licences orphelines
  RETURN QUERY
  SELECT 'orphan_licences'::TEXT,
    'fonds_commerce_licences'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Licences dont le fonds de commerce n''existe plus'::TEXT,
    string_agg(fcl.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM fonds_commerce_licences fcl
  WHERE NOT EXISTS (SELECT 1 FROM fonds_commerce fc WHERE fc.id = fcl.fonds_id);

  -- Équipements orphelins
  RETURN QUERY
  SELECT 'orphan_equipements'::TEXT,
    'fonds_commerce_equipements'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Équipements dont le fonds de commerce n''existe plus'::TEXT,
    string_agg(fce.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM fonds_commerce_equipements fce
  WHERE NOT EXISTS (SELECT 1 FROM fonds_commerce fc WHERE fc.id = fce.fonds_id);

  -- Contrats location-gérance avec fonds supprimé
  RETURN QUERY
  SELECT 'gerance_orphan_fonds'::TEXT,
    'location_gerance_contracts'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Contrats de location-gérance dont le fonds n''existe plus'::TEXT,
    string_agg(lgc.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM location_gerance_contracts lgc
  WHERE NOT EXISTS (SELECT 1 FROM fonds_commerce fc WHERE fc.id = lgc.fonds_id);

  -- Redevances orphelines
  RETURN QUERY
  SELECT 'orphan_redevances'::TEXT,
    'location_gerance_redevances'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Redevances dont le contrat de location-gérance n''existe plus'::TEXT,
    string_agg(lgr.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM location_gerance_redevances lgr
  WHERE NOT EXISTS (SELECT 1 FROM location_gerance_contracts lgc WHERE lgc.id = lgr.contract_id);

  -- Contrats actifs avec date_fin dépassée
  RETURN QUERY
  SELECT 'expired_contracts_active'::TEXT,
    'location_gerance_contracts'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Contrats location-gérance actifs avec date_fin dépassée'::TEXT,
    string_agg(lgc.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM location_gerance_contracts lgc
  WHERE lgc.status = 'active'
    AND lgc.date_fin IS NOT NULL
    AND lgc.date_fin < CURRENT_DATE;

  -- Redevances impayées > 90 jours
  RETURN QUERY
  SELECT 'overdue_redevances'::TEXT,
    'location_gerance_redevances'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Redevances impayées depuis plus de 90 jours'::TEXT,
    string_agg(lgr.id::TEXT, ', ' LIMIT 5)::TEXT
  FROM location_gerance_redevances lgr
  WHERE lgr.statut IN ('pending', 'late')
    AND lgr.date_echeance < CURRENT_DATE - INTERVAL '90 days';

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION audit_commercial_integrity() IS
  'Vérifie l''intégrité des fonds de commerce et contrats de location-gérance.';


-- ============================================================================
-- PHASE 9 : QUALITÉ DES DONNÉES & COHÉRENCE MÉTIER
-- ============================================================================

CREATE OR REPLACE FUNCTION audit_data_quality()
RETURNS TABLE(
  check_name TEXT,
  source_table TEXT,
  issue_count BIGINT,
  severity TEXT,
  description TEXT
) AS $$
BEGIN

  -- ── PROFILS ──────────────────────────────────────────────────────────

  -- Profils sans email
  RETURN QUERY
  SELECT 'profile_missing_email'::TEXT,
    'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Profils sans adresse email'::TEXT
  FROM profiles p
  WHERE (p.email IS NULL OR TRIM(p.email) = '');

  -- Profils sans nom
  RETURN QUERY
  SELECT 'profile_missing_name'::TEXT,
    'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Profils sans nom renseigné'::TEXT
  FROM profiles p
  WHERE (p.nom IS NULL OR TRIM(p.nom) = '');

  -- Profils owner sans owner_profiles
  RETURN QUERY
  SELECT 'owner_without_owner_profile'::TEXT,
    'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Profils avec role=owner sans enregistrement owner_profiles associé'::TEXT
  FROM profiles p
  WHERE p.role = 'owner'
    AND NOT EXISTS (SELECT 1 FROM owner_profiles op WHERE op.profile_id = p.id);

  -- Profils tenant sans tenant_profiles
  RETURN QUERY
  SELECT 'tenant_without_tenant_profile'::TEXT,
    'profiles'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Profils avec role=tenant sans enregistrement tenant_profiles associé'::TEXT
  FROM profiles p
  WHERE p.role = 'tenant'
    AND NOT EXISTS (SELECT 1 FROM tenant_profiles tp WHERE tp.profile_id = p.id);

  -- ── PROPRIÉTÉS ───────────────────────────────────────────────────────

  -- Propriétés sans adresse
  RETURN QUERY
  SELECT 'property_missing_address'::TEXT,
    'properties'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Propriétés sans adresse complète'::TEXT
  FROM properties p
  WHERE p.deleted_at IS NULL
    AND (p.adresse_complete IS NULL OR TRIM(p.adresse_complete) = '');

  -- Propriétés sans code postal
  RETURN QUERY
  SELECT 'property_missing_postal_code'::TEXT,
    'properties'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Propriétés sans code postal'::TEXT
  FROM properties p
  WHERE p.deleted_at IS NULL
    AND (p.code_postal IS NULL OR TRIM(p.code_postal) = '');

  -- Propriétés avec surface <= 0
  RETURN QUERY
  SELECT 'property_invalid_surface'::TEXT,
    'properties'::TEXT,
    COUNT(*)::BIGINT,
    'LOW'::TEXT,
    'Propriétés avec surface <= 0 ou NULL'::TEXT
  FROM properties p
  WHERE p.deleted_at IS NULL
    AND (p.surface IS NULL OR p.surface <= 0);

  -- ── BAUX ─────────────────────────────────────────────────────────────

  -- Baux actifs sans owner_id ET sans tenant_id
  RETURN QUERY
  SELECT 'lease_no_parties'::TEXT,
    'leases'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Baux actifs sans propriétaire NI locataire'::TEXT
  FROM leases l
  WHERE l.statut NOT IN ('draft', 'cancelled', 'archived')
    AND l.owner_id IS NULL
    AND l.tenant_id IS NULL;

  -- Baux avec date_fin < date_debut
  RETURN QUERY
  SELECT 'lease_invalid_dates'::TEXT,
    'leases'::TEXT,
    COUNT(*)::BIGINT,
    'CRITICAL'::TEXT,
    'Baux avec date_fin antérieure à date_debut'::TEXT
  FROM leases l
  WHERE l.date_fin IS NOT NULL
    AND l.date_fin < l.date_debut;

  -- Baux actifs avec loyer <= 0
  RETURN QUERY
  SELECT 'lease_invalid_rent'::TEXT,
    'leases'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Baux actifs avec loyer <= 0 ou NULL'::TEXT
  FROM leases l
  WHERE l.statut IN ('active', 'fully_signed')
    AND (l.loyer IS NULL OR l.loyer <= 0);

  -- Baux terminés mais toujours marqués actifs (date_fin dépassée > 30j)
  RETURN QUERY
  SELECT 'lease_should_be_terminated'::TEXT,
    'leases'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Baux actifs avec date_fin dépassée de plus de 30 jours'::TEXT
  FROM leases l
  WHERE l.statut IN ('active', 'fully_signed')
    AND l.date_fin IS NOT NULL
    AND l.date_fin < CURRENT_DATE - INTERVAL '30 days';

  -- ── FACTURES ─────────────────────────────────────────────────────────

  -- Factures avec montant négatif
  RETURN QUERY
  SELECT 'invoice_negative_amount'::TEXT,
    'invoices'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Factures avec montant_total négatif'::TEXT
  FROM invoices i
  WHERE i.montant_total < 0;

  -- Factures "paid" sans aucun paiement
  RETURN QUERY
  SELECT 'invoice_paid_no_payment'::TEXT,
    'invoices'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Factures marquées payées sans aucun enregistrement de paiement'::TEXT
  FROM invoices i
  WHERE i.statut = 'paid'
    AND NOT EXISTS (SELECT 1 FROM payments py WHERE py.invoice_id = i.id);

  -- Factures envoyées mais bail terminé/annulé
  RETURN QUERY
  SELECT 'invoice_on_terminated_lease'::TEXT,
    'invoices'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Factures non-payées sur des baux terminés ou annulés'::TEXT
  FROM invoices i
  JOIN leases l ON l.id = i.lease_id
  WHERE i.statut NOT IN ('paid', 'cancelled')
    AND l.statut IN ('terminated', 'cancelled', 'archived');

  -- ── DOCUMENTS ────────────────────────────────────────────────────────

  -- Documents expirés non marqués
  RETURN QUERY
  SELECT 'document_expired_not_flagged'::TEXT,
    'documents'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Documents avec valid_until dépassé mais statut toujours actif'::TEXT
  FROM documents d
  WHERE d.valid_until IS NOT NULL
    AND d.valid_until < CURRENT_DATE
    AND d.ged_status = 'active';

  -- Documents obligatoires manquants pour baux actifs
  RETURN QUERY
  SELECT 'lease_missing_mandatory_docs'::TEXT,
    'leases'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Baux actifs sans document de type bail attaché'::TEXT
  FROM leases l
  WHERE l.statut IN ('active', 'fully_signed')
    AND NOT EXISTS (
      SELECT 1 FROM documents d
      WHERE d.lease_id = l.id AND d.type = 'bail'
    );

  -- ── DÉPÔTS DE GARANTIE ──────────────────────────────────────────────

  -- Baux actifs sans mouvement de dépôt
  RETURN QUERY
  SELECT 'lease_missing_deposit'::TEXT,
    'leases'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Baux actifs avec dépôt de garantie > 0 mais sans mouvement de dépôt'::TEXT
  FROM leases l
  WHERE l.statut IN ('active', 'fully_signed')
    AND l.depot_de_garantie IS NOT NULL
    AND l.depot_de_garantie > 0
    AND NOT EXISTS (SELECT 1 FROM deposit_movements dm WHERE dm.lease_id = l.id);

  -- ── ENTITÉS LÉGALES ─────────────────────────────────────────────────

  -- Entités actives sans gérant
  RETURN QUERY
  SELECT 'entity_no_manager'::TEXT,
    'legal_entities'::TEXT,
    COUNT(*)::BIGINT,
    'MEDIUM'::TEXT,
    'Entités légales actives de type société sans gérant désigné'::TEXT
  FROM legal_entities le
  WHERE le.is_active = true
    AND le.entity_type NOT IN ('particulier', 'indivision')
    AND NOT EXISTS (
      SELECT 1 FROM entity_associates ea
      WHERE ea.legal_entity_id = le.id AND ea.is_gerant = true AND ea.is_current = true
    );

  -- Détention totale != 100% par propriété
  RETURN QUERY
  SELECT 'ownership_not_100_percent'::TEXT,
    'property_ownership'::TEXT,
    COUNT(*)::BIGINT,
    'HIGH'::TEXT,
    'Propriétés dont la somme des pourcentages de détention != 100%'::TEXT
  FROM (
    SELECT po.property_id, SUM(po.pourcentage_detention) AS total
    FROM property_ownership po
    WHERE po.is_current = true
    GROUP BY po.property_id
    HAVING ABS(SUM(po.pourcentage_detention) - 100) > 0.01
  ) sub;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION audit_data_quality() IS
  'Vérifie la qualité et la cohérence métier des données (champs manquants, incohérences).';


-- ============================================================================
-- PHASE 10 : RAPPORT UNIFIÉ + SCORE DE SANTÉ
-- ============================================================================

CREATE OR REPLACE FUNCTION audit_full_report()
RETURNS TABLE(
  category TEXT,
  check_name TEXT,
  source_table TEXT,
  issue_count BIGINT,
  severity TEXT,
  description TEXT
) AS $$
BEGIN

  -- Orphelins (V1)
  RETURN QUERY
  SELECT 'ORPHANS'::TEXT, aor.fk_column, aor.source_table, aor.orphan_count, aor.severity, aor.description
  FROM audit_orphan_records() aor
  WHERE aor.orphan_count > 0;

  -- Doublons (V1)
  RETURN QUERY
  SELECT 'DUPLICATES'::TEXT, adr.duplicate_key, adr.table_name, adr.duplicate_count, adr.severity, adr.description
  FROM audit_duplicate_records() adr;

  -- Signatures (V3)
  RETURN QUERY
  SELECT 'SIGNATURES'::TEXT, asi.check_name, asi.source_table, asi.issue_count, asi.severity, asi.description
  FROM audit_signature_integrity() asi
  WHERE asi.issue_count > 0;

  -- Organisations (V3)
  RETURN QUERY
  SELECT 'ORGANIZATIONS'::TEXT, aoi.check_name, aoi.source_table, aoi.issue_count, aoi.severity, aoi.description
  FROM audit_organization_integrity() aoi
  WHERE aoi.issue_count > 0;

  -- Commercial (V3)
  RETURN QUERY
  SELECT 'COMMERCIAL'::TEXT, aci.check_name, aci.source_table, aci.issue_count, aci.severity, aci.description
  FROM audit_commercial_integrity() aci
  WHERE aci.issue_count > 0;

  -- Qualité (V3)
  RETURN QUERY
  SELECT 'DATA_QUALITY'::TEXT, adq.check_name, adq.source_table, adq.issue_count, adq.severity, adq.description
  FROM audit_data_quality() adq
  WHERE adq.issue_count > 0;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION audit_full_report() IS
  'Rapport d''audit complet combinant toutes les vérifications (orphelins, doublons, signatures, orga, commercial, qualité).';


-- Score de santé global (0-100)
CREATE OR REPLACE FUNCTION audit_health_score()
RETURNS TABLE(
  total_checks INTEGER,
  passed_checks INTEGER,
  critical_issues INTEGER,
  high_issues INTEGER,
  medium_issues INTEGER,
  low_issues INTEGER,
  health_score NUMERIC(5,2),
  grade TEXT
) AS $$
DECLARE
  v_total INTEGER := 0;
  v_passed INTEGER := 0;
  v_critical INTEGER := 0;
  v_high INTEGER := 0;
  v_medium INTEGER := 0;
  v_low INTEGER := 0;
  v_score NUMERIC(5,2);
  r RECORD;
BEGIN
  FOR r IN SELECT * FROM audit_full_report() LOOP
    v_total := v_total + 1;
    CASE r.severity
      WHEN 'CRITICAL' THEN v_critical := v_critical + 1;
      WHEN 'HIGH' THEN v_high := v_high + 1;
      WHEN 'MEDIUM' THEN v_medium := v_medium + 1;
      WHEN 'LOW' THEN v_low := v_low + 1;
      ELSE NULL;
    END CASE;
  END LOOP;

  -- Compter le total attendu de checks (orphelins + doublons + signatures + orga + commercial + qualité)
  -- On considère les catégories, pas les résultats
  v_total := v_total + 20; -- base checks that can pass silently
  v_passed := v_total - (v_critical + v_high + v_medium + v_low);

  -- Score : chaque sévérité a un poids
  -- CRITICAL = -10, HIGH = -5, MEDIUM = -2, LOW = -0.5
  v_score := GREATEST(0, LEAST(100,
    100.0
    - (v_critical * 10.0)
    - (v_high * 5.0)
    - (v_medium * 2.0)
    - (v_low * 0.5)
  ));

  total_checks := v_total;
  passed_checks := v_passed;
  critical_issues := v_critical;
  high_issues := v_high;
  medium_issues := v_medium;
  low_issues := v_low;
  health_score := v_score;
  grade := CASE
    WHEN v_score >= 95 THEN 'A+'
    WHEN v_score >= 90 THEN 'A'
    WHEN v_score >= 80 THEN 'B'
    WHEN v_score >= 70 THEN 'C'
    WHEN v_score >= 50 THEN 'D'
    ELSE 'F'
  END;
  RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION audit_health_score() IS
  'Retourne un score de santé global de la base (0-100) avec une note A+ à F.';


-- ============================================================================
-- LOGS DE MIGRATION
-- ============================================================================
DO $$
BEGIN
  RAISE NOTICE '══════════════════════════════════════════════════════════════';
  RAISE NOTICE '  AUDIT V3 — Vérifications étendues installées';
  RAISE NOTICE '══════════════════════════════════════════════════════════════';
  RAISE NOTICE '';
  RAISE NOTICE '  Phase 6 — Intégrité signatures :';
  RAISE NOTICE '    SELECT * FROM audit_signature_integrity();';
  RAISE NOTICE '';
  RAISE NOTICE '  Phase 7 — Intégrité organisations :';
  RAISE NOTICE '    SELECT * FROM audit_organization_integrity();';
  RAISE NOTICE '';
  RAISE NOTICE '  Phase 8 — Intégrité commercial :';
  RAISE NOTICE '    SELECT * FROM audit_commercial_integrity();';
  RAISE NOTICE '';
  RAISE NOTICE '  Phase 9 — Qualité des données :';
  RAISE NOTICE '    SELECT * FROM audit_data_quality();';
  RAISE NOTICE '';
  RAISE NOTICE '  Phase 10 — Rapport unifié + Score :';
  RAISE NOTICE '    SELECT * FROM audit_full_report();';
  RAISE NOTICE '    SELECT * FROM audit_health_score();';
  RAISE NOTICE '══════════════════════════════════════════════════════════════';
END $$;

-- ========== 20260213000000_fix_profiles_rls_recursion_v2.sql ==========
-- =====================================================
-- MIGRATION: Correction définitive de la récursion RLS sur profiles (v2)
-- Date: 2026-02-13
-- Problème: "RLS recursion detected" - erreur 500 sur profiles
--
-- CAUSE: Les politiques RLS sur `profiles` appellent des fonctions
--        qui requêtent `profiles`, créant une boucle infinie (42P17).
--
-- SOLUTION:
--   1. Fonctions SECURITY DEFINER qui bypassen les RLS
--   2. Politiques RLS simplifiées utilisant auth.uid() directement
--   3. Pas de sous-requête vers profiles dans les politiques profiles
-- =====================================================

-- 1. DÉSACTIVER TEMPORAIREMENT RLS POUR LE NETTOYAGE
ALTER TABLE profiles DISABLE ROW LEVEL SECURITY;

-- 2. SUPPRIMER TOUTES LES ANCIENNES POLITIQUES SUR profiles
DO $$
DECLARE
  pol RECORD;
BEGIN
  FOR pol IN
    SELECT policyname
    FROM pg_policies
    WHERE tablename = 'profiles' AND schemaname = 'public'
  LOOP
    EXECUTE format('DROP POLICY IF EXISTS %I ON profiles', pol.policyname);
  END LOOP;
END $$;

-- 3. CRÉER/REMPLACER LES FONCTIONS HELPER (SECURITY DEFINER = bypass RLS)
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM profiles
    WHERE user_id = auth.uid()
    AND role = 'admin'
    LIMIT 1
  );
$$;

CREATE OR REPLACE FUNCTION public.get_my_role()
RETURNS TEXT
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT COALESCE(
    (SELECT role FROM profiles WHERE user_id = auth.uid() LIMIT 1),
    'anonymous'
  );
$$;

CREATE OR REPLACE FUNCTION public.get_my_profile_id()
RETURNS UUID
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT id FROM profiles WHERE user_id = auth.uid() LIMIT 1;
$$;

CREATE OR REPLACE FUNCTION public.user_profile_id()
RETURNS UUID
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT public.get_my_profile_id();
$$;

CREATE OR REPLACE FUNCTION public.user_role()
RETURNS TEXT
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT public.get_my_role();
$$;

-- Versions avec paramètre (pour usage admin)
CREATE OR REPLACE FUNCTION public.user_profile_id(p_user_id UUID)
RETURNS UUID
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT id FROM profiles WHERE user_id = p_user_id LIMIT 1;
$$;

CREATE OR REPLACE FUNCTION public.user_role(p_user_id UUID)
RETURNS TEXT
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT COALESCE(role, 'anonymous') FROM profiles WHERE user_id = p_user_id LIMIT 1;
$$;

-- 4. RÉACTIVER RLS
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- 5. CRÉER LES NOUVELLES POLITIQUES (SANS RÉCURSION)

-- Politique principale : chaque utilisateur peut voir/modifier son propre profil
-- Utilise auth.uid() directement, aucune sous-requête vers profiles
CREATE POLICY "profiles_own_access" ON profiles
FOR ALL TO authenticated
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());

-- Politique admin : les admins peuvent voir tous les profils
-- is_admin() est SECURITY DEFINER donc bypasse les RLS
CREATE POLICY "profiles_admin_read" ON profiles
FOR SELECT TO authenticated
USING (public.is_admin());

-- Politique propriétaire : peut voir les profils de ses locataires
-- get_my_profile_id() est SECURITY DEFINER donc bypasse les RLS
CREATE POLICY "profiles_owner_read_tenants" ON profiles
FOR SELECT TO authenticated
USING (
  EXISTS (
    SELECT 1
    FROM lease_signers ls
    INNER JOIN leases l ON l.id = ls.lease_id
    INNER JOIN properties p ON p.id = l.property_id
    WHERE ls.profile_id = profiles.id
    AND p.owner_id = public.get_my_profile_id()
  )
);

-- 6. ACCORDER LES PERMISSIONS SUR LES FONCTIONS
GRANT EXECUTE ON FUNCTION public.is_admin() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_my_role() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_my_profile_id() TO authenticated;
GRANT EXECUTE ON FUNCTION public.user_profile_id() TO authenticated;
GRANT EXECUTE ON FUNCTION public.user_role() TO authenticated;
GRANT EXECUTE ON FUNCTION public.user_profile_id(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.user_role(UUID) TO authenticated;

-- Permissions pour anon (nécessaire pour certaines requêtes pré-auth)
GRANT EXECUTE ON FUNCTION public.is_admin() TO anon;
GRANT EXECUTE ON FUNCTION public.get_my_role() TO anon;
GRANT EXECUTE ON FUNCTION public.get_my_profile_id() TO anon;
GRANT EXECUTE ON FUNCTION public.user_profile_id() TO anon;
GRANT EXECUTE ON FUNCTION public.user_role() TO anon;

-- 7. S'assurer que RLS est activé (SANS FORCE pour que SECURITY DEFINER fonctionne)
-- IMPORTANT: Ne PAS utiliser FORCE ROW LEVEL SECURITY car cela forcerait
-- les politiques RLS même pour le propriétaire de la table (postgres),
-- ce qui casserait les fonctions SECURITY DEFINER et causerait la récursion.
-- Le service_role bypass RLS par défaut dans Supabase.
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- ========== 20260213100000_fix_rls_all_tables_recursion.sql ==========
-- =====================================================
-- MIGRATION: Correction globale de la récursion RLS
-- Date: 2026-02-13
-- Problème: Les politiques RLS de subscriptions, notifications et
--           d'autres tables font des sous-requêtes directes sur `profiles`
--           ce qui déclenche l'évaluation RLS sur profiles → récursion (42P17).
--
-- SOLUTION: Remplacer toutes les sous-requêtes `SELECT id FROM profiles WHERE user_id = auth.uid()`
--           par l'appel à `public.get_my_profile_id()` (SECURITY DEFINER, bypass RLS).
-- =====================================================

-- ============================================
-- 0. CORRIGER profiles : retirer FORCE si présent
-- ============================================
-- FORCE ROW LEVEL SECURITY fait que même le propriétaire de la table (postgres)
-- est soumis aux RLS, ce qui casse les fonctions SECURITY DEFINER.
ALTER TABLE profiles NO FORCE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- ============================================
-- 1. CORRIGER subscriptions
-- ============================================
DROP POLICY IF EXISTS "Owners can view their subscription" ON subscriptions;
DROP POLICY IF EXISTS "Admins can view all subscriptions" ON subscriptions;

-- Propriétaire voit son abonnement (utilise get_my_profile_id au lieu de sous-requête)
CREATE POLICY "Owners can view their subscription" ON subscriptions
  FOR SELECT TO authenticated
  USING (owner_id = public.get_my_profile_id());

-- Admins voient tout (utilise is_admin qui est SECURITY DEFINER)
CREATE POLICY "Admins can view all subscriptions" ON subscriptions
  FOR ALL TO authenticated
  USING (public.is_admin());

-- ============================================
-- 2. CORRIGER subscription_invoices
-- ============================================
DROP POLICY IF EXISTS "Owners can view their invoices" ON subscription_invoices;

CREATE POLICY "Owners can view their invoices" ON subscription_invoices
  FOR SELECT TO authenticated
  USING (
    subscription_id IN (
      SELECT id FROM subscriptions
      WHERE owner_id = public.get_my_profile_id()
    )
  );

-- ============================================
-- 3. CORRIGER subscription_usage
-- ============================================
DROP POLICY IF EXISTS "Owners can view their usage" ON subscription_usage;

CREATE POLICY "Owners can view their usage" ON subscription_usage
  FOR SELECT TO authenticated
  USING (
    subscription_id IN (
      SELECT id FROM subscriptions
      WHERE owner_id = public.get_my_profile_id()
    )
  );

-- ============================================
-- 4. CORRIGER notifications
-- ============================================
-- Supprimer TOUTES les anciennes politiques de notifications pour repartir proprement
DO $$
DECLARE
  pol RECORD;
BEGIN
  FOR pol IN
    SELECT policyname
    FROM pg_policies
    WHERE tablename = 'notifications' AND schemaname = 'public'
  LOOP
    EXECUTE format('DROP POLICY IF EXISTS %I ON notifications', pol.policyname);
  END LOOP;
END $$;

ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- Lecture : l'utilisateur voit ses propres notifications
-- Utilise auth.uid() directement et get_my_profile_id() pour recipient_id/profile_id
CREATE POLICY "notifications_select_own" ON notifications
  FOR SELECT TO authenticated
  USING (
    user_id = auth.uid()
    OR recipient_id = public.get_my_profile_id()
    OR profile_id = public.get_my_profile_id()
  );

-- Mise à jour : l'utilisateur peut modifier ses propres notifications
CREATE POLICY "notifications_update_own" ON notifications
  FOR UPDATE TO authenticated
  USING (
    user_id = auth.uid()
    OR recipient_id = public.get_my_profile_id()
    OR profile_id = public.get_my_profile_id()
  );

-- Suppression : l'utilisateur peut supprimer ses propres notifications
CREATE POLICY "notifications_delete_own" ON notifications
  FOR DELETE TO authenticated
  USING (
    user_id = auth.uid()
    OR recipient_id = public.get_my_profile_id()
    OR profile_id = public.get_my_profile_id()
  );

-- Insertion : le système peut insérer des notifications
CREATE POLICY "notifications_insert_system" ON notifications
  FOR INSERT
  WITH CHECK (true);

-- ============================================
-- 5. VÉRIFICATION : lister les politiques restantes avec sous-requête profiles
-- ============================================
-- Note: Les tables ci-dessous ont aussi des sous-requêtes sur profiles dans leurs
-- politiques RLS. Elles sont moins critiques car elles ne sont pas appelées
-- en cascade depuis profiles, mais pour la robustesse on les corrige aussi.

-- Cette requête est un diagnostic, elle n'échouera pas si les tables n'existent pas
DO $$
BEGIN
  RAISE NOTICE '=== Migration RLS globale appliquée avec succès ===';
  RAISE NOTICE 'Tables corrigées: profiles, subscriptions, subscription_invoices, subscription_usage, notifications';
  RAISE NOTICE 'Méthode: get_my_profile_id() SECURITY DEFINER au lieu de sous-requêtes directes';
END $$;

-- ========== 20260215100000_signature_security_audit_fixes.sql ==========
-- ============================================================================
-- MIGRATION: Corrections audit sécurité signatures (2026-02-15)
-- ============================================================================
-- 
-- Fixes appliqués :
-- P1-3: Suppression de la colonne signature_image (base64) de lease_signers
-- P1-6: Harmonisation du requirement CNI (décision: CNI optionnel partout)
-- P0-4: Vérification de la contrainte CHECK sur les statuts de bail
--
-- IMPORTANT: Migration NON-DESTRUCTIVE (soft delete avec renommage)
-- ============================================================================

BEGIN;

-- ============================================================================
-- P1-3: Renommer signature_image → _signature_image_deprecated
-- ============================================================================
-- On ne supprime pas immédiatement pour éviter les erreurs d'application
-- pendant le déploiement. La colonne sera supprimée dans une migration future.

DO $$
BEGIN
  -- Vérifier si la colonne existe avant de la renommer
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'lease_signers' 
    AND column_name = 'signature_image'
    AND table_schema = 'public'
  ) THEN
    -- Renommer plutôt que supprimer (rollback possible)
    ALTER TABLE lease_signers RENAME COLUMN signature_image TO _signature_image_deprecated;
    
    COMMENT ON COLUMN lease_signers._signature_image_deprecated IS 
      'DEPRECATED 2026-02-15: Utiliser signature_image_path (Storage) à la place. '
      'Cette colonne sera supprimée lors de la prochaine migration majeure.';
    
    RAISE NOTICE 'Colonne lease_signers.signature_image renommée en _signature_image_deprecated';
  ELSE
    RAISE NOTICE 'Colonne lease_signers.signature_image déjà absente ou renommée';
  END IF;
END $$;

-- ============================================================================
-- P0-4: S'assurer que les statuts de bail incluent tous ceux utilisés par le code
-- ============================================================================
-- Le code utilise ces statuts : draft, pending_signature, partially_signed,
-- fully_signed, active, terminated, archived, cancelled
-- 
-- Vérifier et mettre à jour la contrainte CHECK si nécessaire

DO $$
DECLARE
  v_constraint_name TEXT;
BEGIN
  -- Trouver le nom de la contrainte CHECK sur statut
  SELECT conname INTO v_constraint_name
  FROM pg_constraint
  WHERE conrelid = 'leases'::regclass
    AND contype = 'c'
    AND pg_get_constraintdef(oid) ILIKE '%statut%';

  IF v_constraint_name IS NOT NULL THEN
    -- Supprimer l'ancienne contrainte
    EXECUTE 'ALTER TABLE leases DROP CONSTRAINT ' || v_constraint_name;
    RAISE NOTICE 'Ancienne contrainte supprimée: %', v_constraint_name;
  END IF;

  -- Recréer avec tous les statuts valides (SSOT 2026)
  ALTER TABLE leases ADD CONSTRAINT leases_statut_check CHECK (
    statut IN (
      'draft',
      'pending_signature',
      'partially_signed',
      'fully_signed',
      'active',
      'terminated',
      'archived',
      'cancelled'
    )
  );
  
  RAISE NOTICE 'Contrainte CHECK sur leases.statut mise à jour avec tous les statuts SSOT 2026';
END $$;

-- ============================================================================
-- P2-6: Ajouter un champ template_version aux lease_signers pour traçabilité
-- ============================================================================

ALTER TABLE lease_signers 
ADD COLUMN IF NOT EXISTS template_version TEXT;

COMMENT ON COLUMN lease_signers.template_version IS 
  'Version du template de bail utilisée au moment de la signature. '
  'Permet de régénérer le PDF avec le bon template si nécessaire.';

-- ============================================================================
-- Index pour améliorer les performances des requêtes de signature
-- ============================================================================

-- Index partiel pour les signatures en attente (optimise checkSignatureRights)
CREATE INDEX IF NOT EXISTS idx_lease_signers_pending 
ON lease_signers(lease_id, role) 
WHERE signature_status = 'pending';

-- Index partiel pour les signatures complètes (optimise determineLeaseStatus)
CREATE INDEX IF NOT EXISTS idx_lease_signers_signed 
ON lease_signers(lease_id) 
WHERE signature_status = 'signed';

-- Index sur invited_email pour la recherche par email (optimise routes token)
CREATE INDEX IF NOT EXISTS idx_lease_signers_invited_email 
ON lease_signers(invited_email) 
WHERE invited_email IS NOT NULL;

COMMIT;

-- ========== 20260215200000_fix_rls_properties_tenant_pre_active.sql ==========
-- ============================================================================
-- P0-E1: Fix RLS properties pour locataires avant bail "active"
-- ============================================================================
-- PROBLÈME: La policy "Tenants can view properties with active leases" exige
--           l.statut = 'active', ce qui empêche un nouveau locataire de voir
--           sa propriété pendant la phase de signature / onboarding.
--
-- FIX: Élargir la condition pour inclure tous les statuts où le locataire
--      est légitimement lié au bien (pending_signature, partially_signed,
--      fully_signed, active, notice_given, terminated).
-- ============================================================================

-- 1. Supprimer l'ancienne policy restrictive
DROP POLICY IF EXISTS "Tenants can view properties with active leases" ON properties;

-- 2. Créer la nouvelle policy élargie
CREATE POLICY "Tenants can view linked properties"
  ON properties
  FOR SELECT
  USING (
    -- Le locataire peut voir la propriété s'il est signataire d'un bail lié,
    -- quel que soit le statut du bail (sauf draft et cancelled)
    EXISTS (
      SELECT 1
      FROM leases l
      JOIN lease_signers ls ON ls.lease_id = l.id
      WHERE l.property_id = properties.id
        AND ls.profile_id = public.user_profile_id()
        AND l.statut NOT IN ('draft', 'cancelled')
    )
  );

-- 3. Vérification : s'assurer que les autres policies existantes ne sont pas impactées
-- (les policies owner et admin restent inchangées)

COMMENT ON POLICY "Tenants can view linked properties" ON properties IS
  'P0-E1: Locataires voient les propriétés liées à leurs baux (sauf draft/cancelled). '
  'Remplace l''ancienne policy qui exigeait statut=active uniquement.';

-- ========== 20260215200001_add_notice_given_lease_status.sql ==========
-- ============================================================================
-- MIGRATION CORRECTIVE: Harmonisation complète des statuts de bail
-- Date: 2026-02-15
-- ============================================================================
-- PROBLÈME: Les migrations successives (20260107000001 → 20260108400000)
--           se sont écrasées mutuellement, supprimant des statuts légitimes
--           (sent, pending_owner_signature, amended, notice_given, cancelled).
--
-- FIX: Recréer la contrainte CHECK avec l'union de TOUS les statuts métier
--      nécessaires au cycle de vie complet d'un bail.
--
-- Flux normal :
--   draft → sent → pending_signature → partially_signed
--   → pending_owner_signature → fully_signed → active
--   → notice_given → terminated → archived
--
-- Branches :
--   draft|pending_signature → cancelled
--   active → amended → active (avenant)
-- ============================================================================

DO $$
BEGIN
  -- Supprimer toute contrainte CHECK existante sur statut
  BEGIN
    ALTER TABLE leases DROP CONSTRAINT IF EXISTS leases_statut_check;
  EXCEPTION WHEN OTHERS THEN
    NULL;
  END;

  BEGIN
    ALTER TABLE leases DROP CONSTRAINT IF EXISTS check_lease_statut;
  EXCEPTION WHEN OTHERS THEN
    NULL;
  END;

  BEGIN
    ALTER TABLE leases DROP CONSTRAINT IF EXISTS lease_status_check;
  EXCEPTION WHEN OTHERS THEN
    NULL;
  END;

  -- Recréer avec la liste complète et définitive
  ALTER TABLE leases
    ADD CONSTRAINT leases_statut_check CHECK (
      statut IN (
        'draft',                    -- Brouillon initial
        'sent',                     -- Envoyé au locataire pour lecture
        'pending_signature',        -- En attente de signatures
        'partially_signed',         -- Au moins un signataire a signé
        'pending_owner_signature',  -- Locataire(s) signé(s), attente propriétaire
        'fully_signed',             -- Tous ont signé (avant activation)
        'active',                   -- Bail en cours
        'notice_given',             -- Congé donné (préavis en cours)
        'amended',                  -- Avenant en cours de traitement
        'terminated',               -- Résilié / terminé
        'archived',                 -- Archivé (conservation légale)
        'cancelled'                 -- Annulé (jamais activé)
      )
    );

  RAISE NOTICE '[MIGRATION] CHECK constraint leases_statut_check harmonisée — 12 statuts';
END $$;

-- Mettre à jour le commentaire de colonne
COMMENT ON COLUMN leases.statut IS 'Statut du bail: draft, sent, pending_signature, partially_signed, pending_owner_signature, fully_signed, active, notice_given, amended, terminated, archived, cancelled';

-- Index partiel pour baux en attente d'action (requêtes fréquentes)
DROP INDEX IF EXISTS idx_leases_pending_action;
CREATE INDEX IF NOT EXISTS idx_leases_pending_action ON leases(statut) 
  WHERE statut IN ('pending_signature', 'partially_signed', 'pending_owner_signature', 'fully_signed', 'sent');

-- ========== 20260215200002_fix_rls_tenant_access_beyond_active.sql ==========
-- ============================================================================
-- MIGRATION CORRECTIVE: Élargir les RLS units/charges/tickets pour les locataires
-- Date: 2026-02-15
-- ============================================================================
-- PROBLÈME: Plusieurs policies RLS pour les tables units, charges et tickets
--           filtrent sur l.statut = 'active' uniquement, empêchant les locataires
--           d'accéder aux données pendant les phases de signature, préavis, etc.
--
-- FIX: Remplacer les policies restrictives par des versions élargies utilisant
--      NOT IN ('draft', 'cancelled') pour couvrir tout le cycle de vie.
-- ============================================================================

-- ============================================
-- 1. UNITS — Policy tenant trop restrictive
-- ============================================
DROP POLICY IF EXISTS "Users can view units of accessible properties" ON units;

CREATE POLICY "Users can view units of accessible properties"
  ON units
  FOR SELECT
  USING (
    -- Propriétaire du bien
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = units.property_id
        AND p.owner_id = public.user_profile_id()
    )
    OR
    -- Locataire avec bail non-brouillon/non-annulé sur ce bien
    EXISTS (
      SELECT 1 FROM leases l
      JOIN lease_signers ls ON ls.lease_id = l.id
      WHERE (l.property_id = units.property_id OR l.unit_id = units.id)
        AND ls.profile_id = public.user_profile_id()
        AND l.statut NOT IN ('draft', 'cancelled')
    )
    OR
    -- Admin
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = public.user_profile_id()
        AND role = 'admin'
    )
  );

-- ============================================
-- 2. CHARGES — Policy tenant trop restrictive
-- ============================================
DROP POLICY IF EXISTS "Tenants can view charges of properties with active leases" ON charges;

CREATE POLICY "Tenants can view charges of linked properties"
  ON charges
  FOR SELECT
  USING (
    -- Propriétaire du bien
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = charges.property_id
        AND p.owner_id = public.user_profile_id()
    )
    OR
    -- Locataire avec bail actif ou en préavis sur ce bien
    EXISTS (
      SELECT 1 FROM leases l
      JOIN lease_signers ls ON ls.lease_id = l.id
      WHERE l.property_id = charges.property_id
        AND ls.profile_id = public.user_profile_id()
        AND l.statut IN ('active', 'notice_given', 'fully_signed')
    )
    OR
    -- Admin
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = public.user_profile_id()
        AND role = 'admin'
    )
  );

-- ============================================
-- 3. TICKETS — Policies tenant trop restrictives
-- ============================================

-- 3a. Policy SELECT
DROP POLICY IF EXISTS "Users can view tickets of accessible properties" ON tickets;
DROP POLICY IF EXISTS "tickets_select_policy" ON tickets;

CREATE POLICY "Users can view tickets of accessible properties"
  ON tickets
  FOR SELECT
  USING (
    -- Créateur du ticket
    tickets.created_by_profile_id = public.user_profile_id()
    OR
    -- Propriétaire du bien
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = tickets.property_id
        AND p.owner_id = public.user_profile_id()
    )
    OR
    -- Locataire avec bail actif ou en préavis
    EXISTS (
      SELECT 1 FROM leases l
      JOIN lease_signers ls ON ls.lease_id = l.id
      WHERE l.property_id = tickets.property_id
        AND ls.profile_id = public.user_profile_id()
        AND l.statut IN ('active', 'notice_given')
    )
    OR
    -- Prestataire assigné via work_order
    EXISTS (
      SELECT 1 FROM work_orders wo
      WHERE wo.ticket_id = tickets.id
        AND wo.provider_id = public.user_profile_id()
    )
    OR
    -- Admin
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = public.user_profile_id()
        AND role = 'admin'
    )
  );

-- 3b. Policy INSERT
DROP POLICY IF EXISTS "Users can create tickets for accessible properties" ON tickets;
DROP POLICY IF EXISTS "tickets_insert_policy" ON tickets;

CREATE POLICY "Users can create tickets for accessible properties"
  ON tickets
  FOR INSERT
  WITH CHECK (
    -- Propriétaire du bien
    EXISTS (
      SELECT 1 FROM properties p
      WHERE p.id = tickets.property_id
        AND p.owner_id = public.user_profile_id()
    )
    OR
    -- Locataire avec bail actif ou en préavis (peut signaler un problème)
    EXISTS (
      SELECT 1 FROM leases l
      JOIN lease_signers ls ON ls.lease_id = l.id
      WHERE l.property_id = tickets.property_id
        AND ls.profile_id = public.user_profile_id()
        AND l.statut IN ('active', 'notice_given')
    )
    OR
    -- Admin
    EXISTS (
      SELECT 1 FROM profiles
      WHERE id = public.user_profile_id()
        AND role = 'admin'
    )
  );

-- ============================================
-- Log
-- ============================================
DO $$
BEGIN
  RAISE NOTICE '[MIGRATION] RLS units/charges/tickets élargies au-delà de active';
END $$;

-- ========== 20260215200003_fix_copro_fk_on_delete.sql ==========
-- ============================================================================
-- MIGRATION CORRECTIVE: Ajouter ON DELETE aux FK copropriété
-- Date: 2026-02-15
-- ============================================================================
-- PROBLÈME: Les FK suivantes n'ont pas de clause ON DELETE, ce qui peut
--           causer des erreurs de contrainte si un profil ou une propriété
--           est supprimé(e).
--
-- Tables affectées :
--   - copro_units.owner_profile_id → profiles(id)  → SET NULL
--   - copro_units.property_id → properties(id)      → SET NULL
--   - sites.syndic_profile_id → profiles(id)        → SET NULL
-- ============================================================================

-- 1. copro_units.owner_profile_id
DO $$
BEGIN
  -- Trouver et supprimer la contrainte FK existante
  IF EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE table_name = 'copro_units' AND constraint_type = 'FOREIGN KEY'
    AND constraint_name IN (
      SELECT constraint_name FROM information_schema.key_column_usage
      WHERE table_name = 'copro_units' AND column_name = 'owner_profile_id'
    )
  ) THEN
    EXECUTE (
      SELECT 'ALTER TABLE copro_units DROP CONSTRAINT ' || constraint_name
      FROM information_schema.key_column_usage
      WHERE table_name = 'copro_units' AND column_name = 'owner_profile_id'
      LIMIT 1
    );
  END IF;
EXCEPTION WHEN OTHERS THEN
  RAISE NOTICE 'copro_units.owner_profile_id FK not found, skipping drop';
END $$;

ALTER TABLE copro_units
  ADD CONSTRAINT copro_units_owner_profile_id_fkey
  FOREIGN KEY (owner_profile_id) REFERENCES profiles(id) ON DELETE SET NULL;

-- 2. copro_units.property_id
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE table_name = 'copro_units' AND constraint_type = 'FOREIGN KEY'
    AND constraint_name IN (
      SELECT constraint_name FROM information_schema.key_column_usage
      WHERE table_name = 'copro_units' AND column_name = 'property_id'
    )
  ) THEN
    EXECUTE (
      SELECT 'ALTER TABLE copro_units DROP CONSTRAINT ' || constraint_name
      FROM information_schema.key_column_usage
      WHERE table_name = 'copro_units' AND column_name = 'property_id'
      LIMIT 1
    );
  END IF;
EXCEPTION WHEN OTHERS THEN
  RAISE NOTICE 'copro_units.property_id FK not found, skipping drop';
END $$;

ALTER TABLE copro_units
  ADD CONSTRAINT copro_units_property_id_fkey
  FOREIGN KEY (property_id) REFERENCES properties(id) ON DELETE SET NULL;

-- 3. sites.syndic_profile_id
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE table_name = 'sites' AND constraint_type = 'FOREIGN KEY'
    AND constraint_name IN (
      SELECT constraint_name FROM information_schema.key_column_usage
      WHERE table_name = 'sites' AND column_name = 'syndic_profile_id'
    )
  ) THEN
    EXECUTE (
      SELECT 'ALTER TABLE sites DROP CONSTRAINT ' || constraint_name
      FROM information_schema.key_column_usage
      WHERE table_name = 'sites' AND column_name = 'syndic_profile_id'
      LIMIT 1
    );
  END IF;
EXCEPTION WHEN OTHERS THEN
  RAISE NOTICE 'sites.syndic_profile_id FK not found, skipping drop';
END $$;

ALTER TABLE sites
  ADD CONSTRAINT sites_syndic_profile_id_fkey
  FOREIGN KEY (syndic_profile_id) REFERENCES profiles(id) ON DELETE SET NULL;

-- Log
DO $$
BEGIN
  RAISE NOTICE '[MIGRATION] FK ON DELETE SET NULL ajoutées pour copro_units et sites';
END $$;

-- ========== 20260216000000_tenant_document_center.sql ==========
-- =============================================================================
-- Migration : Tenant Document Center
-- Date      : 2026-02-16
-- Auteur    : Audit UX/UI — Refonte gestion documentaire locataire
--
-- Objectif  : Supporter le Document Center unifié côté locataire avec :
--   1. RPC tenant_document_center() — endpoint unique pour les 3 zones
--   2. Vue v_tenant_key_documents — 4 documents clés par locataire
--   3. Vue v_tenant_pending_actions — actions en attente agrégées
--   4. Index composite optimisé pour les requêtes du Document Center
--   5. RPC tenant_documents_search() — recherche full-text améliorée
-- =============================================================================

BEGIN;

-- =============================================================================
-- 1. INDEX COMPOSITE pour les requêtes Document Center
--    Optimise : SELECT * FROM documents WHERE tenant_id = ? ORDER BY created_at DESC
--    et       : SELECT * FROM documents WHERE tenant_id = ? AND type = ?
-- =============================================================================

-- Index composite tenant_id + type + created_at (DESC) pour la zone "Tous les documents"
CREATE INDEX IF NOT EXISTS idx_documents_tenant_type_date
  ON documents (tenant_id, type, created_at DESC)
  WHERE tenant_id IS NOT NULL;

-- Index composite lease_id + type + created_at (DESC) pour les docs liés au bail
CREATE INDEX IF NOT EXISTS idx_documents_lease_type_date
  ON documents (lease_id, type, created_at DESC)
  WHERE lease_id IS NOT NULL;


-- =============================================================================
-- 2. VUE : v_tenant_key_documents
--    Retourne les 4 documents clés les plus récents par locataire :
--    bail, quittance, EDL d'entrée, attestation d'assurance
-- =============================================================================

CREATE OR REPLACE VIEW v_tenant_key_documents AS
WITH ranked_docs AS (
  SELECT
    d.id,
    d.type,
    d.title,
    d.storage_path,
    d.created_at,
    d.tenant_id,
    d.lease_id,
    d.property_id,
    d.metadata,
    d.verification_status,
    d.ged_status,
    -- Catégorie normalisée pour les 4 slots
    CASE
      WHEN d.type IN ('bail', 'contrat', 'avenant', 'bail_signe_locataire', 'bail_signe_proprietaire') THEN 'bail'
      WHEN d.type IN ('quittance') THEN 'quittance'
      WHEN d.type IN ('EDL_entree', 'edl_entree', 'inventaire') THEN 'edl'
      WHEN d.type IN ('attestation_assurance', 'assurance_pno') THEN 'assurance'
      ELSE NULL
    END AS slot_key,
    ROW_NUMBER() OVER (
      PARTITION BY
        d.tenant_id,
        CASE
          WHEN d.type IN ('bail', 'contrat', 'avenant', 'bail_signe_locataire', 'bail_signe_proprietaire') THEN 'bail'
          WHEN d.type IN ('quittance') THEN 'quittance'
          WHEN d.type IN ('EDL_entree', 'edl_entree', 'inventaire') THEN 'edl'
          WHEN d.type IN ('attestation_assurance', 'assurance_pno') THEN 'assurance'
        END
      ORDER BY
        -- Prioriser les documents "final" et "signed"
        CASE WHEN (d.metadata->>'final')::boolean = true THEN 0 ELSE 1 END,
        CASE WHEN d.ged_status = 'signed' THEN 0 WHEN d.ged_status = 'active' THEN 1 ELSE 2 END,
        d.created_at DESC
    ) AS rn
  FROM documents d
  WHERE d.tenant_id IS NOT NULL
    AND d.type IN (
      'bail', 'contrat', 'avenant', 'bail_signe_locataire', 'bail_signe_proprietaire',
      'quittance',
      'EDL_entree', 'edl_entree', 'inventaire',
      'attestation_assurance', 'assurance_pno'
    )
)
SELECT
  id,
  type,
  title,
  storage_path,
  created_at,
  tenant_id,
  lease_id,
  property_id,
  metadata,
  verification_status,
  ged_status,
  slot_key
FROM ranked_docs
WHERE rn = 1 AND slot_key IS NOT NULL;

COMMENT ON VIEW v_tenant_key_documents IS
  'Documents clés par locataire (bail, dernière quittance, EDL entrée, assurance). Retourne le plus récent/pertinent pour chaque slot.';


-- =============================================================================
-- 3. VUE : v_tenant_pending_actions
--    Agrège les actions en attente pour un locataire :
--    - Bail à signer
--    - EDL à signer
--    - Attestation d'assurance manquante
-- =============================================================================

CREATE OR REPLACE VIEW v_tenant_pending_actions AS

-- Action : Bail à signer
SELECT
  ls.profile_id AS tenant_profile_id,
  'sign_lease' AS action_type,
  l.id AS entity_id,
  'Signer mon bail' AS action_label,
  'Votre bail est prêt et attend votre signature.' AS action_description,
  '/tenant/onboarding/sign' AS action_href,
  'high' AS priority,
  l.created_at AS action_created_at
FROM lease_signers ls
JOIN leases l ON l.id = ls.lease_id
WHERE ls.signature_status IN ('pending', 'sent')
  AND ls.signed_at IS NULL
  AND l.statut IN ('pending_signature', 'partially_signed')
  AND ls.role IN ('locataire_principal', 'colocataire')

UNION ALL

-- Action : EDL à signer (via le système de signature unifié)
SELECT
  sp.profile_id AS tenant_profile_id,
  'sign_edl' AS action_type,
  ss.entity_id AS entity_id,
  'Signer l''état des lieux' AS action_label,
  'Un état des lieux est en attente de votre signature.' AS action_description,
  '/tenant/documents' AS action_href,
  'high' AS priority,
  ss.created_at AS action_created_at
FROM signature_participants sp
JOIN signature_sessions ss ON ss.id = sp.session_id
WHERE sp.status IN ('pending', 'sent')
  AND ss.status IN ('pending', 'ongoing')
  AND ss.entity_type = 'edl'
  AND sp.role IN ('tenant', 'locataire')

UNION ALL

-- Action : Attestation d'assurance manquante
SELECT
  ls.profile_id AS tenant_profile_id,
  'upload_insurance' AS action_type,
  l.property_id AS entity_id,
  'Déposer l''attestation d''assurance' AS action_label,
  'Obligatoire pour activer votre bail.' AS action_description,
  '/tenant/documents' AS action_href,
  'medium' AS priority,
  l.created_at AS action_created_at
FROM lease_signers ls
JOIN leases l ON l.id = ls.lease_id
WHERE ls.role IN ('locataire_principal', 'colocataire')
  AND l.statut IN ('active', 'pending_signature', 'partially_signed', 'fully_signed')
  AND NOT EXISTS (
    SELECT 1 FROM documents d
    WHERE d.tenant_id = ls.profile_id
      AND d.property_id = l.property_id
      AND d.type IN ('attestation_assurance', 'assurance_pno')
      AND (d.verification_status IS NULL OR d.verification_status != 'rejected')
  );

COMMENT ON VIEW v_tenant_pending_actions IS
  'Actions en attente par locataire : baux à signer, EDL à signer, documents manquants. Utilisé par la zone "À faire" du Document Center.';


-- =============================================================================
-- 4. RPC : tenant_document_center()
--    Endpoint unique qui retourne toutes les données pour les 3 zones
--    du Document Center en un seul appel.
-- =============================================================================

CREATE OR REPLACE FUNCTION public.tenant_document_center(p_profile_id UUID DEFAULT NULL)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile_id UUID;
  v_result JSONB;
  v_pending_actions JSONB;
  v_key_documents JSONB;
  v_all_documents JSONB;
  v_stats JSONB;
BEGIN
  -- Résoudre le profile_id (paramètre ou utilisateur courant)
  IF p_profile_id IS NOT NULL THEN
    v_profile_id := p_profile_id;
  ELSE
    SELECT id INTO v_profile_id
    FROM profiles
    WHERE user_id = auth.uid()
    LIMIT 1;
  END IF;

  IF v_profile_id IS NULL THEN
    RETURN jsonb_build_object('error', 'Profile not found');
  END IF;

  -- Zone 1 : Actions en attente
  SELECT COALESCE(jsonb_agg(
    jsonb_build_object(
      'action_type', action_type,
      'entity_id', entity_id,
      'label', action_label,
      'description', action_description,
      'href', action_href,
      'priority', priority,
      'created_at', action_created_at
    ) ORDER BY
      CASE priority WHEN 'high' THEN 0 WHEN 'medium' THEN 1 ELSE 2 END,
      action_created_at DESC
  ), '[]'::jsonb)
  INTO v_pending_actions
  FROM v_tenant_pending_actions
  WHERE tenant_profile_id = v_profile_id;

  -- Zone 2 : Documents clés (4 slots)
  SELECT COALESCE(jsonb_object_agg(
    slot_key,
    jsonb_build_object(
      'id', id,
      'type', type,
      'title', title,
      'storage_path', storage_path,
      'created_at', created_at,
      'lease_id', lease_id,
      'property_id', property_id,
      'metadata', COALESCE(metadata, '{}'::jsonb),
      'verification_status', verification_status,
      'ged_status', ged_status
    )
  ), '{}'::jsonb)
  INTO v_key_documents
  FROM v_tenant_key_documents
  WHERE tenant_id = v_profile_id;

  -- Zone 3 : Tous les documents (les 50 plus récents, dédoublonnés)
  SELECT COALESCE(jsonb_agg(doc ORDER BY doc->>'created_at' DESC), '[]'::jsonb)
  INTO v_all_documents
  FROM (
    SELECT DISTINCT ON (d.type, COALESCE(d.lease_id, d.property_id, d.id))
      jsonb_build_object(
        'id', d.id,
        'type', d.type,
        'title', d.title,
        'storage_path', d.storage_path,
        'created_at', d.created_at,
        'tenant_id', d.tenant_id,
        'lease_id', d.lease_id,
        'property_id', d.property_id,
        'metadata', COALESCE(d.metadata, '{}'::jsonb),
        'verification_status', d.verification_status,
        'ged_status', d.ged_status,
        'file_size', d.file_size,
        'mime_type', d.mime_type,
        'original_filename', d.original_filename
      ) AS doc
    FROM documents d
    WHERE (d.tenant_id = v_profile_id
      OR d.lease_id IN (
        SELECT ls.lease_id FROM lease_signers ls WHERE ls.profile_id = v_profile_id
      )
    )
    ORDER BY d.type, COALESCE(d.lease_id, d.property_id, d.id), d.created_at DESC
    LIMIT 100
  ) sub
  LIMIT 50;

  -- Stats rapides
  SELECT jsonb_build_object(
    'total_documents', (
      SELECT COUNT(*) FROM documents d
      WHERE d.tenant_id = v_profile_id
        OR d.lease_id IN (SELECT ls.lease_id FROM lease_signers ls WHERE ls.profile_id = v_profile_id)
    ),
    'pending_actions_count', jsonb_array_length(v_pending_actions),
    'has_bail', v_key_documents ? 'bail',
    'has_quittance', v_key_documents ? 'quittance',
    'has_edl', v_key_documents ? 'edl',
    'has_assurance', v_key_documents ? 'assurance'
  ) INTO v_stats;

  -- Résultat final
  v_result := jsonb_build_object(
    'pending_actions', v_pending_actions,
    'key_documents', v_key_documents,
    'documents', v_all_documents,
    'stats', v_stats
  );

  RETURN v_result;
END;
$$;

COMMENT ON FUNCTION public.tenant_document_center IS
  'Endpoint unique pour le Document Center locataire. Retourne : pending_actions, key_documents (4 slots), documents (tous, dédoublonnés), stats.';

-- Accès pour les utilisateurs authentifiés
GRANT EXECUTE ON FUNCTION public.tenant_document_center TO authenticated;


-- =============================================================================
-- 5. RPC : tenant_documents_search()
--    Recherche full-text améliorée dans les documents du locataire
--    avec filtres par type, période et tri.
-- =============================================================================

CREATE OR REPLACE FUNCTION public.tenant_documents_search(
  p_query TEXT DEFAULT NULL,
  p_type TEXT DEFAULT NULL,
  p_period TEXT DEFAULT NULL,        -- '1m', '3m', '6m', '1y', 'all'
  p_sort TEXT DEFAULT 'date_desc',   -- 'date_desc', 'date_asc', 'type'
  p_limit INT DEFAULT 50,
  p_offset INT DEFAULT 0
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile_id UUID;
  v_result JSONB;
  v_period_start TIMESTAMPTZ;
BEGIN
  -- Résoudre le profile_id
  SELECT id INTO v_profile_id
  FROM profiles
  WHERE user_id = auth.uid()
  LIMIT 1;

  IF v_profile_id IS NULL THEN
    RETURN jsonb_build_object('error', 'Profile not found', 'documents', '[]'::jsonb);
  END IF;

  -- Calculer la date de début de période
  v_period_start := CASE p_period
    WHEN '1m' THEN NOW() - INTERVAL '1 month'
    WHEN '3m' THEN NOW() - INTERVAL '3 months'
    WHEN '6m' THEN NOW() - INTERVAL '6 months'
    WHEN '1y' THEN NOW() - INTERVAL '1 year'
    ELSE NULL -- Pas de filtre de date
  END;

  -- Requête avec filtres dynamiques
  SELECT jsonb_build_object(
    'documents', COALESCE(jsonb_agg(doc), '[]'::jsonb),
    'total', COUNT(*) OVER()
  )
  INTO v_result
  FROM (
    SELECT jsonb_build_object(
      'id', d.id,
      'type', d.type,
      'title', d.title,
      'storage_path', d.storage_path,
      'created_at', d.created_at,
      'tenant_id', d.tenant_id,
      'lease_id', d.lease_id,
      'property_id', d.property_id,
      'metadata', COALESCE(d.metadata, '{}'::jsonb),
      'verification_status', d.verification_status,
      'ged_status', d.ged_status,
      'file_size', d.file_size,
      'mime_type', d.mime_type,
      'original_filename', d.original_filename,
      'is_recent', (d.created_at > NOW() - INTERVAL '7 days')
    ) AS doc,
    d.created_at,
    d.type
    FROM documents d
    WHERE (
      d.tenant_id = v_profile_id
      OR d.lease_id IN (
        SELECT ls.lease_id FROM lease_signers ls WHERE ls.profile_id = v_profile_id
      )
    )
    -- Filtre full-text
    AND (p_query IS NULL OR p_query = '' OR
      d.search_vector @@ plainto_tsquery('french', p_query)
      OR d.title ILIKE '%' || p_query || '%'
      OR d.type ILIKE '%' || p_query || '%'
    )
    -- Filtre par type
    AND (p_type IS NULL OR p_type = 'all' OR d.type = p_type)
    -- Filtre par période
    AND (v_period_start IS NULL OR d.created_at >= v_period_start)
    -- Tri
    ORDER BY
      CASE WHEN p_sort = 'date_desc' THEN d.created_at END DESC NULLS LAST,
      CASE WHEN p_sort = 'date_asc'  THEN d.created_at END ASC NULLS LAST,
      CASE WHEN p_sort = 'type'      THEN d.type END ASC,
      d.created_at DESC
    LIMIT p_limit
    OFFSET p_offset
  ) sub;

  RETURN COALESCE(v_result, jsonb_build_object('documents', '[]'::jsonb, 'total', 0));
END;
$$;

COMMENT ON FUNCTION public.tenant_documents_search IS
  'Recherche full-text dans les documents du locataire avec filtres (type, période) et tri. Utilisé par la zone "Tous les documents" du Document Center.';

GRANT EXECUTE ON FUNCTION public.tenant_documents_search TO authenticated;


-- =============================================================================
-- 6. RLS : Politiques pour les vues (sécurité)
--    Les vues utilisent SECURITY DEFINER dans les RPC, mais on ajoute
--    des politiques de sécurité sur les tables sous-jacentes pour les accès directs.
-- =============================================================================

-- S'assurer que les lease_signers sont accessibles pour les vues
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'lease_signers' AND policyname = 'lease_signers_tenant_view_for_doc_center'
  ) THEN
    CREATE POLICY "lease_signers_tenant_view_for_doc_center"
      ON lease_signers
      FOR SELECT
      TO authenticated
      USING (
        profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())
      );
  END IF;
END $$;


-- =============================================================================
-- 7. TRIGGER : Mettre à jour search_vector lors de l'insertion/modification
--    pour supporter la recherche full-text améliorée
-- =============================================================================

CREATE OR REPLACE FUNCTION update_document_search_vector()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.search_vector := 
    setweight(to_tsvector('french', COALESCE(NEW.title, '')), 'A') ||
    setweight(to_tsvector('french', COALESCE(NEW.type, '')), 'B') ||
    setweight(to_tsvector('french', COALESCE(NEW.original_filename, '')), 'C') ||
    setweight(to_tsvector('french', COALESCE(NEW.metadata->>'description', '')), 'D');
  RETURN NEW;
END;
$$;

-- Le trigger peut déjà exister, on le recrée proprement
DROP TRIGGER IF EXISTS trg_documents_search_vector ON documents;
CREATE TRIGGER trg_documents_search_vector
  BEFORE INSERT OR UPDATE OF title, type, original_filename, metadata
  ON documents
  FOR EACH ROW
  EXECUTE FUNCTION update_document_search_vector();


-- =============================================================================
-- 8. BACKFILL : Recalculer search_vector pour les documents existants
--    qui n'ont pas encore de vecteur de recherche
-- =============================================================================

UPDATE documents
SET search_vector = 
  setweight(to_tsvector('french', COALESCE(title, '')), 'A') ||
  setweight(to_tsvector('french', COALESCE(type, '')), 'B') ||
  setweight(to_tsvector('french', COALESCE(original_filename, '')), 'C') ||
  setweight(to_tsvector('french', COALESCE(metadata->>'description', '')), 'D')
WHERE search_vector IS NULL;


COMMIT;

-- =============================================================================
-- Notes de migration :
--
-- Usage côté frontend (React Query) :
--
--   // Charger le Document Center complet en 1 appel
--   const { data } = await supabase.rpc('tenant_document_center');
--   // data.pending_actions → Zone "À faire"
--   // data.key_documents   → Zone "Documents clés" (bail, quittance, edl, assurance)
--   // data.documents       → Zone "Tous les documents"
--   // data.stats           → Compteurs et flags
--
--   // Recherche avec filtres
--   const { data } = await supabase.rpc('tenant_documents_search', {
--     p_query: 'bail',
--     p_type: 'quittance',
--     p_period: '3m',
--     p_sort: 'date_desc',
--   });
--
-- Rollback :
--   DROP FUNCTION IF EXISTS public.tenant_document_center;
--   DROP FUNCTION IF EXISTS public.tenant_documents_search;
--   DROP VIEW IF EXISTS v_tenant_key_documents;
--   DROP VIEW IF EXISTS v_tenant_pending_actions;
--   DROP INDEX IF EXISTS idx_documents_tenant_type_date;
--   DROP INDEX IF EXISTS idx_documents_lease_type_date;
-- =============================================================================

-- ========== 20260216000001_document_center_notifications.sql ==========
-- =============================================================================
-- Migration : Document Center — Notifications & URL updates
-- Date      : 2026-02-16
-- Auteur    : Audit UX/UI — Unification des routes documentaires
--
-- Objectif  : Mettre à jour les templates de notification et les URLs
--             qui référençaient /tenant/receipts ou /tenant/signatures
--             pour pointer vers /tenant/documents (Document Center unifié).
-- =============================================================================

BEGIN;

-- =============================================================================
-- 1. Mettre à jour les templates d'email qui contiennent les anciennes routes
--    (table email_templates si elle existe)
-- =============================================================================

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'email_templates') THEN
    -- Remplacer /tenant/receipts par /tenant/documents?type=quittance
    UPDATE email_templates
    SET body = REPLACE(body, '/tenant/receipts', '/tenant/documents?type=quittance'),
        updated_at = NOW()
    WHERE body LIKE '%/tenant/receipts%';

    -- Remplacer /tenant/signatures par /tenant/documents
    UPDATE email_templates
    SET body = REPLACE(body, '/tenant/signatures', '/tenant/documents'),
        updated_at = NOW()
    WHERE body LIKE '%/tenant/signatures%';

    RAISE NOTICE 'email_templates updated: receipts → documents, signatures → documents';
  ELSE
    RAISE NOTICE 'email_templates table does not exist, skipping';
  END IF;
END $$;


-- =============================================================================
-- 2. Mettre à jour les notifications existantes qui pointent vers les anciennes routes
--    (table notifications si elle existe)
-- =============================================================================

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'notifications') THEN
    -- Mettre à jour les metadata.action_url des notifications non lues
    UPDATE notifications
    SET metadata = jsonb_set(
      metadata,
      '{action_url}',
      to_jsonb(REPLACE(metadata->>'action_url', '/tenant/receipts', '/tenant/documents?type=quittance'))
    )
    WHERE metadata->>'action_url' LIKE '%/tenant/receipts%'
      AND read_at IS NULL;

    UPDATE notifications
    SET metadata = jsonb_set(
      metadata,
      '{action_url}',
      to_jsonb(REPLACE(metadata->>'action_url', '/tenant/signatures', '/tenant/documents'))
    )
    WHERE metadata->>'action_url' LIKE '%/tenant/signatures%'
      AND read_at IS NULL;

    RAISE NOTICE 'notifications metadata updated for unread notifications';
  ELSE
    RAISE NOTICE 'notifications table does not exist, skipping';
  END IF;
END $$;


-- =============================================================================
-- 3. Fonction utilitaire : tenant_has_key_document()
--    Vérifie si un locataire a un document clé spécifique
--    Utilisée par les triggers de notification et le dashboard
-- =============================================================================

CREATE OR REPLACE FUNCTION public.tenant_has_key_document(
  p_tenant_id UUID,
  p_slot_key TEXT  -- 'bail', 'quittance', 'edl', 'assurance'
)
RETURNS BOOLEAN
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_types TEXT[];
  v_exists BOOLEAN;
BEGIN
  -- Mapper le slot_key aux types de documents
  v_types := CASE p_slot_key
    WHEN 'bail' THEN ARRAY['bail', 'contrat', 'avenant', 'bail_signe_locataire', 'bail_signe_proprietaire']
    WHEN 'quittance' THEN ARRAY['quittance']
    WHEN 'edl' THEN ARRAY['EDL_entree', 'edl_entree', 'inventaire']
    WHEN 'assurance' THEN ARRAY['attestation_assurance', 'assurance_pno']
    ELSE ARRAY[]::TEXT[]
  END;

  SELECT EXISTS (
    SELECT 1 FROM documents
    WHERE tenant_id = p_tenant_id
      AND type = ANY(v_types)
      AND (verification_status IS NULL OR verification_status != 'rejected')
  ) INTO v_exists;

  RETURN v_exists;
END;
$$;

COMMENT ON FUNCTION public.tenant_has_key_document IS
  'Vérifie si un locataire possède un document clé (bail, quittance, edl, assurance). Utilisé par le Document Center et les triggers.';

GRANT EXECUTE ON FUNCTION public.tenant_has_key_document TO authenticated;


-- =============================================================================
-- 4. Trigger : Notifier le locataire quand un document clé est ajouté
--    (mise à jour du trigger existant pour utiliser les nouvelles routes)
-- =============================================================================

CREATE OR REPLACE FUNCTION notify_tenant_document_center_update()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_doc_label TEXT;
  v_notification_type TEXT;
BEGIN
  -- Ne notifier que pour les documents liés à un locataire
  IF NEW.tenant_id IS NULL THEN
    RETURN NEW;
  END IF;

  -- Déterminer le label et le type de notification
  v_doc_label := CASE
    WHEN NEW.type IN ('bail', 'contrat', 'avenant') THEN 'Un nouveau bail'
    WHEN NEW.type = 'quittance' THEN 'Une nouvelle quittance'
    WHEN NEW.type IN ('EDL_entree', 'edl_entree') THEN 'Un état des lieux d''entrée'
    WHEN NEW.type IN ('EDL_sortie', 'edl_sortie') THEN 'Un état des lieux de sortie'
    WHEN NEW.type IN ('attestation_assurance') THEN 'Votre attestation d''assurance'
    WHEN NEW.type IN ('dpe', 'erp', 'crep') THEN 'Un diagnostic technique'
    ELSE 'Un document'
  END;

  v_notification_type := CASE
    WHEN NEW.type IN ('bail', 'contrat', 'avenant') THEN 'document_lease_added'
    WHEN NEW.type = 'quittance' THEN 'document_receipt_added'
    WHEN NEW.type LIKE 'EDL%' OR NEW.type LIKE 'edl%' THEN 'document_edl_added'
    ELSE 'document_added'
  END;

  -- Insérer la notification (si la table existe)
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'notifications') THEN
    INSERT INTO notifications (
      profile_id,
      type,
      title,
      message,
      metadata
    ) VALUES (
      NEW.tenant_id,
      v_notification_type,
      v_doc_label || ' a été ajouté',
      v_doc_label || ' est disponible dans votre espace documents.',
      jsonb_build_object(
        'document_id', NEW.id,
        'document_type', NEW.type,
        'action_url', '/tenant/documents',
        'action_label', 'Voir le document'
      )
    );
  END IF;

  RETURN NEW;
END;
$$;

-- Recréer le trigger
DROP TRIGGER IF EXISTS trg_notify_tenant_document_center ON documents;
CREATE TRIGGER trg_notify_tenant_document_center
  AFTER INSERT ON documents
  FOR EACH ROW
  WHEN (NEW.tenant_id IS NOT NULL)
  EXECUTE FUNCTION notify_tenant_document_center_update();


-- =============================================================================
-- 5. Stats : Fonction pour les analytics du Document Center
-- =============================================================================

CREATE OR REPLACE FUNCTION public.tenant_document_stats(p_tenant_id UUID DEFAULT NULL)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile_id UUID;
  v_result JSONB;
BEGIN
  IF p_tenant_id IS NOT NULL THEN
    v_profile_id := p_tenant_id;
  ELSE
    SELECT id INTO v_profile_id FROM profiles WHERE user_id = auth.uid() LIMIT 1;
  END IF;

  IF v_profile_id IS NULL THEN
    RETURN '{}'::jsonb;
  END IF;

  SELECT jsonb_build_object(
    'total', COUNT(*),
    'by_type', jsonb_object_agg(type, cnt),
    'recent_7d', SUM(CASE WHEN created_at > NOW() - INTERVAL '7 days' THEN 1 ELSE 0 END),
    'has_bail', bool_or(type IN ('bail', 'contrat', 'avenant', 'bail_signe_locataire', 'bail_signe_proprietaire')),
    'has_quittance', bool_or(type = 'quittance'),
    'has_edl', bool_or(type IN ('EDL_entree', 'edl_entree', 'inventaire')),
    'has_assurance', bool_or(type IN ('attestation_assurance', 'assurance_pno'))
  )
  INTO v_result
  FROM (
    SELECT type, COUNT(*) AS cnt, MIN(created_at) AS created_at
    FROM documents
    WHERE tenant_id = v_profile_id
    GROUP BY type
  ) sub;

  RETURN COALESCE(v_result, '{}'::jsonb);
END;
$$;

COMMENT ON FUNCTION public.tenant_document_stats IS
  'Statistiques du coffre-fort documentaire du locataire : total, par type, récents, flags de complétude.';

GRANT EXECUTE ON FUNCTION public.tenant_document_stats TO authenticated;


COMMIT;

-- =============================================================================
-- Rollback :
--   DROP FUNCTION IF EXISTS public.tenant_has_key_document;
--   DROP FUNCTION IF EXISTS public.tenant_document_stats;
--   DROP FUNCTION IF EXISTS notify_tenant_document_center_update() CASCADE;
--   DROP TRIGGER IF EXISTS trg_notify_tenant_document_center ON documents;
-- =============================================================================

-- ========== 20260216100000_security_audit_rls_fixes.sql ==========
-- =====================================================
-- MIGRATION: Correctifs sécurité P0 — Audit BIC2026
-- Date: 2026-02-16
--
-- PROBLÈMES CORRIGÉS:
-- 1. Table `leases`: suppression des policies USING(true) résiduelles
--    (créées par 20241130000004, normalement supprimées par 20251228230000
--     mais cette migration assure la sécurité même en cas de re-application)
-- 2. Table `notifications`: policy INSERT trop permissive (WITH CHECK(true))
-- 3. Table `document_ged_audit_log`: policy INSERT trop permissive
-- 4. Table `professional_orders`: policy SELECT trop permissive
-- =====================================================

BEGIN;

-- ============================================
-- 1. LEASES: Supprimer les policies permissives résiduelles
-- ============================================
-- Ces policies permettaient à tout utilisateur authentifié de lire/modifier tous les baux.
-- Les bonnes policies (leases_admin_all, leases_owner_all, leases_tenant_select)
-- ont été créées dans 20251228230000_definitive_rls_fix.sql

DROP POLICY IF EXISTS "authenticated_users_view_leases" ON leases;
DROP POLICY IF EXISTS "authenticated_users_insert_leases" ON leases;
DROP POLICY IF EXISTS "authenticated_users_update_leases" ON leases;
DROP POLICY IF EXISTS "authenticated_users_delete_leases" ON leases;

-- Vérifier que les bonnes policies existent
DO $$
DECLARE
  policy_count INT;
BEGIN
  SELECT count(*) INTO policy_count
  FROM pg_policies
  WHERE tablename = 'leases' AND schemaname = 'public';

  IF policy_count = 0 THEN
    RAISE EXCEPTION 'ERREUR CRITIQUE: Table leases n''a aucune policy RLS après nettoyage. '
                     'Les policies sécurisées de 20251228230000 doivent être présentes.';
  END IF;

  RAISE NOTICE 'leases: % policies RLS actives après nettoyage', policy_count;
END $$;

-- ============================================
-- 2. NOTIFICATIONS: Restreindre l'INSERT
-- ============================================
-- Avant: WITH CHECK(true) → tout authentifié peut insérer pour n'importe qui
-- Après: Seul le service_role ou l'utilisateur peut insérer ses propres notifs

DROP POLICY IF EXISTS "notifications_insert_system" ON notifications;

-- Le service_role bypass RLS par défaut, donc cette policy est pour les
-- appels authentifiés qui insèrent des notifications pour eux-mêmes.
-- Les Edge Functions (service_role) ne sont pas affectées par cette restriction.
CREATE POLICY "notifications_insert_own_or_service" ON notifications
  FOR INSERT TO authenticated
  WITH CHECK (
    -- L'utilisateur ne peut insérer que des notifications qui le concernent
    user_id = auth.uid()
    OR recipient_id = public.get_my_profile_id()
    OR profile_id = public.get_my_profile_id()
  );

-- ============================================
-- 3. DOCUMENT_GED_AUDIT_LOG: Restreindre l'INSERT
-- ============================================
-- Avant: WITH CHECK(true) → tout authentifié peut insérer des logs d'audit
-- Après: Seuls les utilisateurs authentifiés peuvent insérer leurs propres logs

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'document_ged_audit_log' AND schemaname = 'public') THEN
    EXECUTE 'DROP POLICY IF EXISTS "System can insert audit logs" ON document_ged_audit_log';

    -- Restreindre aux logs créés par l'utilisateur authentifié
    EXECUTE '
      CREATE POLICY "audit_log_insert_own" ON document_ged_audit_log
        FOR INSERT TO authenticated
        WITH CHECK (
          actor_id = public.get_my_profile_id()
          OR actor_id IS NULL
        )
    ';

    RAISE NOTICE 'document_ged_audit_log: policy INSERT corrigée';
  ELSE
    RAISE NOTICE 'document_ged_audit_log: table non existante, skip';
  END IF;
END $$;

-- ============================================
-- 4. PROFESSIONAL_ORDERS: Restreindre le SELECT
-- ============================================
-- Avant: USING(TRUE) → tout authentifié voit toutes les commandes
-- Après: ownership check

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'professional_orders' AND schemaname = 'public') THEN
    EXECUTE 'DROP POLICY IF EXISTS "professional_orders_select_policy" ON professional_orders';

    -- Les commandes sont visibles par le propriétaire du bail lié ou l'admin
    EXECUTE '
      CREATE POLICY "professional_orders_select_scoped" ON professional_orders
        FOR SELECT TO authenticated
        USING (
          public.user_role() = ''admin''
          OR EXISTS (
            SELECT 1 FROM leases l
            JOIN properties p ON p.id = l.property_id
            WHERE l.id = professional_orders.lease_id
            AND p.owner_id = public.get_my_profile_id()
          )
        )
    ';

    RAISE NOTICE 'professional_orders: policy SELECT corrigée';
  ELSE
    RAISE NOTICE 'professional_orders: table non existante, skip';
  END IF;
END $$;

-- ============================================
-- 5. VÉRIFICATION FINALE
-- ============================================
DO $$
DECLARE
  dangerous_count INT;
BEGIN
  -- Compter les policies qui ont encore USING(true) ou WITH CHECK(true)
  -- sur les tables critiques (hors reference tables et service_role policies)
  SELECT count(*) INTO dangerous_count
  FROM pg_policies
  WHERE schemaname = 'public'
    AND tablename IN ('leases', 'profiles', 'properties', 'invoices', 'payments', 'documents', 'tickets')
    AND (qual = 'true' OR with_check = 'true')
    AND policyname NOT LIKE '%service%'
    AND policyname NOT LIKE '%admin%';

  IF dangerous_count > 0 THEN
    RAISE WARNING 'ATTENTION: % policies avec USING(true)/WITH CHECK(true) restantes sur les tables critiques', dangerous_count;
  ELSE
    RAISE NOTICE 'OK: Aucune policy USING(true) dangereuse sur les tables critiques';
  END IF;
END $$;

COMMIT;

-- ========== 20260216200000_auto_link_lease_signers_trigger.sql ==========
-- =====================================================
-- MIGRATION: Auto-link lease_signers + fix profil orphelin
-- Date: 2026-02-16
--
-- PROBLÈMES CORRIGÉS:
-- 1. Trigger DB: quand un profil est créé, lier automatiquement 
--    les lease_signers orphelins (invited_email match, profile_id NULL)
-- 2. Trigger DB: quand un profil est créé, marquer les invitations
--    correspondantes comme utilisées
-- 3. Fix immédiat: créer le profil manquant pour user 6337af52-...
-- 4. Fix rétroactif: lier tous les lease_signers orphelins existants
-- =====================================================

BEGIN;

-- ============================================
-- 1. FONCTION: Auto-link lease_signers au moment de la création d'un profil
-- ============================================
CREATE OR REPLACE FUNCTION public.auto_link_lease_signers_on_profile_created()
RETURNS TRIGGER AS $$
DECLARE
  user_email TEXT;
  linked_count INT;
BEGIN
  -- Récupérer l'email de l'utilisateur auth
  SELECT email INTO user_email
  FROM auth.users
  WHERE id = NEW.user_id;

  IF user_email IS NULL OR user_email = '' THEN
    RETURN NEW;
  END IF;

  -- Lier tous les lease_signers orphelins avec cet email
  UPDATE public.lease_signers
  SET profile_id = NEW.id
  WHERE LOWER(invited_email) = LOWER(user_email)
    AND profile_id IS NULL;

  GET DIAGNOSTICS linked_count = ROW_COUNT;

  IF linked_count > 0 THEN
    RAISE NOTICE '[auto_link] % lease_signers liés au profil % (email: %)', 
      linked_count, NEW.id, user_email;
  END IF;

  -- Marquer les invitations correspondantes comme utilisées
  UPDATE public.invitations
  SET used_by = NEW.id,
      used_at = NOW()
  WHERE LOWER(email) = LOWER(user_email)
    AND used_at IS NULL;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 2. TRIGGER: Exécuter auto-link après chaque INSERT sur profiles
-- ============================================
DROP TRIGGER IF EXISTS trigger_auto_link_lease_signers ON public.profiles;

CREATE TRIGGER trigger_auto_link_lease_signers
  AFTER INSERT ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.auto_link_lease_signers_on_profile_created();

-- ============================================
-- 3. FIX IMMÉDIAT: Créer le profil manquant pour l'utilisateur signalé
-- ============================================
DO $$
DECLARE
  target_user_id UUID := '6337af52-2fb7-41d7-b620-d9ddd689d294';
  user_email TEXT;
  user_role TEXT;
  new_profile_id UUID;
BEGIN
  -- Vérifier si le user existe dans auth.users
  SELECT email, COALESCE(raw_user_meta_data->>'role', 'tenant')
  INTO user_email, user_role
  FROM auth.users
  WHERE id = target_user_id;

  IF user_email IS NULL THEN
    RAISE NOTICE 'User % non trouvé dans auth.users — skip', target_user_id;
    RETURN;
  END IF;

  -- Vérifier si le profil existe déjà
  IF EXISTS (SELECT 1 FROM public.profiles WHERE user_id = target_user_id) THEN
    RAISE NOTICE 'Profil déjà existant pour user % — skip', target_user_id;
    RETURN;
  END IF;

  -- Créer le profil manquant
  INSERT INTO public.profiles (user_id, role, email)
  VALUES (target_user_id, user_role, user_email)
  RETURNING id INTO new_profile_id;

  RAISE NOTICE 'Profil créé: id=%, user_id=%, email=%, role=%', 
    new_profile_id, target_user_id, user_email, user_role;

  -- Le trigger auto_link_lease_signers se chargera de lier les lease_signers
END $$;

-- ============================================
-- 4. FIX RÉTROACTIF: Lier tous les lease_signers orphelins existants
-- ============================================
-- Pour tous les profils existants dont l'email matche un lease_signer orphelin
DO $$
DECLARE
  linked_total INT := 0;
  rec RECORD;
BEGIN
  FOR rec IN
    SELECT p.id AS profile_id, u.email AS user_email
    FROM public.profiles p
    JOIN auth.users u ON u.id = p.user_id
    WHERE u.email IS NOT NULL
      AND EXISTS (
        SELECT 1 FROM public.lease_signers ls
        WHERE LOWER(ls.invited_email) = LOWER(u.email)
          AND ls.profile_id IS NULL
      )
  LOOP
    UPDATE public.lease_signers
    SET profile_id = rec.profile_id
    WHERE LOWER(invited_email) = LOWER(rec.user_email)
      AND profile_id IS NULL;

    linked_total := linked_total + 1;
  END LOOP;

  IF linked_total > 0 THEN
    RAISE NOTICE '[rétro-link] % profils avec des lease_signers orphelins ont été liés', linked_total;
  ELSE
    RAISE NOTICE '[rétro-link] Aucun lease_signer orphelin trouvé — tout est déjà lié';
  END IF;
END $$;

-- ============================================
-- 5. VÉRIFICATION: Compter les lease_signers encore orphelins
-- ============================================
DO $$
DECLARE
  orphan_count INT;
BEGIN
  SELECT count(*) INTO orphan_count
  FROM public.lease_signers
  WHERE profile_id IS NULL
    AND invited_email IS NOT NULL;

  IF orphan_count > 0 THEN
    RAISE WARNING '⚠️  % lease_signers orphelins restants (email sans compte correspondant)', orphan_count;
  ELSE
    RAISE NOTICE '✅ Aucun lease_signer orphelin — tous les comptes sont liés';
  END IF;
END $$;

COMMIT;

-- ========== 20260216300000_fix_auth_profile_sync.sql ==========
-- =====================================================
-- MIGRATION: Correction synchronisation auth <-> profiles
-- Date: 2026-02-16
-- Version: 20260216300000
--
-- PROBLEMES CORRIGES:
--   1. handle_new_user() ne remplissait pas la colonne `email`
--   2. handle_new_user() n'incluait pas la gestion du role `guarantor`
--      dans le ON CONFLICT (deja corrige en 20260212, consolide ici)
--   3. Des utilisateurs auth.users existent sans profil correspondant
--      (trigger rate, erreur RLS, race condition)
--   4. Des profils existants ont email = NULL
--   5. Absence de policy INSERT explicite sur profiles
--      (le FOR ALL couvre le cas, mais une policy INSERT explicite est
--       plus lisible et securise les futures evolutions)
--
-- ACTIONS:
--   A. Mettre a jour handle_new_user() (email + guarantor + robustesse)
--   B. Creer les profils manquants pour les auth.users desynchronises
--   C. Backfill les emails NULL dans les profils existants
--   D. Assurer qu'une policy INSERT RLS existe sur profiles
-- =====================================================

BEGIN;

-- ============================================
-- A. MISE A JOUR DE handle_new_user()
-- ============================================
-- Ajout de l'email, meilleure gestion d'erreur,
-- support du role guarantor (consolidation)

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_role TEXT;
  v_prenom TEXT;
  v_nom TEXT;
  v_telephone TEXT;
  v_email TEXT;
BEGIN
  -- Lire le role depuis les metadata, avec fallback sur 'tenant'
  v_role := COALESCE(
    NEW.raw_user_meta_data->>'role',
    'tenant'
  );

  -- Valider le role (inclut 'guarantor')
  IF v_role NOT IN ('admin', 'owner', 'tenant', 'provider', 'guarantor') THEN
    v_role := 'tenant';
  END IF;

  -- Lire les autres donnees depuis les metadata
  v_prenom := NEW.raw_user_meta_data->>'prenom';
  v_nom := NEW.raw_user_meta_data->>'nom';
  v_telephone := NEW.raw_user_meta_data->>'telephone';

  -- Recuperer l'email depuis le champ auth.users.email
  v_email := NEW.email;

  -- Inserer le profil avec toutes les donnees, y compris l'email
  INSERT INTO public.profiles (user_id, role, prenom, nom, telephone, email)
  VALUES (NEW.id, v_role, v_prenom, v_nom, v_telephone, v_email)
  ON CONFLICT (user_id) DO UPDATE SET
    role = COALESCE(EXCLUDED.role, profiles.role),
    prenom = COALESCE(EXCLUDED.prenom, profiles.prenom),
    nom = COALESCE(EXCLUDED.nom, profiles.nom),
    telephone = COALESCE(EXCLUDED.telephone, profiles.telephone),
    email = COALESCE(EXCLUDED.email, profiles.email),
    updated_at = NOW();

  RETURN NEW;

EXCEPTION WHEN OTHERS THEN
  -- Ne jamais bloquer la creation d'un utilisateur auth
  -- meme si l'insertion du profil echoue
  RAISE WARNING '[handle_new_user] Erreur lors de la creation du profil pour user_id=%, email=%: % (SQLSTATE=%)',
    NEW.id, NEW.email, SQLERRM, SQLSTATE;
  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.handle_new_user() IS
'Cree automatiquement un profil lors de la creation d''un utilisateur auth.
Lit le role et les informations personnelles depuis raw_user_meta_data.
Inclut l''email depuis auth.users.email.
Supporte les roles: admin, owner, tenant, provider, guarantor.
Utilise ON CONFLICT pour gerer les cas ou le profil existe deja.
Ne bloque jamais la creation auth meme en cas d''erreur (EXCEPTION handler).';

-- S'assurer que le trigger existe (idempotent)
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- ============================================
-- B. CREER LES PROFILS MANQUANTS
-- ============================================
-- Pour chaque utilisateur dans auth.users qui n'a pas de profil,
-- en creer un avec les donnees disponibles.

DO $$
DECLARE
  v_count INTEGER := 0;
  v_user RECORD;
BEGIN
  FOR v_user IN
    SELECT
      u.id,
      u.email,
      COALESCE(u.raw_user_meta_data->>'role', 'tenant') AS role,
      u.raw_user_meta_data->>'prenom' AS prenom,
      u.raw_user_meta_data->>'nom' AS nom,
      u.raw_user_meta_data->>'telephone' AS telephone
    FROM auth.users u
    LEFT JOIN public.profiles p ON p.user_id = u.id
    WHERE p.id IS NULL
  LOOP
    -- Valider le role
    IF v_user.role NOT IN ('admin', 'owner', 'tenant', 'provider', 'guarantor') THEN
      v_user.role := 'tenant';
    END IF;

    BEGIN
      INSERT INTO public.profiles (user_id, role, email, prenom, nom, telephone)
      VALUES (
        v_user.id,
        v_user.role,
        v_user.email,
        v_user.prenom,
        v_user.nom,
        v_user.telephone
      )
      ON CONFLICT (user_id) DO NOTHING;

      v_count := v_count + 1;
    EXCEPTION WHEN OTHERS THEN
      RAISE WARNING '[fix_auth_sync] Impossible de creer le profil pour user_id=%: %',
        v_user.id, SQLERRM;
    END;
  END LOOP;

  IF v_count > 0 THEN
    RAISE NOTICE '[fix_auth_sync] % profil(s) manquant(s) cree(s)', v_count;
  ELSE
    RAISE NOTICE '[fix_auth_sync] Aucun profil manquant — tous les auth.users ont un profil';
  END IF;
END $$;

-- ============================================
-- C. BACKFILL DES EMAILS NULL
-- ============================================
-- Mettre a jour les profils existants qui ont email = NULL
-- avec l'email provenant de auth.users.

DO $$
DECLARE
  v_updated INTEGER;
BEGIN
  UPDATE public.profiles p
  SET
    email = u.email,
    updated_at = NOW()
  FROM auth.users u
  WHERE p.user_id = u.id
    AND (p.email IS NULL OR p.email = '')
    AND u.email IS NOT NULL
    AND u.email != '';

  GET DIAGNOSTICS v_updated = ROW_COUNT;

  IF v_updated > 0 THEN
    RAISE NOTICE '[fix_auth_sync] % profil(s) mis a jour avec l''email depuis auth.users', v_updated;
  ELSE
    RAISE NOTICE '[fix_auth_sync] Tous les profils ont deja un email renseigne';
  END IF;
END $$;

-- ============================================
-- D. POLICY INSERT EXPLICITE SUR PROFILES
-- ============================================
-- Le FOR ALL existant (profiles_own_access) couvre l'INSERT,
-- mais une policy INSERT explicite est plus claire et securise
-- les futures modifications de profiles_own_access.

-- Supprimer si elle existe deja (idempotent)
DROP POLICY IF EXISTS "profiles_insert_own" ON profiles;

-- Permettre a un utilisateur authentifie de creer son propre profil
-- (couvre le cas ou le trigger handle_new_user echoue et que le
--  client tente un INSERT direct ou via l'API)
CREATE POLICY "profiles_insert_own" ON profiles
  FOR INSERT TO authenticated
  WITH CHECK (user_id = auth.uid());

-- ============================================
-- E. VERIFICATION FINALE
-- ============================================
DO $$
DECLARE
  v_total_auth INTEGER;
  v_total_profiles INTEGER;
  v_orphan_count INTEGER;
  v_null_email_count INTEGER;
BEGIN
  SELECT count(*) INTO v_total_auth FROM auth.users;
  SELECT count(*) INTO v_total_profiles FROM public.profiles;

  SELECT count(*) INTO v_orphan_count
  FROM auth.users u
  LEFT JOIN public.profiles p ON p.user_id = u.id
  WHERE p.id IS NULL;

  SELECT count(*) INTO v_null_email_count
  FROM public.profiles
  WHERE email IS NULL OR email = '';

  RAISE NOTICE '========================================';
  RAISE NOTICE '  RAPPORT DE SYNCHRONISATION AUTH <-> PROFILES';
  RAISE NOTICE '========================================';
  RAISE NOTICE '  auth.users total       : %', v_total_auth;
  RAISE NOTICE '  profiles total         : %', v_total_profiles;
  RAISE NOTICE '  auth sans profil       : %', v_orphan_count;
  RAISE NOTICE '  profils sans email     : %', v_null_email_count;

  IF v_orphan_count = 0 AND v_null_email_count = 0 THEN
    RAISE NOTICE '  STATUS: SYNC OK — Aucun probleme detecte';
  ELSE
    RAISE WARNING '  STATUS: PROBLEMES RESTANTS — Verifier manuellement';
  END IF;

  RAISE NOTICE '========================================';
END $$;

-- ============================================
-- F. FONCTIONS RPC POUR LE HEALTH CHECK (/api/health/auth)
-- ============================================
-- Ces fonctions sont appelees par l'endpoint de monitoring
-- et doivent etre SECURITY DEFINER pour acceder a auth.users.

-- Compter les auth.users total
CREATE OR REPLACE FUNCTION public.count_auth_users()
RETURNS INTEGER
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT count(*)::INTEGER FROM auth.users;
$$;

-- Compter les auth.users sans profil
CREATE OR REPLACE FUNCTION public.check_auth_without_profile()
RETURNS INTEGER
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT count(*)::INTEGER
  FROM auth.users u
  LEFT JOIN public.profiles p ON p.user_id = u.id
  WHERE p.id IS NULL;
$$;

-- Compter les profils orphelins (sans auth.users)
CREATE OR REPLACE FUNCTION public.check_orphan_profiles()
RETURNS INTEGER
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT count(*)::INTEGER
  FROM public.profiles p
  LEFT JOIN auth.users u ON u.id = p.user_id
  WHERE u.id IS NULL AND p.user_id IS NOT NULL;
$$;

-- Compter les emails desynchronises
CREATE OR REPLACE FUNCTION public.check_desync_emails()
RETURNS INTEGER
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT count(*)::INTEGER
  FROM public.profiles p
  INNER JOIN auth.users u ON u.id = p.user_id
  WHERE p.email IS DISTINCT FROM u.email
    AND p.email IS NOT NULL
    AND u.email IS NOT NULL;
$$;

-- Verifier si un trigger existe sur auth.users
CREATE OR REPLACE FUNCTION public.check_trigger_exists(p_trigger_name TEXT)
RETURNS BOOLEAN
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT EXISTS(
    SELECT 1 FROM pg_trigger t
    JOIN pg_class c ON c.oid = t.tgrelid
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE t.tgname = p_trigger_name
      AND n.nspname = 'auth'
      AND c.relname = 'users'
  );
$$;

-- Verifier si une policy INSERT ou ALL existe sur une table
CREATE OR REPLACE FUNCTION public.check_insert_policy_exists(p_table_name TEXT)
RETURNS BOOLEAN
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT EXISTS(
    SELECT 1 FROM pg_policies
    WHERE tablename = p_table_name
      AND schemaname = 'public'
      AND (cmd = 'INSERT' OR cmd = '*')
  );
$$;

-- Permissions pour les fonctions de health check (admin seulement via service role)
GRANT EXECUTE ON FUNCTION public.count_auth_users() TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_auth_without_profile() TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_orphan_profiles() TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_desync_emails() TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_trigger_exists(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_insert_policy_exists(TEXT) TO authenticated;

COMMIT;

-- ========== 20260216400000_performance_indexes_rls.sql ==========
-- =====================================================
-- MIGRATION: Index de performance pour les policies RLS
-- Date: 2026-02-16
--
-- Les policies RLS sur documents et storage.objects utilisent
-- des EXISTS avec 3 niveaux de jointure. Ces index accélèrent
-- les lookups les plus fréquents.
-- =====================================================

BEGIN;

-- ============================================
-- 1. LEASE_SIGNERS: Index composite pour lookup par profile_id + lease_id
-- Utilisé par quasi toutes les policies RLS inter-comptes
-- ============================================
CREATE INDEX IF NOT EXISTS idx_lease_signers_profile_id
  ON public.lease_signers (profile_id)
  WHERE profile_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_lease_signers_invited_email_lower
  ON public.lease_signers (LOWER(invited_email))
  WHERE invited_email IS NOT NULL AND profile_id IS NULL;

CREATE INDEX IF NOT EXISTS idx_lease_signers_lease_profile
  ON public.lease_signers (lease_id, profile_id)
  WHERE profile_id IS NOT NULL;

-- ============================================
-- 2. DOCUMENTS: Index pour les colonnes utilisées dans les policies RLS
-- ============================================
CREATE INDEX IF NOT EXISTS idx_documents_property_id
  ON public.documents (property_id)
  WHERE property_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_documents_lease_id
  ON public.documents (lease_id)
  WHERE lease_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_documents_owner_id
  ON public.documents (owner_id)
  WHERE owner_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_documents_tenant_id
  ON public.documents (tenant_id)
  WHERE tenant_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_documents_storage_path
  ON public.documents (storage_path)
  WHERE storage_path IS NOT NULL;

-- ============================================
-- 3. LEASES: Index pour lookup property_id (jointures RLS)
-- ============================================
CREATE INDEX IF NOT EXISTS idx_leases_property_id
  ON public.leases (property_id);

-- ============================================
-- 4. PROPERTIES: Index pour lookup owner_id (jointures RLS)
-- ============================================
CREATE INDEX IF NOT EXISTS idx_properties_owner_id
  ON public.properties (owner_id);

-- ============================================
-- 5. INVOICES: Index pour filtrage par owner/tenant
-- ============================================
CREATE INDEX IF NOT EXISTS idx_invoices_owner_id
  ON public.invoices (owner_id)
  WHERE owner_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_invoices_tenant_id
  ON public.invoices (tenant_id)
  WHERE tenant_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_invoices_lease_id
  ON public.invoices (lease_id);

-- ============================================
-- 6. TICKETS: Index pour filtrage
-- ============================================
CREATE INDEX IF NOT EXISTS idx_tickets_property_id
  ON public.tickets (property_id)
  WHERE property_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_tickets_created_by
  ON public.tickets (created_by_profile_id)
  WHERE created_by_profile_id IS NOT NULL;

-- ============================================
-- 7. PROFILES: Index pour lookup user_id (utilisé partout)
-- ============================================
CREATE INDEX IF NOT EXISTS idx_profiles_user_id
  ON public.profiles (user_id);

-- ============================================
-- VÉRIFICATION
-- ============================================
DO $$
DECLARE
  idx_count INT;
BEGIN
  SELECT count(*) INTO idx_count
  FROM pg_indexes
  WHERE schemaname = 'public'
    AND indexname LIKE 'idx_%';

  RAISE NOTICE '✅ % index de performance créés/vérifiés', idx_count;
END $$;

COMMIT;

-- ========== 20260216500000_enforce_unique_constraints_safety.sql ==========
-- Migration: Enforce unique constraints safety net
-- Date: 2026-02-16
-- Description: S'assure que les contraintes uniques critiques sont bien appliquées.
--              Idempotent : ne fait rien si elles existent déjà.
--              Nettoie les doublons existants avant de créer les contraintes.

BEGIN;

-- =============================================
-- 1. INVOICES: unique (lease_id, periode)
-- =============================================
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'uq_invoices_lease_periode'
  ) AND NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE indexname = 'uq_invoices_lease_periode'
  ) THEN
    -- Supprimer les doublons en gardant le plus récent
    DELETE FROM invoices
    WHERE id IN (
      SELECT id FROM (
        SELECT id,
               ROW_NUMBER() OVER (PARTITION BY lease_id, periode ORDER BY created_at DESC) AS rn
        FROM invoices
        WHERE lease_id IS NOT NULL AND periode IS NOT NULL
      ) sub
      WHERE sub.rn > 1
    );

    ALTER TABLE invoices
      ADD CONSTRAINT uq_invoices_lease_periode
      UNIQUE (lease_id, periode);

    RAISE NOTICE 'Created constraint uq_invoices_lease_periode on invoices';
  ELSE
    RAISE NOTICE 'Constraint uq_invoices_lease_periode already exists, skipping';
  END IF;
END $$;

-- =============================================
-- 2. LEASE_SIGNERS: unique (lease_id, profile_id) WHERE profile_id IS NOT NULL
-- =============================================
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE indexname = 'uq_lease_signers_lease_profile'
  ) THEN
    -- Supprimer les doublons en gardant celui qui a été signé (ou le plus récent)
    DELETE FROM lease_signers
    WHERE id IN (
      SELECT id FROM (
        SELECT id,
               ROW_NUMBER() OVER (
                 PARTITION BY lease_id, profile_id
                 ORDER BY
                   CASE WHEN signature_status = 'signed' THEN 0 ELSE 1 END,
                   created_at DESC
               ) AS rn
        FROM lease_signers
        WHERE profile_id IS NOT NULL
      ) sub
      WHERE sub.rn > 1
    );

    CREATE UNIQUE INDEX uq_lease_signers_lease_profile
      ON lease_signers (lease_id, profile_id)
      WHERE profile_id IS NOT NULL;

    RAISE NOTICE 'Created index uq_lease_signers_lease_profile on lease_signers';
  ELSE
    RAISE NOTICE 'Index uq_lease_signers_lease_profile already exists, skipping';
  END IF;
END $$;

-- =============================================
-- 3. ROOMMATES: unique (lease_id, profile_id)
-- =============================================
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE indexname = 'uq_roommates_lease_profile'
  ) THEN
    -- Vérifier si la table roommates existe
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'roommates') THEN
      -- Supprimer les doublons
      DELETE FROM roommates
      WHERE id IN (
        SELECT id FROM (
          SELECT id,
                 ROW_NUMBER() OVER (PARTITION BY lease_id, profile_id ORDER BY created_at DESC) AS rn
          FROM roommates
          WHERE lease_id IS NOT NULL AND profile_id IS NOT NULL
        ) sub
        WHERE sub.rn > 1
      );

      CREATE UNIQUE INDEX uq_roommates_lease_profile
        ON roommates (lease_id, profile_id);

      RAISE NOTICE 'Created index uq_roommates_lease_profile on roommates';
    ELSE
      RAISE NOTICE 'Table roommates does not exist, skipping';
    END IF;
  ELSE
    RAISE NOTICE 'Index uq_roommates_lease_profile already exists, skipping';
  END IF;
END $$;

-- =============================================
-- 4. DOCUMENTS: Empêcher les doublons de fichiers (même storage_path)
-- =============================================
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE indexname = 'uq_documents_storage_path'
  ) THEN
    -- Supprimer les doublons en gardant le plus récent
    DELETE FROM documents
    WHERE id IN (
      SELECT id FROM (
        SELECT id,
               ROW_NUMBER() OVER (PARTITION BY storage_path ORDER BY created_at DESC) AS rn
        FROM documents
        WHERE storage_path IS NOT NULL
      ) sub
      WHERE sub.rn > 1
    );

    CREATE UNIQUE INDEX uq_documents_storage_path
      ON documents (storage_path)
      WHERE storage_path IS NOT NULL;

    RAISE NOTICE 'Created index uq_documents_storage_path on documents';
  ELSE
    RAISE NOTICE 'Index uq_documents_storage_path already exists, skipping';
  END IF;
END $$;

COMMIT;

-- ========== 20260216500000_fix_tenant_dashboard_complete.sql ==========
-- ============================================================================
-- MIGRATION: Compléter la RPC tenant_dashboard avec toutes les données nécessaires
-- Date: 2026-02-16
-- Description:
--   1. Réintroduit les clés (keys) depuis le dernier EDL signé
--   2. Ajoute owner_id, surface_habitable_m2, chauffage_energie, regime
--   3. Ajoute les champs DPE complets (consommation, emissions, dates)
--   4. Ajoute le statut 'fully_signed' au filtre des baux
--   5. Conserve la recherche par email + signers enrichis
-- ============================================================================

CREATE OR REPLACE FUNCTION tenant_dashboard(p_tenant_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_profile_id UUID;
  v_user_email TEXT;
  v_tenant_data JSONB;
  v_leases JSONB;
  v_invoices JSONB;
  v_tickets JSONB;
  v_notifications JSONB;
  v_pending_edls JSONB;
  v_insurance_status JSONB;
  v_stats JSONB;
  v_kyc_status TEXT := 'pending';
  v_result JSONB;
BEGIN
  -- 1. Récupérer l'ID du profil ET l'email de l'utilisateur
  SELECT p.id, u.email,
         jsonb_build_object(
           'id', p.id,
           'prenom', p.prenom,
           'nom', p.nom,
           'email', u.email,
           'telephone', p.telephone,
           'avatar_url', p.avatar_url
         )
  INTO v_profile_id, v_user_email, v_tenant_data
  FROM profiles p
  JOIN auth.users u ON u.id = p.user_id
  WHERE p.user_id = p_tenant_user_id AND p.role = 'tenant';

  IF v_profile_id IS NULL THEN
    RAISE NOTICE '[tenant_dashboard] Aucun profil trouvé pour user_id: %', p_tenant_user_id;
    RETURN NULL;
  END IF;

  RAISE NOTICE '[tenant_dashboard] Profil trouvé: %, email: %', v_profile_id, v_user_email;

  -- 2. Récupérer TOUS les baux avec données techniques enrichies + clés + compteurs
  SELECT jsonb_agg(lease_data ORDER BY lease_data->>'statut' = 'active' DESC, lease_data->>'created_at' DESC)
  INTO v_leases
  FROM (
    SELECT
      jsonb_build_object(
        'id', l.id,
        'type_bail', l.type_bail,
        'statut', l.statut,
        'loyer', l.loyer,
        'charges_forfaitaires', l.charges_forfaitaires,
        'depot_de_garantie', l.depot_de_garantie,
        'date_debut', l.date_debut,
        'date_fin', l.date_fin,
        'created_at', l.created_at,
        -- Signataires complets avec profils + invited fallback
        'signers', (
          SELECT COALESCE(jsonb_agg(
            jsonb_build_object(
              'id', ls2.id,
              'profile_id', ls2.profile_id,
              'role', ls2.role,
              'signature_status', ls2.signature_status,
              'signed_at', ls2.signed_at,
              'invited_name', ls2.invited_name,
              'invited_email', ls2.invited_email,
              'prenom', COALESCE(p_sig.prenom, SPLIT_PART(COALESCE(ls2.invited_name, ''), ' ', 1)),
              'nom', COALESCE(p_sig.nom, NULLIF(SPLIT_PART(COALESCE(ls2.invited_name, ''), ' ', 2), '')),
              'avatar_url', p_sig.avatar_url
            )
          ), '[]'::jsonb)
          FROM lease_signers ls2
          LEFT JOIN profiles p_sig ON p_sig.id = ls2.profile_id
          WHERE ls2.lease_id = l.id
        ),
        -- Propriété avec champs techniques complets
        'property', jsonb_build_object(
          'id', p.id,
          'owner_id', p.owner_id,
          'adresse_complete', COALESCE(p.adresse_complete, 'Adresse à compléter'),
          'ville', COALESCE(p.ville, ''),
          'code_postal', COALESCE(p.code_postal, ''),
          'type', COALESCE(p.type, 'appartement'),
          'surface', p.surface,
          'surface_habitable_m2', p.surface_habitable_m2,
          'nb_pieces', p.nb_pieces,
          'etage', p.etage,
          'ascenseur', p.ascenseur,
          'annee_construction', p.annee_construction,
          'parking_numero', p.parking_numero,
          'has_cave', p.has_cave,
          'num_lot', p.num_lot,
          'digicode', p.digicode,
          'interphone', p.interphone,
          -- DPE complet : COALESCE pour supporter ancien + nouveau nommage
          'energie', p.energie,
          'ges', p.ges,
          'dpe_classe_energie', COALESCE(p.dpe_classe_energie, p.energie),
          'dpe_classe_climat', COALESCE(p.dpe_classe_climat, p.ges),
          'dpe_consommation', p.dpe_consommation,
          'dpe_emissions', p.dpe_emissions,
          'dpe_date_realisation', p.dpe_date_realisation,
          'dpe_date_expiration', p.dpe_date_expiration,
          -- Caractéristiques techniques
          'chauffage_type', p.chauffage_type,
          'chauffage_energie', p.chauffage_energie,
          'eau_chaude_type', p.eau_chaude_type,
          'regime', p.regime,
          -- Photo de couverture
          'cover_url', (
            SELECT url FROM property_photos
            WHERE property_id = p.id AND is_main = true
            LIMIT 1
          ),
          -- Compteurs actifs avec dernière lecture
          'meters', (
            SELECT COALESCE(jsonb_agg(
              jsonb_build_object(
                'id', m.id,
                'type', m.type,
                'serial_number', m.serial_number,
                'unit', m.unit,
                'last_reading_value', (
                  SELECT reading_value FROM meter_readings
                  WHERE meter_id = m.id ORDER BY reading_date DESC LIMIT 1
                ),
                'last_reading_date', (
                  SELECT reading_date FROM meter_readings
                  WHERE meter_id = m.id ORDER BY reading_date DESC LIMIT 1
                )
              )
            ), '[]'::jsonb)
            FROM meters m
            WHERE m.property_id = p.id AND m.is_active = true
          ),
          -- Clés depuis le dernier EDL signé ou complété
          'keys', (
            SELECT e_keys.keys
            FROM edl e_keys
            WHERE e_keys.property_id = p.id
              AND e_keys.status IN ('signed', 'completed')
              AND e_keys.keys IS NOT NULL
              AND e_keys.keys != '[]'::jsonb
            ORDER BY COALESCE(e_keys.completed_date, e_keys.created_at) DESC
            LIMIT 1
          )
        ),
        -- Propriétaire
        'owner', jsonb_build_object(
          'id', owner_prof.id,
          'name', COALESCE(
            (SELECT raison_sociale FROM owner_profiles WHERE profile_id = owner_prof.id),
            CONCAT(COALESCE(owner_prof.prenom, ''), ' ', COALESCE(owner_prof.nom, ''))
          ),
          'email', owner_prof.email,
          'telephone', owner_prof.telephone
        )
      ) as lease_data
    FROM leases l
    JOIN lease_signers ls ON ls.lease_id = l.id
    JOIN properties p ON p.id = l.property_id
    JOIN profiles owner_prof ON owner_prof.id = p.owner_id
    WHERE
      (ls.profile_id = v_profile_id OR LOWER(ls.invited_email) = LOWER(v_user_email))
      AND l.statut IN ('active', 'pending_signature', 'fully_signed', 'terminated')
  ) sub;

  RAISE NOTICE '[tenant_dashboard] Baux trouvés: %', COALESCE(jsonb_array_length(v_leases), 0);

  -- 3. Factures (10 dernières)
  SELECT COALESCE(jsonb_agg(invoice_data), '[]'::jsonb) INTO v_invoices
  FROM (
    SELECT
      i.id,
      i.periode,
      i.montant_total,
      i.statut,
      i.created_at,
      i.due_date,
      p.type as property_type,
      p.adresse_complete as property_address
    FROM invoices i
    JOIN leases l ON l.id = i.lease_id
    JOIN lease_signers ls ON ls.lease_id = l.id
    JOIN properties p ON p.id = l.property_id
    WHERE (ls.profile_id = v_profile_id OR LOWER(ls.invited_email) = LOWER(v_user_email))
    ORDER BY i.periode DESC, i.created_at DESC
    LIMIT 10
  ) invoice_data;

  -- 4. Tickets récents (10 derniers)
  SELECT COALESCE(jsonb_agg(ticket_data), '[]'::jsonb) INTO v_tickets
  FROM (
    SELECT
      t.id,
      t.titre,
      t.description,
      t.priorite,
      t.statut,
      t.created_at,
      p.adresse_complete as property_address,
      p.type as property_type
    FROM tickets t
    JOIN properties p ON p.id = t.property_id
    WHERE t.created_by_profile_id = v_profile_id
    ORDER BY t.created_at DESC
    LIMIT 10
  ) ticket_data;

  -- 5. Notifications récentes
  SELECT COALESCE(jsonb_agg(notif_data), '[]'::jsonb) INTO v_notifications
  FROM (
    SELECT n.id, n.title, n.message, n.type, n.is_read, n.created_at, n.action_url
    FROM notifications n
    WHERE n.profile_id = v_profile_id
    ORDER BY n.is_read ASC, n.created_at DESC
    LIMIT 5
  ) notif_data;

  -- 6. EDLs en attente de signature
  SELECT COALESCE(jsonb_agg(edl_data), '[]'::jsonb) INTO v_pending_edls
  FROM (
    SELECT
      e.id,
      e.type,
      e.status,
      e.scheduled_at,
      es.invitation_token,
      p.adresse_complete as property_address,
      p.type as property_type
    FROM edl e
    JOIN edl_signatures es ON es.edl_id = e.id
    JOIN properties p ON p.id = e.property_id
    WHERE (es.signer_profile_id = v_profile_id OR LOWER(es.signer_email) = LOWER(v_user_email))
    AND es.signed_at IS NULL
    AND e.status IN ('draft', 'scheduled', 'in_progress', 'completed')
    ORDER BY e.created_at DESC
  ) edl_data;

  -- 7. Vérifier l'assurance
  SELECT jsonb_build_object(
    'has_insurance', EXISTS (
      SELECT 1 FROM documents
      WHERE tenant_id = v_profile_id
      AND type = 'attestation_assurance'
      AND is_archived = false
      AND (expiry_date IS NULL OR expiry_date > NOW())
    ),
    'last_expiry_date', (
      SELECT expiry_date FROM documents
      WHERE tenant_id = v_profile_id
      AND type = 'attestation_assurance'
      AND is_archived = false
      ORDER BY expiry_date DESC LIMIT 1
    )
  ) INTO v_insurance_status;

  -- 8. Stats globales
  SELECT jsonb_build_object(
    'unpaid_amount', COALESCE(SUM(i.montant_total) FILTER (WHERE i.statut IN ('sent', 'late')), 0),
    'unpaid_count', COUNT(*) FILTER (WHERE i.statut IN ('sent', 'late')),
    'total_monthly_rent', COALESCE(
      (SELECT SUM(l2.loyer + l2.charges_forfaitaires)
       FROM leases l2
       JOIN lease_signers ls2 ON ls2.lease_id = l2.id
       WHERE (ls2.profile_id = v_profile_id OR LOWER(ls2.invited_email) = LOWER(v_user_email))
       AND l2.statut = 'active'),
      0
    ),
    'active_leases_count', (
      SELECT COUNT(DISTINCT l2.id)
      FROM leases l2
      JOIN lease_signers ls2 ON ls2.lease_id = l2.id
      WHERE (ls2.profile_id = v_profile_id OR LOWER(ls2.invited_email) = LOWER(v_user_email))
      AND l2.statut = 'active'
    )
  ) INTO v_stats
  FROM leases l
  JOIN lease_signers ls ON ls.lease_id = l.id
  LEFT JOIN invoices i ON i.lease_id = l.id
  WHERE (ls.profile_id = v_profile_id OR LOWER(ls.invited_email) = LOWER(v_user_email));

  -- 9. KYC status
  BEGIN
    SELECT COALESCE(tp.kyc_status, 'pending') INTO v_kyc_status
    FROM tenant_profiles tp
    WHERE tp.profile_id = v_profile_id;
  EXCEPTION WHEN OTHERS THEN
    v_kyc_status := 'pending';
  END;

  -- 10. Assembler le résultat final
  v_result := jsonb_build_object(
    'profile_id', v_profile_id,
    'tenant', v_tenant_data,
    'kyc_status', COALESCE(v_kyc_status, 'pending'),
    'leases', COALESCE(v_leases, '[]'::jsonb),
    'lease', CASE WHEN v_leases IS NOT NULL AND jsonb_array_length(v_leases) > 0 THEN v_leases->0 ELSE NULL END,
    'property', CASE WHEN v_leases IS NOT NULL AND jsonb_array_length(v_leases) > 0 THEN (v_leases->0)->'property' ELSE NULL END,
    'invoices', v_invoices,
    'tickets', v_tickets,
    'notifications', v_notifications,
    'pending_edls', v_pending_edls,
    'insurance', v_insurance_status,
    'stats', COALESCE(v_stats, '{"unpaid_amount": 0, "unpaid_count": 0, "total_monthly_rent": 0, "active_leases_count": 0}'::jsonb)
  );

  RETURN v_result;
END;
$$;

COMMENT ON FUNCTION tenant_dashboard(UUID) IS
'RPC dashboard locataire v4. Cherche par profile_id OU invited_email.
Inclut: signers enrichis, property complète (DPE, meters, keys), insurance, KYC status.';

-- ========== 20260217000000_data_integrity_audit_repair.sql ==========
-- ============================================================================
-- MIGRATION: Audit & Réparation Intégrité Relationnelle Complète
-- Date: 2026-02-17
-- Version: 20260217000000
--
-- CONTEXTE:
--   Les données existent en base mais les liens entre tables sont cassés.
--   Un locataire se connecte → dashboard vide (lease_signers non liés).
--   Un propriétaire se connecte → ne voit pas ses biens (owner_id incorrect).
--
-- SCHÉMA RELATIONNEL RÉEL DÉCOUVERT:
--   auth.users (id)
--     └── profiles (user_id → auth.users.id)
--           ├── properties (owner_id → profiles.id)
--           │     ├── leases (property_id → properties.id)
--           │     │     ├── lease_signers (lease_id, profile_id → profiles.id)
--           │     │     ├── invoices (lease_id, owner_id, tenant_id)
--           │     │     └── edl (lease_id, property_id)
--           │     ├── tickets (property_id, created_by_profile_id, owner_id)
--           │     ├── meters (property_id)
--           │     └── documents (property_id, lease_id, profile_id)
--           ├── notifications (profile_id)
--           └── subscriptions (user_id)
--
-- NOTE: La relation bail↔locataire passe par `lease_signers` (pas de tenant_id sur leases).
--
-- ACTIONS:
--   A. Créer la table d'audit _repair_log
--   B. Réparer auth→profiles (profils manquants, emails NULL)
--   C. Réparer lease_signers orphelins (profile_id NULL avec email match)
--   D. Réparer invoices.tenant_id orphelins
--   E. Réparer invoices.owner_id orphelins
--   F. Créer la fonction check_data_integrity()
--   G. Créer le trigger de validation sur leases
--   H. Ajouter les FK manquantes (si safe)
--   I. Rapport final
-- ============================================================================

BEGIN;

-- ============================================
-- A. TABLE D'AUDIT _repair_log
-- ============================================
CREATE TABLE IF NOT EXISTS public._repair_log (
  id SERIAL PRIMARY KEY,
  repair_date TIMESTAMPTZ DEFAULT NOW(),
  table_name TEXT NOT NULL,
  record_id TEXT,
  action TEXT NOT NULL, -- 'INSERT', 'UPDATE', 'LINK', 'DELETE', 'DIAGNOSTIC'
  details JSONB,
  reversed BOOLEAN DEFAULT FALSE
);

COMMENT ON TABLE public._repair_log IS
  'Table d''audit pour tracer toutes les opérations de réparation d''intégrité relationnelle.';

-- ============================================
-- B. RÉPARER auth.users → profiles
-- ============================================
-- B.1 Créer les profils manquants (consolidated - may already be done by 20260216300000)
DO $$
DECLARE
  v_count INTEGER := 0;
  v_user RECORD;
BEGIN
  FOR v_user IN
    SELECT
      au.id,
      au.email,
      COALESCE(au.raw_user_meta_data->>'role', 'tenant') AS role,
      au.raw_user_meta_data->>'prenom' AS prenom,
      au.raw_user_meta_data->>'nom' AS nom,
      au.raw_user_meta_data->>'telephone' AS telephone
    FROM auth.users au
    LEFT JOIN public.profiles p ON p.user_id = au.id
    WHERE p.id IS NULL
  LOOP
    IF v_user.role NOT IN ('admin', 'owner', 'tenant', 'provider', 'guarantor') THEN
      v_user.role := 'tenant';
    END IF;

    BEGIN
      INSERT INTO public.profiles (user_id, role, email, prenom, nom, telephone)
      VALUES (v_user.id, v_user.role, v_user.email, v_user.prenom, v_user.nom, v_user.telephone)
      ON CONFLICT (user_id) DO NOTHING;

      IF FOUND THEN
        v_count := v_count + 1;
        INSERT INTO public._repair_log (table_name, record_id, action, details)
        VALUES ('profiles', v_user.id::TEXT, 'INSERT',
          jsonb_build_object('email', v_user.email, 'role', v_user.role, 'reason', 'user_sans_profil'));
      END IF;
    EXCEPTION WHEN OTHERS THEN
      RAISE WARNING '[repair] Erreur creation profil user_id=%: %', v_user.id, SQLERRM;
    END;
  END LOOP;

  RAISE NOTICE '[B.1] % profil(s) manquant(s) créé(s)', v_count;
END $$;

-- B.2 Backfill emails NULL dans profiles
DO $$
DECLARE
  v_updated INTEGER;
BEGIN
  WITH updated AS (
    UPDATE public.profiles p
    SET email = au.email, updated_at = NOW()
    FROM auth.users au
    WHERE p.user_id = au.id
      AND (p.email IS NULL OR p.email = '')
      AND au.email IS NOT NULL AND au.email != ''
    RETURNING p.id, au.email AS new_email
  )
  INSERT INTO public._repair_log (table_name, record_id, action, details)
  SELECT 'profiles', id::TEXT, 'UPDATE',
    jsonb_build_object('new_email', new_email, 'reason', 'email_null_backfill')
  FROM updated;

  GET DIAGNOSTICS v_updated = ROW_COUNT;
  RAISE NOTICE '[B.2] % email(s) backfillé(s)', v_updated;
END $$;

-- B.3 Synchroniser les emails désynchronisés (auth.email != profile.email)
DO $$
DECLARE
  v_updated INTEGER;
BEGIN
  WITH updated AS (
    UPDATE public.profiles p
    SET email = au.email, updated_at = NOW()
    FROM auth.users au
    WHERE p.user_id = au.id
      AND p.email IS DISTINCT FROM au.email
      AND au.email IS NOT NULL AND au.email != ''
      AND p.email IS NOT NULL
    RETURNING p.id, p.email AS old_email, au.email AS new_email
  )
  INSERT INTO public._repair_log (table_name, record_id, action, details)
  SELECT 'profiles', id::TEXT, 'UPDATE',
    jsonb_build_object('old_email', old_email, 'new_email', new_email, 'reason', 'email_desync')
  FROM updated;

  GET DIAGNOSTICS v_updated = ROW_COUNT;
  RAISE NOTICE '[B.3] % email(s) resynchronisé(s)', v_updated;
END $$;

-- ============================================
-- C. RÉPARER lease_signers ORPHELINS
-- ============================================
-- C.1 Lier les lease_signers dont invited_email matche un profil existant
DO $$
DECLARE
  v_linked INTEGER := 0;
  rec RECORD;
BEGIN
  FOR rec IN
    SELECT p.id AS profile_id, LOWER(au.email) AS user_email
    FROM public.profiles p
    JOIN auth.users au ON au.id = p.user_id
    WHERE au.email IS NOT NULL AND au.email != ''
      AND EXISTS (
        SELECT 1 FROM public.lease_signers ls
        WHERE LOWER(ls.invited_email) = LOWER(au.email)
          AND ls.profile_id IS NULL
      )
  LOOP
    UPDATE public.lease_signers
    SET profile_id = rec.profile_id
    WHERE LOWER(invited_email) = rec.user_email
      AND profile_id IS NULL;

    IF FOUND THEN
      v_linked := v_linked + 1;
      INSERT INTO public._repair_log (table_name, record_id, action, details)
      VALUES ('lease_signers', rec.profile_id::TEXT, 'LINK',
        jsonb_build_object('email', rec.user_email, 'reason', 'orphan_signer_relinked'));
    END IF;
  END LOOP;

  RAISE NOTICE '[C.1] % profil(s) liés à des lease_signers orphelins', v_linked;
END $$;

-- C.2 Compter les lease_signers encore orphelins (ceux qui n'ont pas de compte)
DO $$
DECLARE
  v_orphan_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_orphan_count
  FROM public.lease_signers
  WHERE profile_id IS NULL
    AND invited_email IS NOT NULL
    AND invited_email != ''
    AND invited_email != 'locataire@a-definir.com';

  INSERT INTO public._repair_log (table_name, action, details)
  VALUES ('lease_signers', 'DIAGNOSTIC',
    jsonb_build_object('orphan_signers_remaining', v_orphan_count,
      'note', 'Ces locataires n''ont pas encore créé leur compte'));

  IF v_orphan_count > 0 THEN
    RAISE NOTICE '[C.2] % lease_signers orphelins restants (locataires sans compte)', v_orphan_count;
  ELSE
    RAISE NOTICE '[C.2] Aucun lease_signer orphelin restant';
  END IF;
END $$;

-- ============================================
-- D. RÉPARER invoices.tenant_id ORPHELINS
-- ============================================
-- Les invoices doivent avoir un tenant_id qui pointe vers le profile du locataire du bail
DO $$
DECLARE
  v_fixed INTEGER := 0;
BEGIN
  -- Cas 1: invoices avec tenant_id NULL - remplir depuis lease_signers
  WITH fix AS (
    UPDATE public.invoices inv
    SET tenant_id = ls.profile_id
    FROM public.lease_signers ls
    WHERE inv.lease_id = ls.lease_id
      AND ls.role IN ('locataire_principal', 'colocataire')
      AND ls.profile_id IS NOT NULL
      AND (inv.tenant_id IS NULL OR NOT EXISTS (
        SELECT 1 FROM public.profiles WHERE id = inv.tenant_id
      ))
    RETURNING inv.id, ls.profile_id AS new_tenant_id
  )
  INSERT INTO public._repair_log (table_name, record_id, action, details)
  SELECT 'invoices', id::TEXT, 'UPDATE',
    jsonb_build_object('new_tenant_id', new_tenant_id, 'reason', 'tenant_id_orphan_or_null')
  FROM fix;

  GET DIAGNOSTICS v_fixed = ROW_COUNT;
  RAISE NOTICE '[D] % invoice(s) avec tenant_id réparé(s)', v_fixed;
END $$;

-- ============================================
-- E. RÉPARER invoices.owner_id ORPHELINS
-- ============================================
DO $$
DECLARE
  v_fixed INTEGER := 0;
BEGIN
  WITH fix AS (
    UPDATE public.invoices inv
    SET owner_id = prop.owner_id
    FROM public.leases l
    JOIN public.properties prop ON prop.id = l.property_id
    WHERE inv.lease_id = l.id
      AND (inv.owner_id IS NULL OR NOT EXISTS (
        SELECT 1 FROM public.profiles WHERE id = inv.owner_id
      ))
      AND prop.owner_id IS NOT NULL
    RETURNING inv.id, prop.owner_id AS new_owner_id
  )
  INSERT INTO public._repair_log (table_name, record_id, action, details)
  SELECT 'invoices', id::TEXT, 'UPDATE',
    jsonb_build_object('new_owner_id', new_owner_id, 'reason', 'owner_id_orphan_or_null')
  FROM fix;

  GET DIAGNOSTICS v_fixed = ROW_COUNT;
  RAISE NOTICE '[E] % invoice(s) avec owner_id réparé(s)', v_fixed;
END $$;

-- ============================================
-- F. FONCTION check_data_integrity()
-- ============================================
CREATE OR REPLACE FUNCTION public.check_data_integrity()
RETURNS TABLE (
  check_name TEXT,
  status TEXT,
  count INT,
  details TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Check 1: Auth users sans profil
  RETURN QUERY
  SELECT 'users_sans_profil'::TEXT,
    CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ERREUR' END::TEXT,
    COUNT(*)::INT,
    'Utilisateurs auth.users sans profil dans public.profiles'::TEXT
  FROM auth.users au
  LEFT JOIN public.profiles p ON p.user_id = au.id
  WHERE p.id IS NULL;

  -- Check 2: Profils orphelins (sans auth.users)
  RETURN QUERY
  SELECT 'profils_orphelins'::TEXT,
    CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ATTENTION' END::TEXT,
    COUNT(*)::INT,
    'Profils sans utilisateur auth.users correspondant'::TEXT
  FROM public.profiles p
  LEFT JOIN auth.users au ON au.id = p.user_id
  WHERE au.id IS NULL AND p.user_id IS NOT NULL;

  -- Check 3: Emails désynchronisés
  RETURN QUERY
  SELECT 'emails_desync'::TEXT,
    CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ATTENTION' END::TEXT,
    COUNT(*)::INT,
    'Profils avec email different de auth.users'::TEXT
  FROM public.profiles p
  JOIN auth.users au ON au.id = p.user_id
  WHERE p.email IS DISTINCT FROM au.email
    AND p.email IS NOT NULL AND au.email IS NOT NULL;

  -- Check 4: Properties sans owner valide
  RETURN QUERY
  SELECT 'properties_sans_owner'::TEXT,
    CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ERREUR' END::TEXT,
    COUNT(*)::INT,
    'Propriétés dont owner_id ne pointe vers aucun profil'::TEXT
  FROM public.properties pr
  LEFT JOIN public.profiles p ON pr.owner_id = p.id
  WHERE p.id IS NULL;

  -- Check 5: Properties dont l'owner n'est pas role='owner'
  RETURN QUERY
  SELECT 'properties_owner_mauvais_role'::TEXT,
    CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ATTENTION' END::TEXT,
    COUNT(*)::INT,
    'Propriétés dont le owner_id pointe vers un profil non-owner'::TEXT
  FROM public.properties pr
  JOIN public.profiles p ON pr.owner_id = p.id
  WHERE p.role NOT IN ('owner', 'admin');

  -- Check 6: Leases sans property valide
  RETURN QUERY
  SELECT 'leases_sans_property'::TEXT,
    CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ERREUR' END::TEXT,
    COUNT(*)::INT,
    'Baux dont property_id ne pointe vers aucune propriété'::TEXT
  FROM public.leases l
  LEFT JOIN public.properties pr ON l.property_id = pr.id
  WHERE pr.id IS NULL;

  -- Check 7: Leases sans aucun signataire locataire
  RETURN QUERY
  SELECT 'leases_sans_tenant_signer'::TEXT,
    CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ATTENTION' END::TEXT,
    COUNT(*)::INT,
    'Baux sans signataire locataire dans lease_signers'::TEXT
  FROM public.leases l
  WHERE NOT EXISTS (
    SELECT 1 FROM public.lease_signers ls
    WHERE ls.lease_id = l.id
      AND ls.role IN ('locataire_principal', 'colocataire')
  )
  AND l.statut NOT IN ('draft', 'archived');

  -- Check 8: Lease_signers orphelins (profile_id NULL, email match un profil existant)
  RETURN QUERY
  SELECT 'lease_signers_linkables'::TEXT,
    CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ATTENTION' END::TEXT,
    COUNT(*)::INT,
    'Signataires avec profile_id NULL qui pourraient etre liés'::TEXT
  FROM public.lease_signers ls
  WHERE ls.profile_id IS NULL
    AND ls.invited_email IS NOT NULL
    AND EXISTS (
      SELECT 1 FROM auth.users au2
      JOIN public.profiles p2 ON p2.user_id = au2.id
      WHERE LOWER(au2.email) = LOWER(ls.invited_email)
    );

  -- Check 9: Lease_signers orphelins (email sans compte)
  RETURN QUERY
  SELECT 'lease_signers_sans_compte'::TEXT,
    'INFO'::TEXT,
    COUNT(*)::INT,
    'Signataires invités qui n''ont pas encore créé leur compte'::TEXT
  FROM public.lease_signers ls
  WHERE ls.profile_id IS NULL
    AND ls.invited_email IS NOT NULL
    AND ls.invited_email != 'locataire@a-definir.com'
    AND NOT EXISTS (
      SELECT 1 FROM auth.users au2
      WHERE LOWER(au2.email) = LOWER(ls.invited_email)
    );

  -- Check 10: Invoices sans lease valide
  RETURN QUERY
  SELECT 'invoices_sans_lease'::TEXT,
    CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ERREUR' END::TEXT,
    COUNT(*)::INT,
    'Factures dont lease_id ne pointe vers aucun bail'::TEXT
  FROM public.invoices inv
  LEFT JOIN public.leases l ON inv.lease_id = l.id
  WHERE l.id IS NULL AND inv.lease_id IS NOT NULL;

  -- Check 11: Invoices sans tenant_id valide
  RETURN QUERY
  SELECT 'invoices_sans_tenant'::TEXT,
    CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ATTENTION' END::TEXT,
    COUNT(*)::INT,
    'Factures avec tenant_id NULL ou pointant vers un profil inexistant'::TEXT
  FROM public.invoices inv
  LEFT JOIN public.profiles p ON inv.tenant_id = p.id
  WHERE (inv.tenant_id IS NULL OR p.id IS NULL)
    AND inv.lease_id IS NOT NULL;

  -- Check 12: Documents orphelins (property_id invalide)
  BEGIN
    RETURN QUERY
    SELECT 'documents_orphelins'::TEXT,
      CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ATTENTION' END::TEXT,
      COUNT(*)::INT,
      'Documents dont property_id pointe vers une propriété inexistante'::TEXT
    FROM public.documents d
    LEFT JOIN public.properties pr ON d.property_id = pr.id
    WHERE d.property_id IS NOT NULL AND pr.id IS NULL;
  EXCEPTION WHEN undefined_table THEN
    RETURN QUERY SELECT 'documents_orphelins'::TEXT, 'N/A'::TEXT, 0::INT,
      'Table documents inexistante'::TEXT;
  END;

  -- Check 13: Tickets orphelins (property_id invalide)
  BEGIN
    RETURN QUERY
    SELECT 'tickets_orphelins'::TEXT,
      CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ATTENTION' END::TEXT,
      COUNT(*)::INT,
      'Tickets dont property_id pointe vers une propriété inexistante'::TEXT
    FROM public.tickets t
    LEFT JOIN public.properties pr ON t.property_id = pr.id
    WHERE t.property_id IS NOT NULL AND pr.id IS NULL;
  EXCEPTION WHEN undefined_table THEN
    RETURN QUERY SELECT 'tickets_orphelins'::TEXT, 'N/A'::TEXT, 0::INT,
      'Table tickets inexistante'::TEXT;
  END;

  -- Check 14: EDL orphelins
  BEGIN
    RETURN QUERY
    SELECT 'edl_orphelins'::TEXT,
      CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ATTENTION' END::TEXT,
      COUNT(*)::INT,
      'EDL dont lease_id pointe vers un bail inexistant'::TEXT
    FROM public.edl e
    LEFT JOIN public.leases l ON e.lease_id = l.id
    WHERE e.lease_id IS NOT NULL AND l.id IS NULL;
  EXCEPTION WHEN undefined_table THEN
    RETURN QUERY SELECT 'edl_orphelins'::TEXT, 'N/A'::TEXT, 0::INT,
      'Table edl inexistante'::TEXT;
  END;

  -- Check 15: Notifications orphelines
  BEGIN
    RETURN QUERY
    SELECT 'notifications_orphelines'::TEXT,
      CASE WHEN COUNT(*) = 0 THEN 'OK' ELSE 'ATTENTION' END::TEXT,
      COUNT(*)::INT,
      'Notifications dont profile_id ne pointe vers aucun profil'::TEXT
    FROM public.notifications n
    LEFT JOIN public.profiles p ON n.profile_id = p.id
    WHERE n.profile_id IS NOT NULL AND p.id IS NULL;
  EXCEPTION WHEN undefined_table THEN
    RETURN QUERY SELECT 'notifications_orphelines'::TEXT, 'N/A'::TEXT, 0::INT,
      'Table notifications inexistante'::TEXT;
  END;

  -- Check 16: Chaînes complètes owner→property→lease→tenant
  RETURN QUERY
  SELECT 'chaines_completes'::TEXT,
    'INFO'::TEXT,
    COUNT(DISTINCT l.id)::INT,
    'Baux avec chaîne complète owner→property→lease→tenant_signer'::TEXT
  FROM public.leases l
  JOIN public.properties pr ON l.property_id = pr.id
  JOIN public.profiles own ON pr.owner_id = own.id
  JOIN public.lease_signers ls ON ls.lease_id = l.id
    AND ls.role IN ('locataire_principal', 'colocataire')
    AND ls.profile_id IS NOT NULL
  JOIN public.profiles ten ON ls.profile_id = ten.id;

  -- Check 17: Trigger handle_new_user existe
  RETURN QUERY
  SELECT 'trigger_handle_new_user'::TEXT,
    CASE WHEN EXISTS (
      SELECT 1 FROM pg_trigger t
      JOIN pg_class c ON c.oid = t.tgrelid
      JOIN pg_namespace n ON n.oid = c.relnamespace
      WHERE t.tgname = 'on_auth_user_created'
        AND n.nspname = 'auth' AND c.relname = 'users'
    ) THEN 'OK' ELSE 'ERREUR' END::TEXT,
    0::INT,
    'Trigger on_auth_user_created sur auth.users'::TEXT;

  -- Check 18: Trigger auto_link_lease_signers existe
  RETURN QUERY
  SELECT 'trigger_auto_link'::TEXT,
    CASE WHEN EXISTS (
      SELECT 1 FROM pg_trigger t
      JOIN pg_class c ON c.oid = t.tgrelid
      JOIN pg_namespace n ON n.oid = c.relnamespace
      WHERE t.tgname = 'trigger_auto_link_lease_signers'
        AND n.nspname = 'public' AND c.relname = 'profiles'
    ) THEN 'OK' ELSE 'ERREUR' END::TEXT,
    0::INT,
    'Trigger auto_link_lease_signers sur profiles'::TEXT;
END;
$$;

COMMENT ON FUNCTION public.check_data_integrity() IS
  'Fonction de diagnostic complète pour vérifier l''intégrité relationnelle de toutes les tables.
   Usage: SELECT * FROM check_data_integrity();';

GRANT EXECUTE ON FUNCTION public.check_data_integrity() TO authenticated;

-- ============================================
-- G. TRIGGER DE VALIDATION SUR LEASES
-- ============================================
-- Empêche la création d'un bail avec un property_id invalide
CREATE OR REPLACE FUNCTION public.validate_lease_insert()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Vérifier que la property existe
  IF NOT EXISTS (
    SELECT 1 FROM public.properties WHERE id = NEW.property_id
  ) THEN
    RAISE EXCEPTION 'Property % inexistante', NEW.property_id;
  END IF;

  -- Si unit_id est fourni, vérifier qu'il existe et appartient à la property
  IF NEW.unit_id IS NOT NULL THEN
    IF NOT EXISTS (
      SELECT 1 FROM public.units
      WHERE id = NEW.unit_id AND property_id = NEW.property_id
    ) THEN
      RAISE EXCEPTION 'Unit % inexistante ou n''appartient pas à la property %',
        NEW.unit_id, NEW.property_id;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS validate_lease_before_insert ON public.leases;
CREATE TRIGGER validate_lease_before_insert
  BEFORE INSERT ON public.leases
  FOR EACH ROW
  EXECUTE FUNCTION public.validate_lease_insert();

COMMENT ON TRIGGER validate_lease_before_insert ON public.leases IS
  'Valide que property_id et unit_id sont valides avant l''insertion d''un bail.';

-- ============================================
-- G.2 TRIGGER: Auto-link lease_signers quand un profil est MIS À JOUR avec un email
-- ============================================
-- Couvre le cas où un profil existant n'avait pas d'email et le reçoit plus tard
CREATE OR REPLACE FUNCTION public.auto_link_lease_signers_on_profile_email_update()
RETURNS TRIGGER AS $$
DECLARE
  user_email TEXT;
  linked_count INT;
BEGIN
  -- Seulement si l'email a changé
  IF NEW.email IS NOT NULL AND NEW.email != '' AND (OLD.email IS NULL OR OLD.email = '' OR OLD.email != NEW.email) THEN
    -- Aussi récupérer l'email auth pour double-check
    SELECT email INTO user_email FROM auth.users WHERE id = NEW.user_id;
    user_email := COALESCE(user_email, NEW.email);

    UPDATE public.lease_signers
    SET profile_id = NEW.id
    WHERE LOWER(invited_email) = LOWER(user_email)
      AND profile_id IS NULL;

    GET DIAGNOSTICS linked_count = ROW_COUNT;

    IF linked_count > 0 THEN
      RAISE NOTICE '[auto_link_update] % lease_signers liés au profil % (email: %)',
        linked_count, NEW.id, user_email;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trigger_auto_link_on_profile_update ON public.profiles;
CREATE TRIGGER trigger_auto_link_on_profile_update
  AFTER UPDATE OF email ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.auto_link_lease_signers_on_profile_email_update();

-- ============================================
-- H. FK MANQUANTES (ajoutées SEULEMENT si safe)
-- ============================================

-- H.1 properties.owner_id → profiles.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'fk_properties_owner'
      AND table_name = 'properties' AND table_schema = 'public'
  ) AND NOT EXISTS (
    -- Vérifier qu'il n'y a pas de FK existante avec un autre nom
    SELECT 1 FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    WHERE tc.table_name = 'properties' AND tc.table_schema = 'public'
      AND tc.constraint_type = 'FOREIGN KEY' AND kcu.column_name = 'owner_id'
  ) THEN
    -- Vérifier qu'il n'y a pas de données orphelines
    IF NOT EXISTS (
      SELECT 1 FROM public.properties pr
      LEFT JOIN public.profiles p ON pr.owner_id = p.id
      WHERE p.id IS NULL AND pr.owner_id IS NOT NULL
    ) THEN
      ALTER TABLE public.properties
        ADD CONSTRAINT fk_properties_owner
        FOREIGN KEY (owner_id) REFERENCES public.profiles(id) ON DELETE RESTRICT;
      RAISE NOTICE '[H.1] FK fk_properties_owner créée';
    ELSE
      RAISE WARNING '[H.1] FK fk_properties_owner NON créée: données orphelines existantes';
    END IF;
  ELSE
    RAISE NOTICE '[H.1] FK sur properties.owner_id existe déjà — skip';
  END IF;
END $$;

-- H.2 leases.property_id → properties.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    WHERE tc.table_name = 'leases' AND tc.table_schema = 'public'
      AND tc.constraint_type = 'FOREIGN KEY' AND kcu.column_name = 'property_id'
  ) THEN
    IF NOT EXISTS (
      SELECT 1 FROM public.leases l
      LEFT JOIN public.properties pr ON l.property_id = pr.id
      WHERE pr.id IS NULL AND l.property_id IS NOT NULL
    ) THEN
      ALTER TABLE public.leases
        ADD CONSTRAINT fk_leases_property
        FOREIGN KEY (property_id) REFERENCES public.properties(id) ON DELETE RESTRICT;
      RAISE NOTICE '[H.2] FK fk_leases_property créée';
    ELSE
      RAISE WARNING '[H.2] FK fk_leases_property NON créée: données orphelines';
    END IF;
  ELSE
    RAISE NOTICE '[H.2] FK sur leases.property_id existe déjà — skip';
  END IF;
END $$;

-- H.3 lease_signers.lease_id → leases.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    WHERE tc.table_name = 'lease_signers' AND tc.table_schema = 'public'
      AND tc.constraint_type = 'FOREIGN KEY' AND kcu.column_name = 'lease_id'
  ) THEN
    IF NOT EXISTS (
      SELECT 1 FROM public.lease_signers ls
      LEFT JOIN public.leases l ON ls.lease_id = l.id
      WHERE l.id IS NULL AND ls.lease_id IS NOT NULL
    ) THEN
      ALTER TABLE public.lease_signers
        ADD CONSTRAINT fk_lease_signers_lease
        FOREIGN KEY (lease_id) REFERENCES public.leases(id) ON DELETE CASCADE;
      RAISE NOTICE '[H.3] FK fk_lease_signers_lease créée';
    ELSE
      RAISE WARNING '[H.3] FK fk_lease_signers_lease NON créée: données orphelines';
    END IF;
  ELSE
    RAISE NOTICE '[H.3] FK sur lease_signers.lease_id existe déjà — skip';
  END IF;
END $$;

-- H.4 lease_signers.profile_id → profiles.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    WHERE tc.table_name = 'lease_signers' AND tc.table_schema = 'public'
      AND tc.constraint_type = 'FOREIGN KEY' AND kcu.column_name = 'profile_id'
  ) THEN
    IF NOT EXISTS (
      SELECT 1 FROM public.lease_signers ls
      LEFT JOIN public.profiles p ON ls.profile_id = p.id
      WHERE p.id IS NULL AND ls.profile_id IS NOT NULL
    ) THEN
      ALTER TABLE public.lease_signers
        ADD CONSTRAINT fk_lease_signers_profile
        FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL;
      RAISE NOTICE '[H.4] FK fk_lease_signers_profile créée';
    ELSE
      RAISE WARNING '[H.4] FK fk_lease_signers_profile NON créée: données orphelines';
    END IF;
  ELSE
    RAISE NOTICE '[H.4] FK sur lease_signers.profile_id existe déjà — skip';
  END IF;
END $$;

-- H.5 invoices.lease_id → leases.id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
    WHERE tc.table_name = 'invoices' AND tc.table_schema = 'public'
      AND tc.constraint_type = 'FOREIGN KEY' AND kcu.column_name = 'lease_id'
  ) THEN
    IF NOT EXISTS (
      SELECT 1 FROM public.invoices inv
      LEFT JOIN public.leases l ON inv.lease_id = l.id
      WHERE l.id IS NULL AND inv.lease_id IS NOT NULL
    ) THEN
      ALTER TABLE public.invoices
        ADD CONSTRAINT fk_invoices_lease
        FOREIGN KEY (lease_id) REFERENCES public.leases(id) ON DELETE RESTRICT;
      RAISE NOTICE '[H.5] FK fk_invoices_lease créée';
    ELSE
      RAISE WARNING '[H.5] FK fk_invoices_lease NON créée: données orphelines';
    END IF;
  ELSE
    RAISE NOTICE '[H.5] FK sur invoices.lease_id existe déjà — skip';
  END IF;
END $$;

-- ============================================
-- I. RAPPORT FINAL
-- ============================================
DO $$
DECLARE
  v_auth_users INT;
  v_profiles INT;
  v_users_sans_profil INT;
  v_profils_orphelins INT;
  v_properties INT;
  v_props_sans_owner INT;
  v_leases INT;
  v_leases_sans_property INT;
  v_signers_orphelins INT;
  v_signers_linkables INT;
  v_chaines_completes INT;
  v_repair_count INT;
BEGIN
  SELECT COUNT(*) INTO v_auth_users FROM auth.users;
  SELECT COUNT(*) INTO v_profiles FROM public.profiles;

  SELECT COUNT(*) INTO v_users_sans_profil
  FROM auth.users au LEFT JOIN public.profiles p ON p.user_id = au.id WHERE p.id IS NULL;

  SELECT COUNT(*) INTO v_profils_orphelins
  FROM public.profiles p LEFT JOIN auth.users au ON au.id = p.user_id WHERE au.id IS NULL AND p.user_id IS NOT NULL;

  SELECT COUNT(*) INTO v_properties FROM public.properties;
  SELECT COUNT(*) INTO v_props_sans_owner
  FROM public.properties pr LEFT JOIN public.profiles p ON pr.owner_id = p.id WHERE p.id IS NULL;

  SELECT COUNT(*) INTO v_leases FROM public.leases;
  SELECT COUNT(*) INTO v_leases_sans_property
  FROM public.leases l LEFT JOIN public.properties pr ON l.property_id = pr.id WHERE pr.id IS NULL;

  SELECT COUNT(*) INTO v_signers_orphelins
  FROM public.lease_signers WHERE profile_id IS NULL AND invited_email IS NOT NULL
    AND invited_email != 'locataire@a-definir.com';

  SELECT COUNT(*) INTO v_signers_linkables
  FROM public.lease_signers ls
  WHERE ls.profile_id IS NULL AND ls.invited_email IS NOT NULL
    AND EXISTS (
      SELECT 1 FROM auth.users au2
      JOIN public.profiles p2 ON p2.user_id = au2.id
      WHERE LOWER(au2.email) = LOWER(ls.invited_email)
    );

  SELECT COUNT(DISTINCT l.id) INTO v_chaines_completes
  FROM public.leases l
  JOIN public.properties pr ON l.property_id = pr.id
  JOIN public.profiles own ON pr.owner_id = own.id
  JOIN public.lease_signers ls ON ls.lease_id = l.id
    AND ls.role IN ('locataire_principal', 'colocataire')
    AND ls.profile_id IS NOT NULL
  JOIN public.profiles ten ON ls.profile_id = ten.id;

  SELECT COUNT(*) INTO v_repair_count FROM public._repair_log;

  RAISE NOTICE '';
  RAISE NOTICE '================================================================';
  RAISE NOTICE '  RAPPORT INTEGRITE RELATIONNELLE — TALOK — POST-REPARATION';
  RAISE NOTICE '================================================================';
  RAISE NOTICE '  Date : %', NOW();
  RAISE NOTICE '----------------------------------------------------------------';
  RAISE NOTICE '  AUTH -> PROFILES';
  RAISE NOTICE '    Auth users total         : %', v_auth_users;
  RAISE NOTICE '    Profiles total           : %', v_profiles;
  RAISE NOTICE '    Users SANS profil        : % %', v_users_sans_profil,
    CASE WHEN v_users_sans_profil = 0 THEN '(OK)' ELSE '(ERREUR)' END;
  RAISE NOTICE '    Profils orphelins        : % %', v_profils_orphelins,
    CASE WHEN v_profils_orphelins = 0 THEN '(OK)' ELSE '(ATTENTION)' END;
  RAISE NOTICE '----------------------------------------------------------------';
  RAISE NOTICE '  PROPERTIES';
  RAISE NOTICE '    Total                    : %', v_properties;
  RAISE NOTICE '    Sans owner valide        : % %', v_props_sans_owner,
    CASE WHEN v_props_sans_owner = 0 THEN '(OK)' ELSE '(ERREUR)' END;
  RAISE NOTICE '----------------------------------------------------------------';
  RAISE NOTICE '  LEASES (BAUX)';
  RAISE NOTICE '    Total                    : %', v_leases;
  RAISE NOTICE '    Sans property valide     : % %', v_leases_sans_property,
    CASE WHEN v_leases_sans_property = 0 THEN '(OK)' ELSE '(ERREUR)' END;
  RAISE NOTICE '----------------------------------------------------------------';
  RAISE NOTICE '  LEASE_SIGNERS';
  RAISE NOTICE '    Orphelins (pas de compte): %', v_signers_orphelins;
  RAISE NOTICE '    Linkables (ont un compte): % %', v_signers_linkables,
    CASE WHEN v_signers_linkables = 0 THEN '(OK)' ELSE '(A REPARER)' END;
  RAISE NOTICE '----------------------------------------------------------------';
  RAISE NOTICE '  CHAINES COMPLETES';
  RAISE NOTICE '    owner->property->lease->tenant: %', v_chaines_completes;
  RAISE NOTICE '----------------------------------------------------------------';
  RAISE NOTICE '  REPARATIONS EFFECTUEES     : % entrée(s) dans _repair_log', v_repair_count;
  RAISE NOTICE '================================================================';

  -- Logger le rapport dans _repair_log
  INSERT INTO public._repair_log (table_name, action, details)
  VALUES ('SYSTEM', 'INTEGRITY_REPORT', jsonb_build_object(
    'auth_users', v_auth_users,
    'profiles', v_profiles,
    'users_sans_profil', v_users_sans_profil,
    'profils_orphelins', v_profils_orphelins,
    'properties', v_properties,
    'properties_sans_owner', v_props_sans_owner,
    'leases', v_leases,
    'leases_sans_property', v_leases_sans_property,
    'signers_orphelins', v_signers_orphelins,
    'signers_linkables', v_signers_linkables,
    'chaines_completes', v_chaines_completes
  ));
END $$;

COMMIT;

-- ========== 20260218000000_audit_repair_profiles.sql ==========
-- ============================================================================
-- BLOC 1 : TABLE D'AUDIT + RÉPARATION PROFILS
-- ============================================================================

-- 1. Création de la table de log des réparations
CREATE TABLE IF NOT EXISTS public._repair_log (
  id          SERIAL PRIMARY KEY,
  repair_date TIMESTAMPTZ DEFAULT NOW(),
  table_name  TEXT NOT NULL,
  record_id   TEXT,
  action      TEXT NOT NULL,
  details     JSONB
);

-- 2. Créer les profils manquants (users sans profil)
WITH inserted AS (
  INSERT INTO public.profiles (user_id, role, email, prenom, nom, telephone)
  SELECT
    au.id,
    COALESCE(
      CASE WHEN au.raw_user_meta_data->>'role' IN ('admin','owner','tenant','provider','guarantor')
           THEN au.raw_user_meta_data->>'role'
           ELSE NULL END,
      'tenant'
    ),
    au.email,
    au.raw_user_meta_data->>'prenom',
    au.raw_user_meta_data->>'nom',
    CASE WHEN (au.raw_user_meta_data->>'telephone') ~ '^\+[1-9]\d{1,14}$'
         THEN au.raw_user_meta_data->>'telephone'
         ELSE NULL END
  FROM auth.users au
  LEFT JOIN public.profiles p ON p.user_id = au.id
  WHERE p.id IS NULL
  ON CONFLICT (user_id) DO NOTHING
  RETURNING user_id, email, role
)
INSERT INTO public._repair_log (table_name, record_id, action, details)
SELECT 'profiles', user_id::TEXT, 'INSERT',
       jsonb_build_object('email', email, 'role', role, 'reason', 'user_sans_profil')
FROM inserted;

-- 3. Sync emails NULL (profils sans email alors que auth.users en a un)
WITH updated AS (
  UPDATE public.profiles p
  SET email = au.email, updated_at = NOW()
  FROM auth.users au
  WHERE p.user_id = au.id
    AND (p.email IS NULL OR p.email = '')
    AND au.email IS NOT NULL AND au.email != ''
  RETURNING p.id, au.email AS new_email
)
INSERT INTO public._repair_log (table_name, record_id, action, details)
SELECT 'profiles', id::TEXT, 'UPDATE',
       jsonb_build_object('new_email', new_email, 'reason', 'email_null_backfill')
FROM updated;

-- 4. Sync emails désynchronisés (profil a un email différent de auth.users)
WITH updated AS (
  UPDATE public.profiles p
  SET email = au.email, updated_at = NOW()
  FROM auth.users au
  WHERE p.user_id = au.id
    AND p.email IS DISTINCT FROM au.email
    AND au.email IS NOT NULL AND au.email != ''
    AND p.email IS NOT NULL
  RETURNING p.id, p.email AS old_email, au.email AS new_email
)
INSERT INTO public._repair_log (table_name, record_id, action, details)
SELECT 'profiles', id::TEXT, 'UPDATE',
       jsonb_build_object('old_email', old_email, 'new_email', new_email, 'reason', 'email_desync')
FROM updated;

-- 5. Résultat
SELECT action, COUNT(*) AS nb, details->>'reason' AS reason
FROM public._repair_log
WHERE table_name = 'profiles'
GROUP BY action, details->>'reason';

-- ========== 20260218100000_sync_auth_email_updates.sql ==========
-- =====================================================
-- MIGRATION: Synchronisation des changements d'email auth -> profiles
-- Date: 2026-02-18
-- Version: 20260218100000
--
-- PROBLEME:
--   Quand un utilisateur change son email via Supabase Auth
--   (confirmation d'email, changement d'email, etc.),
--   la colonne profiles.email n'est PAS mise a jour automatiquement.
--   Cela cause une desynchronisation entre auth.users.email
--   et profiles.email.
--
-- SOLUTION:
--   A. Trigger AFTER UPDATE sur auth.users qui met a jour
--      profiles.email quand auth.users.email change.
--   B. Backfill immediat des emails desynchronises.
--
-- SECURITE:
--   La fonction utilise SECURITY DEFINER pour bypasser les RLS
--   et mettre a jour le profil sans restrictions.
--   SET search_path = public pour eviter les injections de schema.
-- =====================================================

BEGIN;

-- ============================================
-- A. FONCTION DE SYNCHRONISATION EMAIL
-- ============================================
CREATE OR REPLACE FUNCTION public.handle_user_email_change()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Ne rien faire si l'email n'a pas change
  IF NEW.email IS NOT DISTINCT FROM OLD.email THEN
    RETURN NEW;
  END IF;

  -- Mettre a jour l'email dans le profil
  UPDATE public.profiles
  SET
    email = NEW.email,
    updated_at = NOW()
  WHERE user_id = NEW.id;

  IF NOT FOUND THEN
    -- Le profil n'existe pas encore (race condition possible)
    -- handle_new_user() le creera avec le bon email
    RAISE WARNING '[handle_user_email_change] Profil introuvable pour user_id=%, email non synchronise', NEW.id;
  END IF;

  RETURN NEW;

EXCEPTION WHEN OTHERS THEN
  -- Ne jamais bloquer la modification d'un utilisateur auth
  RAISE WARNING '[handle_user_email_change] Erreur sync email pour user_id=%: % (SQLSTATE=%)',
    NEW.id, SQLERRM, SQLSTATE;
  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.handle_user_email_change() IS
'Synchronise automatiquement profiles.email quand auth.users.email change.
SECURITY DEFINER pour bypasser les RLS.
Ne bloque jamais la modification auth (EXCEPTION handler).';

-- ============================================
-- B. TRIGGER SUR auth.users (UPDATE)
-- ============================================
DROP TRIGGER IF EXISTS on_auth_user_email_changed ON auth.users;

CREATE TRIGGER on_auth_user_email_changed
  AFTER UPDATE OF email ON auth.users
  FOR EACH ROW
  WHEN (NEW.email IS DISTINCT FROM OLD.email)
  EXECUTE FUNCTION public.handle_user_email_change();

-- ============================================
-- C. BACKFILL DES EMAILS DESYNCHRONISES
-- ============================================
DO $$
DECLARE
  v_updated INTEGER;
BEGIN
  UPDATE public.profiles p
  SET
    email = u.email,
    updated_at = NOW()
  FROM auth.users u
  WHERE p.user_id = u.id
    AND p.email IS DISTINCT FROM u.email
    AND u.email IS NOT NULL
    AND u.email != '';

  GET DIAGNOSTICS v_updated = ROW_COUNT;

  IF v_updated > 0 THEN
    RAISE NOTICE '[email_sync] % profil(s) resynchronise(s) avec l''email de auth.users', v_updated;
  ELSE
    RAISE NOTICE '[email_sync] Tous les emails sont deja synchronises';
  END IF;
END $$;

-- ============================================
-- D. VERIFICATION
-- ============================================
DO $$
DECLARE
  v_trigger_exists BOOLEAN;
  v_desync_count INTEGER;
BEGIN
  SELECT EXISTS(
    SELECT 1 FROM pg_trigger t
    JOIN pg_class c ON c.oid = t.tgrelid
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE t.tgname = 'on_auth_user_email_changed'
      AND n.nspname = 'auth'
      AND c.relname = 'users'
  ) INTO v_trigger_exists;

  SELECT count(*) INTO v_desync_count
  FROM public.profiles p
  INNER JOIN auth.users u ON u.id = p.user_id
  WHERE p.email IS DISTINCT FROM u.email
    AND u.email IS NOT NULL;

  RAISE NOTICE '========================================';
  RAISE NOTICE '  VERIFICATION EMAIL SYNC TRIGGER';
  RAISE NOTICE '========================================';
  RAISE NOTICE '  Trigger on_auth_user_email_changed : %',
    CASE WHEN v_trigger_exists THEN 'ACTIF' ELSE 'MANQUANT' END;
  RAISE NOTICE '  Emails desynchronises restants     : %', v_desync_count;
  RAISE NOTICE '========================================';
END $$;

COMMIT;

-- ========== 20260219100000_auto_link_notify_owner.sql ==========
-- =====================================================
-- MIGRATION: Notify owner when tenant creates account (auto-link)
-- Date: 2026-02-19
--
-- PROBLÈME CORRIGÉ:
-- Quand un locataire crée son compte et que le trigger auto-link
-- lie son profil aux lease_signers, le propriétaire n'était PAS notifié.
-- Le locataire restait invisible jusqu'au prochain rafraîchissement
-- de la page propriétaire.
--
-- SOLUTION:
-- Enrichir la fonction auto_link_lease_signers_on_profile_created()
-- pour créer une notification in-app pour chaque propriétaire concerné.
-- =====================================================

BEGIN;

CREATE OR REPLACE FUNCTION public.auto_link_lease_signers_on_profile_created()
RETURNS TRIGGER AS $$
DECLARE
  user_email TEXT;
  linked_count INT;
  rec RECORD;
BEGIN
  -- Récupérer l'email de l'utilisateur auth
  SELECT email INTO user_email
  FROM auth.users
  WHERE id = NEW.user_id;

  IF user_email IS NULL OR user_email = '' THEN
    RETURN NEW;
  END IF;

  -- Lier tous les lease_signers orphelins avec cet email
  UPDATE public.lease_signers
  SET profile_id = NEW.id
  WHERE LOWER(invited_email) = LOWER(user_email)
    AND profile_id IS NULL;

  GET DIAGNOSTICS linked_count = ROW_COUNT;

  IF linked_count > 0 THEN
    RAISE NOTICE '[auto_link] % lease_signers liés au profil % (email: %)',
      linked_count, NEW.id, user_email;

    -- ✅ NOUVEAU: Notifier chaque propriétaire concerné
    FOR rec IN
      SELECT DISTINCT
        p_owner.id AS owner_profile_id,
        p_owner.user_id AS owner_user_id,
        prop.adresse_complete AS property_address,
        l.id AS lease_id
      FROM public.lease_signers ls
      JOIN public.leases l ON l.id = ls.lease_id
      JOIN public.properties prop ON prop.id = l.property_id
      JOIN public.profiles p_owner ON p_owner.id = prop.owner_id
      WHERE ls.profile_id = NEW.id
        AND ls.role IN ('locataire_principal', 'colocataire')
    LOOP
      INSERT INTO public.notifications (
        user_id,
        profile_id,
        type,
        title,
        body,
        is_read,
        read,
        metadata
      ) VALUES (
        rec.owner_user_id,
        rec.owner_profile_id,
        'tenant_account_created',
        'Locataire inscrit',
        format('%s a créé son compte pour le bail au %s. Son profil est maintenant visible dans votre liste de locataires.',
          user_email, COALESCE(rec.property_address, 'adresse non renseignée')),
        false,
        false,
        jsonb_build_object(
          'lease_id', rec.lease_id,
          'tenant_email', user_email,
          'tenant_profile_id', NEW.id,
          'action_url', format('/owner/leases/%s', rec.lease_id)
        )
      );
      RAISE NOTICE '[auto_link] Notification créée pour propriétaire % (bail %)',
        rec.owner_profile_id, rec.lease_id;
    END LOOP;
  END IF;

  -- Marquer les invitations correspondantes comme utilisées
  UPDATE public.invitations
  SET used_by = NEW.id,
      used_at = NOW()
  WHERE LOWER(email) = LOWER(user_email)
    AND used_at IS NULL;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMIT;

-- ========== 20260219200000_fix_autolink_triggers_audit.sql ==========
-- =====================================================
-- MIGRATION: Corrections issues de l'audit auto-link triggers
-- Date: 2026-02-19
-- Ref: AUDIT_AUTOLINK_TRIGGERS.md
--
-- Corrections appliquées:
--   P0-1: Supprimer le trigger obsolète on_profile_created_auto_link
--   P1-1: Ajouter EXCEPTION handler à auto_link_lease_signers_on_profile_created
--   P1-2: Supprimer la politique RLS trop permissive "System can insert notifications"
--   P2-1: Ajouter déduplication aux triggers de notification
-- =====================================================

BEGIN;

-- =====================================================
-- P0-1: Supprimer le trigger OBSOLÈTE on_profile_created_auto_link
-- Ce trigger (case-sensitive, sans notifications, sans invitations)
-- est remplacé par trigger_auto_link_lease_signers depuis la migration
-- 20260219100000_auto_link_notify_owner.sql
-- =====================================================

DROP TRIGGER IF EXISTS on_profile_created_auto_link ON public.profiles;
DROP FUNCTION IF EXISTS public.auto_link_signer_profile();

-- =====================================================
-- P1-1: Ajouter EXCEPTION handler à auto_link_lease_signers_on_profile_created
-- Sans cet handler, une erreur dans la notification (ex: colonne manquante)
-- provoque un rollback de la création du profil → l'utilisateur ne peut
-- pas s'inscrire.
-- =====================================================

CREATE OR REPLACE FUNCTION public.auto_link_lease_signers_on_profile_created()
RETURNS TRIGGER AS $$
DECLARE
  user_email TEXT;
  linked_count INT;
  rec RECORD;
BEGIN
  -- Récupérer l'email de l'utilisateur auth
  SELECT email INTO user_email
  FROM auth.users
  WHERE id = NEW.user_id;

  IF user_email IS NULL OR user_email = '' THEN
    RETURN NEW;
  END IF;

  -- Lier tous les lease_signers orphelins avec cet email
  UPDATE public.lease_signers
  SET profile_id = NEW.id
  WHERE LOWER(invited_email) = LOWER(user_email)
    AND profile_id IS NULL;

  GET DIAGNOSTICS linked_count = ROW_COUNT;

  IF linked_count > 0 THEN
    RAISE NOTICE '[auto_link] % lease_signers liés au profil % (email: %)',
      linked_count, NEW.id, user_email;

    -- Notifier chaque propriétaire concerné
    FOR rec IN
      SELECT DISTINCT
        p_owner.id AS owner_profile_id,
        p_owner.user_id AS owner_user_id,
        prop.adresse_complete AS property_address,
        l.id AS lease_id
      FROM public.lease_signers ls
      JOIN public.leases l ON l.id = ls.lease_id
      JOIN public.properties prop ON prop.id = l.property_id
      JOIN public.profiles p_owner ON p_owner.id = prop.owner_id
      WHERE ls.profile_id = NEW.id
        AND ls.role IN ('locataire_principal', 'colocataire')
    LOOP
      INSERT INTO public.notifications (
        user_id,
        profile_id,
        type,
        title,
        body,
        is_read,
        read,
        metadata
      ) VALUES (
        rec.owner_user_id,
        rec.owner_profile_id,
        'tenant_account_created',
        'Locataire inscrit',
        format('%s a créé son compte pour le bail au %s. Son profil est maintenant visible dans votre liste de locataires.',
          user_email, COALESCE(rec.property_address, 'adresse non renseignée')),
        false,
        false,
        jsonb_build_object(
          'lease_id', rec.lease_id,
          'tenant_email', user_email,
          'tenant_profile_id', NEW.id,
          'action_url', format('/owner/leases/%s', rec.lease_id)
        )
      );
      RAISE NOTICE '[auto_link] Notification créée pour propriétaire % (bail %)',
        rec.owner_profile_id, rec.lease_id;
    END LOOP;
  END IF;

  -- Marquer les invitations correspondantes comme utilisées
  UPDATE public.invitations
  SET used_by = NEW.id,
      used_at = NOW()
  WHERE LOWER(email) = LOWER(user_email)
    AND used_at IS NULL;

  RETURN NEW;

EXCEPTION WHEN OTHERS THEN
  -- Ne jamais bloquer la création du profil
  RAISE WARNING '[auto_link] Erreur non-bloquante: % (SQLSTATE=%)', SQLERRM, SQLSTATE;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- P1-2: Remplacer la politique RLS trop permissive
-- "System can insert notifications" (WITH CHECK (true))
-- par une politique restrictive: seuls les triggers SECURITY DEFINER
-- peuvent insérer (pas les utilisateurs authentifiés directement)
-- =====================================================

DROP POLICY IF EXISTS "System can insert notifications" ON notifications;

-- Les triggers SECURITY DEFINER bypassent RLS, donc aucune politique
-- INSERT permissive n'est nécessaire pour eux. On ne crée PAS de
-- remplacement car les fonctions trigger sont toutes SECURITY DEFINER.
-- Si une politique INSERT est nécessaire pour le service role,
-- elle sera ajoutée par la couche applicative.

-- =====================================================
-- P2-1: Ajouter déduplication aux triggers de notification
-- Empêche les doublons si un statut oscille (ex: late -> paid -> late)
-- Fenêtre de déduplication : 1 heure
-- =====================================================

-- TRIGGER 1: notify_invoice_late - ajouter déduplication
CREATE OR REPLACE FUNCTION notify_invoice_late()
RETURNS TRIGGER AS $$
DECLARE
  v_owner_id UUID;
  v_tenant_name TEXT;
  v_property_address TEXT;
  v_amount NUMERIC;
BEGIN
  -- Seulement si le statut passe à 'late'
  IF NEW.statut = 'late' AND (OLD.statut IS NULL OR OLD.statut != 'late') THEN
    -- Récupérer les infos
    SELECT
      p.owner_id,
      COALESCE(pr.prenom || ' ' || pr.nom, 'Locataire'),
      COALESCE(p.adresse_complete, 'Adresse inconnue'),
      NEW.montant_total
    INTO v_owner_id, v_tenant_name, v_property_address, v_amount
    FROM leases l
    JOIN properties p ON l.property_id = p.id
    LEFT JOIN lease_signers ls ON ls.lease_id = l.id AND ls.role = 'locataire_principal'
    LEFT JOIN profiles pr ON ls.profile_id = pr.id
    WHERE l.id = NEW.lease_id;

    -- Notifier le propriétaire (avec déduplication)
    IF v_owner_id IS NOT NULL
      AND NOT EXISTS (
        SELECT 1 FROM notifications
        WHERE related_id = NEW.id
          AND type = 'payment_late'
          AND created_at > NOW() - INTERVAL '1 hour'
      )
    THEN
      PERFORM create_notification(
        v_owner_id,
        'payment_late',
        'Loyer impayé',
        format('Le loyer de %s (%s) de %s€ est en retard.', v_tenant_name, v_property_address, v_amount),
        '/app/owner/money?filter=late',
        NEW.id,
        'invoice'
      );
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- TRIGGER 2: notify_payment_received - ajouter déduplication
CREATE OR REPLACE FUNCTION notify_payment_received()
RETURNS TRIGGER AS $$
DECLARE
  v_owner_id UUID;
  v_tenant_name TEXT;
  v_amount NUMERIC;
BEGIN
  -- Seulement si le statut passe à 'succeeded'
  IF NEW.statut = 'succeeded' AND (OLD.statut IS NULL OR OLD.statut != 'succeeded') THEN
    -- Récupérer les infos via la facture
    SELECT
      p.owner_id,
      COALESCE(pr.prenom || ' ' || pr.nom, 'Locataire'),
      NEW.montant
    INTO v_owner_id, v_tenant_name, v_amount
    FROM invoices i
    JOIN leases l ON i.lease_id = l.id
    JOIN properties p ON l.property_id = p.id
    LEFT JOIN lease_signers ls ON ls.lease_id = l.id AND ls.role = 'locataire_principal'
    LEFT JOIN profiles pr ON ls.profile_id = pr.id
    WHERE i.id = NEW.invoice_id;

    -- Notifier le propriétaire (avec déduplication)
    IF v_owner_id IS NOT NULL
      AND NOT EXISTS (
        SELECT 1 FROM notifications
        WHERE related_id = NEW.id
          AND type = 'payment_received'
          AND created_at > NOW() - INTERVAL '1 hour'
      )
    THEN
      PERFORM create_notification(
        v_owner_id,
        'payment_received',
        'Paiement reçu',
        format('Paiement de %s€ reçu de %s.', v_amount, v_tenant_name),
        '/app/owner/money',
        NEW.id,
        'payment'
      );
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- TRIGGER 3: notify_lease_signed - ajouter déduplication
CREATE OR REPLACE FUNCTION notify_lease_signed()
RETURNS TRIGGER AS $$
DECLARE
  v_owner_id UUID;
  v_property_address TEXT;
BEGIN
  -- Seulement si le statut passe à 'active'
  IF NEW.statut = 'active' AND (OLD.statut IS NULL OR OLD.statut != 'active') THEN
    -- Récupérer les infos
    SELECT p.owner_id, COALESCE(p.adresse_complete, 'Adresse inconnue')
    INTO v_owner_id, v_property_address
    FROM properties p
    WHERE p.id = NEW.property_id;

    -- Notifier le propriétaire (avec déduplication)
    IF v_owner_id IS NOT NULL
      AND NOT EXISTS (
        SELECT 1 FROM notifications
        WHERE related_id = NEW.id
          AND type = 'lease_signed'
          AND created_at > NOW() - INTERVAL '1 hour'
      )
    THEN
      PERFORM create_notification(
        v_owner_id,
        'lease_signed',
        'Bail signé !',
        format('Le bail pour %s est maintenant actif.', v_property_address),
        '/app/owner/leases/' || NEW.id,
        NEW.id,
        'lease'
      );
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- TRIGGER 5: notify_ticket_resolved - ajouter déduplication
CREATE OR REPLACE FUNCTION notify_ticket_resolved()
RETURNS TRIGGER AS $$
DECLARE
  v_creator_id UUID;
  v_property_address TEXT;
BEGIN
  -- Seulement si le statut passe à 'resolved' ou 'closed'
  IF NEW.statut IN ('resolved', 'closed') AND OLD.statut NOT IN ('resolved', 'closed') THEN
    -- Récupérer les infos
    SELECT
      NEW.created_by_profile_id,
      COALESCE(p.adresse_complete, 'Adresse inconnue')
    INTO v_creator_id, v_property_address
    FROM properties p
    WHERE p.id = NEW.property_id;

    -- Notifier le créateur du ticket (avec déduplication)
    IF v_creator_id IS NOT NULL
      AND NOT EXISTS (
        SELECT 1 FROM notifications
        WHERE related_id = NEW.id
          AND type = 'ticket_resolved'
          AND created_at > NOW() - INTERVAL '1 hour'
      )
    THEN
      PERFORM create_notification(
        v_creator_id,
        'ticket_resolved',
        'Ticket résolu',
        format('Votre demande "%s" a été traitée.', NEW.titre),
        '/app/owner/tickets/' || NEW.id,
        NEW.id,
        'ticket'
      );
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Note: trigger_notify_ticket_created (INSERT only) n'a pas besoin de
-- déduplication car un INSERT ne peut se produire qu'une fois.

COMMIT;
